{"id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 0, "fitness": 0.2946231998743257, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "93fc0210-c92b-450f-a320-746a8f711589", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "4eea01ca-912e-443b-b38e-00d18eb79708", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "79c36f1a-4218-477f-a5dc-dabbd6f2808e", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "0156acd3-c7ac-4596-9188-a62ab29af4f3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "79775419-8cb8-4fbe-a506-48c5a7f9f1f3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "af17a6bb-7c8f-45fd-b49d-f4fd7989b2bf", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "4523474f-d388-460b-97b5-eb8e65f56262", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "A hybrid swarm-inspired metaheuristic combining particle swarm optimization and differential evolution for efficient search across diverse landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.8582636125280056, 0.8456784474411954, 0.8634665362729247, 0.8529959949795458, 0.8144463220036522, 0.7948934453371095, 0.9008493107376133, 0.89455249838192, 0.8355828245660835, 0.6681932733246808, 9.999999999998899e-05, 9.999999999998899e-05, 0.6869667050140741, 0.4866818561637357, 0.0013159637442328176, 0.061055599599107, 0.056041876585916306, 0.6320565412768446, 0.11318724402102676, 0.14429748508085982, 0.11393020940675092, 0.13612210902379462, 0.07749793148458795, 0.07505925449991668, 0.10967598923677724, 0.10780970622280606, 0.12644240459471656, 0.10755247340162932, 0.10345406634315912, 0.09215388902504129, 0.14020005720457007, 0.05107445248735021, 0.10551072828192576, 0.07978556127342584, 0.1330706005665172, 0.12158145337784843, 0.9888248245006644, 0.9586242013741129, 0.9886755568792486, 0.9666144291172569, 0.9835018856494203, 0.9720266735961777, 0.9845192867668335, 0.987040974888132, 0.9820813168124202, 0.6293820364798196, 0.7136179005806503, 0.6378023080347671, 0.6083701764692864, 0.6880884554860398, 0.692484185413012, 0.6565305501399163, 0.08874418651743177, 0.08572089479105982, 0.21208515247598347, 0.21753944324445096, 0.2351599716312729, 0.0508201785493686, 0.19237831201748845, 0.21193470914410217, 0.06599917182288095, 0.16855211599818343, 0.23481409802487085, 0.7597139939586018, 0.3880171655154985, 0.20652526346603373, 0.34694538412342313, 0.28109711879258403, 0.3164874520607406, 0.13336410777298824, 0.2576738910845725, 0.4949783999271026, 0.5297475647178171, 0.5212481423293259, 0.13332573395848957, 0.4476258705379037, 0.4461318332813302, 0.2650946864559537, 0.1336594231990088, 0.18747515939000037, 0.10764404612283196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01814721677301312, 0.15125309872958315, 0.1174911645802742, 0.2822747404548752, 0.17689059533622453, 0.13134242923847128, 0.16731871971318957, 0.23709292939904558, 0.07031911701628779, 0.03669130932782516, 0.8105287360075226, 0.22406456053501733, 0.18228170417178846, 0.026455035648593195, 0.12318184544829525, 0.1692730852140939, 0.07710618443921136, 0.07990682199545807, 0.11557158561388281, 0.10220074042873872, 0.17304300952945684, 0.09097444259150256, 0.3281869647525779, 0.17787939398609487, 0.21917974432206988, 0.006568578376040746, 0.36020106731152357, 0.006781275890311411, 0.3670234854671204, 0.04446919742085409, 0.20512281532914334, 0.7238787407031972, 0.7341682458230157, 0.65392920012734, 0.7107119124996408, 0.6343325120890961, 0.6744801323864017, 0.6772428171840947, 0.7357938148969607, 0.6934620458167144, 0.050835181753740466, 0.06483414936828358, 0.08582951701196051, 0.07805664447706384, 0.0843245389333439, 0.1301106953303217, 0.09703013082813228, 0.12668525270493847, 0.0728887461546861, 0.27095239031411456, 0.255083096071845, 0.19544952828949558, 0.28396286617013355, 0.24715988740430217, 0.15963413977166507, 0.2134635832851577, 0.16470052173445293, 0.17625470887448969, 0.23100149489765043, 0.23186756920490847, 0.22222191672051528, 0.2904877756456111, 0.2984900406297494, 0.23473123085713565, 0.2841372917200904, 0.2728687770983559, 0.1635751411822861, 0.27915867076263257, 0.30816155714455684, 0.16403725734514685, 0.2533526034007767, 0.2140536772981223, 0.1855822420823483, 0.20020941445844032, 0.1952181450874353, 0.09208544018390452, 0.19669217896081226, 0.21087256459756631, 0.16533477689779663, 0.18373368574627602, 0.1952951891329413, 0.18661696120250126, 0.19856565523735525, 0.20893985086627376, 0.2085385446936393, 0.18974936718137791, 0.25171394195394414, 0.18800924467522528, 0.20335732464508238, 0.18664137693516458, 0.1814192466512402, 0.21048883516068906, 0.20647981036890684, 0.17721520798306845, 0.9181425772430277, 0.18781621826460093, 0.11313478108600883, 0.17182411454560187, 0.2003541975747214, 0.20153349725154135, 0.12308573229656528, 0.16925617832585194, 0.16676256185976657, 0.12504747756253454, 0.2104217359947066, 0.12476465234687928, 0.10324482944226165, 0.7174880501339268, 0.8665541177914776, 0.10427358987316859, 0.6729821610228162, 0.748112890814608, 0.17821651502347335, 0.19030683733800857, 0.18297445963826553, 0.19386278278601143, 0.187562806615994, 0.19738900653605074, 0.21036279033789074, 0.19380219123585973, 0.17325423754200653, 0.08033209284820642, 0.07504618352125092, 0.0838718657451425, 0.0756575226465569, 0.0693975645374112, 0.08155801793869555, 0.08164291194211915, 0.08502920280901871, 0.0777295601317275]}, "mutation_prompt": null}
{"id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 8, "fitness": 0.30325762078244334, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "176ea77d-de08-4de5-abd8-8ab3678253aa", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "e07f9342-e0be-41e9-9603-ea12c32b83dd", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "99535166-11bc-4480-a309-c80f8f651f44", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_inertia = self.inertia_weight - eval_count/self.budget * 0.4\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (adaptive_inertia * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces an adaptive inertia weight that decreases over time to improve convergence stability and efficiency.", "configspace": "", "generation": 10, "fitness": 0.269829664613419, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.27.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8894105583416165, 0.8936804830847871, 0.8886175786441086, 0.8836190589757902, 0.8408776471397302, 0.8995167192695218, 0.896375566951608, 0.9085176179853485, 0.9044790488965366, 0.6670147704777534, 0.6299738586523342, 9.999999999998899e-05, 0.7594376688746758, 0.034448891347841015, 0.36192355587962977, 0.6909792329511701, 0.7934476968181359, 9.999999999998899e-05, 0.11382830392601351, 0.07789637698228713, 0.07673961310101873, 0.11700262007223705, 0.1117505032886289, 0.07678121757268686, 0.0863358220369902, 0.13762231079710985, 0.054391497429197244, 0.0937546658193058, 0.10782656243517108, 0.08691144370086934, 0.10067650582589671, 0.12316683205449352, 0.06672613860408094, 0.08079433540124303, 0.06887440755386198, 0.15254507134695738, 0.9873294546126019, 0.9486146784245704, 0.9877955440855546, 0.9701940769046304, 0.9783454179886171, 0.9828944664381217, 0.9803240929308965, 0.983004732502593, 0.9771058271242911, 0.733630109206157, 0.6112605835806413, 0.10216125771559925, 0.7848696289881526, 0.5739606196400735, 0.642584268997684, 0.43618370878171264, 0.08628497640458954, 0.3280280181272046, 0.23160720224432152, 0.17159502201217225, 0.2202972265468237, 0.08137308635068441, 0.19481732152319997, 0.2108986265900359, 0.07214067099425314, 0.1818830625853355, 0.23042802696716602, 0.1755865755236682, 0.1318786305999603, 0.17178979040598008, 0.1743151511751163, 0.16438477853906375, 0.240078266698331, 0.13406934197111664, 0.32235300186570814, 0.1998534396231546, 0.13914801307015912, 0.02452635287029792, 0.1336350365840201, 0.167734495001165, 0.13283761574021702, 0.13147425503095223, 0.13416894099935184, 0.16314674767915582, 0.10848997279941719, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11252657900681728, 0.020179226194082744, 0.06268273341726327, 9.999999999998899e-05, 0.06415863450082215, 0.04164476851426857, 0.0498175808152479, 0.06115819191307659, 0.18473717663489186, 0.01951995569578835, 0.029366400861165154, 0.21730288705415157, 0.05850852581991717, 0.10029204447290396, 0.05072706961680906, 0.13953360923233138, 0.07311314480964248, 0.08710095375556526, 0.1905928425294472, 0.1262359914020209, 0.10568034847080232, 0.19733552233426255, 0.07369366873298244, 0.19984210293436533, 0.17705815783036427, 0.21343504980108474, 0.23439534110085647, 0.039196229386307624, 0.006639141561381567, 0.1228589233447257, 9.999999999998899e-05, 0.08334339359897691, 0.6245779214231495, 0.4719822035936333, 0.6401550120145301, 0.5283884684134419, 0.5815595861815677, 0.4988957887370985, 0.5302942072269644, 0.5827781616469534, 0.5417523928306502, 0.07067209770459759, 0.0744789117171285, 0.041876307556603765, 0.10521250749704181, 0.046474877381084245, 0.07329265153329312, 0.1442294916768373, 0.1100552576275391, 0.08261967272886961, 0.29290453250577086, 0.37063982246468796, 0.19785981866158786, 0.25499338989710063, 0.15768659843145538, 0.14626066838934293, 0.26199098962019196, 0.1630711820896249, 0.17393406395282307, 0.3026698974789006, 0.26173773325942484, 0.17535903569059397, 0.2315630703352367, 0.23567181546404248, 0.3020068748487523, 0.24811710391154462, 0.3568257542625115, 0.21419885317839438, 0.253698896458023, 0.19693878515428342, 0.17094466168258882, 0.3331204493230304, 0.2304281917804527, 0.180588461233968, 0.21630260385179512, 0.2687131607614177, 0.17368151350945027, 0.21979232459635512, 0.20869535731596212, 0.2538028281968554, 0.19241604291718983, 0.22364342963104422, 0.19913685531134606, 0.26214937172208075, 0.19175339809764202, 0.19950418681164306, 0.20550609961015331, 0.8445149402884465, 0.20311609566442723, 0.19906099185438741, 0.18653943416506047, 0.19072103563174647, 0.1893133612212713, 0.20813826662219703, 0.1868248417302224, 0.10502088590229686, 0.18796959155558257, 0.13539864193298146, 0.17319129044991854, 0.20110727567616016, 0.2003814581420874, 0.12321376789802452, 0.16901151894291833, 0.16786911708020757, 0.15622419103802132, 0.20762057727799388, 0.12502330627635005, 0.10468061976386178, 0.22531495275400248, 0.8954525198357439, 0.10534555222163777, 0.8968707945360087, 0.7277226175601295, 0.17791329798385014, 0.1786349320378836, 0.19019512522185056, 0.18699954086287374, 0.1924742164772293, 0.19883410327192697, 0.1743841221158896, 0.2236240778673042, 0.1792145997972603, 0.09685300636201022, 0.09529852952834139, 0.0810632892710006, 0.08129594279314423, 0.079708460830478, 0.09593298936235717, 0.10242481664208103, 0.100720832864725, 0.09588219526289488]}, "mutation_prompt": null}
{"id": "9e6591cb-e24a-45e9-9953-d9832c442972", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                # Stochastic adjustment of inertia weight\n                dynamic_inertia = self.inertia_weight * np.random.uniform(0.9, 1.1)\n                velocities[i] = (dynamic_inertia * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Integrates stochastic inertia weight adjustment, enhancing convergence by dynamically adapting exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.29741978754646137, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8968406506136286, 0.8794864375737802, 0.912547371537091, 0.8174166355399234, 0.8549965222017304, 0.9003526599619961, 0.8889579528225913, 0.8955197536402105, 0.875727152545739, 0.7386575968178631, 9.999999999998899e-05, 0.763114840271931, 0.7595275540922093, 0.04676018505583701, 9.999999999998899e-05, 0.7407897162989096, 0.05973499227535772, 0.7776952621976176, 0.08581176539757684, 0.12717716990461048, 0.11276173951447432, 0.1258498763157906, 0.09685779430500374, 0.12217785537142245, 0.10375430679359687, 0.11258054436744991, 0.14192472519601196, 0.10040408951232216, 0.1240302091577441, 0.07801438300687791, 0.11042629609472865, 0.12080226231470337, 0.43153696575187694, 0.11655469889513859, 0.10868860457907414, 0.07601618626004802, 0.9899663539856852, 0.9802936440989114, 0.9899364403970144, 0.9718203624282533, 0.9830249679866281, 0.0995676115796954, 0.9766036448776837, 0.97819306854942, 0.9819535374439264, 0.7311513099160294, 0.5973028839632344, 0.4731399636796163, 0.1510870250616595, 0.6834862579621475, 0.15165152099145485, 0.48305555312849635, 0.08813664156112666, 9.999999999998899e-05, 0.22876543561984586, 0.7940133738571684, 0.22748119342995266, 0.19488372675419374, 0.20662143550943923, 0.28045156319889286, 0.15121651515229895, 0.17866499740502728, 0.2218404944221003, 0.5240179144133961, 0.12559128588219848, 0.21904638169279522, 0.2957688128718081, 0.6805648889975676, 0.5900046104072967, 0.34220591955300106, 0.14035625622657077, 0.1350803883121613, 0.5680724693156498, 0.11319600851468126, 0.13470914543285328, 0.5749920353719091, 0.5559131142250169, 0.1352674175418762, 0.6919827106796634, 0.1322998300980205, 0.23152519783566872, 9.999999999998899e-05, 0.08830599547269069, 0.09719153968497996, 9.999999999998899e-05, 9.999999999998899e-05, 0.0194451573537624, 0.05114321608564243, 0.006397368463112452, 0.20439672059762992, 0.0893167855306507, 0.10207103060664469, 0.26358078261060314, 0.2719816747217021, 0.029793075679365066, 0.13372194508213908, 0.2381775464941399, 0.4095783628088848, 0.11039093915404374, 0.05076738802616909, 0.1172112271499498, 0.183185694800432, 0.08085528427532551, 0.22757399294896485, 0.16118235411538373, 0.13043709157258798, 0.1670611386188684, 0.07542358463840648, 0.04331652939620667, 0.1578922248472847, 0.2541305374735343, 0.04147332297840223, 0.15477588449427293, 9.999999999998899e-05, 0.10725541881988554, 0.04967129724245811, 0.08377425708474673, 0.6215951440296557, 0.6535820541576141, 0.7314836367935815, 0.6019763664693378, 0.21658220005480167, 0.6221284844917556, 0.7247015331199067, 0.6693844417692999, 0.7104885957204463, 0.07302955750717754, 0.08562600686830812, 0.12677057038580386, 0.08509938944440765, 0.09317740445909695, 0.1314850738339023, 0.14037426717349677, 0.0890139392706989, 0.08724398692508517, 0.2737781184762642, 0.2282455950244594, 0.26085816143767915, 0.2738020659849093, 0.20178498453963234, 0.17554156500299045, 0.26850091506010587, 0.1592281923193204, 0.20358418366359354, 0.3730822449559358, 0.27453982500166063, 0.15745248305804382, 0.2642393996290896, 0.24711372967907186, 0.18804802246876384, 0.29836721783649, 0.2503552789764466, 0.16720512001834342, 0.0891452259777088, 0.28005519434551585, 0.15051369023415462, 0.18116792012658878, 0.25839540191416743, 0.2224718192016668, 0.244832062109275, 0.31543658983186673, 0.1031905902236534, 0.18786058099335212, 0.1778517653188757, 0.17864683103413026, 0.20399487731498012, 0.2699440650120296, 0.18951674683278175, 0.20764572803113968, 0.20050819629685523, 0.19221283779923837, 0.2064104492722072, 0.24383352173565043, 0.21319635061837838, 0.1836870226009295, 0.20242195216863634, 0.19351865586453743, 0.18312844824912877, 0.20460203789426867, 0.20469860302059895, 0.934238116747822, 0.16427542258915295, 0.15456149933367036, 0.9174534775694785, 0.2015680539572804, 0.2011023588944647, 0.0999405320878115, 0.16937738732561358, 0.1665356657886623, 0.079283720989201, 0.16660446959183317, 0.1278251347617293, 0.9152105297696688, 0.16858405937602838, 0.2126297720112349, 0.8651245476467188, 0.9030787428778092, 0.7856452042749223, 0.17873218391162227, 0.182134540930721, 0.19341358441935075, 0.18543605397412088, 0.19059946128736438, 0.1776728047935241, 0.19027455258005055, 0.23070471647505963, 0.19585257324238714, 0.09576319925956644, 0.07556042339752489, 0.07223009467563424, 0.08845126473865328, 0.0816457984526916, 0.09987145400518072, 0.08141037254677708, 0.07242768875475869, 0.10851969202228762]}, "mutation_prompt": null}
{"id": "750a6624-752d-462d-8f5b-edd5ac0c590c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Adaptive inertia weight\n                inertia_weight = 0.4 + 0.6 * (self.budget - eval_count) / self.budget\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                # Using neighborhood best instead of random choice for a\n                # adaptive approach\n                a, b, c = sorted(indices, key=lambda idx: personal_best_scores[idx])[:3]\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive inertia weight and neighborhood best strategy to refine the balance between exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.20816761167530617, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.5115019519899777, 0.46395313269153693, 0.4533295867267698, 0.4755512694866275, 0.18570033912082085, 0.19095865887348273, 0.5551792945492534, 0.48780386292316136, 0.5548231858678766, 0.25347809481114303, 0.05517709018993211, 0.12283965628137461, 0.1585616385725943, 0.08124688075628661, 9.999999999998899e-05, 0.023066453007038246, 0.12411311546778037, 0.11665100422662622, 0.09452285046500097, 0.08570459783282025, 0.07244461341684583, 0.05877298887660143, 0.09095908960204013, 0.07501353348752204, 0.07872053908577692, 0.13245068274735206, 0.07277035298715795, 0.09869198923466027, 0.08622927759684385, 0.07721713757253579, 0.10027111281985834, 0.11059397846707253, 0.10306812352907413, 0.0852090629046437, 0.07098681201179935, 0.09852656592821296, 0.9885144293966659, 0.9811268657318722, 0.9939181420471437, 0.9339186457887098, 0.9886486536631225, 0.9816821263453831, 0.9869267823330123, 0.9906276379334241, 0.9863657715537636, 0.25929388073566584, 0.3315284212050038, 0.1729691489809546, 0.33383268459838966, 0.14861911216714196, 0.16009994655927018, 0.34580777715267863, 0.08842357014012736, 0.08208888618728039, 0.5157559147036235, 0.250427402339198, 0.135099446023904, 0.2486133124807972, 0.18733705631309006, 0.1845145874368801, 0.11989743131601083, 0.6606345643129363, 0.5885726626390895, 0.2163300950030661, 0.1223685643823712, 0.12445042234012926, 0.10877012675392561, 0.1306440247034215, 0.1300965381713005, 0.11377563425364556, 0.12101725681774622, 0.10003699821790246, 0.1523389194484044, 0.02150498164576331, 0.12502621540525483, 0.13350226078486727, 0.09145294742361454, 0.1166550752771911, 0.13749006923247797, 0.08165043693290497, 0.08933661369602997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01757809308328051, 9.999999999998899e-05, 0.006050372173679541, 0.004871121816769852, 0.03510166689909422, 0.08743237792220482, 0.09621119436848602, 0.08301871348770296, 0.1216552302090178, 0.04279810353498448, 0.05088157977675123, 0.37274234120667515, 0.1395867354521686, 0.10423372862733671, 9.999999999998899e-05, 9.999999999998899e-05, 0.04351773438898576, 0.056537163091698095, 0.03465545579427454, 0.03229812109599117, 0.045045915536147896, 0.04023221740721383, 0.03712865785697139, 0.06605591570291036, 0.17496187853230827, 0.16242913179215845, 0.028531095778278948, 0.20492683217818453, 0.004567277973798078, 0.06234427184177094, 0.03536145668544355, 0.07093830457379446, 0.42619874582243134, 0.4227694201419926, 0.4631304460325749, 0.4190097189262645, 0.3837829347930458, 0.235549449017732, 0.42118343208751274, 0.38390162679609574, 0.3843950748343711, 0.05381586545496286, 0.06060103530858718, 0.03552600802101402, 0.07300191556104496, 0.07126248538423441, 0.1154443037226407, 0.1254428296276736, 0.08146081005164163, 0.09636114712417077, 0.14229200821352717, 0.17055254494162164, 0.13916554740476095, 0.16881883643591877, 0.1366313703765718, 0.14750452848682727, 0.18548943758389447, 0.1481979163947793, 0.17760730336305974, 0.24234640937953655, 0.2677642905220672, 0.2162058326507822, 0.2795132904817471, 0.24766647484751492, 0.3104188792574899, 0.25550055653389203, 0.29069476887497714, 0.13051598778472906, 0.20361759290836923, 0.165243744565588, 0.1472359742145709, 0.21446702576394272, 0.17109946286261235, 0.1766245020861028, 0.13191867862481121, 0.21484015440624094, 0.22304877759301167, 0.19691905211723293, 0.20154058332201974, 0.18903460994438637, 0.16525937019198733, 0.15490722471077678, 0.1806292371243028, 0.19744924889565962, 0.19121139203935378, 0.16650348466011256, 0.18490261473841052, 0.18207005941724597, 0.19057381392868833, 0.18896039234558137, 0.19559498083841742, 0.17853765132388655, 0.21159997808459752, 0.20165215863648356, 0.18490848344439015, 0.22583544519698784, 0.17690377827424142, 0.1478632886941159, 0.15622296155839943, 0.19655997887552434, 0.42463292117837725, 0.15864950186432636, 0.16750957012561285, 0.1792885811009597, 0.4753027438554501, 0.1628556369334594, 0.1643215347617183, 0.47006799607357275, 0.6347883120832363, 0.6169574769159614, 0.19511704416290676, 0.6062352962557838, 0.17262923744129532, 0.183437916607591, 0.1985596779758857, 0.18284462345193364, 0.20584775146402656, 0.17240922223775035, 0.18290869290518874, 0.20041996703817644, 0.18447338429387006, 0.17807527821458535, 0.060753566759025435, 0.06564478190600398, 0.06917871895336847, 0.06749257999192437, 0.07798667766912915, 0.05930096463025325, 0.06598140244024886, 0.05699417898847148, 0.06980669648496585]}, "mutation_prompt": null}
{"id": "63754513-1382-44dc-a373-519a4ad9557b", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Adaptive inertia weight calculation\n            self.inertia_weight = 0.4 + 0.5 * (np.tanh((eval_count / self.budget) - 0.5) + 1)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Dynamic scaling of differential weight\n                adaptive_weight = self.differential_weight * (1 - np.exp(-eval_count / self.budget))\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive inertia weight and dynamic differential weight scaling to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 13, "fitness": 0.24925070957810735, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8274688235062674, 0.7621553533762894, 0.6919719104411839, 0.18337820102402091, 0.4458116048064048, 0.7927713049234588, 0.6648738138931249, 0.6877107591932405, 0.7876384634897712, 0.420667308489278, 0.04057945159531262, 0.050416313273863866, 0.30998551076134984, 0.044145561426384705, 0.2197381098037473, 0.40076065983524944, 0.421216162729827, 0.23960654465359887, 0.11465093433138462, 0.10926900223874547, 0.10522489768320176, 0.07169082823131412, 0.11984378558495556, 0.05501998943565323, 0.10025432081767449, 0.09449303877850268, 0.06953774670129242, 0.07584732670700245, 0.09649787764185536, 0.11228642265445765, 0.05451876018637758, 0.055773562717394976, 0.11781094451694829, 0.08023560335800262, 0.09527959241149364, 0.08448689948111443, 0.9882168729167988, 0.09934472598198685, 0.9905347647389341, 0.9289677460102713, 0.983354088745762, 0.9761274347216224, 0.9804096597136471, 0.9872539472723861, 0.9835259478022076, 0.05978351667479087, 0.2707518743944566, 0.09478557852300051, 0.30529981838729137, 0.3527376712101693, 0.324873635549898, 0.3162233127319525, 0.08789768328627268, 9.999999999998899e-05, 0.17265153487092866, 0.26023986032484103, 0.7826675173984197, 0.1761524377285819, 0.2738704010112417, 0.2786172664470412, 0.1573661711970411, 0.20575801085885081, 0.8146673691321427, 0.19213000836682026, 0.12868421808125763, 0.1436031180552616, 0.2519160769970872, 0.1347491132421692, 0.10727491330540906, 0.488722480251936, 0.22145031054673003, 0.27827824092885944, 0.2522498653883004, 0.21624974472964253, 0.12716519244612812, 0.23654261777430496, 0.1878366339584734, 0.12795006646326423, 0.13297510276449742, 0.1314466860504796, 0.10301643267119875, 9.999999999998899e-05, 9.999999999998899e-05, 0.08361048118798065, 9.999999999998899e-05, 9.999999999998899e-05, 0.014945084550534005, 0.15680448996173035, 0.18093568045388664, 0.4293873819936599, 0.22033611263080832, 0.29681205395782695, 0.2191700328115217, 0.3814012471350374, 0.025090218871331116, 0.024627308017108995, 0.4736590086422724, 0.05753343311373116, 0.3193242855249314, 9.999999999998899e-05, 0.28636287118902504, 0.04768779757428021, 0.1474223721719249, 0.1311373828162239, 0.08437552307145435, 0.1116914142689297, 0.09210983085536806, 0.0663831608264549, 0.2190306308904877, 0.24593549303204698, 0.1782828787019045, 9.999999999998899e-05, 9.999999999998899e-05, 0.23280763016182393, 0.04872874113837167, 0.0486562988164434, 0.12809581735995257, 0.5958475467836422, 0.6548063257250927, 0.668584056466248, 0.5190357166488149, 0.1814043998345065, 0.5505816434797348, 0.5973147095491669, 0.5692378290591522, 0.5678971175221386, 0.07352098013175512, 0.06241440036632262, 0.04208752525405257, 0.08805455131884043, 0.08662936634013663, 0.10247421710791782, 0.10102612416093637, 0.07885507200502706, 0.08275942946758119, 0.2717018520955736, 0.2335133789834174, 0.11712283472939233, 0.23162797909721056, 0.2430482117218732, 0.1660455686480936, 0.2559395897421378, 0.21522543055731946, 0.2079233504970176, 0.1760513775118019, 0.3068828848629631, 0.22025065092101104, 0.2751537749804652, 0.22566919088589288, 0.32793874084733465, 0.2719292580075532, 0.3817302282904711, 0.3115119772230942, 0.24796682181808793, 0.20222413908803183, 0.1672052345093885, 0.26513516543708615, 0.1946163425131977, 0.21995843504365953, 0.14960304127154178, 0.31645296720894256, 0.10315154686417483, 0.1958139377604834, 0.18634175347021165, 0.17475315694307014, 0.18767382036334435, 0.1845806263822125, 0.17737207414446454, 0.19393220147748025, 0.18638003294847472, 0.18978076023720836, 0.19414255800534674, 0.1986608018067454, 0.19740596432774682, 0.19913626857759192, 0.18724421722154616, 0.2155822210068603, 0.18108237713982422, 0.22004111303292206, 0.17197510353098788, 0.8288519412477424, 0.16523770888051825, 0.1522623577549881, 0.8962933849443614, 0.19958711462743672, 0.20049560767153685, 0.1230505718544237, 0.1706936210941773, 0.16690332347285586, 0.11580511345078104, 0.2109058191208243, 0.12517322347525828, 0.10979572250878755, 0.16824307046640408, 0.9007255454661655, 0.3471814197749524, 0.2852276668988839, 0.11826091863302135, 0.1790050227103689, 0.2027381289366692, 0.1801026193412283, 0.17703276667865775, 0.18643510032400368, 0.1997520607520612, 0.18653015760850644, 0.1832311193154168, 0.17909024806442098, 0.07829538635259137, 0.07354802510146796, 0.0790710205371955, 0.06280251179143836, 0.07272290585691721, 0.06391736620211963, 0.08370661590971518, 0.05744362824543037, 0.066942758766382]}, "mutation_prompt": null}
{"id": "ee91b60b-c5a6-42ef-9b94-95108761f988", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "132e7cf0-9cf2-461e-a627-bcc9744c3606", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "ae7a522b-0cf0-4f24-898b-4a9c5b6d0351", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "d3c3c664-e8c4-46fe-aa84-f21c7e4035f5", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "32687590-5a14-42ea-a828-5f0d52b6c909", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "280b9ae3-1301-4d7c-b58c-7d0df419aed2", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "10e40783-fa80-4c3a-9dcb-52bc75c57250", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "3bc9338f-e1bd-4e58-b823-1fd64735d0bb", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Adaptive inertia weight\n            dynamic_inertia_weight = 0.9 - (0.8 * eval_count / self.budget)  # Change 1/5\n\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * r1)  # Change 2/5\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * r2)  # Change 3/5\n                cognitive_velocity = adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = adaptive_social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (dynamic_inertia_weight * velocities[i] +  # Change 4/5\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces dynamic inertia weight and adaptive cognitive and social coefficients to improve convergence speed and accuracy.", "configspace": "", "generation": 21, "fitness": 0.25624505350697385, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.7732460472181151, 0.7507775635335858, 0.7857780282262571, 0.16720074608025404, 0.18577385254898193, 0.7467217497918088, 0.7898598894483357, 0.7855293990987666, 0.17426875588598356, 0.5913860481170023, 9.999999999998899e-05, 0.02962347283954181, 0.5541387814820471, 0.04354141005262968, 9.999999999998899e-05, 0.04628383408933501, 0.05194517788551001, 0.5433979448164614, 0.10005145243897551, 0.11221348976632928, 0.10547160959143309, 0.07247290344522062, 0.07596346293593326, 0.12120498244023348, 0.10827688474637742, 0.11874112455560293, 0.1089537665302438, 0.10668906547240586, 0.13457625702806397, 0.08543963622153783, 0.1078388188645446, 0.12251192957169876, 0.09598183808724248, 0.12137871145420154, 0.07818064189199936, 0.06767617484085864, 0.9911520276347501, 0.9788372359175859, 0.9910810453469109, 0.9631320585973289, 0.9871394721927943, 0.9861498469326117, 0.9862534260651938, 0.987184453713643, 0.9846455359869195, 0.5062233209981656, 0.46766695910523914, 0.3447611433655501, 0.4449150454641465, 0.18313678378181153, 0.4653888529879435, 0.5031156984596812, 0.08816708135985407, 9.999999999998899e-05, 0.6763213345068666, 0.22984390636131613, 0.8438162231957844, 0.08970726171037857, 0.2766491252008938, 0.2012733955932512, 0.7398187170313791, 0.7660212980084613, 0.3081600958111861, 0.14695204239858672, 0.2673502851884184, 0.1526957429961494, 0.12174789486716764, 0.2095999889799326, 9.999999999998899e-05, 0.13359633633587997, 0.13514496639871854, 0.21620014929889342, 0.24080464588819306, 0.009788697344025654, 0.11988341990107076, 0.1925632222124729, 0.10286563797557768, 0.27520930356873263, 0.12486034373632715, 0.1159188977118294, 0.09713789873935097, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06971904289308417, 9.999999999998899e-05, 0.019237310309304312, 0.0826443789364254, 9.999999999998899e-05, 0.06405154123752399, 0.2288152171718869, 0.07494488645938313, 0.12275371054527973, 0.2986531299957096, 0.014997351418541638, 0.024645694358412573, 0.1578270278952234, 0.20923301919328974, 0.04336513852899826, 0.04319534110024037, 0.06602801835459304, 0.041943042724913004, 0.0648092866799792, 0.06569966537955674, 0.11081062843503897, 0.0833982281301262, 0.0923001939316096, 0.059739646464556095, 0.11149264520175017, 0.33280667220698945, 0.21152013836671457, 0.16155306950347514, 0.25106924525088137, 9.999999999998899e-05, 0.1129388639553972, 0.04460974980760124, 0.07542284907129737, 0.5617385137038015, 0.6274459630686018, 0.49487006977610903, 0.5537974203073035, 0.5888666068617039, 0.6138859538998959, 0.691313530698878, 0.5947661877352577, 0.5714765396507979, 0.06156213561259771, 0.0528170148318613, 0.08528588833586892, 0.09756188806045285, 0.1336548393918915, 0.1189942150987836, 0.12833993317224468, 0.1108406163310447, 0.11337034095885978, 0.14746834600455072, 0.141221893215707, 0.16258360031005303, 0.1833328658564759, 0.24185485280583519, 0.17929942465163384, 0.19309082481442386, 0.1339465193385322, 0.20155053953870083, 0.2840483129313357, 0.30074159658248567, 0.2409467935076196, 0.41563614156162265, 0.2744354420534054, 0.21849372261192845, 0.2893543417204826, 0.36557062646722804, 0.19664236755744358, 0.22701276897711586, 0.221776490019308, 0.19793393868301834, 0.29748277169972603, 0.23782374984235388, 0.1905219079156968, 0.17131319747807738, 0.26573359222175674, 0.14372135484021986, 0.19446452714425477, 0.20606679733751443, 0.19828815343651318, 0.17558865625573505, 0.20295199777110184, 0.20331413443687796, 0.17654701382520377, 0.21473139148860065, 0.183540501206493, 0.1918681761875639, 0.18573534697201477, 0.2341584978299267, 0.21223431572967744, 0.2033398729026591, 0.2404216765648014, 0.1786554219962745, 0.19545990584640394, 0.21855414418504815, 0.162098538073578, 0.7513162703832011, 0.15042973955740213, 0.7918527760527878, 0.1981071072892273, 0.19800380029137132, 0.09945913389943162, 0.1682105764034001, 0.7259406522756154, 0.08273880070389028, 0.20436018549320734, 0.7691220358925388, 0.6303201788454802, 0.21457731409600633, 0.20013897359616373, 0.1923503534051113, 0.29170141651990167, 0.3505071375813169, 0.1835283942922542, 0.19148805105001598, 0.1770844806096158, 0.17701406190285962, 0.17292603560530329, 0.17924688394838773, 0.20318033490128606, 0.20192254710358337, 0.1964635616259648, 0.08045460390405479, 0.06887290928337186, 0.07900016869699789, 0.08425011452743114, 0.07450774170075836, 0.06978999524985341, 0.07915118100746166, 0.06902179351134785, 0.08254653303053239]}, "mutation_prompt": null}
{"id": "d9134ed4-afce-419d-8bba-e44601763fe7", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.inertia_weight = 0.9 - 0.8 * (eval_count / self.budget)  # Adaptive inertia weight\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] += np.random.normal(0, 0.1, self.dim)  # Gaussian noise\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive inertia weight and increases population diversity by perturbing velocities with Gaussian noise dynamically.", "configspace": "", "generation": 22, "fitness": 0.19967997647650348, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.3979803457608596, 0.39789488913731585, 0.41538894468506826, 0.3941024546389158, 0.3983848071628848, 0.41228709415582065, 0.42368000512231596, 0.3936214689332861, 0.395791307321412, 0.027935080928998324, 0.01697988056821087, 9.999999999998899e-05, 0.028663377456400352, 0.005293167073603611, 9.999999999998899e-05, 0.0038285284568714273, 0.021222633672002167, 0.031231300353381064, 0.08118525722701819, 0.11033038334514289, 0.0939801340872003, 0.11203444615639713, 0.11856183784269392, 0.09951460490077457, 0.097518829697541, 0.10529512247480632, 0.0947690156002513, 0.0656425427329892, 0.07728991200148538, 0.07862522945545569, 0.08060560276243689, 0.08171886824041086, 0.06435301281317496, 0.0979631009424573, 0.09324318906761908, 0.09311665430005778, 0.9875790808759246, 0.9748556960893194, 0.9904001704608005, 0.9726306195742643, 0.9895212071529506, 0.8953878882558999, 0.9889279527392169, 0.9867415888627007, 0.9865191575491767, 0.2545608806881885, 0.22368243585235903, 0.22946139693835865, 0.24734788690444098, 0.2500341518333473, 0.2319270870159128, 0.21412413842557154, 0.25723848875283006, 0.21897551458438724, 0.3078091663531918, 0.3323933584405149, 0.34156586177231396, 0.31659225847538597, 0.3106712179026734, 0.17709861420830753, 0.2435555539600961, 0.3395557706404344, 0.3143428479142102, 0.16043800997209878, 0.1490353206163083, 0.1428367596663649, 0.11152370248492549, 0.16178743204939006, 0.1104591214918812, 0.16363265015491957, 0.1514692118049088, 0.15520843767744086, 0.14858203327383468, 0.09954485632641719, 0.12744181511109998, 0.12373099970080148, 0.13119022815583503, 0.13058608076385458, 0.1461839369860516, 0.12303295447441909, 0.10953855234419929, 9.999999999998899e-05, 9.999999999998899e-05, 0.016912394535055664, 0.0028281089713569907, 0.005150171208083143, 9.999999999998899e-05, 0.008844077597987443, 9.999999999998899e-05, 0.03654348481315206, 0.07002332262192756, 0.03831003862369686, 0.06433870094368954, 0.11148752070920909, 0.0033234435704582177, 0.022946642372651538, 0.1432673182273102, 0.0709468346988591, 0.05130783600917088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05141312689403699, 0.0883940356239713, 0.09676573141586209, 0.0619407440127101, 0.10499321794926197, 0.07055904786939404, 0.08372584752389522, 0.0457374182340855, 0.08179962006499208, 0.38078048538032394, 0.37690240070992553, 0.3905905276833721, 0.38369290540005485, 0.38110284710034625, 0.37122255441485963, 0.38176079897062987, 0.37539194408964927, 0.3754515162622195, 0.09995808961027997, 0.0788294224703977, 0.051691688179306805, 0.08352085834418854, 0.07055690036196705, 0.11026442600524655, 0.06000020897700831, 0.09396648432104338, 0.09719699306923668, 0.16529273934583966, 0.19195163895776735, 0.1424031767980185, 0.22383719965475024, 0.19664891461646938, 0.1418521052338878, 0.23470143315511283, 0.1725422322680923, 0.213296678609051, 0.25962887229078346, 0.26838219595132284, 0.2728974066667176, 0.2605351810493869, 0.261563486808439, 0.28402242586350646, 0.2342787319602695, 0.28640920575651563, 0.1688435171175504, 0.172433380442491, 0.17644546757222612, 0.1489440171778722, 0.20860784141269173, 0.17729571482526807, 0.2300771647230172, 0.12647723240885056, 0.21528312493464885, 0.18564125277345067, 0.19915616428989846, 0.18337052067227544, 0.18655471920644018, 0.18253360820766018, 0.18644615191601122, 0.1933400985363739, 0.19249948590838972, 0.21004290446039553, 0.20920732242246465, 0.19077745333403695, 0.18111489213592424, 0.1876275259505864, 0.19433497682352785, 0.19121837973433686, 0.20635111383421167, 0.18234287881133038, 0.19722691142947324, 0.18871767705514253, 0.576753514557052, 0.1575151180417863, 0.15364907757260426, 0.5137922201456044, 0.19641072691078065, 0.19481224429915056, 0.09953441029356414, 0.18355003776963819, 0.15702700070286446, 0.08266591871152285, 0.1695357652592513, 0.12422552152934263, 0.2024581455387755, 0.4409079728132975, 0.4766569817957971, 0.21080367215676055, 0.61072001649001, 0.19578393946741324, 0.18853496388285285, 0.18322551573958712, 0.18769296294557147, 0.19295362706136665, 0.18331531973636594, 0.1889349895568564, 0.18149201291459227, 0.18859979321166342, 0.19142582138047037, 0.08006269540902267, 0.06481845670145325, 0.07264903535680078, 0.06999808568315002, 0.06683046650043178, 0.07914500647680345, 0.0882365623574749, 0.07208043611350856, 0.08522690054542892]}, "mutation_prompt": null}
{"id": "d680d810-4141-4060-959e-559febbcf5c3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "58cb8507-5b41-4e19-9661-844d551e21f3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "349fcd49-c063-481b-a690-25ce7ae111ad", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                # Dynamic inertia weight adjustment\n                inertia_weight_dynamic = self.inertia_weight * (1 - eval_count / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces a dynamic inertia weight adjustment for improved convergence speed and solution quality.", "configspace": "", "generation": 25, "fitness": 0.26159099243330036, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8995935752145394, 0.8751853435470175, 0.9031549947859774, 0.86726925302024, 0.8762058273111627, 0.9005663711214938, 0.9155861566857972, 0.9004300281277925, 0.9107656512549714, 0.7410673238373807, 0.041445395509394856, 0.05480158826407555, 0.3861780121806071, 9.999999999998899e-05, 9.999999999998899e-05, 0.5562774201941, 0.7276844912259175, 9.999999999998899e-05, 0.08555167458859292, 0.0835459609237661, 0.09009651148868647, 0.11014280634548124, 0.14383017908376972, 0.09042016742098657, 0.07763610225860518, 0.10917910810857834, 0.06340558325163603, 0.11362568542217755, 0.11615406623200941, 0.11446655123622662, 0.09024447963754012, 0.09321618273708487, 0.0839674356099116, 0.0789707060011855, 0.0709753568318845, 0.1166774068523242, 0.98732842456244, 0.9485937471454741, 0.9877883617977937, 0.9701815748076453, 0.9783422298302572, 0.9828926378632881, 0.9803215217926889, 0.9830037188561916, 0.9771018612074908, 0.6403659652561678, 0.6094003657739144, 0.10305357811628313, 0.7083550045168607, 0.30729362996008835, 0.5431159651186078, 0.7495529264078975, 0.10340527284895251, 0.7185174214018226, 0.23164277125338417, 0.144808852863077, 0.1785930143812573, 0.08137308635068441, 0.21121623164678593, 0.21116932537042998, 0.07214067099425314, 0.17931608764219342, 0.17851586689437648, 0.23071235502585263, 0.13203384198735546, 0.167038545599962, 0.16083357723330682, 0.16382355649796487, 0.1673976189491606, 0.133615872668162, 0.18355628107993838, 0.15304492047349905, 0.1351271106194023, 9.999999999998899e-05, 0.13170500960691278, 0.19952308463669777, 0.13183050733713209, 0.13095376226208122, 0.1313146613026327, 0.1544083010588987, 0.10872131074092473, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027017328498842863, 9.999999999998899e-05, 0.03488118123476236, 9.999999999998899e-05, 0.0638020578759333, 0.0010608907006591783, 0.39294709634781644, 0.04755418260945932, 0.04091397790376816, 0.11596364878900334, 0.16651844604420707, 0.014796457518555184, 0.027667168680769683, 0.21436311402232933, 0.058487561334486404, 0.0817208882127628, 0.05077941752267345, 0.14959304203084833, 0.07200540625115226, 0.08736853140018996, 0.19044259201651081, 0.12741034244640215, 0.10509394487354817, 0.20527903081451926, 0.07436622807402493, 0.1897359986867697, 0.09287533597715625, 0.21018639723066512, 0.11619664795044815, 0.03925927422854403, 0.0066710234551381475, 0.10357544372592109, 0.04663677677252964, 0.08333371423460323, 0.6324663507832812, 0.6201653815023269, 0.6020369694157847, 0.5935541587836017, 0.5907865213416199, 0.6184576863962785, 0.46799005492931445, 0.5829816240215271, 0.5271981171224237, 0.07817986626364093, 0.06334725641029526, 0.04142210628962162, 0.15707332234694782, 0.05130754226012435, 0.0703736447810579, 0.14043988677751118, 0.11059424217033087, 0.08330724050402583, 0.23899027283666963, 0.25247658151448515, 0.3365520191632976, 0.22121119605366013, 0.3484336021787865, 0.14568572706345928, 0.2382053633834469, 0.169792403937858, 0.16004798936668796, 0.1464616928143656, 0.28072489180114846, 0.16518823013821182, 0.24979766424802052, 0.2584836878917469, 0.211911276729698, 0.2556417851467887, 0.33573744637075253, 0.3064297186659032, 0.29853817738863986, 0.1311760556929481, 0.1640731979502752, 0.3397102894676748, 0.1725348441810498, 0.18199862334882433, 0.22592186954372262, 0.3669520747456808, 0.20094921507403163, 0.2143728269720807, 0.22178055599639146, 0.21154141284121353, 0.19750082637853983, 0.2196519767580849, 0.19629941782261318, 0.21169317451621783, 0.20492502712458616, 0.18663950126245332, 0.18095858125300157, 0.2158407429435789, 0.20286206238636229, 0.2249928457413496, 0.18645468520104402, 0.20905724894048594, 0.18889974240936647, 0.2017945177827528, 0.19364154192953853, 0.26388140959434825, 0.18808504927297487, 0.1354909923964671, 0.17320674344180387, 0.20103290284535236, 0.20040646747051294, 0.12326032333355674, 0.16901456710147444, 0.16787463781924694, 0.15622341036349185, 0.20583453641020844, 0.12485558412915032, 0.10464856968855552, 0.2248333898562872, 0.900939212197955, 0.10534503074400203, 0.7895111163068116, 0.6627624274091757, 0.1855093686381819, 0.20542488171426831, 0.17922900348313087, 0.18249104985366105, 0.18241430005510528, 0.193803548691878, 0.19279411729503504, 0.19914433770561646, 0.17537080305697694, 0.10406612968387985, 0.09775188158046277, 0.09575830983865585, 0.06487407945009582, 0.0779396669459207, 0.12306966172123734, 0.09195064140380294, 0.1802925517746986, 0.08401372539453678]}, "mutation_prompt": null}
{"id": "ad1658ed-64da-4d66-9935-6bd2645a99d2", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "2df96dab-f7a2-4568-8057-d0bde4603fa4", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "1d629095-452a-407f-9334-2ea79929572b", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            dynamic_inertia = self.inertia_weight * (1 - eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (dynamic_inertia * velocities[i] +  # Updated line\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces a dynamic inertia weight in the particle swarm component to improve convergence by adjusting the influence of previous velocities adaptively.", "configspace": "", "generation": 28, "fitness": 0.26159099243330036, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8995935752145394, 0.8751853435470175, 0.9031549947859774, 0.86726925302024, 0.8762058273111627, 0.9005663711214938, 0.9155861566857972, 0.9004300281277925, 0.9107656512549714, 0.7410673238373807, 0.041445395509394856, 0.05480158826407555, 0.3861780121806071, 9.999999999998899e-05, 9.999999999998899e-05, 0.5562774201941, 0.7276844912259175, 9.999999999998899e-05, 0.08555167458859292, 0.0835459609237661, 0.09009651148868647, 0.11014280634548124, 0.14383017908376972, 0.09042016742098657, 0.07763610225860518, 0.10917910810857834, 0.06340558325163603, 0.11362568542217755, 0.11615406623200941, 0.11446655123622662, 0.09024447963754012, 0.09321618273708487, 0.0839674356099116, 0.0789707060011855, 0.0709753568318845, 0.1166774068523242, 0.98732842456244, 0.9485937471454741, 0.9877883617977937, 0.9701815748076453, 0.9783422298302572, 0.9828926378632881, 0.9803215217926889, 0.9830037188561916, 0.9771018612074908, 0.6403659652561678, 0.6094003657739144, 0.10305357811628313, 0.7083550045168607, 0.30729362996008835, 0.5431159651186078, 0.7495529264078975, 0.10340527284895251, 0.7185174214018226, 0.23164277125338417, 0.144808852863077, 0.1785930143812573, 0.08137308635068441, 0.21121623164678593, 0.21116932537042998, 0.07214067099425314, 0.17931608764219342, 0.17851586689437648, 0.23071235502585263, 0.13203384198735546, 0.167038545599962, 0.16083357723330682, 0.16382355649796487, 0.1673976189491606, 0.133615872668162, 0.18355628107993838, 0.15304492047349905, 0.1351271106194023, 9.999999999998899e-05, 0.13170500960691278, 0.19952308463669777, 0.13183050733713209, 0.13095376226208122, 0.1313146613026327, 0.1544083010588987, 0.10872131074092473, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027017328498842863, 9.999999999998899e-05, 0.03488118123476236, 9.999999999998899e-05, 0.0638020578759333, 0.0010608907006591783, 0.39294709634781644, 0.04755418260945932, 0.04091397790376816, 0.11596364878900334, 0.16651844604420707, 0.014796457518555184, 0.027667168680769683, 0.21436311402232933, 0.058487561334486404, 0.0817208882127628, 0.05077941752267345, 0.14959304203084833, 0.07200540625115226, 0.08736853140018996, 0.19044259201651081, 0.12741034244640215, 0.10509394487354817, 0.20527903081451926, 0.07436622807402493, 0.1897359986867697, 0.09287533597715625, 0.21018639723066512, 0.11619664795044815, 0.03925927422854403, 0.0066710234551381475, 0.10357544372592109, 0.04663677677252964, 0.08333371423460323, 0.6324663507832812, 0.6201653815023269, 0.6020369694157847, 0.5935541587836017, 0.5907865213416199, 0.6184576863962785, 0.46799005492931445, 0.5829816240215271, 0.5271981171224237, 0.07817986626364093, 0.06334725641029526, 0.04142210628962162, 0.15707332234694782, 0.05130754226012435, 0.0703736447810579, 0.14043988677751118, 0.11059424217033087, 0.08330724050402583, 0.23899027283666963, 0.25247658151448515, 0.3365520191632976, 0.22121119605366013, 0.3484336021787865, 0.14568572706345928, 0.2382053633834469, 0.169792403937858, 0.16004798936668796, 0.1464616928143656, 0.28072489180114846, 0.16518823013821182, 0.24979766424802052, 0.2584836878917469, 0.211911276729698, 0.2556417851467887, 0.33573744637075253, 0.3064297186659032, 0.29853817738863986, 0.1311760556929481, 0.1640731979502752, 0.3397102894676748, 0.1725348441810498, 0.18199862334882433, 0.22592186954372262, 0.3669520747456808, 0.20094921507403163, 0.2143728269720807, 0.22178055599639146, 0.21154141284121353, 0.19750082637853983, 0.2196519767580849, 0.19629941782261318, 0.21169317451621783, 0.20492502712458616, 0.18663950126245332, 0.18095858125300157, 0.2158407429435789, 0.20286206238636229, 0.2249928457413496, 0.18645468520104402, 0.20905724894048594, 0.18889974240936647, 0.2017945177827528, 0.19364154192953853, 0.26388140959434825, 0.18808504927297487, 0.1354909923964671, 0.17320674344180387, 0.20103290284535236, 0.20040646747051294, 0.12326032333355674, 0.16901456710147444, 0.16787463781924694, 0.15622341036349185, 0.20583453641020844, 0.12485558412915032, 0.10464856968855552, 0.2248333898562872, 0.900939212197955, 0.10534503074400203, 0.7895111163068116, 0.6627624274091757, 0.1855093686381819, 0.20542488171426831, 0.17922900348313087, 0.18249104985366105, 0.18241430005510528, 0.193803548691878, 0.19279411729503504, 0.19914433770561646, 0.17537080305697694, 0.10406612968387985, 0.09775188158046277, 0.09575830983865585, 0.06487407945009582, 0.0779396669459207, 0.12306966172123734, 0.09195064140380294, 0.1802925517746986, 0.08401372539453678]}, "mutation_prompt": null}
{"id": "5793d390-c88c-48c1-851d-3bc8543e8db6", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "3a75a6a4-a9dc-4eaa-9129-8f5d9079f2c1", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "220a6c34-f612-4794-a95e-a217503d0ae0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "579b58ee-266b-4876-ac96-0fd2e6d97f0e", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "ccc651e5-b8aa-4165-a487-6561c5b3d8f6", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "9e4f6118-687b-46a6-9d91-bfd545b1a029", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Dynamic inertia weight adaptation\n                dynamic_inertia = self.inertia_weight * (1 - eval_count / self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (dynamic_inertia * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Adaptive differential weight based on iteration progress\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5) * (1 - eval_count / self.budget)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces dynamic inertia and differential weight adaptation based on iteration progress to enhance convergence and robustness.", "configspace": "", "generation": 34, "fitness": 0.2586622729064469, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.9083838940930119, 0.8785947178398139, 0.9030932010908321, 0.8783047298389097, 0.8641576487086676, 0.8808246609685543, 0.9181525079317995, 0.8924656784101059, 0.9082673110027074, 0.6653070679444046, 0.06544005936887098, 9.999999999998899e-05, 0.6536553807480935, 9.999999999998899e-05, 9.999999999998899e-05, 0.7251125180544831, 0.3855895179138411, 0.003301672878896711, 0.17871848393174405, 0.11890650699170202, 0.11175078613322764, 0.10870555945333327, 0.14284376685081335, 0.08106343629188417, 0.09802181841108382, 0.14047397315717258, 0.05572969043682774, 0.11900037545196196, 0.11825310455146332, 0.10603478846537384, 0.0980520286893225, 0.09330144460005452, 0.10851066936589382, 0.07639653473594066, 0.10664435471313882, 0.11238254974580142, 0.9873284190601497, 0.9485933993665747, 0.9877883618051803, 0.9701807301180906, 0.9783422040920495, 0.9828920380749893, 0.980321707816887, 0.9830037014639792, 0.9771022465220808, 0.5827407687056108, 0.5548595461410848, 0.1041358329802512, 0.5667762784737316, 0.1729254632603865, 0.6967885090292976, 0.585315025688833, 0.1432833997391696, 0.43164896759618054, 0.23164277125338417, 0.14823662626164225, 0.18285166554025023, 0.08137308635068441, 0.21121208489838428, 0.21122520203847894, 0.07214067099425314, 0.1786987451223676, 0.221963918653863, 0.18015113696574425, 0.1318410279021609, 0.1455456296724298, 0.17243619792468812, 0.157293095143476, 0.16731358048912093, 0.13340328034829596, 0.19195703271063713, 0.16643974636228254, 0.14669746454689303, 0.0743362352862369, 0.13150360100194702, 0.1501032472511732, 0.13195769251772127, 0.1312217937409349, 0.13026102268189876, 0.12335038426118339, 0.10872968358163104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011911435915433088, 9.999999999998899e-05, 0.065332512653274, 9.999999999998899e-05, 0.07187482224195296, 0.04910543133965273, 0.04052464646091869, 0.1784655236401712, 0.09496801218530004, 0.03406456422862192, 0.03371196417981026, 0.3460659054844504, 0.058840908042780526, 0.15135758054380766, 0.05016491123633171, 0.14411090861454667, 0.07247254480371579, 0.0875759887197255, 0.18988228311990363, 0.12314948568306772, 0.10504768833217082, 0.20792972686478695, 0.07365191851021136, 0.18954710926996088, 0.09383788468386844, 0.21111362589816662, 0.11922538924570547, 0.039279312136874744, 0.006678949928842326, 0.09106388256439113, 0.046637814153738466, 0.0835342559335529, 0.5259311018652452, 0.5391340746011093, 0.6408773907198496, 0.5066663609206075, 0.5706299745269817, 0.4998637770859591, 0.533542835033127, 0.6628575822681995, 0.581204587960993, 0.06933264137576711, 0.06905395084269927, 0.043660611409751304, 0.0962588755867344, 0.04482456398749013, 0.08336810041224796, 0.1284636432446098, 0.1111172868220972, 0.09181590024305575, 0.2347011915939896, 0.2346065456710289, 0.20699768878169322, 0.2335719036479419, 0.3714063054497926, 0.14077072621795683, 0.25225216901337477, 0.17930463330367652, 0.15981903881972193, 0.14535078290670134, 0.28955175899210917, 0.16929479861564234, 0.34504918959212116, 0.24200954563776156, 0.2866020353817843, 0.4389342621297271, 0.41473074245511476, 0.31791270074326794, 0.3048395717910354, 0.2626276094468666, 0.1745641275391796, 0.31721925316528754, 0.1581101664855047, 0.17045273656535376, 0.21257773636276656, 0.29509297081707897, 0.2358468950951529, 0.22988439346071377, 0.23138767131783589, 0.20904493239600197, 0.2354753144884727, 0.1943723337852431, 0.19515690678192954, 0.23019982235156977, 0.20265744040949785, 0.19140833369597132, 0.20703213605660453, 0.22879354861660983, 0.202855341441056, 0.2063364577872674, 0.22418352981287004, 0.20689596795316023, 0.1889706238678548, 0.209603362587527, 0.18829009953510956, 0.2638780050998173, 0.18818809304233275, 0.1355496627675824, 0.17320620678846899, 0.20105455706926045, 0.2004071664775655, 0.12326475169957718, 0.16901753221208238, 0.1678753706570647, 0.15621487896424446, 0.20688824851617327, 0.12509857311427042, 0.1046571909252989, 0.22483322919618942, 0.7051185257711654, 0.10534504508172271, 0.8173982476942685, 0.5375166095890883, 0.17778211867349014, 0.2272023846896456, 0.1878794834304911, 0.1950774645812725, 0.2355608318655884, 0.18975052448626695, 0.18621118566017947, 0.19899872647113626, 0.20187565632576565, 0.09005291278645167, 0.09013313086701547, 0.08719892160064979, 0.07710715812059787, 0.0758581417950045, 0.10863116897566594, 0.08143385205736065, 0.07914851759436603, 0.07490766285020578]}, "mutation_prompt": null}
{"id": "f953bcde-2212-49ef-9f6f-10f95fe3eded", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            self.inertia_weight = 0.4 + 0.6 * (1 - diversity / (self.upper_bound - self.lower_bound))  # Update inertia weight\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines adaptive strategies by incorporating a dynamic inertia weight adjustment based on the diversity of the population to enhance convergence.", "configspace": "", "generation": 35, "fitness": 0.1723471497727712, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.35044983659527174, 0.3890051019583307, 0.3740884702481776, 0.33588039800646674, 0.1885797601564243, 0.3280124793665684, 0.3338835020489197, 0.3531027605851812, 0.3085723286034848, 0.028311919625916948, 9.999999999998899e-05, 9.999999999998899e-05, 0.018122829095047366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006127580485979722, 9.999999999998899e-05, 0.07615645523353964, 0.08302459172103505, 0.08278195907446684, 0.07755371435848957, 0.06441089432996783, 0.05130897126527312, 0.1058085970604925, 0.06392361536328084, 0.09657835985023355, 0.06586002332304286, 0.060551243029762, 0.06000372011554045, 0.07214693939474437, 0.0523109564995099, 0.08802235601244468, 0.09786752482771899, 0.03436522300385769, 0.05445472504395277, 0.9910267614973596, 0.984788738712716, 0.9939244516371606, 0.9378057751518029, 0.9871735565298113, 0.9839075749492994, 0.9878623273389683, 0.9906009456053101, 0.9847671419444867, 0.08033797573145618, 0.13772160250251908, 0.053890156650876264, 0.19541218208166866, 0.12905316237052633, 0.13948563059426855, 0.08812632765784378, 0.08549909478704953, 0.08332834423731506, 0.19081715893166284, 0.24104651664520138, 0.2866045393039066, 0.19244326622274643, 0.11828200712485615, 0.20517266252897925, 0.20414219633223074, 0.19675048702430986, 0.170610038586122, 0.1736274820572311, 0.18999808392385442, 0.13649879268486498, 0.1513068674888518, 0.1091753784575289, 9.999999999998899e-05, 0.10098509037431125, 0.10126658839772462, 0.12372759597482252, 0.11297037290890899, 0.10292624103824743, 0.1224203072986445, 0.12021471066995348, 0.04504742793388883, 0.12040153842365142, 0.10705990122294351, 0.0017687229295243467, 0.13921919631976976, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028785210260488525, 0.03936891621562555, 0.03915222536528995, 0.0439105443684672, 0.08795448513768334, 0.03476804637942865, 0.01812575803298222, 0.11270236074472817, 0.07575803177059193, 0.07504332540245595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019100409740818725, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11076274298114108, 0.10988640469117761, 0.08984228157428698, 0.060171989349527166, 0.02831902820051746, 0.002260531138567834, 0.05598324058989401, 0.041731730848920234, 0.04970024766813963, 0.3590170419990609, 0.3730129089683867, 0.3494725566332926, 0.30705369844246666, 0.2069622184812563, 0.2088838986522239, 0.38587167965503455, 0.37800454838944364, 0.3028463316307137, 0.05795630451620459, 0.046869501384296575, 0.056757762088591845, 0.06391911552528817, 0.0735810909603768, 0.11450363937480457, 0.07237402057880904, 0.11783588460968752, 0.0713883899017217, 0.1818638969153793, 0.21078232584541534, 0.1393371059579256, 0.17876050977522773, 0.19894321903970635, 0.13568127542954111, 0.19005899573576257, 0.13244220985956856, 0.1788172064798147, 0.2050153843016953, 0.20163511492343655, 0.22337656820581997, 0.23140639664678608, 0.1843498154454145, 0.23168822570584102, 0.22544005863543526, 0.2701611317257083, 0.22081090881073506, 0.18141939072797786, 0.1297442248374675, 0.18906059377845463, 0.1710033096256206, 0.24495891189501495, 0.1879112947651742, 0.17715626461702172, 0.1880436139308741, 0.08956857681550445, 0.17396133636893518, 0.17057093501867526, 0.16049651431465795, 0.16790859537042857, 0.16890351808238047, 0.19079515340039876, 0.1679517515151745, 0.17819440726617364, 0.16872762250279505, 0.17246010176586568, 0.16203392641725678, 0.17232928268730652, 0.1740514868917029, 0.20593851473979685, 0.17192120770853292, 0.19807407737984428, 0.18084263062234873, 0.16911916669255422, 0.4704420517438077, 0.18411525279678798, 0.12453652983586216, 0.47146979317380844, 0.19676386832297044, 0.17016175566451397, 0.12117505771001613, 0.16846127212917905, 0.139247940851296, 0.16129714718099364, 0.16487061819193283, 0.13679187489851696, 0.1933862081310469, 0.21325394088697702, 0.4680459000690693, 0.19816836945836713, 0.2838692720981072, 0.20263625272576957, 0.17884509323632558, 0.21174586554925867, 0.18570389253372943, 0.20227012459561278, 0.20241890771305449, 0.20101775171008796, 0.20213136371676865, 0.1875980614647107, 0.18726561862691626, 0.08006718849818895, 0.06415606932606766, 0.07291916216890293, 0.058107316544924625, 0.04790656532686022, 0.05061677285638233, 0.05820429894048107, 0.07205861270971159, 0.06914196103373504]}, "mutation_prompt": null}
{"id": "62458ecb-68db-4a61-8d9a-0408aedee4fb", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "3b8d2cf0-620e-4bd8-93be-1135780df4a2", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "fc7367a4-7e05-43fb-81e5-68f8704962d1", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-0.1, high=0.1, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances the hybrid swarm-inspired metaheuristic by introducing adaptive crossover and differential weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.894040904426846, 0.8719666289877804, 0.8948182101047353, 0.8806107961879536, 0.8662671605333186, 0.8791183264797611, 0.8879806937722001, 0.8928005923812545, 0.8964274128443289, 0.6368629413547023, 0.6371487499618953, 9.999999999998899e-05, 0.790082160947964, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359567947144023, 0.7602524197162469, 0.0536070713428769, 0.12744118387889014, 0.1181160779588798, 0.08286831525008087, 0.10496603162001816, 0.08588308890782415, 0.09896053355575218, 0.08488107124972977, 0.11267147942469258, 0.05485205494403167, 0.1397935680153436, 0.11903615961389025, 0.1005443841089605, 0.0908717066655561, 0.15682037410202487, 0.10094084955784421, 0.08897108781583007, 0.11995033688610202, 0.11239281536205614, 0.987333621909683, 0.9447167333544922, 0.9878290113167927, 0.9702535225410004, 0.9783587770825309, 0.9829020108493942, 0.9803347127214872, 0.9830088401322735, 0.9771211117133258, 0.709450420615474, 0.6995874861470766, 0.07755612350609442, 0.7515490602386532, 0.15403368240207416, 0.7217818146022845, 0.6635602104028533, 0.40841388115041466, 0.6397046152786544, 0.23168247575138723, 0.16795531850981116, 0.8761788295777656, 0.08137308635068441, 0.3750764510705793, 0.20734176086038725, 0.07015223072441601, 0.1808353719021648, 0.2326247248049007, 0.5813290009204218, 0.6027054207581317, 0.4910072333254616, 0.43357314054566287, 0.4183329704275325, 0.5234129758540254, 0.13421622466650984, 0.3674882094606573, 0.23113212082644408, 0.3059432171736999, 0.22610743273266776, 0.132716999387971, 0.3598784772237741, 0.5895656475170041, 0.33264358414890516, 0.13459339672280202, 0.17166694815474803, 0.12125420148840349, 9.999999999998899e-05, 0.0369690296869003, 9.999999999998899e-05, 9.999999999998899e-05, 0.17802942477693073, 9.999999999998899e-05, 0.10359510200681565, 0.1075601586579924, 0.12707038038797636, 0.06895916942429559, 0.08142649318639816, 0.09534230408550681, 0.11778358567860325, 0.08183046451029219, 0.13379723298185942, 0.2829355767859776, 0.09558850485601711, 0.18650341439769946, 0.04984775779499828, 0.17096614886324546, 0.08010079181387664, 0.10315484730866387, 0.20041925661079307, 0.1483492156303926, 0.10271952409579932, 0.21000650119047581, 0.07470690155936754, 0.18643599673931022, 0.23401237256689422, 0.212245314063649, 0.1388273788927772, 0.20063724928692606, 0.006560697585470954, 0.12815073319568016, 0.0438985557527809, 0.0828827524657183, 0.7241993950311616, 0.845262961459679, 0.6085144452268305, 0.8696383767610095, 0.6942173964972367, 0.696872554052981, 0.6970135092170293, 0.7201138581645449, 0.6508694070166059, 0.07093460560884468, 0.08088734198063763, 0.09222777193117926, 0.12187434167019096, 0.06145492129855412, 0.10380530170621516, 0.07445541990125693, 0.09697621356798658, 0.0726623287996293, 0.2628094842093399, 0.3695301401003227, 0.15663945673527346, 0.24766767971382464, 0.200970519795861, 0.12393353118503003, 0.28287093888381565, 0.16026880345559802, 0.18054704089060558, 0.2746914691865747, 0.2646807184774592, 0.3395517890618326, 0.3201111302967573, 0.22396239875218105, 0.2775760582291328, 0.4704870452896931, 0.33238312209186294, 0.21965435613008133, 0.30452957614237874, 0.27518783953926684, 0.14995638869428474, 0.2890285866251484, 0.1834883698449632, 0.19234233012670632, 0.21340545344418382, 0.2815142112292879, 0.20606993261207518, 0.18715822225276102, 0.2512033953038556, 0.21010088252462833, 0.19525298268226976, 0.17512740448297026, 0.18844893351416458, 0.21293138675113976, 0.18362243378362642, 0.22917125441175568, 0.20838423436790887, 0.22753309396451293, 0.21853732144958626, 0.17992843615920118, 0.7767067956185703, 0.20880742875245895, 0.18074051583396944, 0.22027238588769948, 0.17858109673257694, 0.10502289666537801, 0.1879849398998722, 0.13500223051630433, 0.17320018960023587, 0.20106818688415673, 0.20028013367621733, 0.12312553315747932, 0.16897830930377167, 0.1678859205820643, 0.15622731335904794, 0.20797013939017361, 0.12534009481099728, 0.10446021364306268, 0.22531521809457966, 0.9276219043506136, 0.10533537312708363, 0.910175859813403, 0.8651110804598925, 0.18411478608190768, 0.19535589422453603, 0.1799343978199518, 0.19046153522779907, 0.1823100197385007, 0.1841072508951822, 0.1787921569705082, 0.19264772135406516, 0.19983429191351743, 0.08200806146361683, 0.08373471630634, 0.09457197007942031, 0.08456501258375138, 0.08036375773271687, 0.08952131083128556, 0.09701533103876303, 0.088251405740287, 0.05940630019717241]}, "mutation_prompt": null}
{"id": "733f35e2-7cb3-40e6-b009-454d857446d8", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 39, "fitness": 0.3593930381561505, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "a4c47f08-b948-4148-933c-fed8ab3d0973", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "ed875c6e-95db-4ddd-ae81-5f56c4001f2a", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            improvement = np.mean(personal_best_scores) - global_best_score\n            dynamic_velocity_bound = 0.1 * (1.0 + improvement / np.abs(self.lower_bound))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -dynamic_velocity_bound, dynamic_velocity_bound)  # Adaptive clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive velocity bounds based on improvement to balance exploration and exploitation dynamically.", "configspace": "", "generation": 40, "fitness": 0.27816309492601393, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8480478165301072, 0.8374036210919162, 0.8574757564489073, 0.8292979850941375, 0.8193311014395153, 0.8479705564532902, 0.8517594255094425, 0.8350183748864969, 0.8107832788373741, 0.03343314975081235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10393235942301449, 9.999999999998899e-05, 0.37709655472116277, 0.44711462174932504, 0.004844537181535102, 0.1525693691842469, 0.09187713468052772, 0.09287289717457681, 0.08694388979729561, 0.06903632342606358, 0.07476494271980572, 0.14071460966389715, 0.10696797147869164, 0.12219527972427335, 0.11105052473597765, 0.1519063033056678, 0.06365993240768364, 0.09412950187292268, 0.0691388126704322, 0.11726923488565588, 0.06357271363709782, 0.05585506315648869, 0.08392825304881613, 0.8388926706361627, 0.8122988017504404, 0.7216031530227813, 0.7964347632495392, 0.8434111747433143, 0.8711686952435522, 0.9118480856964798, 0.9143802741158542, 0.9085722266507613, 0.6048673160180142, 0.5282589364804104, 0.11030403517260778, 0.6190495719517382, 0.5297193040927998, 0.15263324674728462, 0.08753508540714938, 0.08673523055983767, 0.0851680230159565, 0.21174454482719962, 0.09337142692596301, 0.13874043908543243, 0.17459661605797594, 0.21362769443535679, 0.19564035867530916, 0.17281231909434502, 0.15240275415812032, 0.2363620657537191, 0.4414435626496904, 0.4030145955774136, 0.33838881771988805, 0.12814918616920346, 0.12333413961572659, 9.999999999998899e-05, 0.20906504387396885, 0.47415486302795695, 0.4769037656744307, 0.38774706727440156, 0.13667490328361587, 0.12268624730288469, 0.4216198141760996, 0.13721698705224827, 0.12233511859133994, 0.4698023862673425, 0.35175716580749483, 0.3259412967224422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0840503710801822, 9.999999999998899e-05, 0.00910665989203574, 0.24244154848359567, 0.16089563033408283, 0.3228813418134101, 0.06601269060910164, 0.062423863899442766, 0.05505675143418176, 0.021774648162221966, 0.03321988428924161, 0.020378684294490634, 0.21566975174922753, 0.05957205192113613, 0.0752076140294815, 0.036250830153496616, 0.02225927394593341, 0.03980489268217313, 0.05929041035977134, 0.1568797554443465, 0.060819936770414085, 0.0703549013435324, 0.10217680007117835, 0.04936329920088578, 0.20772067062455057, 0.1430293785511092, 0.19666439216886, 0.005961962947127919, 0.3093564729412084, 0.005822769649343362, 0.26306528392166373, 0.008691129087598393, 0.0772609707566686, 0.7754094152792811, 0.7535316011058547, 0.7553954802372359, 0.7748125390912208, 0.7104510632975307, 0.7202595642830008, 0.7545055236368874, 0.7227596391115572, 0.7535573771794464, 0.07741028251080317, 0.05032673094239448, 0.12148837638113874, 0.09834612000250942, 0.09725835381237014, 0.1594428065085136, 0.0697273651293181, 0.0791599678203474, 0.1077022790664689, 0.2504756620468348, 0.3406904275944116, 0.171407222041424, 0.21853642677731044, 0.5431097638124764, 0.5724403967359315, 0.6187731791902049, 0.27639586326463994, 0.31508671874280625, 0.23731704589616887, 0.4870660860662269, 0.2212433957736526, 0.34064401191272164, 0.27546325874773725, 0.2864535925773215, 0.4446934422535981, 0.4247684495252435, 0.35550126352569755, 0.19485818877279248, 0.3473887858740483, 0.19729499202060052, 0.2872810913558719, 0.25291915007831145, 0.24109939517505274, 0.2186913941511226, 0.2577042389496792, 0.07510984005130683, 0.21394714252509217, 0.22728416161751552, 0.24309999749318978, 0.20445111019438889, 0.20166061184896011, 0.25554398576954573, 0.22316627575221315, 0.20689433250836942, 0.19728881071714732, 0.1814602472910406, 0.18618407578185803, 0.19256710564409618, 0.20086248819584074, 0.21717433636954953, 0.18373613151669144, 0.17137659830842422, 0.18728420936655976, 0.18037071108671499, 0.1265820241756379, 0.18831608463243155, 0.15399035656966464, 0.931024861706017, 0.20126281776042265, 0.9467101273170225, 0.12238779524629118, 0.9298156893025138, 0.17653774400712496, 0.8510075951108085, 0.21103394201105152, 0.8627396040548287, 0.7922500205384277, 0.20763751446984535, 0.2117393378293706, 0.10498177246836382, 0.16785588111651595, 0.0943554316291546, 0.19161748892079478, 0.20974909181037626, 0.17403787089584366, 0.17326105105966105, 0.18175546227671946, 0.19755770665341488, 0.19081678090928156, 0.17569129138570438, 0.17844189698058288, 0.10086058462827352, 0.1216752703902737, 0.09072254429318038, 0.0871273235834904, 0.08733056267384742, 0.09688865196986429, 0.08661133178264446, 0.09438502112535951, 0.07741957878482464]}, "mutation_prompt": null}
{"id": "82cd5a72-a156-4771-8b56-ae708a12966b", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Unchanged\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Unchanged\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Unchanged\n            adaptive_cognitive_coeff = self.cognitive_coeff * (1.0 + 0.1 * np.sin(np.pi * eval_count / self.budget))\n            adaptive_social_coeff = self.social_coeff * (1.0 + 0.1 * np.cos(np.pi * eval_count / self.budget))\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = adaptive_social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Unchanged\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive learning rates for personal and social coefficients, based on evaluation progress.", "configspace": "", "generation": 41, "fitness": 0.33798296422456175, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8217008016082321, 0.825084474691931, 0.8288387480190145, 0.816935282886309, 0.8328645162267617, 0.8314693733868654, 0.8424419495213512, 0.8254808980174714, 0.8019832509436272, 0.6306443720736493, 0.5612702240904253, 0.5984722691343047, 0.6504830838722248, 0.589539351102258, 0.6658617772556503, 0.6103091090468442, 0.5916084835946811, 0.5846359368136058, 0.6138813025945591, 0.1389237628168687, 0.1314580143096291, 0.15601669448220656, 0.15288156923700935, 0.12247134095136569, 0.12173540835080765, 0.11716297081567995, 0.1549265079930917, 0.08957465665816544, 0.06701647170686442, 0.10711813023636674, 0.10708292523169216, 0.13715779086655566, 0.10193122578758318, 0.10310620964123796, 0.1271433306028672, 0.06310447206447112, 0.91717417179059, 0.9017007266578937, 0.9162374045135596, 0.9453138867752889, 0.9077939769585099, 0.9560182172641771, 0.9158797649837713, 0.9183484890396411, 0.9236224157487897, 0.5139225905941014, 0.5310542846558148, 0.5269945155243538, 0.5485604538343808, 0.5406927034759608, 0.5461971466005509, 0.5462769975169386, 0.5188248585642419, 0.543652174200778, 0.8540320477404618, 0.22022019815589677, 0.22221199484667786, 0.37122525210062773, 0.2142425422083568, 0.26818544476287487, 0.17529192276204486, 0.25988976984000967, 0.2273576273878316, 0.5992299881629337, 0.33247812958966483, 0.38815315397084027, 0.5542501616233866, 0.5716086492884537, 0.15987812030070947, 0.554874270821651, 0.43574038402397464, 0.4776452834355358, 0.5026725031973227, 0.12775594641341126, 0.4917812696200332, 0.4661174278033131, 0.13064615003567837, 0.5382896946883049, 0.12717333282123966, 0.4631273263250183, 0.5036122642402773, 0.09402496982545894, 0.16313008516798833, 0.08822357224605981, 0.0386386331764208, 0.13001359359312104, 0.04801184861963936, 0.2310104847309159, 9.999999999998899e-05, 0.05467876644352454, 0.11406684904258035, 0.08182234439110436, 0.15529297584589308, 0.0851803510202157, 0.13899586102419947, 0.03686993048553, 0.0761275667437269, 0.10725579662030016, 0.07163648417927337, 0.17602906163933385, 0.18745422480009277, 0.14373715924836872, 0.2007550483241637, 0.22239749265799724, 0.09119504834111136, 0.12630412944775804, 0.14602605811422542, 0.11664278924138949, 0.1950306608241965, 0.0870490392047113, 0.09036005947092396, 0.3040461606339119, 0.19016639236285804, 0.2664291676246737, 0.09364490374889556, 0.27491777283312313, 0.18948382847369916, 0.7410246715764855, 0.7325111313885455, 0.7732904189786748, 0.6195632312146198, 0.6914647632715054, 0.7272662215218617, 0.7255161709194256, 0.7226046099279279, 0.6912293227281843, 0.14004398898572923, 0.14933399647423962, 0.14925458710864037, 0.1395883088811214, 0.1375524089105602, 0.10657765791759521, 0.12770504848958242, 0.13393753021938826, 0.09469653455719329, 0.14593822166888315, 0.15494447574595838, 0.15613796634546762, 0.21017935881753624, 0.16408770646818482, 0.16053922614665228, 0.2162411066430514, 0.17228154773849913, 0.1493586910329151, 0.29958590094900595, 0.4326106635994992, 0.353387191726495, 0.27608664992500553, 0.3201484682752741, 0.4441419595173445, 0.23359752117730737, 0.3213956428002894, 0.3707326659043515, 0.19594454817280016, 0.31281748102736173, 0.1580842299111309, 0.20222687847744825, 0.34207408899603875, 0.26310383963616, 0.24544558222748214, 0.34941656375954666, 0.2943097411407998, 0.21905670110355335, 0.22953230936474722, 0.22705708438454364, 0.2161083053412104, 0.2118869046551144, 0.19767219326728613, 0.2117396343564365, 0.19736174498646397, 0.19162732243513725, 0.17101526429674163, 0.18191519851491833, 0.2503886471308544, 0.19514130288189868, 0.19672111780646184, 0.16693576134050436, 0.2210888906249746, 0.2073795349340397, 0.1975660679100324, 0.8098781999225779, 0.86035673760827, 0.17954474974917956, 0.8501418517540702, 0.17172536646738468, 0.887976513652903, 0.6957335901902311, 0.16920202403516438, 0.1639778712847294, 0.7304157650269099, 0.6360988776426713, 0.711227053104319, 0.20560414594505638, 0.12616063355910012, 0.8753032687365805, 0.20141040276313515, 0.16380614332222598, 0.16620026422999523, 0.1868523429526162, 0.18230773226349828, 0.18887749274247645, 0.16805971498529393, 0.17848237444202464, 0.20555090518618613, 0.18751716646579286, 0.20211008319098778, 0.17439925909376675, 0.09563201940249733, 0.0862544426208125, 0.0821315725556051, 0.09528164145248497, 0.08416612556797298, 0.08428619048501296, 0.09640912397337853, 0.08112259927188858, 0.0869220889763681]}, "mutation_prompt": null}
{"id": "35c5b4dc-699f-476b-af1a-aff432b5f983", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "4309b053-fa6e-425a-9cd3-5ccfd130be0b", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            if eval_count % 10 == 0:  # Adaptive population scaling every 10 iterations\n                self.population_size = max(5, int(20 - 15 * (eval_count / self.budget)))\n                \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive population size scaling and velocity adjustment based on convergence rate to enhance diversity and convergence speed.", "configspace": "", "generation": 43, "fitness": 0.345781450903506, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8124045991712848, 0.8209806048965884, 0.8160204943963175, 0.8284718932656876, 0.8035426617954196, 0.8356907279701118, 0.8359187451163923, 0.8479978188357875, 0.826520198678231, 0.5583288222102962, 0.5981338508824636, 0.618387284483366, 0.6509111484036607, 0.636822549762903, 0.6163378617677082, 0.603391024441041, 0.5756765865997973, 0.6124152278532062, 0.11318254246697357, 0.16972970989482505, 0.14069059209445045, 0.16455528338036052, 0.15172060152437405, 0.6102107736335071, 0.1144160661889908, 0.18031234745745883, 0.13070810319200754, 0.09197368451813381, 0.11796717106108734, 0.08945787198702071, 0.10841395952134503, 0.11309681465321919, 0.10751669528731489, 0.10511020717033681, 0.10385648861714492, 0.08917675802216563, 0.9355521203684793, 0.923411252333241, 0.9366379132738073, 0.9162128481415642, 0.9075400779475359, 0.9233943964040896, 0.9291828916560908, 0.9305525448501336, 0.9580601024516026, 0.544023653110528, 0.49021707676771176, 0.5411197282860365, 0.5670289624372846, 0.5276182393080224, 0.597297345867057, 0.5069314122220007, 0.517165066440181, 0.569276451352261, 0.37515417932124007, 0.1777826715823918, 0.854767079901216, 0.8859397771773915, 0.8848096734782135, 0.2710866394975293, 0.8449378302562927, 0.23067887667128084, 0.22956433830038991, 0.37920134592955823, 0.11589818477522351, 0.3390712458284393, 0.5768292661886196, 0.4602547442192868, 0.12930069001337052, 0.3418300470433937, 0.5109467387748385, 0.4936886399730239, 0.4198007558914979, 0.38215566693821534, 0.3544747996203058, 0.2387149039768417, 0.5803606030809846, 0.3594872905894325, 0.4742495868520349, 0.20405805979157954, 0.40393170401254763, 0.06837767182489374, 9.999999999998899e-05, 0.14112449531849147, 0.03539900874038726, 0.046023365136885874, 0.06140365837815043, 0.0675671269043796, 0.045712233801039504, 0.024954586357491593, 0.1224941761260896, 0.12911619659778228, 0.13554391851486158, 0.06881695564526125, 0.11217019104503867, 0.04262494899265945, 0.1494752385044561, 0.14719767027793096, 0.09489651549397549, 0.06380143371965874, 0.14971889366512736, 0.1499298946219656, 0.07217572370251091, 0.13025966946284495, 0.11288781201418097, 0.14741553853170042, 0.24058671431512935, 0.1956053377317618, 0.292051704804969, 0.12359305346229921, 0.18931130453625145, 0.23481549674106938, 0.20240390879812287, 0.2471290314383804, 0.2623897712076353, 0.17034460147135155, 0.2591970012867124, 0.6597322783604838, 0.7365566400794052, 0.7747960752609665, 0.6127576458595827, 0.7143740803697711, 0.7017577899487615, 0.7148290487535567, 0.6140741862110131, 0.7416968797147477, 0.11238717269851062, 0.14039637755832668, 0.14845024517719407, 0.14066250184474394, 0.1490362013450406, 0.13823161197593348, 0.6370026696045158, 0.14812864437353657, 0.1078624394973029, 0.1494604048882695, 0.14571766231579786, 0.16628855374754226, 0.20094318923356658, 0.2628307155338129, 0.2589741006843417, 0.23028538926211628, 0.13962934766939306, 0.2516033994852671, 0.32195326749120545, 0.2969611138352384, 0.37798117986069424, 0.21483832698318706, 0.4333018818792057, 0.467321912914456, 0.2941548591066344, 0.33277707457080885, 0.2877151310118031, 0.25708207233954583, 0.18258833838280697, 0.23296685484202206, 0.24868476933284434, 0.14880556873621387, 0.35412333173464516, 0.20084565455997427, 0.27166162997346743, 0.13900064542986856, 0.1996298379099204, 0.20932044541249106, 0.22587568074705244, 0.21940675685816435, 0.24073209529515127, 0.2058867169178048, 0.21684115507904467, 0.21433717408369934, 0.20092817466800228, 0.1787970609201106, 0.18318472131531238, 0.1743163656535287, 0.18665304181145892, 0.1669338080713907, 0.19951186360768847, 0.17409313669930637, 0.2170894237816121, 0.19158739659876678, 0.16960766165409058, 0.863195225888103, 0.18207811605023783, 0.18723862548670978, 0.19482986953559467, 0.1964242063179935, 0.7958952702835459, 0.830120797101149, 0.1742604308544473, 0.7849876455943138, 0.701265692474287, 0.1517913900138521, 0.20363523771154213, 0.20122772038538184, 0.7573505248081485, 0.7657753434276116, 0.7788834581017532, 0.6913396830578188, 0.19126913342441798, 0.22381030091957133, 0.1794649732316531, 0.17946926589939793, 0.18762252690474324, 0.20901484203395515, 0.1817007553381078, 0.181210102113043, 0.18883258487650434, 0.08937032427116498, 0.08407277679738978, 0.08598491373047978, 0.09422448180064347, 0.08177491299926132, 0.07563341981990779, 0.08933500224908475, 0.09130554127753421, 0.1015768755800367]}, "mutation_prompt": null}
{"id": "3a96bad9-58cd-42f0-8b3f-352e27a67be3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "e11791af-a4f6-4e9f-8e27-9cf9bb767372", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "06ad7512-e22c-4ab6-b973-91c7258d2aad", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "f01b3f6d-d44b-4ecf-aa60-b69dcf5ee7c0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                if eval_count / self.budget > 0.8:  # New: Introduce random perturbation\n                    velocities[i] += np.random.uniform(-0.01, 0.01, size=self.dim)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances solution diversity by introducing semi-randomized velocity perturbations during convergence phase.", "configspace": "", "generation": 47, "fitness": 0.3572973264030914, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185361748, 0.1212926125901519, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4667462063159509, 0.5507238831490702, 0.5258066250384875, 0.6005280748056302, 0.5051995349785238, 0.537750664620268, 0.5465834480578762, 0.5625253026381478, 0.5369919626029798, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46452507653876884, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20056523585876507, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.24207329302250258, 0.4859217767082963, 0.4444362684782406, 0.5306160817707342, 0.13074086021211428, 0.4628925883303354, 0.452917040168316, 0.3231397620005336, 0.42488590049562824, 0.09613363802773967, 0.20940655059949986, 0.0248813706133868, 0.04666338924106217, 0.1667539464086305, 0.03664668561640516, 0.4063948503840318, 0.20279895701634798, 0.054387871100825436, 0.15357473992384207, 0.15421944904579832, 0.12243277458294144, 0.07089387370245748, 0.11331745746911437, 0.03692527667627876, 0.10937456817310665, 0.12618179085975556, 0.08612375746910561, 0.18063365415150223, 0.1757323427174715, 0.21260679201718424, 0.33781811010538265, 0.232637454278791, 0.11510731724234924, 0.11489465709328361, 0.16134557503348135, 0.11971047034695315, 0.4016513316487994, 0.09992139753039997, 0.1727349647277695, 0.21803331122595548, 0.19586449150029162, 0.2546273040703172, 0.20552724416717472, 0.18925775101838294, 0.2999377214574602, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6876650632204135, 0.7329516486004173, 0.7027250809461498, 0.7205875261902377, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182206350803192, 0.2660857364136867, 0.17327755928285005, 0.21075746704323073, 0.1645818388883452, 0.14787115078368884, 0.1984513788349156, 0.2036242843208672, 0.1587560958323646, 0.3197644299046818, 0.38304089499218386, 0.25525695962817596, 0.44702113936946763, 0.4221569586707682, 0.46998985116605585, 0.4158860924606642, 0.35400749671003184, 0.38924394161247455, 0.3351280558284506, 0.2563271287733261, 0.25666545929763995, 0.26016904679083663, 0.2607336367139286, 0.33434230866847925, 0.24908242871800745, 0.3983303274732741, 0.2758694548334114, 0.1851880844940622, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.2009998166820247, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17382460048980197, 0.18450849854878226, 0.19170852739476651, 0.17799856323548824, 0.18482124849389558, 0.18227737045232328, 0.1801078980947043, 0.08271963157290796, 0.08425792927922116, 0.0870896169529718, 0.08446607946126528, 0.08674384746665942, 0.09752436834220102, 0.0969431010145112, 0.08888552076579126, 0.08916539793953959]}, "mutation_prompt": null}
{"id": "63f8549f-f5b0-49a3-8b58-2a59309f23f0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n        self.restart_prob = 0.01  # New addition for probabilistic restart\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n\n            # Apply probabilistic restart mechanism\n            if np.random.rand() < self.restart_prob:\n                population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                               size=(self.population_size, self.dim))\n            else:\n                population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances diversity and convergence by introducing a probabilistic restart mechanism in the evolutionary loop.", "configspace": "", "generation": 48, "fitness": 0.3051738638329621, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.6738509435170459, 0.7723496080532084, 0.8242704300219104, 0.6729026441889612, 0.7977811381181982, 0.7918084882659713, 0.6968297298543699, 0.8022956744094447, 0.7831052773308087, 0.26626785486072035, 0.4549738408294136, 0.5448743390786643, 0.2946176262878164, 0.525697281854786, 0.5593493366324592, 0.30740849686005745, 0.48585027490968435, 0.5444321087227948, 0.12347928486754356, 0.14370434869350412, 0.17272105583597674, 0.15543669437967167, 0.14412718527140678, 0.16213838203628983, 0.13157610442401035, 0.5121722325406433, 0.16643002070769675, 0.09056053938362019, 0.08332644350715057, 0.126466676318303, 0.10216114399719567, 0.10490602100331159, 0.08049252509700633, 0.09170998447276413, 0.09465853062198493, 0.11379401117948962, 0.8844927147213656, 0.9338335593113885, 0.9012874254565857, 0.8334426578370262, 0.9265559726587475, 0.9306752058461383, 0.8266520266462751, 0.9211476923031746, 0.9311261950104726, 0.3222647464697378, 0.4094951310132525, 0.47718009931101746, 0.28832787844818364, 0.4201133200146855, 0.49086625370370396, 0.24788366983379806, 0.5032960169288526, 0.5189916881105225, 0.573655675001931, 0.6681543266418286, 0.35917844014796163, 0.3234296716331716, 0.21213325461677446, 0.18779656983198512, 0.3265727473627049, 0.5349958636056386, 0.7405393116559478, 0.14616285181599165, 0.3762858764168876, 0.4616107422290423, 0.1715242080882906, 0.5127548017572909, 0.6372104328068688, 0.20427921520689296, 0.39722629958451494, 0.5333323497874314, 0.13366145664198792, 0.12685023962816555, 0.46136700259845986, 0.18032724833566227, 0.26877745144982945, 0.5023251383696278, 0.11960093428196839, 0.23384414785387975, 0.41364919083342055, 0.01951067730576217, 0.02559520009972438, 0.10528668649460182, 0.022349116469552288, 0.001402547101067686, 0.08553859238383754, 9.999999999998899e-05, 0.046403245560799, 0.011622004344438719, 0.10255203493504361, 0.1383759802186998, 0.1536885914211089, 0.10363696105494202, 0.12246471486148713, 0.06826756142961143, 0.11087826945913071, 0.12717526458041517, 0.11394801413917544, 0.11856253404209693, 0.1583774100890739, 0.09313451826065011, 0.11676250754176654, 0.1581853447235131, 0.08919181211120175, 0.11625728421064452, 0.2143938553353516, 0.14791140076479914, 0.0822312440381473, 0.13078016156157213, 0.1259047747526263, 0.11797947263971997, 0.15795479867791418, 0.19673423719235106, 0.10642278784975845, 0.14812176153315615, 0.20263159421051236, 0.5745616999547051, 0.6383604521532097, 0.6832696674822107, 0.4965052535275698, 0.553887893057572, 0.6844138583345487, 0.5035082435120719, 0.5546896644444539, 0.6928424072799828, 0.12662293207745556, 0.14803668733548425, 0.13947621349144212, 0.11757794166786839, 0.10964959713693057, 0.1067790522346258, 0.13218368329927654, 0.10754028314152275, 0.10982965644377474, 0.1456337852424402, 0.15354776215442656, 0.1847732251189631, 0.15297536503247156, 0.2060173849961795, 0.22821720002725343, 0.16660779392051994, 0.15914376356684423, 0.19431881261852368, 0.2608555087489537, 0.30895371004890093, 0.36302940608584633, 0.3487495210783397, 0.44554250430852593, 0.3963874661835711, 0.32948602156217177, 0.4072437035034706, 0.3388167897501586, 0.22526213124560013, 0.2594146433995308, 0.20744442022040577, 0.17089401432561846, 0.2772448486589071, 0.2790207150100581, 0.21083981122517348, 0.30673622220851315, 0.34067029133158544, 0.2318149319900784, 0.21690049845160553, 0.19662120728854482, 0.17932741646992378, 0.20548547554515462, 0.20042662110863618, 0.20298993117900532, 0.1975843693973015, 0.22292257198520027, 0.18047061254515262, 0.1805287028978002, 0.21541619113462251, 0.20555286230997216, 0.20097022507795614, 0.19556275436066994, 0.18935780610582975, 0.22336517611579654, 0.20505585269368454, 0.37465751422987803, 0.1690830675764109, 0.18435836743387612, 0.1759971881044965, 0.7767515180908231, 0.8258867671461465, 0.22639408708840447, 0.7951033908015659, 0.16494434379307754, 0.18102080003352017, 0.49591151272643297, 0.6607717808716111, 0.27729837325048734, 0.2006873031140285, 0.7558134930610642, 0.324876314454127, 0.2913009944037025, 0.6176925379382265, 0.1960140604065741, 0.20342084111023995, 0.1862799180027308, 0.1831144802931446, 0.1909560992711289, 0.17941751787339266, 0.17904181196698865, 0.18106189928700067, 0.18954659062616075, 0.07787780828393442, 0.0828610061967835, 0.08917275841459105, 0.08013257837541898, 0.07959894790878774, 0.0769223790865452, 0.06649152097038935, 0.07463457151513686, 0.09080828807116481]}, "mutation_prompt": null}
{"id": "3df83f5f-4f7c-480c-af6e-9e976d267e36", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            current_velocity_bound = self.velocity_bound * (1 - eval_count / self.budget)  # Adaptive velocity bound\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -current_velocity_bound, current_velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refinement of SwarmDifferentialEvolution by introducing adaptive velocity bounds based on function evaluations.", "configspace": "", "generation": 49, "fitness": 0.3458144681283478, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8367207430461837, 0.839778728253008, 0.830237100074847, 0.8187812338966531, 0.8389436005807712, 0.8397663851476891, 0.8530748969426055, 0.8329204202238447, 0.8244644972395918, 0.6194342835755735, 0.6632903853839924, 0.6214631705911486, 0.651083495937642, 0.5982047556665229, 0.6156569402335006, 0.6218400084498507, 0.6376669917401661, 0.5989251295604319, 0.1357436569798428, 0.15315145383854778, 0.6382806153936776, 0.15342034341517896, 0.1409341719593683, 0.12199847392038465, 0.1201747553108169, 0.13179314374958917, 0.15503584587727348, 0.10629523285150322, 0.10779161923614133, 0.12657012280431412, 0.09516404604375517, 0.1121921900839794, 0.0927253864358849, 0.07873035576228138, 0.10416846622107878, 0.1271465130246321, 0.907771023182604, 0.8962647409127316, 0.930956288808924, 0.9402506363075813, 0.9073779697099226, 0.9560669123756473, 0.9269739273307978, 0.909324356299472, 0.931079970779415, 0.5300123751296402, 0.5045421065303037, 0.5250878407190618, 0.6045765883344454, 0.5916016768102217, 0.5655827021798739, 0.5987577161855623, 0.5771079515265097, 0.5661798808596292, 0.827027159871361, 0.2209047076631473, 0.3690158075143055, 0.1719590034301144, 0.26821307374371495, 0.18615426601723306, 0.17477174970894516, 0.7929081125044541, 0.3505554176449357, 0.6664012593649897, 0.4307591173989085, 0.44277426532306496, 0.4588913621038315, 0.5008012413648113, 0.16097521925208125, 0.22328562191886525, 0.5268302645504189, 0.44207372342452855, 0.2680855960156009, 0.40656072322009695, 0.3874042331329559, 0.39934915968289353, 0.13068544075722544, 0.3927265201744332, 0.49319049253003, 0.34550318494720966, 0.4430706012846275, 0.16639034577778278, 0.1609220471061793, 0.04895658753376664, 0.047460293030807565, 0.06916447938878167, 0.031725765076823564, 0.10043806550835255, 0.02619747279286533, 0.08470589048171573, 0.10827685702098111, 0.11619202672839712, 0.11949339072618548, 0.07884467763286207, 0.1483505906802387, 0.10481754089048978, 0.14091382861915025, 0.10425550796116223, 0.14035223451042422, 0.17745977451928407, 0.171247212259365, 0.3123017583546177, 0.15993334153731065, 0.21934956574442044, 0.08418274713389051, 0.10885724459369595, 0.1521205093657363, 0.13019879479174856, 0.17213658601238313, 0.1428420656167515, 0.09603185085052124, 0.24445898081445316, 0.1913447274006731, 0.23336711546335032, 0.21666565082514522, 0.19142180529585873, 0.2118917283905103, 0.7323768911769637, 0.6978400152861557, 0.7686364666186901, 0.7375088882280376, 0.7303046817747124, 0.6904496230030163, 0.6313181737848055, 0.7313534417868286, 0.7611147022589639, 0.11179589820644364, 0.14749499732588778, 0.13934529791192363, 0.1654174470047246, 0.17310046187638506, 0.15269190248378395, 0.0927827833449183, 0.140978262451393, 0.13174051091073746, 0.17721129230454713, 0.17978725290956243, 0.14858798687164776, 0.27243643995798206, 0.17583085499332518, 0.19405930102147106, 0.13953966746496005, 0.20298367799080763, 0.14842920348846533, 0.22905254680580445, 0.2828560931328764, 0.3202031038740426, 0.3233111358271552, 0.3374896229138119, 0.252931858721102, 0.30781059613237083, 0.3729564599704014, 0.36029739491678825, 0.19120264471311443, 0.2768476149169945, 0.23221963867279316, 0.26506744158572315, 0.3056026812145852, 0.2545525635923567, 0.310595459371664, 0.3147368458267248, 0.3460786989999729, 0.2347825838463723, 0.1999991918664571, 0.19497344603952116, 0.19185535458842173, 0.20565286591875598, 0.23870766596308668, 0.23698387210164396, 0.24227258216063952, 0.22223260713375947, 0.17778043224767348, 0.19393515145555384, 0.25217087372699576, 0.2082795290610573, 0.18719473540549703, 0.17383608394301187, 0.20713972226075594, 0.23276634072123947, 0.2185562327264392, 0.8424623316975274, 0.8342544325879413, 0.1780320042678346, 0.8348357470396776, 0.765920002483702, 0.8963573925689609, 0.7426326909311363, 0.16875813385538008, 0.16373459129623402, 0.6770145265453686, 0.20445630637273682, 0.7433928009758082, 0.20578953861324378, 0.20293649342312503, 0.8896600149400853, 0.1657020577674213, 0.331753887416947, 0.16363941122176673, 0.20955321509218727, 0.18933542667536996, 0.20649816513307773, 0.19231767352767803, 0.18104666057799845, 0.17715824380825085, 0.19506432705984267, 0.19203675701258227, 0.18067100371039269, 0.08265369502786857, 0.07869137434336904, 0.08663423481008381, 0.08897251133033368, 0.0828143549091781, 0.08439064180221578, 0.08874896385406883, 0.09279815018809134, 0.08992934964726207]}, "mutation_prompt": null}
{"id": "c704c229-63e3-4bf6-9611-24fc12d6abc5", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "0d9332ae-9e6e-4282-9c15-7da3abe1d99c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "51428ad6-0cb2-4c1c-b8c4-27dfbce325b5", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            diversity = np.sqrt(np.mean(np.var(population, axis=0)))  # Calculate diversity\n            self.velocity_bound = 0.1 + 0.2 * diversity  # Adaptive velocity bound\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Targets exploration improvement by introducing adaptive velocity bounds based on the diversity of the swarm.", "configspace": "", "generation": 52, "fitness": 0.3353647651577641, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8295449640041912, 0.8422316180946484, 0.8485884799995079, 0.8357826767198095, 0.8322617487565476, 0.832754555880785, 0.8446979023831853, 0.8195829395803693, 0.8314264998944385, 0.5181986594476606, 0.29292243799554163, 0.5724989930952777, 0.6142846304885217, 0.5680674713873048, 0.6083799606596276, 0.1723753205051527, 0.5394091154038807, 0.5739846535240437, 0.14238721662463627, 0.1439325292626581, 0.15892133046290924, 0.09027756485743044, 0.10888521205132495, 0.11258036342455957, 0.11441469401215176, 0.09645512217132268, 0.11368555293089755, 0.08723593447280342, 0.14413286645327494, 0.08436103036003972, 0.10545362792394641, 0.10771050717186481, 0.07129716304578393, 0.062094691857157325, 0.09477928943064473, 0.09562241854901421, 0.9154676109082529, 0.8725631000967362, 0.8021759040448868, 0.8469580295660014, 0.9417111346112592, 0.7835052432927575, 0.9150951395857889, 0.8620875953659743, 0.7620031251904495, 0.5910717792901266, 0.49002846107414066, 0.615509629635105, 0.5986299776219555, 0.6225548498241043, 0.6010109558468013, 0.6358096602550116, 0.4880293793339938, 0.6128227241235762, 0.21756683473340543, 0.15313931753211563, 0.17009347054309654, 0.2752865365460694, 0.2124458624923462, 0.8563044951546401, 0.17514738023481224, 0.8622659093181522, 0.894557377948721, 0.5896350503179, 0.5865679554219165, 0.5552263300881557, 0.555913497599501, 0.6014672052827721, 0.18626363869684093, 0.5398777660556042, 0.553516911429365, 0.5556033291611766, 0.13538190391426252, 0.36391867627683494, 0.504769117523939, 0.49315656955083165, 0.5055666909605667, 0.4741733250219953, 0.49372542947072484, 0.12942845364811273, 0.13535102004885324, 0.1408505390119681, 0.06498033147201732, 0.10325685398217133, 0.14786538751194134, 0.13697488850632378, 0.08073376416352329, 0.12981463394210846, 0.07911947914210382, 0.19509111289534575, 0.17054365205680788, 0.08668615700641802, 0.15138682806330162, 0.08096871772260661, 0.03269612605821692, 0.09275766437630695, 0.18824583101477632, 0.12655060682864583, 0.08251838150027035, 0.23184049897002423, 0.14623927427399053, 0.18015032447036794, 0.30630305469534336, 0.2228311680049393, 0.16930736535273394, 0.12741104376232248, 0.12296744897526479, 0.0675581151950937, 0.15078767096995438, 0.19957968780049806, 0.23661387848779503, 0.21425305667186345, 0.22954947948891846, 0.11821795007345914, 0.3190362807147997, 0.22888944956224933, 0.08320150694838302, 0.762422311082761, 0.7625662378709698, 0.7307464696525205, 0.7189525311417972, 0.7417323494526606, 0.7558722803020819, 0.7076055367812121, 0.781170842128263, 0.7027922733846581, 0.07083308894597173, 0.10355508497994292, 0.0537218382944995, 0.14513479434097243, 0.08119154437176512, 0.11492504363390055, 0.11118256898705237, 0.10594868837280769, 0.09176490707072393, 0.2694091482633757, 0.19282945160138953, 0.19462515623604393, 0.31490289754011913, 0.27363068596278495, 0.48138586027529995, 0.26778480014662087, 0.24125023004101287, 0.18145984159005668, 0.20257982311070777, 0.2809303475519207, 0.23212509452360186, 0.19746465874889352, 0.26410765181780493, 0.30074259633258016, 0.14197798179372823, 0.47149606627407725, 0.14175346994529825, 0.15410096569671405, 0.3896120684337845, 0.2075887636999112, 0.22008239403374963, 0.3028459971669347, 0.2458523618712639, 0.15167194648631444, 0.2948877715965621, 0.109132507495322, 0.2554963636509021, 0.22030496814227385, 0.21638611553438336, 0.29155871952973433, 0.23183446948669362, 0.24056252795005717, 0.24577178632594054, 0.2733043381112754, 0.23329234294311052, 0.1809308707850018, 0.18805403889984507, 0.19120042657479042, 0.19188962956856792, 0.1716156483808713, 0.16667663874360406, 0.18893481032235881, 0.16946873854576383, 0.17752697353093094, 0.17811301627646603, 0.17398963713775595, 0.13196892221322765, 0.9153620885782539, 0.20041995449415184, 0.9259466165651347, 0.10789992542178983, 0.9173022067279828, 0.17617304967267777, 0.8238022638437499, 0.2052846954976505, 0.7793255976293944, 0.20662751185232842, 0.15619907457641424, 0.2099154324056126, 0.10481448294340623, 0.8218588770165293, 0.6757153139760358, 0.17951233806862987, 0.1868018929077212, 0.17897195212185035, 0.1877564418502834, 0.19956203795666694, 0.19603491087120906, 0.18123494877773616, 0.19889927894193504, 0.19030294895925748, 0.09660441836936406, 0.09340412812972931, 0.09248300742394022, 0.09944725695105605, 0.09493106119006156, 0.08422017165392714, 0.09432573767887376, 0.08667776583004327, 0.09335966631425452]}, "mutation_prompt": null}
{"id": "2f0a882c-e609-4fc0-bd52-8111f60ab9fc", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            self.velocity_bound = 0.1 * (1 - eval_count / self.budget)  # Cooling schedule for velocity bounds\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.3 * (np.random.rand() - 0.5)  # Enhanced adaptive tuning\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhance adaptive differential weight tuning and introduce a cooling schedule for velocity bounds.", "configspace": "", "generation": 53, "fitness": 0.33266870299922635, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8280968862506743, 0.8410713254612876, 0.8536953206059874, 0.8338890364616118, 0.8363661458277971, 0.836269065599678, 0.8472070629757845, 0.8114937934680287, 0.8178819922468076, 0.6353309435596182, 0.620634085120277, 0.6259310900929317, 0.6856491188413534, 0.6503233902423475, 0.6437881952580033, 0.6156248451790567, 0.6412889325517237, 0.640640663710182, 0.13663537924406466, 0.15298295683043506, 0.11476143809504935, 0.1540794349756437, 0.15293478189730614, 0.18104818442621085, 0.5700220671335153, 0.10193960947238334, 0.1411878277755344, 0.10646001562891594, 0.08880672989129412, 0.13448193954932464, 0.09634291767154879, 0.09326959346760944, 0.10694872474207406, 0.12520285815654808, 0.10676615052681515, 0.11268067718866948, 0.9159926583664895, 0.9066480060885624, 0.9127329240712885, 0.9424176488986717, 0.9162566355999299, 0.9562286898999095, 0.9174233080042569, 0.9178130483062467, 0.9207332810796338, 0.5748719495299285, 0.473667318530579, 0.5579962022462854, 0.5489766533200098, 0.5738618918333418, 0.5731602744920858, 0.5673199306521419, 0.5484092470757147, 0.5635796516666249, 0.21301209783736708, 0.7642134785374871, 0.37448707029193884, 0.2684557783761218, 0.20683604551576784, 0.2192636171446165, 0.1740489272532303, 0.21291785211671999, 0.8057869310555389, 0.4624589851490396, 0.34406599816160255, 0.5193992892925489, 0.5222285967590057, 0.5999350375439338, 0.164255917050931, 0.45462717346027126, 0.3896642761407234, 0.550787178969111, 0.386625920257177, 0.32861546183079127, 0.13181590286242117, 0.6380331909428338, 0.12901324508549283, 0.5150032550028172, 0.30245735855822287, 0.13121667038933116, 0.5313612014497916, 0.09453249978284717, 0.009633143572200797, 0.1067162480857089, 0.03733785170578796, 0.03471049664999082, 0.038981268402848435, 9.999999999998899e-05, 9.999999999998899e-05, 0.08965373338460902, 0.09178916891388256, 0.24285545013466647, 0.11078268685653314, 0.12719452648112817, 0.10184286083911798, 0.050496367543287346, 0.09316259353517653, 0.13667270730894565, 0.08204442369714438, 0.18487283822853917, 0.15666540868695733, 0.12839686830753727, 0.2629769459733219, 0.26125091710259063, 0.12129055160636293, 0.09953718900092212, 0.2598067179734488, 0.1777392785212334, 0.07416906342614604, 0.15592947108923705, 0.13143238119102119, 0.14404504205463686, 0.21067044001341817, 0.31005753525514856, 0.2673145038055941, 0.22896765458210555, 0.20399344486259474, 0.7510600924436387, 0.7252725320054445, 0.7012501579092392, 0.6911160894546925, 0.6487276280776789, 0.7343722393449776, 0.7409558539001226, 0.6400970807798143, 0.7514808984191915, 0.7050493556065448, 0.14021736479930447, 0.10965837638712073, 0.1364587287315735, 0.18028786978848643, 0.14403821227864555, 0.13860195246736162, 0.5951572288459706, 0.13933125920876377, 0.19898792503729767, 0.22115389089903803, 0.1507478157952159, 0.18155666311468, 0.2001331223303443, 0.14671086287797697, 0.19325903159019486, 0.1778589905967809, 0.20389527850345013, 0.24216952524295898, 0.3991427835830089, 0.34524311336451363, 0.44550594727915926, 0.2697509544475297, 0.25256027431137174, 0.4377750774986243, 0.4134797746718307, 0.3901312851278138, 0.2582201064501082, 0.31723803678912676, 0.13120787037456993, 0.19884654439937166, 0.3396188193871019, 0.2819182527551122, 0.12816546506944992, 0.283051459095804, 0.29353059639855494, 0.19836878603148156, 0.22783688350673026, 0.22842887237002352, 0.1965517577803938, 0.22735131338168513, 0.18905076809528876, 0.19877376509211175, 0.2070241220233462, 0.21812825802300018, 0.21654960784260413, 0.16960088409712848, 0.18672273427177954, 0.1827440612497937, 0.18388107000144982, 0.171068899359898, 0.18321284091616408, 0.18606618893555726, 0.22280060655044576, 0.16164975180374075, 0.1640076411861342, 0.1586087061321001, 0.8058514779089864, 0.8326565473719791, 0.19928358457893935, 0.16566706831193023, 0.16614242037027638, 0.16211447000634016, 0.799734486022918, 0.20804979092415288, 0.15176244768142588, 0.20859469202876757, 0.16145034594494156, 0.8452494577140308, 0.16722159515028256, 0.15301479448271005, 0.16434028242644272, 0.1844799643889703, 0.17375673320132168, 0.20201931436564724, 0.19142990003094196, 0.18105232359067225, 0.17940167781305594, 0.18620768785383757, 0.18944551620312577, 0.18048192997418666, 0.07865381333134669, 0.07760380114289855, 0.0848423904529444, 0.07654056896485106, 0.10087155553972349, 0.08664051254110894, 0.08479568578622199, 0.07672948578398331, 0.07880238445618493]}, "mutation_prompt": null}
{"id": "91c58b3d-dc51-4576-ade4-196de98b0f7c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "1499d77a-3f8f-4e14-8f68-4a35beaccb86", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (0.7 * self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)  # Added velocity-momentum term\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces a velocity-momentum term to enhance convergence speed and stability.", "configspace": "", "generation": 55, "fitness": 0.34358179428442015, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8934158671144985, 0.881807766684223, 0.9147793178393622, 0.8605887514547659, 0.8706991775634213, 0.8901439983903928, 0.8765884518290787, 0.8712587051493413, 0.8643741110692511, 0.7799123297169617, 0.7315421900095856, 0.7852088908030184, 0.7618609387100206, 0.7543270227169834, 0.8012211354621671, 0.7853766216533116, 0.7733957421646418, 0.7757720699933252, 0.15563810412144763, 0.15671507837924292, 0.18150553446634354, 0.13719920367909166, 0.1835194915417906, 0.11073472697498399, 0.11986425886899377, 0.17872942576065143, 0.1785192498285758, 0.1268774951034366, 0.06260090586843581, 0.13966797776135953, 0.08399285504167642, 0.1251384385863099, 0.11397509495384728, 0.11037545067525101, 0.13672538156241154, 0.07952399979376112, 0.9214735762573789, 0.913283769292792, 0.9065528877646256, 0.9288610490139154, 0.8940731326098021, 0.9393037370495356, 0.926307231999457, 0.903607895364405, 0.9124207044984805, 0.42871356136690664, 0.43837866078786314, 0.604446756249867, 0.4622729499991759, 0.6904819821226809, 0.6558762757346592, 0.6929232454028869, 0.6683512657563466, 0.6197008719795221, 0.2115495001069938, 0.8151253141249659, 0.3387353799371563, 0.20568023542770952, 0.8810616170898298, 0.26542997187265704, 0.17366162191830314, 0.2293258465221648, 0.7836470029083542, 0.686425073422763, 0.23839830268821227, 0.4093394620006455, 0.5530694137164576, 0.6196346489309204, 0.15153687647798575, 0.21784550511010625, 0.17998611635594186, 0.624291721548246, 0.31626365009381163, 0.1272173543866043, 0.3973728577378218, 0.44420147659746145, 0.38760245330860166, 0.4112613664248991, 0.24590608120359525, 0.22240041528075982, 0.5086740655579522, 0.11159724115212188, 0.04938605079297209, 0.05189991204971334, 0.04406463220440182, 0.13311032156401015, 0.008247944800173546, 0.09185846394451469, 9.999999999998899e-05, 0.0028869619513693934, 0.16489761173062234, 0.1070153189719042, 0.14483361104496706, 0.1343933367755944, 0.21709707531622568, 0.055794214366468475, 0.10075007075452869, 0.06738713793149909, 0.09961154352323842, 0.26103258642740856, 0.2644923218402938, 0.2543202260284445, 0.2100647346346306, 0.1724404754927904, 0.09416320752885154, 0.10022144215028295, 0.12142173708170045, 0.14579399292987527, 0.12388897831769463, 0.1939060847586901, 0.12264604948738456, 0.17933102841646087, 0.28008907380458914, 0.1282817110557507, 0.11045816129211783, 0.1437687816063553, 0.22559934767181633, 0.7688726802625167, 0.8383313779984363, 0.7272398669579792, 0.7926185349983609, 0.7055831139597996, 0.6618762241921023, 0.6236935281239402, 0.5959712723016845, 0.8378987905756069, 0.12736512921144716, 0.12344193518752689, 0.12206155734431345, 0.12248724474219108, 0.7430685450891574, 0.09499275616771119, 0.14056633603885693, 0.13399753733301223, 0.10807775960658927, 0.1676552282487329, 0.1742875911850733, 0.1567619874069931, 0.17228340647697837, 0.1698881029848509, 0.15058033822075156, 0.1512842695166533, 0.19279785611839706, 0.14954649159397848, 0.2698556046983186, 0.4704818174261388, 0.27073670805226846, 0.30010349383889057, 0.37816085229960705, 0.2650541977092915, 0.2785565486131172, 0.3475852549512737, 0.3207028578582468, 0.34024526286189916, 0.21169743719053935, 0.16624979905062298, 0.3439607496528714, 0.27292470790735734, 0.24954911999059048, 0.34130413852363395, 0.21065901013462895, 0.27132165323651847, 0.19176313947232781, 0.23322551968712957, 0.20404105613959622, 0.20029767883069183, 0.20320606031307897, 0.21803333546081405, 0.2098360778880738, 0.20157252814251292, 0.22615319234431697, 0.17791181389171162, 0.16736629920443447, 0.2105699623368099, 0.19145310067718246, 0.179943777501267, 0.17008020199776763, 0.1909363733178726, 0.2053610162794719, 0.17164317901565862, 0.1936350714853574, 0.16445272123435184, 0.18695640757583754, 0.7876293648506608, 0.787665784947047, 0.8896256676752187, 0.7429207127962243, 0.14609729470400712, 0.1628836581305816, 0.7969902834711393, 0.2058803332336705, 0.15148580656143162, 0.20481186589680278, 0.20145095962627624, 0.8630226467750426, 0.16739680028924686, 0.1643329939563578, 0.1648103544585714, 0.18347646436682796, 0.18344456451735092, 0.1864234339281987, 0.19789697413123253, 0.18142502592248655, 0.18594207839349808, 0.1837757039946618, 0.18917306798589129, 0.17910047893499592, 0.09379103806292843, 0.0862909554216752, 0.0859529053069038, 0.08663728474274213, 0.09551204095821719, 0.0901416801056597, 0.09489106344270315, 0.08870951066870825, 0.10016154384941434]}, "mutation_prompt": null}
{"id": "52200d35-136e-459a-9383-fab16d8676f6", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            adaptive_population_size = max(5, int(self.population_size * (1 - eval_count / self.budget)))  # Dynamic resizing\n            for i in range(adaptive_population_size):  # Use adaptive population size\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound * (1 - eval_count / self.budget))  # Adaptive velocity scaling\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += adaptive_population_size\n\n            for i in range(adaptive_population_size):  # Use adaptive population size\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(adaptive_population_size):  # Use adaptive population size\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances swarm dynamics by introducing dynamic population resizing and adaptive velocity scaling for better exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.30083805519125767, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8215893525627791, 0.8402075652348534, 0.8412151985005321, 0.8244663210089606, 0.8210097533032246, 0.8366451177128098, 0.8094665000031191, 0.8389035552004085, 0.8060709275874987, 0.4326252132584888, 0.5324107670885968, 0.3678623623422833, 0.609372383349482, 0.521689598986995, 0.5197469091276894, 0.5683940180883037, 0.6069447628081625, 0.6371851215836449, 0.13391084507087903, 0.18137257357984116, 0.17932803964997435, 0.14560292058506075, 0.1458937543819555, 0.11785686015020747, 0.1756694859888297, 0.15048155885324743, 0.163858122358006, 0.09670120180458508, 0.0965570325234878, 0.10740090885879094, 0.11165322494699648, 0.11642573456863503, 0.10843927496648609, 0.10968473618603825, 0.08388203977092767, 0.09794365402557359, 0.9466484022999762, 0.9395335381477, 0.9328993693236748, 0.9170234397987903, 0.9422880527066586, 0.9228024741447015, 0.9147736974819239, 0.9404621031155764, 0.9325031526441115, 0.4128414648089489, 0.4226127188721517, 0.330933363164318, 0.4511012338449565, 0.424391697193924, 0.4432636940311864, 0.38330642219790856, 0.3893278965071689, 0.39024774735728496, 0.2227744497340638, 0.13827100661659575, 0.36655398363548786, 0.2752194753871494, 0.2020065966257929, 0.23492110095108265, 0.8115198504590915, 0.2321485650077444, 0.3759614458299483, 0.18400327446679732, 0.20753611972164965, 0.44411962491986556, 0.39042194268744423, 0.26309709798158887, 0.13015832783376624, 0.5312608817510385, 0.12379413140841677, 0.31002087323412186, 0.18586201640429922, 0.183812561930915, 0.1329943506095449, 0.2270183977782726, 0.2719265973423486, 0.2722063099163242, 0.382637856391867, 0.238238864238005, 0.2692309827402716, 0.04781530052446248, 0.06242471575986708, 0.011039899808763964, 0.04630262363333515, 0.00593769738343386, 0.03269960901192992, 0.02279973758901066, 0.09435214330920771, 0.12985982341096025, 0.08578275932946766, 0.09456325219079187, 0.10625690332526316, 0.11961880333699204, 0.049384654522563354, 0.1329898949905075, 0.14336326162151747, 0.10264667045241349, 0.11200685108131181, 0.15978715269554655, 0.09370941906530805, 0.16453757205195585, 0.07448448169494681, 0.11665863115853858, 0.08744617425915968, 0.24185922334585308, 0.1173273323026518, 0.11371302435724451, 0.23385946001512492, 0.07749647016542405, 0.14285183923113798, 0.15705526976939177, 0.16603829048019558, 0.1757192287463749, 0.1276481817522368, 0.2420372788002434, 0.17754817890233077, 0.6475916281324987, 0.6135828220820678, 0.6844501320656577, 0.5799643844270526, 0.6004828377129441, 0.6249233347679624, 0.5400165649469503, 0.5652693008997791, 0.5498011045572591, 0.1296192507102909, 0.1271982432116432, 0.13284209874389852, 0.12765228197987777, 0.13629321606991274, 0.14831543012240822, 0.12347083284313831, 0.15057106460584913, 0.1294777089256448, 0.15382351393213411, 0.16063344888688302, 0.14745880081950924, 0.15747291732163282, 0.2429871175684145, 0.15037574825064892, 0.16972236562173437, 0.16510298759195774, 0.1554008579054842, 0.3162921129725548, 0.3238475993309937, 0.4523719979947368, 0.2705274700217075, 0.2671190695808646, 0.37914597396062044, 0.4182417612885919, 0.24322338427892443, 0.3236327805594429, 0.20755134698263578, 0.15531253849554538, 0.22826953677456663, 0.24438802000739124, 0.1946815486600768, 0.24272076735215442, 0.18089084843013714, 0.25134786653446917, 0.2448237969836895, 0.23789293232956976, 0.18347814474728796, 0.21056096106133115, 0.19630197079940026, 0.22441648911947276, 0.18898253666458253, 0.21152319058087454, 0.1968329123075503, 0.19236367348964645, 0.21720553534109666, 0.18556551074102023, 0.19668247859498278, 0.19361556008458147, 0.20410270185240165, 0.18596653089549697, 0.17230927528080175, 0.1907321990406241, 0.20583615727852056, 0.806127757090581, 0.1841258082389512, 0.17985082069435743, 0.17637880881005208, 0.775005986208653, 0.8689773999734661, 0.7236772326603128, 0.2044859313630063, 0.17493135157757211, 0.8411555859483923, 0.19904037110747752, 0.203363312024611, 0.8470428087785433, 0.20915288199875026, 0.20722584347588324, 0.16544898445600043, 0.7398659142360133, 0.10380366039612277, 0.1826045497176102, 0.17831086179233935, 0.21718548806453297, 0.17448563599984612, 0.1861050630961536, 0.18823605258716458, 0.1891340009612269, 0.1918388594153051, 0.1992302594685702, 0.08748683769070353, 0.08616554191396075, 0.0752699256329068, 0.08792642357877889, 0.0892279521905548, 0.07823184612366874, 0.07073788314158969, 0.08526152518411922, 0.07789722125502319]}, "mutation_prompt": null}
{"id": "cf6be3e8-b6b1-47a6-b0da-cb998ebca381", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            # Use time-varying social coefficient\n            self.social_coeff = 1.5 + 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Improves swarm behavior by using time-varying social coefficients for more adaptive exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.34952661721364636, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.82800651380291, 0.8273122382499722, 0.8558357688613676, 0.8090654877392085, 0.8126041667606191, 0.844790434186864, 0.8234507187826062, 0.7869087994402383, 0.8362118293942828, 0.5913289903365644, 0.5762434313756231, 0.6170070091699168, 0.6174653061178744, 0.6369102268186522, 0.574085608640647, 0.5845969797216832, 0.570056442525871, 0.6039264323995732, 0.11224025851060615, 0.10734710718479779, 0.15551136326845427, 0.14151461763391748, 0.11966789796174693, 0.12327452460864496, 0.1307750099433751, 0.12987924376787818, 0.1793790990756845, 0.1038642172601576, 0.13841404804681368, 0.10826312092310186, 0.09330563940243342, 0.08275839136780128, 0.0941254506346253, 0.0772667782316937, 0.11074242057946126, 0.09547060459737111, 0.9192797169165818, 0.9117112271920335, 0.9091497453272626, 0.9431888110239758, 0.9105976917858891, 0.9560033526172271, 0.9342104673904447, 0.9181846634328228, 0.9298265802364543, 0.5527965058919515, 0.5066245267477598, 0.5086441922638596, 0.14814034707274348, 0.5145122114168843, 0.4931113505818778, 0.5457519362103568, 0.5501985278062468, 0.5150959918567113, 0.7881294062017737, 0.8222349042765448, 0.7968943115540068, 0.3708170005119863, 0.2144113706353714, 0.2659500564352607, 0.16426595734927774, 0.6982099558434387, 0.23170936970026046, 0.5589550173653101, 0.5016793680659528, 0.4973961787284512, 0.4996836693622426, 0.5256555424280982, 0.18724657589623694, 0.5323649133446735, 0.47994372943512487, 0.5822056177711655, 0.38522701280016003, 0.4368886734043047, 0.5026167473889389, 0.49282840868365774, 0.13017316432401838, 0.5027436212392542, 0.28048957762556925, 0.38264445538451086, 0.4371340318015233, 0.0840261481190051, 0.14649867409367467, 0.05461620840308001, 0.0372052035226057, 0.15354656567072256, 0.06003939986757956, 0.1606928978616219, 0.0366068225627294, 0.053549413325761464, 0.198551580736811, 0.10016820379675795, 0.11540920443717129, 0.07499172455533076, 0.13697958327023285, 0.06334724458275154, 0.2119887393222991, 0.08596944413723628, 0.07592454932942894, 0.1827895710198506, 0.1895752411380136, 0.24631358774725065, 0.3360975276258177, 0.1760266408722866, 0.1282240534390099, 0.1156238384241568, 0.16960393744984248, 0.12868125424569532, 0.32828943180197934, 0.16924668629732353, 0.10301453888987033, 0.2360397395254693, 0.28132857652439813, 0.2533207681948437, 0.28790565762227205, 0.25915028113939154, 0.23084175561197573, 0.7476530699769466, 0.737446302144911, 0.7431387804910414, 0.721717940777008, 0.6979505448859428, 0.7437752011282848, 0.7143660107570036, 0.6640379136113536, 0.7179213006589702, 0.1366670751430571, 0.1142222902331772, 0.11134497346140904, 0.15056441911728202, 0.09699060141084281, 0.09356547123510739, 0.15224724798739897, 0.15072784859255806, 0.1080219692135721, 0.2080027825024937, 0.17055029836456126, 0.16554146493827138, 0.16185742768614564, 0.24985526556125848, 0.16016671142262717, 0.2954013562897999, 0.16484830906539805, 0.2125240084834119, 0.46394487742354695, 0.3883270405608914, 0.27168393538640734, 0.4586202782376013, 0.30423490404850906, 0.30653545215474975, 0.4259163937639736, 0.24084836002648902, 0.3109132491154374, 0.2954410358161853, 0.26346811338230636, 0.1506000336550709, 0.19406831266412183, 0.21801144116909665, 0.3453088981448045, 0.1747825206030782, 0.21798590664646422, 0.3441904239812982, 0.22380154461028257, 0.19473966823669198, 0.18989510328187154, 0.256211177531372, 0.21001221118248936, 0.20778695471355157, 0.1983663555601607, 0.20632602393116184, 0.20334316612828607, 0.18903049279781847, 0.18218992332885975, 0.25110901045375245, 0.17018931517838953, 0.20706051576271434, 0.17241978768040211, 0.20700197621182748, 0.2054688960998109, 0.21926029556813642, 0.8496759884695064, 0.8505695783831843, 0.1907208749205752, 0.8403886349220229, 0.17158699828572532, 0.8907292090909357, 0.7487969221899302, 0.16923422254686815, 0.16411747052357006, 0.6528215608288266, 0.559584956974684, 0.7263759110244827, 0.20566186132341524, 0.719554996357786, 0.8492172132893785, 0.16726753734525812, 0.16403857210883, 0.16464485712914834, 0.17813371320970128, 0.17321758670861165, 0.18304902147975177, 0.18313244184378008, 0.189953618334467, 0.19606255492357905, 0.17646740701179464, 0.18392501728007782, 0.18598430354582574, 0.08989765991426024, 0.08193103554259984, 0.08625629251366229, 0.09264505136591505, 0.08406982853711886, 0.08595665039176237, 0.09139584154604019, 0.0859659779556925, 0.0972004143359072]}, "mutation_prompt": null}
{"id": "a6d4b35c-a8ed-4d07-b24b-182162fa92b1", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            # Adaptive social coefficient\n            self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * eval_count / self.budget)\n\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive social coefficient to dynamically balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.3367852611650227, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8061329825656907, 0.8343065824383421, 0.8507707984663531, 0.8228779873263429, 0.8106359389036464, 0.8133660623805097, 0.8180626303692422, 0.7957390678439591, 0.8169173808641356, 0.640380919177576, 0.6019415475752351, 0.6056052018683786, 0.5995344878616056, 0.6048935106215054, 0.589050319746679, 0.560709143441924, 0.5308340942821279, 0.6159999561767497, 0.15408133622138975, 0.15756670002235174, 0.15480779037804238, 0.14392423754836037, 0.15019614401586223, 0.11260398709536823, 0.1543266369481895, 0.09538483967862887, 0.14246319084576475, 0.09454298559712027, 0.06062133102564515, 0.10828985930389756, 0.10794382821721848, 0.06904791700873014, 0.1305843532641966, 0.0801759381510988, 0.11767253268315703, 0.15508137959349677, 0.9258197508721464, 0.9069955449396494, 0.9111295711506513, 0.9456029393877939, 0.9096371954971371, 0.9466393599036961, 0.9399237177995431, 0.9180068289470088, 0.9232803801712437, 0.5428948610199116, 0.5344237405371297, 0.5388909869053675, 0.14733392147788782, 0.5651316324142253, 0.5509461687772723, 0.5937927928505973, 0.5683158628259927, 0.5616450732521618, 0.8321432017716627, 0.7591260940165534, 0.21223987159859747, 0.27020476317150044, 0.21379891062114675, 0.1884122845642442, 0.16414011875802026, 0.22421602870102741, 0.7552812774303841, 0.5457209122802071, 0.44129098662752764, 0.37979425038798964, 0.5474634496593694, 0.5387942426212486, 0.16371684135215459, 0.1287901685208822, 0.5330941376403342, 0.4949367669803476, 0.42094426636819926, 0.1247529019100797, 0.4803245925251681, 0.5423731965806893, 0.12997459705865766, 0.5017470974632849, 0.12640208826022858, 0.49239724634134485, 0.5062328339481912, 0.19844563321073028, 0.12507498286385765, 0.0875357961315898, 0.04118595996772623, 0.04762362505369766, 0.08016013367717278, 0.1535318649305205, 0.04064543351616434, 0.2925853182710684, 0.09893164333417193, 0.11909315749404359, 0.18625958029597467, 0.08821848112252884, 0.1436239689975728, 0.03627123893999651, 0.09977664346225323, 0.09552377421440617, 0.06470616306913102, 0.19607277031455772, 0.16591246546616056, 0.157595285353619, 0.2724606100002708, 0.14596451541375555, 0.10087728709258559, 0.11286135502258654, 0.12905938193344968, 0.1544064642941121, 0.30497942399542644, 0.1578830462639218, 0.11986614234948667, 0.16080866919933612, 0.276023909359683, 0.32105902627405336, 0.22681096280704216, 0.2663147273944695, 0.16908566365987754, 0.6726987883951043, 0.7303502829949667, 0.7163752164141164, 0.7015963685331967, 0.7501458985203343, 0.6428458053524286, 0.708177936439468, 0.7352403005848684, 0.6910393197589788, 0.1200070302256554, 0.15404985657041181, 0.11289321651568685, 0.13719527174218293, 0.12973953222097878, 0.08218909713395484, 0.15171855391225875, 0.09155957424237715, 0.13940854099917976, 0.16190068002144375, 0.20678369484854975, 0.1772405694975865, 0.24824163963094537, 0.16272096912457878, 0.2279943769105679, 0.19920178213621398, 0.163927039699574, 0.14242233370915314, 0.3868839341206386, 0.3176261372971231, 0.2575842839135819, 0.26954461036557276, 0.44281320463749485, 0.3253282654751588, 0.4164995529352127, 0.3800290054732913, 0.23128846090526944, 0.3103264580070729, 0.23950459890487297, 0.17159606131982197, 0.25622367481355246, 0.3566976765432278, 0.29987832766409894, 0.21867215231060555, 0.28959936252993246, 0.28886318813810596, 0.19355396934280256, 0.22039161985415334, 0.19805376718964685, 0.22626751500260356, 0.23485122415028858, 0.20652626491121673, 0.20436219035766934, 0.20454643793145988, 0.20131405187432916, 0.2055309948946238, 0.1669962426986551, 0.21030215384960327, 0.20907027379824017, 0.17992347590070912, 0.17122814401817088, 0.2074502025018522, 0.19278078997413628, 0.17116557287373546, 0.8459575699463537, 0.1638800751079319, 0.19036239113652087, 0.8212692258129028, 0.19703780298658113, 0.8873959340029117, 0.8141949480004922, 0.16945927835022978, 0.1640387885757878, 0.7675549283690121, 0.20581829641254867, 0.15124454070353588, 0.20602083203520127, 0.20211067640355773, 0.8235870641656384, 0.6686801980710396, 0.6209587791619007, 0.1647977284221237, 0.18474743310121233, 0.20137425510663487, 0.18891551869229872, 0.18625263140990167, 0.1854678253804608, 0.1952345311355339, 0.17864614553063618, 0.18259856208656755, 0.1752939457728102, 0.09593009164714472, 0.08560584673140093, 0.09006723113808146, 0.09562906928414305, 0.08976296079175827, 0.08376149807877065, 0.08710260554061255, 0.0799395416331421, 0.08094797816225452]}, "mutation_prompt": null}
{"id": "014cd4e0-312c-482c-b039-9a9005eccf80", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "80936008-43cc-435f-857e-5f203d2e6596", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "d7b2f672-d213-4edd-96e2-18c1407d1fea", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_weight = self.differential_weight + 0.4 * (np.random.rand() - 0.5)  # Adjusted dynamic range\n                mutant_vector = population[a] + dynamic_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic mutation strategy in the Differential Evolution phase.", "configspace": "", "generation": 61, "fitness": 0.33807386229442987, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8364325499229381, 0.8327946754142451, 0.8404389346606821, 0.8359492318602977, 0.8265217759449095, 0.8313599554700404, 0.8235060219651884, 0.814440744358121, 0.820577295485396, 0.6134941012954407, 0.6390415849342657, 0.605967642406261, 0.5983390858373886, 0.6401227452490714, 0.6686522948491594, 0.6014255986247464, 0.6161188083742781, 0.6066899059839155, 0.14143835378254188, 0.15262812466418618, 0.15302892276871893, 0.16675200313984462, 0.11903815169687693, 0.1330891998395688, 0.17733827526168267, 0.15252791282884515, 0.15629662252883303, 0.10428586078899804, 0.10700974794869667, 0.15262047152733027, 0.11897235053331257, 0.11170402480781538, 0.09304317096127301, 0.11772505500993125, 0.1136596137522421, 0.08728090048411918, 0.912786666512255, 0.9266546105185133, 0.8978004862586192, 0.9430053071885898, 0.8380582349187106, 0.9447345499275687, 0.916804824453828, 0.9394800049799071, 0.9293025516793499, 0.5784925334917498, 0.5242269407444461, 0.5500257639080439, 0.5426502888787039, 0.5483110977646447, 0.5414252742512842, 0.5613631316252129, 0.5607471046326911, 0.6056102751670777, 0.225186752938898, 0.17674042532994738, 0.22314626255636083, 0.2089584981299445, 0.36456692084186426, 0.20317611673359992, 0.17483856147544918, 0.27553507611097694, 0.8732765834295987, 0.558002391754807, 0.5436591945312264, 0.5479628555805596, 0.566192116105644, 0.5555231147464168, 0.165026962989688, 0.4891206272337141, 0.13114026354539565, 0.58625637143196, 0.5190270278424092, 0.4690855277320647, 0.5579534167171767, 0.42624704695487314, 0.5120424186155773, 0.5492886518971019, 0.38479344496083057, 0.4929055416355761, 0.5101262549275756, 0.10692093712204187, 0.07580117710315704, 0.1507325896142856, 0.1609029364388922, 0.12379710757321505, 0.1562902254705434, 0.052231210622341706, 0.03492323645860418, 0.11503879037002829, 0.08660859683866251, 0.07552715771622664, 0.10314551409309802, 0.10857663764064196, 0.11231759359178561, 0.08866540729224703, 0.11427706496303802, 0.09555993314660916, 0.08974680044629335, 0.05066971514636498, 0.17958450308791252, 0.13531206125576467, 0.29425139946376466, 0.16801827456983498, 0.3474022542162435, 0.24961671031533228, 0.19843896579371634, 0.1551455866326522, 0.18205967997895423, 0.10778263410185485, 0.09504231638617022, 0.2475631750925621, 0.3270497315082195, 0.23469858763919105, 0.3302098687519933, 0.24879640071040987, 0.08094414054826415, 0.7105827084682612, 0.7085580308230194, 0.6811223616188403, 0.7337960441525864, 0.6237453015568089, 0.6691905187242281, 0.732301848969561, 0.7222941206512947, 0.7457549865554765, 0.1134400086367856, 0.10451130783109497, 0.08594721275514061, 0.12450991007042378, 0.12117690171974738, 0.1236429887016669, 0.1392136009240723, 0.10695239230831977, 0.11799484448882469, 0.1593398058606752, 0.1917501584955158, 0.27655225576160536, 0.17864966206185795, 0.1916465851679583, 0.21126112211716996, 0.24077264676781973, 0.3373425020526206, 0.19423563535727195, 0.24846745628988198, 0.3667446048272919, 0.2820738610796777, 0.27775591079788275, 0.3149767442747802, 0.437159979856506, 0.27991190235824426, 0.39266429949334625, 0.33556164298433333, 0.25513141146379403, 0.2822089330411738, 0.19894149103831626, 0.22332057219578028, 0.31084684721089906, 0.3253100854286577, 0.2267054764424562, 0.2488108214678858, 0.21516519040942017, 0.20900627927946058, 0.2149748695121827, 0.19531730472992803, 0.2231201649818092, 0.2366466225952909, 0.1911773598335602, 0.23016732531552453, 0.21949043370537547, 0.20011078103494895, 0.17907230096769255, 0.1824195554051532, 0.19901909410409457, 0.18825247695023806, 0.19328857258968468, 0.17112435077655097, 0.1992489538504678, 0.17836140896395813, 0.17113780189840688, 0.16383201038065787, 0.16262447135900726, 0.15068571320731516, 0.8885560955078243, 0.7727722709628972, 0.2097102367820447, 0.19928485398974438, 0.1618793973910102, 0.1605448877164346, 0.7773372919519215, 0.20673060304033097, 0.7367286499002691, 0.20531271947665652, 0.15042528308402292, 0.8509175553590492, 0.17725926355524912, 0.800827744567665, 0.1517467486225763, 0.19007455091148728, 0.17909718378833783, 0.1767342564032155, 0.17757830167699762, 0.1741833521815841, 0.18836452700557837, 0.1852069803741605, 0.20435204293468912, 0.16875409096437655, 0.08687977342302078, 0.09499941013079893, 0.08789259617237877, 0.09934677704737338, 0.08799349251889688, 0.09078325240144036, 0.09952880618779181, 0.11662403900071072, 0.09318796555351816]}, "mutation_prompt": null}
{"id": "cb400d3a-4416-48ab-8a88-1667d7c2ae31", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.3 * (np.random.rand() - 0.5)  # Adjusted perturbation\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive differential weight scaling and increases population diversity with a mutation-based perturbation.", "configspace": "", "generation": 62, "fitness": 0.3560001726997148, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8176985859517404, 0.8114029797485116, 0.8466396748143665, 0.8191281967752905, 0.839382967369243, 0.8247442002662753, 0.845605780170485, 0.8165870246683484, 0.8295221633379187, 0.6218885499725912, 0.6479096596259903, 0.6342901291095193, 0.6124287540783568, 0.6165782134513904, 0.6085415560962057, 0.6260936650643051, 0.630042366449217, 0.629991644166589, 0.1497520758114399, 0.15263823754731476, 0.13999126749558966, 0.15512517914317236, 0.18003750811659425, 0.12263683094703592, 0.18202949526578682, 0.13957738653618468, 0.6518049236218519, 0.12736394467431023, 0.08572793887677144, 0.1262800511875657, 0.11329782251503151, 0.11269017580604868, 0.0828588588124749, 0.10376340574100062, 0.09167261875467703, 0.0946318350364117, 0.926077732769088, 0.927632805802289, 0.9254498473158742, 0.9426738705228758, 0.9093879260234436, 0.9561513709825388, 0.9200371987661954, 0.9393881887589581, 0.9208747040907328, 0.5301689530563025, 0.4929613217687868, 0.6053416732852939, 0.5705078948907814, 0.5991449617164655, 0.5472603134684996, 0.5914180028956095, 0.584746177808702, 0.5502825871020718, 0.7706897507268406, 0.810010365343616, 0.36119776914767976, 0.20806483124268438, 0.27005064881245366, 0.18680484678646214, 0.17334749495271173, 0.23821515338600807, 0.8084657390300038, 0.5883361099640615, 0.3193505803091935, 0.4849297342576703, 0.4829309794440001, 0.6539108800412047, 0.5845819720109837, 0.5770222798634151, 0.5105243036539373, 0.5836940755294092, 0.5671774359369733, 0.42645149934818904, 0.527909800034077, 0.5095939333167985, 0.1293760125494977, 0.5269601260558778, 0.3867590493139904, 0.13069548972390277, 0.5028503587028876, 0.13281969134894223, 0.0515059091044654, 0.08167839515273367, 0.033463079125569895, 0.052577658605095556, 0.1048177478694533, 0.02572037209604372, 0.06427566726608569, 0.049790104997216256, 0.10650647336088681, 0.10050419140613265, 0.10281226519208153, 0.14728409855536428, 0.15491409666758205, 0.04011575579361415, 0.10535767597655543, 0.12767312121708496, 0.12883791197758765, 0.354285844470526, 0.1877293820162893, 0.12488436184414309, 0.20610026441788065, 0.3179124042255864, 0.13360852066996065, 0.1358610445582188, 0.23183552103028926, 0.13640117358307413, 0.18333265035707047, 0.19989921724526272, 0.1321001461270931, 0.27023249771919344, 0.28259224699903396, 0.33322318386325966, 0.24138526833862028, 0.37795678581958425, 0.14081248460717233, 0.7289279869631327, 0.7418618939924861, 0.7470388244022832, 0.7353779302634698, 0.7139665359146827, 0.703383569935025, 0.6706262832761745, 0.6929495057240567, 0.7361918749679763, 0.17253288408063705, 0.12582005881864078, 0.08257791902378753, 0.6707659529946539, 0.13673715706667045, 0.14182233003966527, 0.11915110551152452, 0.1473457323946843, 0.6123445469069906, 0.17527754935976225, 0.1776640358867586, 0.17897659552148926, 0.22019522331544006, 0.16509001812074675, 0.14756995092886027, 0.15516574377664405, 0.17708847886405388, 0.19701573379812487, 0.19544486712681597, 0.30977261132378053, 0.4290716688460272, 0.275172502998407, 0.2585053373621756, 0.2549540198765484, 0.37831296731814923, 0.32999084585602234, 0.41238448671486116, 0.26277518593633264, 0.35592188810684455, 0.13989208624780258, 0.1982703096200018, 0.23049866157479215, 0.3238963544299761, 0.25009176472401373, 0.2786078557504109, 0.23167271082677743, 0.21388442482996872, 0.20154124995122802, 0.21662556657821586, 0.208796357371543, 0.23829056480200528, 0.22902409611902985, 0.22127456534777323, 0.20398955617903936, 0.19271673095268005, 0.20323481415193323, 0.16906692050159722, 0.18287188378148056, 0.1895498256098661, 0.17885392057143257, 0.17844140520430407, 0.198710687009933, 0.19439978377038047, 0.20356773691020758, 0.8545723942749027, 0.16402016947165665, 0.20323225025370972, 0.8513374641407069, 0.8631885475210104, 0.19925352770723714, 0.15976821008608855, 0.16544222530346575, 0.7627512185479852, 0.8336011187770551, 0.7029053690868279, 0.664140066926221, 0.20903147993188997, 0.20073807276246158, 0.8464641321170612, 0.1671709894996538, 0.15299373758264734, 0.1644637922805856, 0.19645659473670918, 0.1884317612863533, 0.18501139886096252, 0.18336385634678698, 0.18399822964386237, 0.19227859410390058, 0.18630863760286864, 0.1880568733356055, 0.19331422977108492, 0.09358335886212299, 0.09490252670454224, 0.07589234391861244, 0.09194019266426912, 0.09020554374611234, 0.08978522795965493, 0.07833122765599387, 0.08359673450675431, 0.0713939379108528]}, "mutation_prompt": null}
{"id": "12efa652-d5c1-4074-af81-fe2a5bdf076c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Introduce a dynamic scaling factor based on distance to global best\n                distance_scaling = np.linalg.norm(population[a] - global_best_position) / self.dim\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5) * distance_scaling\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances exploitation by introducing adaptive mutation scaling and local search intensification in the differential evolution phase.", "configspace": "", "generation": 63, "fitness": 0.3396754935258791, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.833465057146701, 0.8368078202498862, 0.8467491030144618, 0.8326865015929128, 0.8132125139868827, 0.8294290656957661, 0.8505494747203253, 0.8383549284263621, 0.8134621049754462, 0.6432313541080481, 0.6090954179999831, 0.6403794384343662, 0.6232779635427296, 0.6400373666780117, 0.6102664712336501, 0.62493140420015, 0.6675757847492334, 0.616467669248594, 0.17935489839035923, 0.13713450971366092, 0.11495051929097322, 0.15550275716360706, 0.11407492983325118, 0.18227878931861596, 0.1399957010135755, 0.12376617220091779, 0.17763858822967393, 0.11120641135756937, 0.10454856759036557, 0.15355254325975243, 0.09053547756698499, 0.09666419198960097, 0.08988942586309279, 0.12731726001577914, 0.0879561105304485, 0.12432699306807427, 0.9071244078580679, 0.9241412360210753, 0.9092690282648227, 0.942782544696415, 0.9158877492656374, 0.9561694290561009, 0.9139980110626701, 0.9038200978907726, 0.913558908177049, 0.5388900471599335, 0.05820748404229814, 0.5708111448992154, 0.5723913355084883, 0.56951946829139, 0.5820075880203863, 0.5530215745080936, 0.5058845884601839, 0.551048006574377, 0.813550299479414, 0.15407736950517215, 0.20379530466086626, 0.2756062302231034, 0.8144191534677632, 0.26588567802357654, 0.22177423310162936, 0.760882357306455, 0.22925173705477853, 0.13021502895734116, 0.48199961844865347, 0.5558228575034561, 0.6328631266769947, 0.5981176983967694, 0.25211137800375516, 0.12789091263658736, 0.5244576291288864, 0.5088071326553381, 0.1288674154762377, 0.41754723745837385, 0.5546650900813734, 0.566137848420776, 0.12899536628057484, 0.49011548575019737, 0.487515680860524, 0.48599185555643776, 0.3647680700785553, 0.09467297914681916, 0.051714065184776836, 0.07207558991776497, 0.036743094541750954, 0.06609539121252017, 0.028984850522654648, 0.09939691129417882, 0.012411381514018327, 0.12857855273933816, 0.11008897574748477, 0.11351719016665685, 0.15898074215333924, 0.1309227055343376, 0.1388517563303494, 0.08449288449802428, 0.10303348759969067, 0.15653249660302904, 0.08833093574351858, 0.03733707865895508, 0.05055228930616629, 0.4897269176612635, 0.14330278334764912, 0.13824207248253972, 0.15326785671864196, 0.09209397621463034, 0.12254547437124752, 0.12744349454862824, 0.20640526755031874, 0.17346708055814852, 0.12772829081525727, 0.2494260373978543, 0.25913613292757987, 0.2715254508311251, 0.23535192279652284, 0.23665950260539537, 0.16181102496500166, 0.6902877775838163, 0.7514391930531428, 0.7369970141568025, 0.7173802556896092, 0.6386823098129345, 0.7010752251882544, 0.7088995219637066, 0.6552441693093088, 0.7352046609192888, 0.14377240845034034, 0.15346352478224512, 0.07540690342255207, 0.17589738532697152, 0.1347839451312529, 0.14548942345649396, 0.11693382697883903, 0.1515716193598291, 0.1529220334477699, 0.1631742452486622, 0.1601188863876336, 0.18832122707107202, 0.21834861742746214, 0.18852609814768717, 0.14461473047974505, 0.18087649141017448, 0.17455972910659223, 0.2055602405895074, 0.26436819747616846, 0.4538042370427742, 0.20293002851837383, 0.3427843485546651, 0.27845443156627214, 0.4278297756976185, 0.45924430608685274, 0.285096104907015, 0.2260077406959874, 0.221072014920207, 0.33232017748137754, 0.17488479645584265, 0.2260092719341995, 0.24455075532845472, 0.17846958121786538, 0.16933920702203453, 0.24362372218498163, 0.24980395862804872, 0.20970671159642862, 0.21302876835477758, 0.1975648157989206, 0.197620200158097, 0.20402339400494884, 0.22005131491307406, 0.20672064373922994, 0.1991704496123441, 0.19149521874137576, 0.1771490984633367, 0.18793413841651618, 0.18723084077443874, 0.1917692863432695, 0.2158738142913238, 0.2028552057705133, 0.20219011704288692, 0.18150930221761197, 0.1901750871715362, 0.8259558802552289, 0.1618539578790944, 0.1901902347796871, 0.8378227263916572, 0.19605621786690908, 0.8630275665762358, 0.768344387327375, 0.705292665513281, 0.16327193473894164, 0.653712707130986, 0.2075143167924297, 0.8045772555083297, 0.2055783379431778, 0.20085548112292617, 0.836287765858605, 0.16738316958951105, 0.8206139042783411, 0.16473623858399478, 0.1849671686202159, 0.17638028635235625, 0.17604932125760842, 0.18705562386437447, 0.19554424084059252, 0.17613529855918764, 0.18174924431250927, 0.1872392462949216, 0.17860363943195023, 0.09014473807770895, 0.10239116478619448, 0.07851408540144444, 0.08903327944768646, 0.07940635062970558, 0.09326172488909301, 0.08308597845544596, 0.0859044938484318, 0.08836906579512982]}, "mutation_prompt": null}
{"id": "cb146e04-4bab-4c92-b954-59cc9663a1ca", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Introducing stochastic adaptive inertia weight update\n            self.inertia_weight = 0.9 - (0.5 * np.random.rand() * (eval_count / self.budget))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduce a stochastic adaptive inertia weight update to balance exploration and exploitation dynamically.", "configspace": "", "generation": 64, "fitness": 0.3229726390083756, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.7907676535478837, 0.7724330811584775, 0.8082255166721686, 0.7903161166476287, 0.7949399925253356, 0.8156521241830399, 0.7873045905731734, 0.8121059657499303, 0.7774764844540742, 0.5743199648262447, 0.46567658207929374, 0.5819033108763252, 0.48976861090204715, 0.5390259872228719, 0.5738313619024227, 0.5283506934674025, 0.4794183356826518, 0.5349100603609656, 0.1559398503655326, 0.1399614302599348, 0.10973177081397822, 0.13745547611727738, 0.17260592543086006, 0.12282288448946677, 0.5155404590197226, 0.11391041547943692, 0.15407353945958568, 0.10191031109419268, 0.1059580712636804, 0.09444428640988478, 0.09024643031551804, 0.0959344769502164, 0.07037990033760344, 0.10351950216745376, 0.09075931700940565, 0.09101303810276751, 0.9124051044787632, 0.919002754898357, 0.9270177638462348, 0.9271971616031738, 0.9264539617297668, 0.9455035122310557, 0.9223430543407942, 0.9307450873322048, 0.9193636237531386, 0.42471909717689793, 0.48058634368292175, 0.46737495250928973, 0.4427761485036711, 0.4233760560981471, 0.42327298346705433, 0.4396084444583167, 0.44631697687070726, 0.4455381784748025, 0.3796193445610204, 0.22274389842111375, 0.22024421118807602, 0.21822891515789666, 0.8668047037671092, 0.20675283589442073, 0.23661487488321786, 0.2195630430205966, 0.21365026886777305, 0.3779018847741409, 0.316247343188345, 0.3590556776360544, 0.3302655876617796, 0.1278963246853968, 0.12613524940907772, 0.13049387139005353, 0.34863349485788364, 0.44133971720152554, 0.37038879239439926, 0.3775141236883319, 0.33751252953468447, 0.31061087674069365, 0.3538094882146887, 0.3263524769559957, 0.38211660734303043, 0.39040278373422754, 0.3259400989908009, 0.23795254398464372, 0.02764878234576118, 0.07690455647766625, 0.04407879651614477, 0.08158041304862673, 0.04279937890834595, 0.02434207264287902, 0.0673408316035089, 0.10336542166347595, 0.1845109248669956, 0.10951227500401639, 0.1634312308041419, 0.04898585967234903, 0.18130438911314473, 0.04509854374101374, 0.08945782970911587, 0.21966540795122913, 0.10821517724675012, 0.08785827441393812, 0.19709977798189127, 0.062292184752236746, 0.13417378771563382, 0.2899324803404515, 0.12109950806456149, 0.2574244462036672, 0.14677831713216816, 0.13339636586046488, 0.2302439912442702, 0.0920870825743626, 0.09151951448058682, 0.18987216471443735, 0.2249600135500185, 0.20101365591811504, 0.25628612983373156, 0.25376864800676324, 0.22619275135266803, 0.6998065090555197, 0.723643827251198, 0.6195726821441918, 0.5828880955258333, 0.656656408004852, 0.6893070618306706, 0.6990801161254816, 0.6515388454751052, 0.6759128709876577, 0.1216339408689171, 0.15076356096489685, 0.12696650904687667, 0.10731585831523172, 0.17684460028737325, 0.15209565329069796, 0.14649712603801768, 0.1464992600946471, 0.110038818857078, 0.20799811073801844, 0.17693570612868448, 0.15318807953219749, 0.28353314582022915, 0.24071190168199696, 0.18123346261363993, 0.18499788260599448, 0.16887393295020958, 0.2594313497229075, 0.30036077356330526, 0.4267679061717389, 0.35533960415841803, 0.2763953559090493, 0.45683171643695986, 0.43961316124939764, 0.4262770397924722, 0.396367934428566, 0.4041401112962444, 0.21662244422958088, 0.28605406901153496, 0.18518240018494114, 0.21690182078870812, 0.23040184103217176, 0.24875565880502115, 0.30181280917789, 0.24470219235609691, 0.23488733807906625, 0.23556255119595082, 0.1855007078814479, 0.20468505598897746, 0.18910407943761987, 0.20965386944176256, 0.23107090130653374, 0.1954122619422427, 0.2071255651233136, 0.20657772092413274, 0.18488207284600078, 0.17964747354492194, 0.20153426043858802, 0.19767813232384746, 0.18950058076762966, 0.17796873794106816, 0.24796843027451865, 0.1898346204240965, 0.24690973619494738, 0.16524876346336836, 0.8289368562228105, 0.19455371618830297, 0.8727521970171854, 0.18634893608869607, 0.8680223427000757, 0.1565893084587585, 0.1677362907058676, 0.8190275837562676, 0.6207130294868903, 0.20550166550258198, 0.16507999498540482, 0.759450010264922, 0.20946693698846397, 0.8778653916530914, 0.7423025347957095, 0.5818865829323945, 0.16303323597118524, 0.1843748526371376, 0.18559880100370418, 0.18617774065920845, 0.17943749832806755, 0.19992223578112223, 0.19069074630622074, 0.18068570290710484, 0.19931233054754216, 0.18867201323266714, 0.0858131270621103, 0.08089501033565305, 0.09146250559180769, 0.09378662396415316, 0.08513745253492322, 0.08638806384407494, 0.09243893870838815, 0.07845521032765901, 0.09106226725286137]}, "mutation_prompt": null}
{"id": "5dc4d6a6-660a-48aa-8128-19e8f5fbcf72", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "697b270a-4300-4a62-857e-63aafe545257", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            fitness_scores = np.max(scores) - scores  # Calculate fitness scores\n            fitness_probabilities = fitness_scores / np.sum(fitness_scores)  # Fitness proportionate probabilities\n            for i in range(self.population_size):\n                a, b, c = np.random.choice(np.arange(self.population_size), 3, replace=False, p=fitness_probabilities)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces fitness proportionate selection to enhance exploration and convergence in the swarm.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {}, "mutation_prompt": null}
{"id": "da61b9bc-747f-41f8-bb44-d0a9966c27b2", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "abac551c-4b8a-4b78-b5c2-dbf10f8b27e6", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "24c11544-f31c-4644-98b5-773b4bf591bd", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "44527a4c-8153-4041-86d8-11e2db46dbb0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "1303c264-f289-4296-ad47-19adc1ce43fe", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "119366ff-6b0f-4fc2-ae52-36b52f91ba9a", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "0047a12b-c94b-4a06-88f6-1c84504d0014", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                adaptive_weight *= 1.0 + 0.1 * np.sin(2 * np.pi * eval_count / self.budget)  # Dynamic mutation rate\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances diversity by incorporating a dynamic mutation rate controlled by sinusoidal functions for adaptive exploration.", "configspace": "", "generation": 73, "fitness": 0.3429422474592591, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.833771143494056, 0.840305891656685, 0.8396066869352019, 0.824930961965282, 0.8332218510882992, 0.8489411921205271, 0.8467225031682707, 0.8132283566252803, 0.828062305367933, 0.6058983451571329, 0.6334472551712851, 0.5664371373801621, 0.6715653195598004, 0.6668518694007185, 0.6055875093505804, 0.6342926359340032, 0.6520122541667868, 0.6189234571219955, 0.1259316271021551, 0.17587296479741055, 0.1108326872699057, 0.12701432642209998, 0.14810798812493176, 0.12329099421582301, 0.12127481752237745, 0.1030927513891976, 0.15411876661037716, 0.10120306239433197, 0.0794248114257643, 0.10013208553854802, 0.10687242835172495, 0.08660762116205933, 0.10045694833366692, 0.10430427629824934, 0.13785702054908855, 0.0805150618004884, 0.9090920857733638, 0.8929724347629762, 0.9088548381635927, 0.9432325381583803, 0.9133466047846744, 0.9559761308739982, 0.9117316561426392, 0.920321175771894, 0.9236026184595952, 0.5492047872359913, 0.5293592211428365, 0.5409781785982999, 0.5882892946918474, 0.5885033434216251, 0.5472300315249076, 0.606928239816942, 0.5968785646021375, 0.5922467276775222, 0.22328183101142263, 0.8446063488352864, 0.223569321944322, 0.2698474874212611, 0.8327363310094111, 0.18658109275226864, 0.1587310988510663, 0.381933346866581, 0.23763317248953741, 0.6938675696672266, 0.12872168296874387, 0.32297702714100285, 0.5316639068969914, 0.6026563861336929, 0.16812085187670855, 0.12786151452158834, 0.4713942054022835, 0.5691164770282453, 0.40441037249405787, 0.5592422910694627, 0.49797727078840914, 0.5283871264011544, 0.1302960238977352, 0.5217704641203365, 0.4651240946426092, 0.43653466502225835, 0.38941819003083455, 0.13357974039080034, 0.1803336362273139, 0.06286164599971567, 0.04876825692434972, 0.0661441106392815, 0.04404307289645493, 0.04034478878598935, 0.29302185962789595, 0.028659146280026304, 0.11037857068880108, 0.13314638274084845, 0.12112288896571444, 0.0907406833184623, 0.14645454203478003, 0.1034288930681001, 0.17150694195478422, 0.10543441345581539, 0.08851910946776353, 0.17433408595595956, 0.22901114834412606, 0.2360528003727772, 0.24550678035743, 0.16901154425450082, 0.1131282328924319, 0.12836666020701648, 0.14647253106063796, 0.08885428598948875, 0.2016634973410738, 0.39755224561202096, 0.12205871187607154, 0.21431284190402022, 0.21529962669089875, 0.22463521856443303, 0.34046605896424076, 0.25909931477537695, 0.18555632128982957, 0.7272222410071763, 0.7330216297788581, 0.7604018880288581, 0.7605292619524692, 0.6716052979420961, 0.6007709490875146, 0.71782619213353, 0.6905877051553205, 0.6631131721746699, 0.13064277975953753, 0.1359697778346295, 0.11001200272833433, 0.18201094089749215, 0.1542653660087353, 0.17828505464781597, 0.15626960801786138, 0.14871862953833714, 0.1557458931699568, 0.16558907369244968, 0.23751588972644067, 0.17198054187720568, 0.15028950791852602, 0.241717716935669, 0.16740062867982253, 0.18319795792725369, 0.1475902750337278, 0.2687428889514969, 0.30571177677073846, 0.40595629925811094, 0.4706600531514289, 0.30316885920481673, 0.2965301395897124, 0.34456155685673584, 0.41693062789782986, 0.39062713549552186, 0.3230386914178234, 0.26998517566540836, 0.3022531426210475, 0.15561341686574326, 0.24263516896646886, 0.2063692759944925, 0.32635973159813314, 0.2240589774460232, 0.2375491000142298, 0.28796324567073583, 0.19048454971717987, 0.21415923887649313, 0.20238552151361477, 0.19154848513296652, 0.23817003550972005, 0.19896277808911833, 0.19568107029725157, 0.20384307002832913, 0.2184341285128224, 0.17825652754878052, 0.16289842091051354, 0.210655948548077, 0.1786870870858338, 0.172029491974655, 0.16292798590228774, 0.2074064858721787, 0.2229463345522087, 0.17520337480110681, 0.7745531346703527, 0.16453958297919324, 0.18762476625092905, 0.8258759271687746, 0.7940657654175276, 0.8593379392368886, 0.7526976090031396, 0.16839543143963998, 0.16434902376981442, 0.20070606552763293, 0.6896968566122799, 0.631377087246749, 0.20579535035933005, 0.1972717064802646, 0.8388673600007777, 0.1658674664615657, 0.1537395781348967, 0.16715370227078585, 0.19618390484119896, 0.1775070416356559, 0.1747083076342194, 0.1962446351808117, 0.17497811107619632, 0.18016628918602384, 0.1768020470047026, 0.17447637982537378, 0.2062009584324731, 0.08747433780000213, 0.09603277393408338, 0.08957085556624134, 0.08710600290555481, 0.08582980973917964, 0.08374897594095232, 0.09566219681615296, 0.07941249973934028, 0.08803406316817841]}, "mutation_prompt": null}
{"id": "523c70ed-5fbb-4b3d-afee-7e9a6843b277", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "315d223e-44af-4d82-b98a-6a6c34f1c683", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "1695001f-567d-423c-90d3-4394c52207d3", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "d44c19ba-442c-496f-ab50-4aadfa45d1cc", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "a4a64332-8824-4660-88c8-25fe1a0f48b0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        # Initialize the population with chaotic map\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.sin(np.pi * np.random.rand(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive population size and enhanced diversity through chaotic map-based initialization.", "configspace": "", "generation": 78, "fitness": 0.31885450264023346, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8278204051297127, 0.8177814172359695, 0.8145210682360784, 0.8287028792198747, 0.8345860884686874, 0.8306607895171794, 0.8303072094309345, 0.8188087862993343, 0.8276970166927836, 0.6246878244056377, 0.5828429891113065, 0.6175532421726453, 0.6302166155892508, 0.6093480637040538, 0.5055520850688668, 0.6072960718083895, 0.6191736732483994, 0.6066234820881082, 0.13705046357259687, 0.10870599484535648, 0.12145172435265594, 0.16632734197018895, 0.12035673536899338, 0.1359872302636802, 0.13865111437439503, 0.6459750447157468, 0.1500427361259643, 0.12801554449584052, 0.1286489747768783, 0.1057912635576862, 0.11393972441536171, 0.09125805828097766, 0.10152347642771142, 0.10651934320580092, 0.12955977159956167, 0.12711040331267087, 0.9310945041911447, 0.9266256269594771, 0.9308863187530587, 0.9326775747884399, 0.9139692467403819, 0.9095463713269365, 0.9236372859811287, 0.9304477644455427, 0.916239076202279, 0.5413190206832914, 0.5811170204244235, 0.5578398018948055, 0.5545829728448003, 0.49779990475696034, 0.5273101944330134, 0.5582414387149024, 0.6150129168989291, 0.5794105293973205, 0.19585992876000002, 0.22233334423815931, 0.8410232741587877, 0.33889004219954455, 0.18357743739915144, 0.2092230016592317, 0.24679281611538095, 0.25112762980181247, 0.24028461251789357, 0.12615944733977524, 0.5705082256019964, 0.11781546668226472, 0.5567082784361281, 0.10182792134047047, 0.5327806187668751, 0.12366916715669363, 0.11614543447478842, 0.5533552096534955, 0.5637997930652012, 0.1261366156506385, 0.5997630721087773, 0.1263854811676658, 0.1278076272548706, 0.11588134410452677, 0.3833692668868415, 0.4480111054227591, 0.5182951282312731, 0.3810000498741165, 0.08911377930433406, 0.0022226493168699957, 0.03872671917373316, 0.049820275842508255, 0.02986867347044897, 0.01944454407193974, 0.04228777283870799, 0.00026443350509108843, 0.16524866843489194, 0.0814284768008563, 0.07858879995553525, 0.14130796863007544, 0.12939124699447146, 0.15256328403910024, 0.06656125760847098, 0.15088044380373866, 0.03404778959317556, 0.14290183589497318, 0.06708219623069622, 0.039838677600112726, 0.17163447857820557, 0.15646078210672876, 0.09610806182036014, 0.12116533106933325, 0.10869437657817338, 0.10892688192398203, 0.12797276549474867, 0.142950663948753, 0.1263820674693299, 0.19585164537950206, 0.30181852493461836, 0.21766493672608245, 0.30302918094542686, 0.08108664436325963, 0.17812861541499891, 0.7396852905510922, 0.7120130332214928, 0.7563833126851849, 0.6232594307215471, 0.7019123731630159, 0.7478505567835134, 0.7240765152581233, 0.669438229037811, 0.6129417654622336, 0.11041030465948931, 0.1066588151316693, 0.11326338037976547, 0.14660749517893024, 0.11320167023766647, 0.12876159508520035, 0.17580684040375727, 0.13364590055104586, 0.13504909114822072, 0.22647295858638805, 0.17537668752238456, 0.17002541898196832, 0.1766555632129272, 0.184871500821708, 0.16150370668054237, 0.16816902258868704, 0.17928377042264765, 0.22167587786631426, 0.2960924783561135, 0.23736729805619172, 0.2917758115978052, 0.4395286924870998, 0.4151324518989802, 0.45492131347701703, 0.4019977686288646, 0.39742079086684967, 0.4065160443056184, 0.28154610720547113, 0.324149837165026, 0.21062604034317012, 0.24246070313588286, 0.218930096230593, 0.20125417033244153, 0.30522680635116684, 0.2523978320997865, 0.24270110004963208, 0.20283741810161204, 0.21343845067444778, 0.2567352287686082, 0.18595719668504906, 0.18671328650477526, 0.20866370678368695, 0.19084218133029696, 0.1914506280355336, 0.18998435758820564, 0.1902557457072679, 0.20533928665521206, 0.1642473378200897, 0.2024473759966594, 0.20538582322183596, 0.17402350100380604, 0.19136623779882134, 0.20174492756154094, 0.1717197291568362, 0.17179246307870688, 0.15760743933674837, 0.7876745659540605, 0.18481771576188977, 0.7413543630789441, 0.1649169726501012, 0.16897832586809114, 0.13906993222072028, 0.18289398282964153, 0.20610696972039977, 0.15759969276535812, 0.2008704931833284, 0.19946115345973026, 0.1637646195971424, 0.197065489469062, 0.7917550669081344, 0.8286451274334448, 0.8045812732667292, 0.18609871115694854, 0.19162653049008782, 0.1903154066499807, 0.21059644822748091, 0.1876585181435616, 0.18209861424985385, 0.22248965943742416, 0.18342665231734268, 0.173891128961837, 0.09636842937982582, 0.09913642019925029, 0.08417152515554394, 0.09375728648537118, 0.09817762164162613, 0.08447385972748866, 0.08517228924277753, 0.09568997211356167, 0.09342196934444513]}, "mutation_prompt": null}
{"id": "07ad1668-5864-4a26-a946-f124706196f0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "518c437c-07b6-48dd-892b-ebeeb0323a90", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5) * (0.5 + 0.5 * (eval_count / self.budget))\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances diversity by introducing a dynamic mutation scaling factor adapted to the current iteration fraction.", "configspace": "", "generation": 80, "fitness": 0.35106768985517106, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8376217449227689, 0.8321646427739731, 0.8579929112038629, 0.8327882312696121, 0.8333328625313656, 0.8257672194799853, 0.8486955978646519, 0.844003602634968, 0.8269896135809971, 0.6336312693034243, 0.6334132017176366, 0.6024560518420458, 0.6191585911178737, 0.606539705322673, 0.6451601308278598, 0.6512719812040302, 0.6424046143251594, 0.6027962030177834, 0.15263067710378142, 0.13742736994060556, 0.12343389906001723, 0.14016022554062568, 0.1251825027883966, 0.13059098116376222, 0.17241062918097272, 0.16985732146224142, 0.15276098140931504, 0.1109247193533398, 0.09415007164587164, 0.11920205295900921, 0.102629770479015, 0.0928776195275921, 0.1117795044058103, 0.12598486241092288, 0.11233989922100751, 0.15022357635902095, 0.917280418768649, 0.8956303889031234, 0.9134648468720481, 0.9293408895034447, 0.9068615633531918, 0.9460150969925525, 0.9279100091074929, 0.9167374910206023, 0.9235608394837144, 0.5256070972090222, 0.4983946387052921, 0.5433664734494474, 0.6244495704408405, 0.5449440798714889, 0.5260750615692489, 0.5569729574832037, 0.6201087786998378, 0.5375044669200164, 0.2264599968927402, 0.8409898940309721, 0.21283892131596527, 0.20703741569530087, 0.20828407115837888, 0.26707883519675457, 0.1740445425080821, 0.8600219372379169, 0.857097909509607, 0.6023997712190581, 0.12822201275602596, 0.5464694638888489, 0.4950838754034047, 0.5727352622553099, 0.46570289484664695, 0.5566851557665744, 0.5799522073544472, 0.5541737532692249, 0.5374334632335638, 0.13071621187540372, 0.4992580951082476, 0.4919818729540397, 0.4767130798367696, 0.5490061712026428, 0.5146146941969516, 0.4120222539635793, 0.5302447354675054, 0.18189152596438418, 0.17634251005259227, 0.08884456813285602, 0.017699713740026546, 0.09531993737611699, 0.04957484909181109, 0.03412254174638507, 0.06836975056011396, 0.09237586153747357, 0.09742914939697023, 0.09512937059155535, 0.13727798185332996, 0.10760547551077615, 0.13139346296518795, 0.048156421121569704, 0.11035301764775263, 0.10962979955136465, 0.08501904678561101, 0.22993068063230326, 0.06716062834814562, 0.19111040196506468, 0.1919084233883931, 0.4268263638551817, 0.12411355686812853, 0.16259857432490132, 0.1908295734366503, 0.13346594676677637, 0.11332205359089587, 0.10498233490885212, 0.07249237633886241, 0.2630149009890389, 0.2274247121364954, 0.2131576762227978, 0.26959194787096874, 0.25314898047212486, 0.2722606601698887, 0.7106645750601465, 0.749293918396321, 0.7392608068691592, 0.6615463542024025, 0.7502263798642734, 0.7166162521279722, 0.7162867603531783, 0.7128303584869247, 0.7574922073997382, 0.15486866050454373, 0.10342343525130504, 0.1493966460964008, 0.08819490758438409, 0.14695948455703034, 0.17239141304390937, 0.13917426752246642, 0.1383011461183392, 0.08831244261803894, 0.15457035202884217, 0.1651676543551548, 0.1627113226069199, 0.2228266722522475, 0.17034004037614958, 0.18976041939790378, 0.23129207517680672, 0.1773646794176319, 0.16845461378194704, 0.4803942266828536, 0.33107747153015954, 0.24627955005039026, 0.3713559468947074, 0.30629055419971507, 0.39396308257719437, 0.45436490917194383, 0.4377957976661655, 0.27620341493141864, 0.22648965828644518, 0.21099263658347922, 0.16863166373171057, 0.2129375005073375, 0.20628801063066882, 0.29653234840564446, 0.2538101628205498, 0.27200987776254404, 0.4161372444897383, 0.19658864150372657, 0.2301398251380441, 0.24223309845729823, 0.1959117419281018, 0.2362772163701281, 0.21096073421152994, 0.20993490790757008, 0.2134892701261033, 0.2661579087138062, 0.1804836519676417, 0.17503143729680182, 0.17605604363688399, 0.20861356720498092, 0.19784951441137044, 0.18009195460803873, 0.1970294884501652, 0.19124937087461158, 0.1846525643211574, 0.8474685194628031, 0.16438002102904647, 0.7887877552832304, 0.8492737224021742, 0.1714983385235448, 0.8887481849766822, 0.7451434840481634, 0.19819820143146072, 0.8263586852934373, 0.7279404169397627, 0.20715228988174672, 0.15223183822835384, 0.20513360165880734, 0.12622970398787037, 0.8446873157356138, 0.16675904662990038, 0.1618012121305652, 0.16691698179795111, 0.18423570738570216, 0.18926437304877952, 0.21597193619071464, 0.17587101768523716, 0.18591806629041152, 0.20150068212737327, 0.19658443805889392, 0.1814200232397366, 0.20213777532080857, 0.08404426291075817, 0.08021341220865397, 0.08713627830635229, 0.0893092430589062, 0.08115300511113888, 0.09781812184868233, 0.08182690237541812, 0.08993655070215067, 0.08941427254484913]}, "mutation_prompt": null}
{"id": "4fa102cc-f7cf-40ab-9163-06980d6de98c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "8af59051-e022-4492-98f3-5987fa3d2163", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "0dd7ea8c-d513-4c58-90f3-cf6d0b03c493", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "3c418d88-0856-470e-9050-a10c100f2adf", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight * (1.0 + 0.5 * np.tanh(0.5 * (np.std(scores) / np.mean(scores))))\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])  # Adjusted mutation\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhance population diversity by introducing adaptive mutation rates based on population convergence dynamics.", "configspace": "", "generation": 84, "fitness": 0.3459269098273837, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8282009793948609, 0.8267847051788567, 0.8340838267798636, 0.841458379206785, 0.8437505582184166, 0.844808553455534, 0.8225778462966805, 0.8425953813689139, 0.8258881787059725, 0.5773718833623723, 0.5842944310411866, 0.6260401923131421, 0.6001955683102185, 0.6412224052415965, 0.6394623229094869, 0.5496645356009772, 0.6312140650422381, 0.6111304902782455, 0.15590582621171922, 0.1529919134483243, 0.12861751235050856, 0.15122234476454344, 0.18128070158969, 0.12357347711125255, 0.13760030447359806, 0.1298673182696619, 0.15231779175945015, 0.07590941909641569, 0.0894261010398435, 0.0964939014366597, 0.11443497209156761, 0.08295633577806671, 0.09272860512695391, 0.07923296330686358, 0.08223824786428413, 0.1367679320811671, 0.9403488089170764, 0.9364684084818132, 0.9116663247299132, 0.9324230363785116, 0.9129582652171477, 0.948177975576528, 0.9319720972001342, 0.9267304545168913, 0.9190901127303375, 0.5288692026291779, 0.5098831342526539, 0.5093122622684, 0.5468063875958618, 0.5205917430525309, 0.5706925680385386, 0.5828501030207041, 0.5184154739990419, 0.5311833961142025, 0.8556333391379528, 0.8077113404792294, 0.8253667315546057, 0.362676308251939, 0.8784251489585404, 0.8475230542070112, 0.2264836369847495, 0.23656252544563527, 0.23872854054332215, 0.3869268472305827, 0.6147333700257641, 0.5635482148413034, 0.5999724600133143, 0.5319399434134063, 0.1762679819747529, 0.1257763543849858, 0.581298935348594, 0.48660197650655934, 0.5175662255538382, 0.46617418230777474, 0.1302858248913702, 0.48071682146222006, 0.4987416787634834, 0.130977642899752, 0.48656410228889113, 0.5215208903132067, 0.1298089747555008, 0.08485229492791846, 0.13089857931461835, 0.04989045346333587, 0.03955563390838723, 0.12600464699062597, 0.2920250836911603, 0.0016567773861937418, 0.11812816484353739, 0.06372004824898392, 0.16046896045166015, 0.1363874227418842, 0.1281406855115571, 0.1711246943872078, 0.12470791431343675, 0.10148337954431585, 0.11163900012570027, 0.12340863106252908, 0.15684533989249372, 0.22431633007036011, 0.2873741487741308, 0.11118467363564632, 0.12388016583513795, 0.19150755964638166, 0.09185664269028526, 0.13590796754990775, 0.20519296574635104, 0.11311725223153901, 0.13968064469016972, 0.17942588696434725, 0.20621487531540283, 0.21864118575143598, 0.20126898607317711, 0.28023939248805796, 0.23761271878908607, 0.32771643569419573, 0.26129899765819775, 0.7329754164044504, 0.722077534985474, 0.6540659530081908, 0.7335594352303264, 0.7340497940474587, 0.700764214054329, 0.6835518115699215, 0.7375748697825817, 0.7140784997448573, 0.1350384550802317, 0.10684744302048044, 0.14324869832824572, 0.12846634286449699, 0.15125236121375274, 0.12344131346447906, 0.10874922607116821, 0.12574075450361688, 0.12925667929130047, 0.1760053673532428, 0.140798993689758, 0.1772787625415444, 0.19367412438562026, 0.21675345017646208, 0.16031358170415455, 0.15796483796533534, 0.15044249914271368, 0.17114611001794144, 0.38469512240693726, 0.3877087243796705, 0.26669949193984643, 0.4214966795724817, 0.32219025852576477, 0.26879916655047065, 0.4057858040336252, 0.3630200872867815, 0.42417065403617393, 0.36772208317580357, 0.22758758375736665, 0.23424936424067966, 0.38289601523530803, 0.218376299111253, 0.38126081241647847, 0.3472492988023834, 0.28235370948621696, 0.2696428409493794, 0.20195947196075414, 0.21631110015115385, 0.2054350131171796, 0.21349748209795327, 0.2134746866411874, 0.19200543876856357, 0.20158880412545155, 0.19214238912794723, 0.21122037041641928, 0.17246977532290586, 0.1832242577427352, 0.19269085566856037, 0.18846260573363793, 0.1830133678699134, 0.22104872307208256, 0.16617299122290274, 0.1957295355981794, 0.18671634095525957, 0.1712795567967692, 0.16206268215821873, 0.1552463796335778, 0.866275632169751, 0.19794856633463798, 0.8471519035392698, 0.11970426567139891, 0.1679587629685566, 0.17477370671547177, 0.16531291419937566, 0.7066292466215964, 0.7975207601649036, 0.7718679058987823, 0.20173387453972647, 0.20268298274774066, 0.20148395899741722, 0.20861915393438435, 0.8110879485451064, 0.1766931908522612, 0.184283341135268, 0.19185552505305792, 0.2026200093547742, 0.1914262293065132, 0.1819630812368387, 0.1785386227410587, 0.19649730417275246, 0.17860791644778273, 0.10863683307058125, 0.10938485753880545, 0.09435430714356441, 0.08134769843445322, 0.0775338595115811, 0.09587590153121195, 0.0860864479203679, 0.08631034257302095, 0.08801579973974327]}, "mutation_prompt": null}
{"id": "020c9e50-290a-4a2b-9128-5f8727845fa0", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_cognitive_coeff = self.cognitive_coeff * (1 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                cognitive_velocity = adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduces adaptive personal best velocity scaling to enhance personal exploration capability.", "configspace": "", "generation": 85, "fitness": 0.3400087376595663, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.7684274061567211, 0.7768776696078, 0.8182677585335116, 0.801219714129998, 0.8032278966475533, 0.8217996245820303, 0.8040813442932846, 0.7545932575861376, 0.8088632589660114, 0.5502793929251942, 0.5680678296416793, 0.5755257914698272, 0.537032778298114, 0.6239024055193803, 0.5279015871765851, 0.537050617536631, 0.5515633690796764, 0.5187755196936588, 0.1399978012123957, 0.11822169612290001, 0.152476855469452, 0.14970336848160737, 0.12718542713926817, 0.12334791945839474, 0.12090428003365306, 0.12101023394942934, 0.49918888449764276, 0.10599173419204877, 0.12690308934248729, 0.11443097984508699, 0.09390299123614498, 0.07651321301766856, 0.08216529222168478, 0.09543104903919941, 0.10006552795041312, 0.08260958152556264, 0.9188287770105094, 0.9083678402717491, 0.9089008266277846, 0.9432069030852414, 0.925200647736471, 0.9560206788231931, 0.9310233838697737, 0.9141530999566586, 0.9268882737963863, 0.4529553998174449, 0.43313688085444635, 0.4782166516926979, 0.496760699917817, 0.5318597932327953, 0.4635962377989725, 0.4823918154495195, 0.46685239264544065, 0.46435997935860973, 0.7704982872262076, 0.2223283808067762, 0.22183250807647414, 0.27885832062813776, 0.20822488209346357, 0.26605590776178156, 0.16432118532925566, 0.8453621290990991, 0.8351191681353755, 0.6126795851691529, 0.40170422343008316, 0.4461920801208141, 0.4251772953196964, 0.39339029689299, 0.16664690645783253, 0.4514376763489275, 0.4289291189137381, 0.4464603706319902, 0.3053502989338438, 0.3968926422113406, 0.36186135945943965, 0.4179226742484712, 0.1303772820706256, 0.34881066452430465, 0.3866048806769996, 0.39782292766507876, 0.29110745303500896, 0.016785849119043794, 0.06618218716921931, 0.10074039464350137, 0.041690316996426335, 0.1273545450947311, 0.059096656050506846, 0.10747745501008066, 0.05094387380319909, 0.13088400549490276, 0.1585807340428479, 0.13088728475800504, 0.13440031201440328, 0.06049739336135629, 0.1672106013950121, 0.041885165493408594, 0.12519198255234276, 0.1431720286690037, 0.09359454477060225, 0.1897330092930697, 0.16417047283628838, 0.12448519149862536, 0.28588091174412145, 0.21075096616817057, 0.10466577690231538, 0.15752853422317348, 0.15352885710386288, 0.11952510855273757, 0.3045266881548643, 0.12483639337031505, 0.12167033403260807, 0.2358728163752406, 0.2457031780325738, 0.18319763073853046, 0.139306746503278, 0.19120542039876465, 0.16458265785220172, 0.6894092273701997, 0.6879513580858689, 0.6573477151181547, 0.6977926243774362, 0.6886530532234538, 0.6516425676516835, 0.706021105972146, 0.7277210395863787, 0.6622555662552503, 0.13863796834914033, 0.11346678110447261, 0.08983322898157042, 0.16877977961647905, 0.113211654852169, 0.1801451913120674, 0.18048408698877139, 0.11449410120126846, 0.13756703910030788, 0.1845882146968023, 0.21885165221455505, 0.1613031546364, 0.1518001905194667, 0.18406150779668828, 0.156610463064923, 0.16761522245666616, 0.2301132635983778, 0.1557480073180324, 0.34028953078448687, 0.40882293386611135, 0.2760787354993198, 0.2999914508424132, 0.4174042026554081, 0.3542937347998326, 0.3836636521044565, 0.3252848655884344, 0.4058378183646467, 0.280560911904395, 0.24081443260145363, 0.15131659722043056, 0.31044521577941087, 0.21786115373064197, 0.3461204007795672, 0.12191318614866309, 0.2783467108106906, 0.2893258341977156, 0.19059296760509947, 0.19556525686926374, 0.20948496342683298, 0.19791670050174348, 0.22424029872515716, 0.20384564387505244, 0.21359730127864096, 0.2496608672500663, 0.2321576388022749, 0.1861095600811563, 0.19276163106059963, 0.2506111620368655, 0.17053391460603162, 0.1718667408128478, 0.17174391287167312, 0.22138596129741284, 0.20684165234338603, 0.1834305672425165, 0.8459124705164264, 0.16445627220823367, 0.7796308865641606, 0.8015253311228365, 0.7858329774017659, 0.8882958829724316, 0.7667639522285319, 0.16899255986714357, 0.1641585131348493, 0.6502924112356453, 0.5933328082950227, 0.7150929459590015, 0.2058853500374972, 0.6611046061530613, 0.8444456989388092, 0.6883192643851153, 0.1638689095739122, 0.16511009697663426, 0.17855335612280543, 0.1960184583766028, 0.19096735222662364, 0.1821394147668186, 0.18037765963943475, 0.17930446439581205, 0.17696533046952645, 0.17362558915128834, 0.20161370460224037, 0.08848538971385533, 0.08434004924863292, 0.09553501488813632, 0.08890988464153249, 0.09522632088478444, 0.08901261100419156, 0.08624336057488002, 0.08036442570388158, 0.10441817866016723]}, "mutation_prompt": null}
{"id": "18fdd4fb-ecdd-4748-b718-de774e347450", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "882f69b3-2b2f-49f8-b9ea-7046dc128566", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "1ec3081d-ecb6-4ab4-b4ee-4fc190280c2f", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "e5c59756-a414-40e2-bff4-b4e868243542", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            # Adaptive cognitive and social coefficients\n            adaptation_factor = eval_count / self.budget\n            adaptive_cognitive_coeff = self.cognitive_coeff * (1 - adaptation_factor)\n            adaptive_social_coeff = self.social_coeff * (1 + adaptation_factor)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = adaptive_social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances exploration-exploitation balance by incorporating adaptive cognitive and social coefficients based on search progress.", "configspace": "", "generation": 89, "fitness": 0.3522786329394406, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8382576522982539, 0.8239377331611272, 0.8327805316900498, 0.8336625518586521, 0.8121941805981918, 0.8392671995570339, 0.8253650439199793, 0.8193459833137602, 0.8257436378199268, 0.5716482135193703, 0.5788022061164495, 0.6175578771163084, 0.6006338163106837, 0.6175563078519294, 0.6378158683203512, 0.594356140977613, 0.626598428842746, 0.6007316072338745, 0.13914224231213213, 0.1531784555627108, 0.12915017384067018, 0.6287465763613004, 0.12856076317868081, 0.12858931641498295, 0.11962195152069921, 0.12086799434100559, 0.15741912737177777, 0.10745934187979544, 0.13915150499528284, 0.10246342638816563, 0.11476514553072703, 0.061499589265168964, 0.10135696393520544, 0.07100055601355104, 0.11208485125638434, 0.0631160173537515, 0.9199653108954355, 0.9031169689687129, 0.9132228116273835, 0.9427171634027163, 0.9135874995195017, 0.9560008536341538, 0.9196733060948853, 0.9159427903604744, 0.9305293361728446, 0.5483703212404478, 0.5262066340348892, 0.5742595780328794, 0.583082941858422, 0.49992424891264886, 0.5360184021194748, 0.5275046441147913, 0.5640031580002897, 0.5617133373501517, 0.7818216513136851, 0.20365717068372646, 0.8597551891075331, 0.8885030682652569, 0.20764623412564764, 0.2114793931427864, 0.14912794132197904, 0.7807682784220091, 0.8262116904708682, 0.5735891273287442, 0.5162173635925729, 0.5237384341960213, 0.4937524893877011, 0.5804684719102795, 0.11299510152717307, 0.4781492768868978, 0.4701390594179369, 0.5261210969583862, 0.49445888740175237, 0.47431502098973255, 0.4900329680608714, 0.59943721440233, 0.13060244764231244, 0.4522881680302351, 0.31801611654599105, 0.39854204018424266, 0.45156363373031916, 0.07877221020877001, 0.14824329977034845, 0.0722489892624697, 0.037043442291633255, 0.041731743916658126, 0.06900230577741018, 0.2357082121920272, 0.25144350659478454, 0.060528717516608266, 0.09354496699314718, 0.08890013328300739, 0.1460790047902194, 0.10908309294853369, 0.22867181453138896, 0.052065402648608816, 0.14073027147127648, 0.08155643881515318, 0.13396899453117694, 0.2211605350031154, 0.17174732605901522, 0.15303369194508232, 0.4219225553552577, 0.33166670366910367, 0.1000720144756273, 0.1311275713244655, 0.15436487009262767, 0.12962898166692016, 0.20633181190377003, 0.11877920722350177, 0.1455857283132831, 0.2124304820217099, 0.25012359479574053, 0.23674662012191716, 0.1813133040243804, 0.26158123660700994, 0.2153684581046047, 0.7413809336040227, 0.7110643568984407, 0.7005677411636756, 0.761689448239922, 0.6934020218711174, 0.6246942611384223, 0.7282117333544225, 0.7013962847013493, 0.7375244947235666, 0.15231250696932275, 0.10355468579066585, 0.11806046149339511, 0.13795510536954025, 0.09852397306741201, 0.11318369689667851, 0.18249447229161775, 0.13542025474967379, 0.11963929808576046, 0.2099386162962683, 0.163511282821719, 0.2485684097800951, 0.18450425086433753, 0.22292493905547028, 0.1658279113452854, 0.13624277843245558, 0.19338396211687936, 0.21288155213518833, 0.3078217779828708, 0.3243628555170789, 0.29505025750734803, 0.4281919496158183, 0.38005506995729443, 0.3278932490823414, 0.39229955391278637, 0.4076088081420447, 0.30546613692082103, 0.22440563252574253, 0.19673154332790133, 0.1921687161577793, 0.31657298905976017, 0.2634656766046828, 0.2926987473514704, 0.20659078775334472, 0.2894698373124349, 0.15896606314273176, 0.21303198868155515, 0.20644483342480047, 0.21340752748938963, 0.20570642231267489, 0.2130605540863283, 0.20187945466239876, 0.19347147053102964, 0.19285313062972975, 0.20601397653927023, 0.18738066941272113, 0.1730955325126643, 0.2514778363850265, 0.17866480369560156, 0.19147463250743824, 0.1865559402515683, 0.20685094168008922, 0.19309630786985832, 0.16899605577847343, 0.8283121455143042, 0.16449494819119714, 0.1900510123825383, 0.8386713716522737, 0.17174493483554454, 0.876172098374009, 0.7186865588352962, 0.1690021415117231, 0.16406773180720668, 0.7062244554806183, 0.7080021682942694, 0.15145563959630348, 0.20567048399104793, 0.6922267951754363, 0.866576749561232, 0.16727137094085665, 0.16402727811258644, 0.1651679158625584, 0.18079786802237086, 0.17847175437394414, 0.18754062549474426, 0.19485496502421762, 0.1907099339446826, 0.19536790790087022, 0.18674778703675432, 0.1899111907193325, 0.1885414500000756, 0.10676972983734867, 0.093418973224905, 0.09562101669804746, 0.08580221593776283, 0.09078139314394151, 0.09916049268325244, 0.09948537093725174, 0.09091528603133137, 0.08134673054201991]}, "mutation_prompt": null}
{"id": "6117a55a-3de8-4bb6-8688-fa0cd01f3b24", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "f3a569c4-235c-4e41-84ba-2ee3208c8643", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "34bccdd0-c4c9-4247-84a2-119d9cf98c4a", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            self.velocity_bound = 0.1 + 0.4 * (1 - eval_count / self.budget)  # Adaptive velocity bound\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * (eval_count / self.budget))  # Dynamic cognitive coefficient\n                cognitive_velocity = adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Introduced adaptive velocity bound and improved exploitative behavior via dynamic cognitive coefficient.", "configspace": "", "generation": 92, "fitness": 0.3574270266112156, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8369500882084556, 0.8484678673039009, 0.8144258083725942, 0.8157655844846924, 0.8286643303219671, 0.8243219676869005, 0.8366937471708884, 0.7997955313302786, 0.851608816917226, 0.6267675985731193, 0.5862525360271975, 0.49758740932799805, 0.6187067409103735, 0.5284350191362074, 0.5976958262944707, 0.6009864642360734, 0.5749755500331543, 0.6189255951623092, 0.09676266736776429, 0.13958263611872812, 0.10314019578560396, 0.13234588589004592, 0.10951038727656504, 0.09571705510749129, 0.10816628996206401, 0.1218966952033006, 0.14053794229882755, 0.10509550563110348, 0.09670909671945316, 0.11041511084128919, 0.10769828364336465, 0.10022407601930605, 0.07628361954754892, 0.09029225930110385, 0.09147276449640684, 0.06278442271730655, 0.9458087789720565, 0.9017529924153305, 0.9195450349576049, 0.9455900047722514, 0.9396130501009778, 0.9496514412128936, 0.9422419306012105, 0.9281413725825982, 0.9281249680878865, 0.6064012864307369, 0.5632697394453927, 0.558108608001507, 0.5892555933257018, 0.5937587228776648, 0.5761447191360661, 0.5998019569751712, 0.5774011829759751, 0.5832982542410604, 0.8371143374848716, 0.13981221251288078, 0.21826402557957425, 0.39947582336790466, 0.3924248445024231, 0.8854642449987438, 0.1785788881435787, 0.18051382977835095, 0.17366246310509392, 0.13377370437010672, 0.3682764587688393, 0.13529008414979926, 0.5911747621115822, 0.5154492044828738, 0.442449553800085, 0.5928060452895652, 0.45033038434591777, 0.4970984591093842, 0.6170783566206575, 0.5574736795594692, 0.1345888758657322, 0.4781840178283324, 0.520441544746747, 0.5316612559670009, 0.6008375836541364, 0.44673758315365353, 0.4963755443846598, 0.12049798525481381, 0.16036653816064406, 0.4827796856582456, 0.051959515523507305, 0.19177690491910282, 0.09272050183520164, 0.3053635811940122, 0.11252655328024064, 0.2594016829192114, 0.11576736404887489, 0.1368629288041091, 0.17227377993813264, 0.065842048658866, 0.01325026327179113, 0.08907897159142175, 0.2048614308145449, 0.19688346194205575, 0.07474736322025544, 0.2742951700088041, 0.21715761689873003, 0.14675321869431524, 0.07263943515247662, 0.10311417055790995, 0.2005141603143138, 0.09193824556975161, 0.151953516379983, 0.0898912599068693, 0.28451315220720785, 0.22978812451865738, 0.2194715055078501, 0.006456414925420151, 0.3670601962346015, 0.3390309585913729, 0.2869784311304624, 0.18629605464887122, 0.3497999852582335, 0.7586291321875864, 0.6883531430638401, 0.7000657933971111, 0.7346528813060287, 0.6784426610691272, 0.745197839908978, 0.6794587616391813, 0.6938644724812828, 0.7105769819718303, 0.07483063599944562, 0.09295180431696481, 0.06595616933230009, 0.09365436037773911, 0.1549041221373736, 0.09746270702589577, 0.15635004898439275, 0.12226493906831415, 0.08173723835314828, 0.2504905146564431, 0.5341798250114782, 0.2691523478297104, 0.24697302243460817, 0.28693975840775054, 0.20055352890863742, 0.20453289597945135, 0.20168262165449635, 0.3048904860851459, 0.36419508606549666, 0.42778699538521825, 0.2296562856425971, 0.20275364761418946, 0.4979612270956134, 0.4269024514438533, 0.2400732174735123, 0.3931191263670887, 0.40280873246107396, 0.2531303150728198, 0.30509047034389536, 0.20368603794792384, 0.2676993653398023, 0.27503806295700584, 0.31637911380248784, 0.09918880750784442, 0.3360981455113131, 0.11556200729937083, 0.22460533573440056, 0.20877487058914934, 0.2121478693936586, 0.21952930393195125, 0.2373375383590426, 0.220883138773746, 0.2560626042196362, 0.23708740101458392, 0.22801247922311785, 0.1774000259760724, 0.22490897127363685, 0.18019053640336224, 0.1831825289600112, 0.18714507628263455, 0.1846635866786318, 0.20952382365822408, 0.20064590254030845, 0.18143040371479124, 0.9062043462213876, 0.14597265013756455, 0.885668018953402, 0.9039991640204897, 0.2003933047759593, 0.9291303617561287, 0.12203195608499717, 0.9142665969393842, 0.17601946149227365, 0.8535758276969316, 0.2109486511563824, 0.8664490426564573, 0.2088241303891858, 0.16884329884429283, 0.21034184443638637, 0.10455472580323744, 0.8455185941105549, 0.7985129122408895, 0.19096081767351136, 0.1807959115869633, 0.18915750658148067, 0.1793771256181359, 0.17927818317697874, 0.19730773810144397, 0.20392152726730273, 0.1862485700675487, 0.20740038353170986, 0.08351953381851074, 0.08888870379651648, 0.09023776697985719, 0.09755432984674917, 0.09049155214493165, 0.12315157501943574, 0.09844834530006341, 0.10011578740572025, 0.08319735898349268]}, "mutation_prompt": null}
{"id": "cd8bd38c-61fb-4eee-9b98-fef1e129a66b", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            population_size = int(self.initial_population_size * (1 + 0.5 * np.sin(np.pi * eval_count / self.budget)))  # Adaptive population size\n            for i in range(population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in population])\n            eval_count += population_size\n\n            for i in range(population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            new_population = np.copy(population)\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhanced swarm dynamics with adaptive population size and inertia weight for improved convergence.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {}, "mutation_prompt": null}
{"id": "82151ea7-6d6d-4360-af07-5faabd3adb24", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "ac345fa7-35ca-4673-8cdc-f4159065ba94", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                # Chaotic map for diversity\n                chaotic_factor = 0.7 + 0.3 * np.cos(np.pi * eval_count / self.budget)\n                trial_vector = np.clip(trial_vector * chaotic_factor, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Enhances diversity by applying chaotic maps for parameter tuning and diversity control.", "configspace": "", "generation": 95, "fitness": 0.3293256410042882, "feedback": "The algorithm SwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8494200934315125, 0.8375440541787846, 0.8538542752429352, 0.8247024734529438, 0.836852438425886, 0.8362201150774204, 0.8371016968230984, 0.8370509801165869, 0.8353040692534501, 0.5817031155480124, 0.5854355954570472, 0.5607367650657011, 0.569279502348445, 0.5874016130663074, 0.5393346964012121, 0.5900115422031098, 0.4690915544926738, 0.6026624633854629, 0.6009373356587739, 0.10113828691040982, 0.12897029388088688, 0.17943184061378903, 0.15231696459313937, 0.10490651675213536, 0.12270786618522289, 0.11895368584428834, 0.17932538436391565, 0.08326242962822328, 0.06122053801719085, 0.1273817195555499, 0.1194755190255169, 0.09080403245767699, 0.11250408944811785, 0.06619163506114711, 0.08754259760971239, 0.12552410811562564, 0.9189519346817816, 0.8787239930510763, 0.9282748134450718, 0.9395320155000935, 0.905736216247414, 0.9559181661336054, 0.9268419336788241, 0.9131401821142364, 0.9224829329799047, 0.383935450129119, 0.36197146174402506, 0.528887632898726, 0.5009132350120435, 0.6101434404533413, 0.5489874935481598, 0.45302158659499303, 0.4289367644991674, 0.44517653642487653, 0.6763508588666596, 0.22022937799511044, 0.2286667490518436, 0.36823568348959057, 0.8290823088333948, 0.31507318195452405, 0.16378932605892405, 0.23008068062354103, 0.17491512181811963, 0.6119748586607886, 0.16810830180713487, 0.5558546571499661, 0.3553957548005612, 0.40290480307755505, 0.16959183828034896, 0.2128517797579701, 0.38721060468780655, 0.5424724305960074, 0.29466779861318204, 0.1279157369569648, 0.3699570920151055, 0.30555590835955093, 0.1303395058338509, 0.32133724934661245, 0.4153782390179228, 0.27720610658430567, 0.39012647219514285, 0.07933689352776985, 0.12417726323716483, 0.0545658909728447, 0.03262580638804424, 0.06711825098529589, 0.01146263641676959, 0.33163496425594363, 0.010626078149685747, 0.017816740340169, 0.13104892481814023, 0.14589086497814718, 0.10570459279118372, 0.07873161020819575, 0.12890374695686513, 0.055003268561438334, 0.08734466029939902, 0.09438846022562752, 0.08502542194993201, 0.16029176460578087, 0.16798488311755666, 0.21278575966600333, 0.15270332795659103, 0.18397985092956437, 0.09040492667578803, 0.11372846362875211, 0.1606679891439864, 0.10949805918026811, 0.3208765747631148, 0.11837033656471563, 0.1152103282268554, 0.08048230929069156, 0.1811361189345715, 0.12011458737240333, 0.12858253883290072, 0.16320455284576396, 0.170029263108043, 0.5401546638970591, 0.6179580694428646, 0.6138827359797886, 0.6308805329173138, 0.5455026630378738, 0.5401472330390065, 0.5701031463439304, 0.6196367216844938, 0.5539703641927154, 0.5309449260058154, 0.09662224507718997, 0.11677268090665471, 0.14971316396961887, 0.09847078459824166, 0.13601237672068966, 0.17981172625696473, 0.14986879486716975, 0.11610682660922889, 0.14995192751371034, 0.2780183801566256, 0.2006028985708389, 0.15076454421889052, 0.16781059100141427, 0.1570020997562036, 0.14672425947268097, 0.21678355453513054, 0.15925562042163188, 0.29663089148454447, 0.27092532949175585, 0.35552941269453053, 0.3845114639230396, 0.3373252066271524, 0.3752020639905377, 0.3797535746773456, 0.36157809107539196, 0.3209818637231576, 0.1992243290239254, 0.3127159951347922, 0.1636172304061163, 0.3436652261253179, 0.23807724251206863, 0.3480215981103888, 0.17785529474798312, 0.2845187406300772, 0.32489268176544583, 0.2256744169244198, 0.26245748490490006, 0.2569856243192835, 0.24276958257200743, 0.24203629064587562, 0.2436603211073064, 0.24175146098930722, 0.2476234797218001, 0.25452681686576084, 0.19751679456739513, 0.1698689173011515, 0.2098903088957813, 0.21028877583097227, 0.17409850355740486, 0.17010434047657197, 0.18186118920982286, 0.16621345750598115, 0.18826793836850597, 0.8508086790240452, 0.16445690351921893, 0.18925073938198023, 0.8430176415077688, 0.7600363067820168, 0.8843407671995983, 0.6929778172852714, 0.16865834513428968, 0.1655563263173322, 0.7192198175365868, 0.6648918493373228, 0.6833993582367868, 0.2059278067473308, 0.7353582722233338, 0.8701394284870636, 0.5103818508797417, 0.1638203134867845, 0.16496647834517353, 0.18831306131784586, 0.1941940003575494, 0.1823144517565931, 0.19299376038636795, 0.19022534714417239, 0.19014686221505506, 0.21869486256703508, 0.19079679611503764, 0.18683712163299848, 0.09036562256568847, 0.07829917471261161, 0.08655389025310467, 0.08677956786687213, 0.08540598861580528, 0.09309473091153198, 0.08886493077932733, 0.09076610427592036, 0.08378019775268764]}, "mutation_prompt": null}
{"id": "0af643bf-076f-4949-a19f-d321dd53db26", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "d5ee3d1c-7b6b-4778-b687-98c21beeacbe", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "edf0f699-55a6-40c9-afb0-2beb5de85c7c", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
{"id": "2ecfb088-8869-4399-8c3f-6563706ffe91", "solution": "import numpy as np\n\nclass SwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.differential_weight = 0.8\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for better exploration initially\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_bound = 0.1  # Added to control velocity magnitude\n\n    def __call__(self, func):\n        # Initialize the population\n        population = np.random.uniform(low=self.lower_bound, high=self.upper_bound,\n                                       size=(self.population_size, self.dim))\n        velocities = np.random.uniform(low=-self.velocity_bound, high=self.velocity_bound, size=(self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Nonlinear decay of inertia weight\n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coeff * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_velocity + social_velocity)\n                velocities[i] = np.clip(velocities[i], -self.velocity_bound, self.velocity_bound)  # Clip velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = population[i]\n            global_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_position = personal_best_positions[global_best_idx]\n                global_best_score = personal_best_scores[global_best_idx]\n\n            # Differential Evolution update\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_weight = self.differential_weight + 0.2 * (np.random.rand() - 0.5)\n                mutant_vector = population[a] + adaptive_weight * (population[b] - population[c])\n                trial_vector = np.copy(population[i])\n                adaptive_crossover = self.crossover_rate * (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_crossover:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    new_population[i] = trial_vector\n                    scores[i] = trial_score\n            population = new_population\n\n        return global_best_position, global_best_score", "name": "SwarmDifferentialEvolution", "description": "Refines swarm behavior by introducing nonlinear inertia weight decay and dynamic velocity bounds.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "733f35e2-7cb3-40e6-b009-454d857446d8", "metadata": {"aucs": [0.8321491509953003, 0.8412041185197137, 0.8403395172301549, 0.8195442907659587, 0.8386157351183947, 0.8467628906396306, 0.820480967245347, 0.8172347346713241, 0.825353082989262, 0.6042042173852396, 0.5872646346548207, 0.6299277395122285, 0.629482091166158, 0.5642582555409503, 0.4678486139573169, 0.6403744235376408, 0.631616919538268, 0.6324696768607805, 0.1498004656146853, 0.1140571172163285, 0.14266336490135922, 0.15305550493122022, 0.12813522185372872, 0.12129261259068447, 0.12974013862778977, 0.12871241122703336, 0.1770368250232779, 0.10401632275021078, 0.1054307807739755, 0.10364441847808792, 0.10631873499887023, 0.07475095139913557, 0.07842134860031524, 0.07575308799770408, 0.07937862129570672, 0.1105532624956046, 0.9193108858733408, 0.911742415159638, 0.9093941527938283, 0.9431887101756012, 0.9182790856843012, 0.9560021109806549, 0.9341728645673938, 0.9172278415364112, 0.9256051153515394, 0.4887572544595695, 0.5603554871589282, 0.5485240042704178, 0.6085236274379238, 0.534272803839447, 0.5611002620947307, 0.5737584781702794, 0.5808221011866258, 0.5620801336790981, 0.8594271041787646, 0.22090154770496662, 0.3565612487291886, 0.7472947985605204, 0.20794187483550142, 0.21189833349483733, 0.17661458755692871, 0.7773558825821988, 0.2317581291710339, 0.6093047484085445, 0.46829133381149746, 0.5360759403498121, 0.5246745899913472, 0.6236522074898065, 0.20331384158588794, 0.5462144593728675, 0.47796774784925966, 0.5973645859187828, 0.3163958250545308, 0.4859217767082963, 0.4608595531818168, 0.5306160817707342, 0.13074086021211428, 0.47352454616612294, 0.452917040168316, 0.381693207570599, 0.4475458579944801, 0.09721171863966738, 0.2136374711002732, 0.02702307530912129, 0.046686983580416896, 0.17064736670815983, 0.036700314660558564, 0.4063957004282114, 0.20636333153472686, 0.054567179686207834, 0.15389216350030166, 0.1547668980438648, 0.12205648019484328, 0.07083816968557477, 0.11319897403874679, 0.03714975507760776, 0.1104726950238053, 0.12431043948824394, 0.08603687681898586, 0.18342003552826036, 0.17823204095306466, 0.21386807244283101, 0.34132959227846027, 0.23392746933704034, 0.11678961082024875, 0.11530486674118712, 0.16240855468355608, 0.12059943065954071, 0.40165277860096704, 0.1055186968449674, 0.1821500097407498, 0.2243428653748819, 0.1978490215392208, 0.26949974769056273, 0.20553615543060322, 0.19732009698830466, 0.3087447377637803, 0.7347942422668172, 0.745952555690375, 0.7698272428800479, 0.748219846476134, 0.7494935147386559, 0.6880822221747125, 0.7350363566718827, 0.7031529130455606, 0.7213406040419343, 0.11876974711291277, 0.11340601727442412, 0.1061133250119235, 0.128897204029485, 0.12719135171349027, 0.10837802253985884, 0.17896197896999022, 0.11873144917997602, 0.17182849993307703, 0.2182826915204703, 0.2660858574688142, 0.1719935801271154, 0.20000335670318148, 0.16261161406037805, 0.1475537405088988, 0.1984679810339346, 0.200249594576146, 0.15888921238761045, 0.3197704975987524, 0.38646346173765234, 0.25525921302045873, 0.44702113936946763, 0.4221569586707682, 0.470003506834482, 0.4158860924606642, 0.3540075291206316, 0.38934076821219665, 0.3351280558284506, 0.25632722511534844, 0.2566660066668689, 0.2601764306600687, 0.26081120220327714, 0.33502622040237184, 0.24908621709459022, 0.40000284385916207, 0.27587810880412866, 0.18575775971729258, 0.22088820245810625, 0.2652037154454776, 0.21454469455070546, 0.23637751364189497, 0.20636881619536274, 0.19254141358412358, 0.22778988708554182, 0.20125525213645323, 0.18039236397751157, 0.1944783595551458, 0.2506681301688446, 0.18170786209194223, 0.18147503169092438, 0.1724797597046347, 0.20702669919572203, 0.6519607816275053, 0.19349924455356127, 0.8532414774281852, 0.16446491262285923, 0.1903610834151952, 0.826873890825631, 0.7546315157705213, 0.8907378120200492, 0.7492885908279597, 0.16916631193465836, 0.1641253750568663, 0.7301570307071445, 0.6166567884161938, 0.709962537575824, 0.20567005334541189, 0.6970636045842965, 0.8669850624099978, 0.1672596808278185, 0.16396513651854094, 0.16518848384906304, 0.18333306388124349, 0.18877579752077722, 0.17549827518155126, 0.18473346397415102, 0.19170852739476651, 0.18062203172762548, 0.18393255388256213, 0.18227737045232328, 0.1758770354999175, 0.08154346954606373, 0.08427095624898862, 0.08681282965695913, 0.08609373370505946, 0.08674384746665942, 0.09769233439610547, 0.0969431010145112, 0.08888552076579126, 0.08932462121909301]}, "mutation_prompt": null}
