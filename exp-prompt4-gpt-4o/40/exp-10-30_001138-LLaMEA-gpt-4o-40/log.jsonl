{"id": "faa25113-2d0a-443a-b3fa-a01a670108e0", "solution": "import numpy as np\n\nclass PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            # Update personal bests\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            # Update global best\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            # Update velocities and positions for PSO\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Mutation and crossover for DE\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "PSO_ADE", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Evolution (PSO-ADE) that dynamically balances exploration and exploitation by combining swarm intelligence and mutation strategies.", "configspace": "", "generation": 0, "fitness": 0.2193315253061646, "feedback": "The algorithm PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6249250565458927, 0.5547030483815362, 0.6511367125711017, 0.6405343447828945, 0.6277953903093594, 0.5265957279511562, 0.6448019332734063, 0.6150950578840151, 0.6168045815631116, 0.22107030630015823, 0.2147082812954707, 0.03280782701180307, 0.26369521801908047, 0.2434525108539578, 0.26334539168379667, 0.045239791082314906, 0.30846823833275105, 0.25347343013491985, 0.09578719289454307, 0.08555802945524249, 0.098913779089011, 0.11449629525581317, 0.08617457324662281, 0.1446864630689988, 0.0849345918451232, 0.11616607953265468, 0.08636425503637091, 0.10930896945766178, 0.08311680163257829, 0.08297617975961313, 0.09396364194283047, 0.07601764367945796, 0.09128952293990733, 0.1042974687824959, 0.07816688715709774, 0.08110677745671546, 0.9769793752868636, 0.9692431846535614, 0.9688221231390304, 0.960097923845876, 0.9728487706293016, 0.9572042340957961, 0.9761770555273545, 0.9608917809092763, 0.9589925640116258, 0.26597457167187244, 0.2121270086665793, 0.05660582141948367, 0.25519644615751613, 0.21310055407098794, 0.22714185725562364, 0.2291371647784639, 0.21234632747707005, 0.19664664115152386, 0.29001942589319096, 0.1693439977234069, 0.16878557412939044, 0.19317033623197044, 0.20712149597830354, 0.19106709000426436, 0.2554692524159706, 0.22540555771246773, 0.20286487082578597, 0.14961298740961715, 0.14366826419369194, 0.12323088755611988, 0.0932911754299448, 0.15816365149313516, 0.15604801144899794, 0.16253348329806727, 0.11854789184745096, 0.17412625967337114, 0.16443279666982946, 0.12463913717660269, 0.18414039640026358, 0.19307301065039906, 0.1229907078455652, 0.1560260895133211, 0.12546083758440474, 0.08819606261000412, 0.18198554608015405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031361772367591634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061239127206277444, 0.03355442611258763, 0.0828095386966694, 0.08977923562481771, 0.023634926640057508, 0.00930416444267046, 0.07191880429032571, 0.03967835713171686, 0.04138634081704817, 0.034579083866048466, 9.999999999998899e-05, 0.09490229048154775, 0.07309310655936474, 0.046803816441918555, 0.046726792229322744, 0.12306115673524931, 0.04479723996827201, 0.05022853425002738, 0.1521799822705454, 0.023716720090190768, 0.008143630665738644, 0.07018500244412584, 0.1422593536231318, 0.10686857811700179, 0.05261622811113453, 0.07505989131439694, 0.1156193568589744, 0.4247222361868209, 0.4291021555042517, 0.4522594085071886, 0.4478890921324976, 0.4425351498224651, 0.47119854431556174, 0.43590422494179015, 0.41642222769963066, 0.42391604222168455, 0.07753517911482899, 0.0714663108604906, 0.058200265209854884, 0.08696382250484858, 0.08585640863871247, 0.11584254782528769, 0.07357395239003439, 0.10407622921450055, 0.10068354150849501, 0.16346139425483475, 0.13025436461390016, 0.2023288608991176, 0.15260432356586007, 0.17381664615487602, 0.1636620870133254, 0.15352894913212656, 0.12674435554866526, 0.18919334278961264, 0.3094673196893758, 0.3051725298956859, 0.28082129384434307, 0.27799480437579993, 0.2889304503469189, 0.2711592392110638, 0.33663963593878177, 0.26466689001795407, 0.30127531908856175, 0.20018503460723258, 0.20303799493347952, 0.20458950319725477, 0.24731514745220906, 0.18251584661865794, 0.2683510875357521, 0.22128858104903015, 0.2559184391027771, 0.20991057117475764, 0.19760976162642485, 0.15639852506602436, 0.19438009956441604, 0.20827781442467164, 0.17738539959363409, 0.19430326399228626, 0.1678497537962732, 0.17695235787556374, 0.19933328026599906, 0.18129881251321256, 0.1974175364474563, 0.21242895485534874, 0.18097943708257336, 0.1788912514040547, 0.18735088291259572, 0.19567040380779943, 0.1939007332253987, 0.18964646460105195, 0.7087015386420876, 0.1700948493340626, 0.15333950515449324, 0.1723978980364973, 0.19715237036322442, 0.19798117270740323, 0.1398877724952765, 0.2353881906151266, 0.8001090480615074, 0.37628532065478704, 0.2056737433690199, 0.45093269747551856, 0.20424877437452016, 0.16790291259514012, 0.15336696460002808, 0.2081152080749532, 0.2017628223697734, 0.19703652491371026, 0.19302646133497214, 0.17874165073732529, 0.17378776492306458, 0.17883413854855823, 0.21199789405843183, 0.18676458066062362, 0.17679618630305427, 0.18154870477421703, 0.17647684696221644, 0.07623289969387648, 0.07621641058780482, 0.06711194340514592, 0.06718945442161495, 0.07925325350904766, 0.0782411313891076, 0.07660669202080894, 0.08178770136174773, 0.08022869378740982]}, "mutation_prompt": null}
{"id": "9789edac-a476-44a5-b949-04cc4e4995e1", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # start with a higher inertia\n        self.inertia_damping = 0.99  # adaptive damping factor\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.6  # increased mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1  # percentage of elite solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            # Update personal bests\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            # Update global best\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            # Update velocities and positions for PSO with adaptive inertia\n            self.inertia_weight *= self.inertia_damping  # adaptively reduce inertia\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Elite preservation and mutation for DE\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue  # preserve elite solutions\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE", "description": "An enhanced PSO-DE hybrid with adaptive inertia and elite preservation to improve convergence and robustness.", "configspace": "", "generation": 1, "fitness": 0.22842950115559232, "feedback": "The algorithm Enhanced_PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "faa25113-2d0a-443a-b3fa-a01a670108e0", "metadata": {"aucs": [0.6514763786454311, 0.6386357280180661, 0.6437093002344436, 0.6913022880005519, 0.6754488441671124, 0.6442299489386956, 0.6481355775765014, 0.6752493122044156, 0.653683500978452, 0.057060736790865096, 0.31141778257196173, 9.999999999998899e-05, 0.27441143804152957, 0.38640584172753123, 0.39356720107034815, 9.999999999998899e-05, 0.03747104624084363, 0.3482148921564332, 0.10471067835965986, 0.10170384096278262, 0.0979843123438835, 0.1042340337844897, 0.11337490428187524, 0.10705123478149359, 0.1062220670947277, 0.10244924878879935, 0.10337818226447504, 0.09472012998295543, 0.09834952315334466, 0.08895967316394437, 0.14540748685739868, 0.08166769941997065, 0.08606843197657055, 0.08825502697304621, 0.09007105610637245, 0.0892523165504212, 0.9775967909465246, 0.977970392646196, 0.9774920620723548, 0.9587255882981881, 0.9702091510152363, 0.9762319835661275, 0.9787157621437532, 0.9685748490029831, 0.9687388928884523, 0.26510774639628465, 0.2604733106114472, 0.16445823889610145, 0.22856372521833168, 0.13516066216404488, 0.26867133423212863, 0.2730829497425382, 0.08761101496773449, 0.26018015958423923, 0.6307520529379385, 0.16973644057128912, 0.5303663334829235, 0.19209372380675382, 0.1985566314157413, 0.18648364538334017, 0.28856962480767834, 0.2066181062225675, 0.19936265507613937, 0.1473895403574681, 0.09476896710130855, 0.14608413409529641, 0.08734925612855027, 0.1199123210930666, 0.1441040439423441, 0.21543580721528988, 0.15799677766832243, 0.14157271293509344, 0.16473944055679257, 0.10515155306162582, 0.16110495147759685, 0.14801812886575172, 0.16772627001592066, 0.16041394336702275, 0.15882721892387508, 0.2953188584153611, 0.18008230870705866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018145476816719075, 9.999999999998899e-05, 9.999999999998899e-05, 0.00025558370418443666, 0.018039780462059785, 0.01104925927373357, 0.03901641522199062, 0.029536290053322922, 0.07205742260819847, 0.06292146149331168, 0.010392078710018682, 0.030305256142834303, 0.05517588483490421, 0.045387600527003635, 0.03447671712446465, 0.021585443835648088, 0.042176594477955076, 0.03030722158677912, 0.08966274509782923, 0.07034122041259139, 0.04949611888271499, 0.06609599337541006, 0.06551140095419994, 0.043376055558746685, 0.09651322840027055, 0.03508273309460985, 0.05602869452454173, 0.12809268280429553, 0.12275836514567895, 0.13197305900411616, 0.2164059822605202, 0.08388092620667686, 0.06527550741926025, 0.4221593819078724, 0.432391238931373, 0.46627611727687, 0.45162296304460925, 0.4456528261186451, 0.4030655934472547, 0.4875690113998993, 0.44893460353804004, 0.4608246049304938, 0.08170318671148669, 0.05816918992162168, 0.15272570908827765, 0.08522999066347803, 0.0715492154193329, 0.08935695828477563, 0.0987986414177443, 0.09021877560580638, 0.08067318950961111, 0.18804242368764224, 0.12884021576178073, 0.14001143186786835, 0.18060728437024387, 0.14727640744681192, 0.1913380895901423, 0.14910042270297508, 0.13083768018173214, 0.13828799754554388, 0.36169728449314476, 0.22043686698054554, 0.36813565599350784, 0.2723773074244267, 0.30705725778681714, 0.34570816724022224, 0.3645569149657666, 0.4003223860284061, 0.39428209893083654, 0.21402998781309812, 0.21548295827511843, 0.16942289071231897, 0.1817466964388551, 0.2415795281936517, 0.23246648730278552, 0.21149147169208593, 0.26772824525087313, 0.21293792573122916, 0.1803486363030966, 0.19128555088866195, 0.1758409303130033, 0.17164519466127914, 0.18513973524744132, 0.18554190619454802, 0.18730552551912927, 0.20053013718841617, 0.19606481669350573, 0.17982760692598554, 0.18471190079258115, 0.18285188425246168, 0.1924108630665261, 0.1932897974206762, 0.18829902333297555, 0.18576467387698603, 0.18791870415900636, 0.1857452204263942, 0.6658111931162892, 0.167810239825104, 0.15237137435605874, 0.6483258240878356, 0.19738291400792063, 0.16288937772579648, 0.6660790856353929, 0.1474113171813093, 0.20158267652771378, 0.4629580441642499, 0.2036083539603103, 0.14770706865392425, 0.3187702553624686, 0.1642674198659011, 0.17547478489288593, 0.2036198184883995, 0.20491245909023592, 0.1513404701720863, 0.1750412612718204, 0.1871155103947787, 0.17488906836419105, 0.1804947214962167, 0.18036453599431335, 0.18372155901508036, 0.20123166085330035, 0.17532521426942949, 0.16712949988904824, 0.07514471208504969, 0.07327956625065402, 0.072833587409728, 0.07864818127940176, 0.06284315462357914, 0.07343714832944026, 0.06511473849232774, 0.06974853249821167, 0.07243860484042774]}, "mutation_prompt": null}
{"id": "d0527b0b-31b7-49c1-9443-41c9ff778e9c", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            # Introduce Lévy flight for random exploration\n            if np.random.rand() < 0.1:\n                step = self.levy_flight(self.dim)\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE", "description": "A refined PSO-DE hybrid introducing Lévy flights for enhanced exploration and dynamic population sizing for improved computational efficiency.", "configspace": "", "generation": 2, "fitness": 0.2372157771103891, "feedback": "The algorithm Enhanced_PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "9789edac-a476-44a5-b949-04cc4e4995e1", "metadata": {"aucs": [0.6296381976602612, 0.6605192154714341, 0.6176411068779923, 0.668587312690246, 0.6524521197888595, 0.6329490089339946, 0.6519107602928034, 0.624405500119788, 0.6395725322281189, 0.05706566527091217, 0.3290926238703974, 9.999999999998899e-05, 0.3473763384408167, 0.2742494217235204, 0.28600538616136917, 0.02075437342668396, 0.27819673688760926, 0.3263367665601995, 0.2917723050952201, 0.13524008619076977, 0.33752102961996766, 0.12236947126433917, 0.084274692837361, 0.2826367025027081, 0.11687179573245554, 0.14018586646085773, 0.09156799076002642, 0.11203346721171858, 0.07069403516992245, 0.10584945417948333, 0.07860455079942019, 0.09848903504637219, 0.09814886868748929, 0.09757529367285767, 0.11575215895891466, 0.13314880769994453, 0.9807589941231246, 0.9759340294375769, 0.9759767923477052, 0.9589673158290016, 0.9677163386872574, 0.9676106871738429, 0.9775100888900312, 0.9680692187710892, 0.9667323806639339, 0.35846960453234533, 0.3827805651177322, 0.3487033188422123, 0.33083952405670236, 0.1485217937613421, 0.36183858916364, 0.12547583629977432, 0.11297751339379669, 0.3470711720489946, 0.1988382468270874, 0.20983699258752253, 0.5408968417781546, 0.1984232923531597, 0.23608331565471596, 0.18603691152416135, 0.32890318250072836, 0.18564616081279284, 0.27295944762411983, 0.15995232715510066, 0.07724693113546433, 0.09830378416857888, 0.0983017273905542, 0.1615214482355879, 0.10885919208224293, 0.16169238842168976, 0.08539731608758816, 0.14189148478512903, 0.16440043390713832, 0.0686068238167179, 0.1532855539585416, 0.16905315336708104, 0.17882643250783947, 0.16241218971723848, 0.17324005179482194, 0.13392248611911128, 0.19130160675850927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031595352524834586, 9.999999999998899e-05, 9.999999999998899e-05, 0.0058005187732633745, 9.999999999998899e-05, 9.999999999998899e-05, 0.02629814478555459, 0.05639104595898603, 0.06111897992661941, 0.07142786618798724, 0.025790100762656976, 0.020756206257286247, 0.05140829877991204, 0.06406859822130684, 0.05401364136468001, 0.06805274252653093, 0.05885595214167283, 0.028878515454971554, 0.047637434397035605, 0.046923260376825926, 0.04507580649628107, 0.0635080839634502, 0.18797857065200907, 0.05868531164624036, 0.032563672035879065, 0.03599885563396943, 0.036798665108876194, 0.12566215204518028, 0.16571923500391805, 0.09911966184743504, 0.051792905259612554, 0.07090682921335878, 0.06767638318691338, 0.46917967293669116, 0.4598866297234675, 0.45602037502312165, 0.4589158102324753, 0.4800869861042433, 0.45469935210028767, 0.4553118242895986, 0.4398503376757873, 0.4498773492081869, 0.06722792975858338, 0.10358091099350308, 0.10101612839113605, 0.33301653898814565, 0.1019108230984741, 0.10543292508625346, 0.10473893372721543, 0.10126587012773558, 0.10544508629444849, 0.15272107959733117, 0.17905699078650394, 0.20968504024800239, 0.1890866912577821, 0.1390985608076497, 0.15166847779440706, 0.19144682503308108, 0.14482433400961925, 0.18411961071310368, 0.20412392696131754, 0.2232307525494035, 0.3725133554204697, 0.2861901553620285, 0.3153040964516973, 0.26092334617881774, 0.3779430037044035, 0.36779413658143, 0.3395749873889985, 0.25931277497763094, 0.18450442110318854, 0.20956982591524698, 0.16946870710180428, 0.24256044589933168, 0.23527358900921724, 0.23208924446083445, 0.24674595286546308, 0.21814463911385829, 0.17676778831136308, 0.14355327754129243, 0.19437390122648313, 0.18499446148443843, 0.19853944268082824, 0.19548411753352335, 0.1989391586211504, 0.17450371166295642, 0.18720487584739098, 0.18333387192623807, 0.18830505483325455, 0.1843687602807108, 0.21661350433846405, 0.18193383774324734, 0.20321863390265849, 0.1816903499644439, 0.18514480990324866, 0.20524098246653844, 0.6963682388916108, 0.16605011235947453, 0.14296112308752584, 0.701955794994013, 0.19693794422662836, 0.549950250178092, 0.16839704948838152, 0.6572128729740685, 0.6609502351185756, 0.31461638350177323, 0.20405810091191934, 0.19409070178021104, 0.27065831522808637, 0.2906263610475971, 0.14426266156327294, 0.20870612264896038, 0.1916653653698387, 0.15175044436558804, 0.18135820110994194, 0.1927446173889964, 0.18376090291667946, 0.18830063919165474, 0.1846625412954609, 0.18877979690732904, 0.19312264175634086, 0.1786434744002734, 0.17451444642468306, 0.06994586185933316, 0.06717241232701532, 0.07942360404065252, 0.07352679602343704, 0.07908959340249022, 0.07225925855905424, 0.08599515510998468, 0.07028275477840962, 0.07257313025692169]}, "mutation_prompt": null}
{"id": "b32a0dde-3f05-47df-8ca1-583103367003", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.95  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE", "description": "An enhanced PSO-DE algorithm integrating adaptive inertia weight, fitness-based mutation, and population adaptation for robust optimization.", "configspace": "", "generation": 3, "fitness": 0.27236488970583567, "feedback": "The algorithm Enhanced_PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "d0527b0b-31b7-49c1-9443-41c9ff778e9c", "metadata": {"aucs": [0.8243940719311202, 0.7884974582008775, 0.7969516177331215, 0.7836241781547899, 0.7808683276370069, 0.7847201220752467, 0.8029891541879637, 0.7819834286787763, 0.8233471686109626, 0.6042458367320844, 0.5656160783032151, 0.03631455713588205, 0.6363609534211556, 0.4930205472757573, 0.5615446982878773, 0.19080543566265107, 0.40502806383675893, 0.34624608170072557, 0.14150749360344161, 0.10596145315997108, 0.11871583393688456, 0.13150649299273687, 0.0658040302324231, 0.1104558513858136, 0.1254560578530587, 0.12110723898708242, 0.13893203169193435, 0.14394974685138473, 0.11391155196587266, 0.10568294858047944, 0.12102936879467308, 0.12488824753010652, 0.10973806500491978, 0.11076044600116508, 0.10897886955191571, 0.1376350953662948, 0.9835623778636662, 0.9775738602722822, 0.9782476869306792, 0.9616986541036527, 0.9686715109225511, 0.9610890951038098, 0.9775362906837498, 0.9788783288495457, 0.9754131954116587, 0.46893946214064763, 0.38077463956638735, 0.5487907835007564, 0.4984163101319363, 0.48068644682742356, 0.5514022433354955, 0.35437782122590644, 0.330844932802813, 0.42822134689000857, 0.29066127562284116, 0.23720584340334938, 0.21899056123494132, 0.19224321536142952, 0.18965250246884557, 0.19015472827309532, 0.6051122674344531, 0.16494096092343302, 0.22342211905914988, 0.16438650233667762, 0.09302986737554197, 0.15882097199177603, 0.09754574778519232, 0.1685275401775571, 0.3205394061437935, 0.17151616485035992, 0.16891728044921006, 0.15980309017108707, 0.21976998023442662, 0.16487990508365147, 0.12317600154997888, 0.17320137375478994, 0.11874026734657495, 0.14299635789627463, 0.1184767897530945, 0.19866794489533435, 0.21076996117508184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02477622932784418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0728772994313962, 0.0630272813053282, 0.060385015334478376, 0.0693837014358849, 0.030331014047589977, 0.07375352177648364, 0.06472952498482887, 0.07597439335624345, 0.04847273134132213, 0.03127084996010676, 0.03201508186271662, 0.08350461854598656, 0.07200661183205159, 0.16257857366452844, 0.06980474957394378, 0.08906591808774589, 0.09074558263456234, 0.06443748737499388, 0.15908620811655272, 0.0504363082900785, 0.18285524940835485, 0.14500941202997386, 0.03570420629294657, 0.19205034252353215, 0.1255196424296613, 0.20972048184978498, 0.07640202327071566, 0.49718740664412586, 0.5143072175550512, 0.5445359644254922, 0.5467467643180158, 0.5363996110460115, 0.5033821374882956, 0.5752802275155929, 0.504974389763351, 0.5531268207054016, 0.07941583842272215, 0.10963389305861493, 0.08926764820702049, 0.09661496127392688, 0.10469656710569974, 0.10352458884876214, 0.10090870988289591, 0.10060880031625807, 0.09874881296759608, 0.13728940467982742, 0.190232067518873, 0.2533109365417979, 0.1724534093248401, 0.24132901592509548, 0.24369247855415677, 0.22235297530113363, 0.17628874847840348, 0.1579066567320051, 0.29230772550791795, 0.1939319971662593, 0.3959147701670461, 0.37828829395371044, 0.293973532027514, 0.4094235144648296, 0.36927994701914735, 0.4420116035022177, 0.34919333113968765, 0.20694120263239768, 0.3055906927557833, 0.23868090328031233, 0.17497093446541345, 0.1864684477573444, 0.23651045867762444, 0.2859112185238242, 0.28610956323959524, 0.22879256254351954, 0.2048414027298554, 0.20111549238435877, 0.20137946782833482, 0.23068310019312888, 0.1999294769335247, 0.22767202063504666, 0.2077046903539167, 0.19052663438903772, 0.1781786024173243, 0.48347344423694816, 0.1787926324803346, 0.19673365418416966, 0.6594238784605367, 0.19021379878386957, 0.1833061385546706, 0.18901361215292223, 0.1987876524292057, 0.21008769533021743, 0.7951396894062613, 0.16332914284024558, 0.15351834664112662, 0.8096094673869793, 0.19821581321262982, 0.168725406108716, 0.14061287699229963, 0.15728982564848049, 0.20988501033921947, 0.5060775383757075, 0.20553379210599154, 0.7085713376666811, 0.14912577996338205, 0.16652904638258237, 0.1480771600479016, 0.2033215319600047, 0.6307781598141184, 0.1497465509392517, 0.18634606572435308, 0.1811255287341914, 0.18241295739615193, 0.19441715059963738, 0.17909890710155674, 0.17267453198688454, 0.16882831480191984, 0.18910303408174878, 0.18350134452033717, 0.1012408460853963, 0.08259868781283297, 0.0727566180080883, 0.08846590393287823, 0.09178370123269486, 0.09180410858128585, 0.07535330073595414, 0.09390319916264578, 0.08035907776717666]}, "mutation_prompt": null}
{"id": "fab345c3-08d3-4fed-944b-b18d958945a7", "solution": "import numpy as np\n\nclass Improved_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def adaptive_clustering(self):\n        # New clustering mechanism based on Euclidean distance\n        distance_matrix = np.sqrt(np.sum((self.population[:, np.newaxis] - self.population) ** 2, axis=2))\n        np.fill_diagonal(distance_matrix, np.inf)\n        cluster_threshold = np.percentile(distance_matrix, 25)\n        clusters = (distance_matrix < cluster_threshold).sum(axis=1)\n        return clusters\n\n    def stochastic_perturbation(self, vector):\n        # New stochastic perturbation for enhanced exploration\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(vector + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            clusters = self.adaptive_clustering()\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_vector = self.stochastic_perturbation(trial_vector)\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Improved_PSO_ADE", "description": "An improved hybrid PSO-DE algorithm incorporating a multi-population strategy with adaptive clustering and a new stochastic perturbation mechanism for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.2674113689944502, "feedback": "The algorithm Improved_PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b32a0dde-3f05-47df-8ca1-583103367003", "metadata": {"aucs": [0.7911190320852753, 0.8052771010300361, 0.808855078531002, 0.8127469820535868, 0.7981207184636416, 0.8112621647555984, 0.8078996453306766, 0.7951287229591133, 0.7952767568079555, 0.3366688314076488, 0.04647587333684655, 0.07206363799826099, 0.33849551423084523, 0.0776242162416918, 0.5248271152621069, 0.2703032884436253, 0.3724479083222897, 0.03158431671259443, 0.116328004754649, 0.15448712720797453, 0.13710092931192097, 0.1473115785120488, 0.10757377069055585, 0.13383315371125137, 0.111399134639938, 0.11483993664824832, 0.12839031869082662, 0.1463175455317034, 0.08774052471139915, 0.11023247006021197, 0.12363132167739566, 0.11498465186376816, 0.0990974083934194, 0.10746157574594872, 0.11234290759447085, 0.09700066091094284, 0.9737919167305435, 0.9659304098804821, 0.9694892140858553, 0.9569776816476221, 0.9660683452118178, 0.9565916903139198, 0.976908340051026, 0.9740998478724479, 0.9593804312911003, 0.49472672703596476, 0.46910624600132256, 0.44521255166044216, 0.42878951844556856, 0.33336249445010835, 0.3883667183701234, 0.3328110048202021, 0.4606773111243959, 0.4105041634072297, 0.21907400575014657, 0.2211525033664643, 0.2182217461313114, 0.21396291541334822, 0.20804356114462585, 0.47873493706838266, 0.35325145584243245, 0.21686930689558848, 0.7191430885971596, 0.19583822355647917, 0.08981781738222616, 0.09737932139973038, 0.09712678737832425, 0.12775346250904762, 0.1636340592795712, 0.11570996937008526, 0.17099688541889102, 0.1542919817590096, 0.12287798934692984, 0.18275960781930012, 0.1524735665940289, 0.16441164178963186, 0.19803775447382632, 0.17532050904105512, 0.16922110755323938, 0.16012407464293377, 0.21031937161280978, 0.0021666025092293983, 9.999999999998899e-05, 9.999999999998899e-05, 0.016558533587630708, 9.999999999998899e-05, 0.009527581142589558, 0.0016119470970572536, 9.999999999998899e-05, 0.06956945203069553, 0.10589393903292899, 0.06137303691934071, 0.08300276696132436, 0.0781067549186315, 0.017055146472889304, 0.02623982542582648, 0.13779336955402854, 0.09798577461693858, 0.028664452997455236, 0.03195112393145305, 0.06946663454087554, 0.031173305927383765, 0.08645381127886742, 0.06849573738427095, 0.08316432723672573, 0.09295731869764734, 0.20531114518407234, 0.06455517179326276, 0.09105117606059832, 0.04232286165906518, 0.07310141471742149, 0.0967529609953448, 0.07444039095792032, 0.10777022919398604, 0.05974333998317494, 0.16625849535595916, 0.07835273482347349, 0.4594140780923107, 0.4639127125765531, 0.511108300681482, 0.48303291006243965, 0.505876170679967, 0.4668086208620681, 0.5364255276395922, 0.5462498479522846, 0.49443399829716617, 0.10367903880565432, 0.10207929391713899, 0.10109294815530268, 0.12530505046660623, 0.14221512823680937, 0.11310519251746243, 0.13973780448089712, 0.15130970015423995, 0.11549818730258321, 0.18382385302305349, 0.16056507600370784, 0.18044985784919731, 0.18400257894502892, 0.1409234506878858, 0.309225971870003, 0.21614235149236083, 0.16126038015981337, 0.1801056267409149, 0.29635803529659566, 0.2906998595685476, 0.42283555986709187, 0.3835333859667005, 0.289655413160283, 0.3672998860243475, 0.48546841485551673, 0.32757574853769733, 0.2758361663578466, 0.2611390274232013, 0.20005689839803997, 0.22945217621709268, 0.2158762745187518, 0.19405032809233735, 0.22740476436781243, 0.2842664424697062, 0.22818395086611287, 0.21407225208664282, 0.22527796237499365, 0.19482043460838194, 0.17979766425838972, 0.19230206042375197, 0.20637823524211985, 0.19908269027846992, 0.2113096674452689, 0.2153385687670173, 0.19356439319461005, 0.20472062900692356, 0.2354294734886918, 0.2326207823347045, 0.18354693088757046, 0.21151113640892427, 0.20021087109461055, 0.1760493284071778, 0.19757909437661003, 0.1972829533327236, 0.8796870386664323, 0.18395665983437404, 0.152252178543545, 0.8323207496366712, 0.19893547590878602, 0.19358555684705214, 0.14048958406091827, 0.8074004777554352, 0.7945794226061209, 0.43436691440487896, 0.2093175134844072, 0.6210628600452681, 0.36915166621131223, 0.4343617376606512, 0.1509180270306164, 0.41880669951604166, 0.20783218741947596, 0.44930944719904686, 0.18029187754922682, 0.1742512921828533, 0.18729287450413556, 0.1748611118324872, 0.17843660927413896, 0.18315522571443044, 0.184839608612003, 0.20799142278977356, 0.18052963410782064, 0.07851662442296015, 0.08369475612016974, 0.07985665867544633, 0.08256219439731816, 0.08975131512565038, 0.06944216706645456, 0.09089690016504137, 0.08279114742224503, 0.08012541719599153]}, "mutation_prompt": null}
{"id": "53b2d941-28c1-49c9-853a-401b7dd98ecb", "solution": "import numpy as np\n\nclass Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.random_search_probability = 0.05\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= 0.98  # Fine-tuned damping for inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if np.random.rand() < self.random_search_probability:\n                self.population += self.levy_flight((self.pop_size, self.dim))  # Random search perturbations\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm incorporating dynamic population resizing, adaptive learning rates, and random search perturbations for enhanced exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.2515292087489683, "feedback": "The algorithm Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "b32a0dde-3f05-47df-8ca1-583103367003", "metadata": {"aucs": [0.7428994676316265, 0.6994045711492942, 0.7479497537301576, 0.6220908834327594, 0.705148713133037, 0.7335787675679146, 0.7311969544035866, 0.706544004789728, 0.7283067963495922, 0.520640544539428, 0.40805802913800204, 0.11209118814068175, 0.5171654504846976, 0.32309284381758685, 0.4483901812996701, 0.41175090699900463, 0.39522373054129467, 0.12146490147978584, 0.14124829482734602, 0.18907149881416352, 0.13470578684101797, 0.11588409363932373, 0.13759986005520075, 0.12302711570287861, 0.10826846709103521, 0.10363510474319937, 0.12521663520429027, 0.0991214731024962, 0.11410483975104557, 0.09907458028281713, 0.11217376895556463, 0.1345324501539399, 0.09658523422793441, 0.11060350741131697, 0.11180449116485447, 0.10127722555800922, 0.9835567259999137, 0.9774315066514634, 0.9782622648754106, 0.9679270227738268, 0.9687288906014602, 0.9683378691669794, 0.9775863453008339, 0.9790508320028788, 0.9672847659527755, 0.39267566316857305, 0.35071513271997723, 0.32353333194969447, 0.18595583732529064, 0.2968192300227154, 0.19665237655321266, 0.23534994888366845, 0.34727585531652316, 0.37073857469172133, 0.16838173328405814, 0.17079267648606278, 0.21159151581751223, 0.19061422068436318, 0.623485787389078, 0.1953128719642484, 0.12391778383163399, 0.12256386849805656, 0.40886835080697703, 0.14286839158903641, 0.29490975028177113, 0.1698291781386957, 0.1146888956341321, 0.1209404567913982, 0.10954693067142884, 0.16968099213999543, 0.16998043345314817, 0.17746768002096036, 0.12024749161825599, 0.1293732389034984, 0.19704675636765534, 0.1908780929169227, 0.13317539640953202, 0.1885124177891534, 0.19925902048111122, 0.1486843923477119, 0.22201884829986795, 0.0023063432640295645, 9.999999999998899e-05, 9.999999999998899e-05, 0.011418557240943317, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023906521928316327, 9.999999999998899e-05, 0.0357229263980946, 0.09104548484888542, 0.08352769142630545, 0.038965678381288504, 0.08457527149699418, 0.02543206653087815, 0.0622789999689376, 0.03761237181219712, 0.054377735580984354, 0.03289116376773782, 0.02673706566610856, 0.02512669037663129, 0.1611843269935953, 0.06187870025974285, 0.07515844592092957, 0.06937339509384366, 0.07308988421504747, 0.07070062717763848, 0.052526636587863496, 0.1597168234900178, 0.037105022340638616, 0.08246762070278257, 0.07382232669221234, 0.19627897565347963, 0.27017651458818204, 0.05068725533396723, 0.14511688414100976, 0.07512711303965791, 0.46689646253296313, 0.49915852354676005, 0.47633335726609716, 0.49723787161338984, 0.4692215451398225, 0.4952849426871633, 0.5078834451323082, 0.4844762035434014, 0.512552392225312, 0.08289648327420296, 0.08009153572793515, 0.11877463187953341, 0.08914724215268777, 0.09136482951815383, 0.15076954255887776, 0.13200394595608522, 0.08686675355645135, 0.12376780619780225, 0.22975829617855326, 0.1444598224697884, 0.1718939284395654, 0.1317661025132063, 0.187135254815068, 0.13808545128967997, 0.1984048694235272, 0.2775016804995897, 0.21738676947710933, 0.33194986075326627, 0.227425684034249, 0.3758686474689139, 0.24095843932546301, 0.3072925282797091, 0.3878313864802957, 0.40704365757624283, 0.4145230275094135, 0.3999532418591113, 0.26875395046556483, 0.1596411435977234, 0.22895649311572475, 0.1710085875874966, 0.17623358364664277, 0.23657842439890353, 0.227777296377338, 0.23496231920125787, 0.2980415820034775, 0.19816677496875856, 0.15849387246806035, 0.19164513208370337, 0.1849089668394699, 0.2030145846151724, 0.2052358629695602, 0.19020735744722184, 0.19866703143416198, 0.19215628346290436, 0.19188717776216357, 0.22643584136592954, 0.1952318116013949, 0.20588925493137744, 0.5409758017162256, 0.224017035092265, 0.1867069571481489, 0.17350948879504124, 0.20290257587092608, 0.5488134486053275, 0.1652060592553526, 0.1526620909182166, 0.799820244598658, 0.19620408888698726, 0.1910969378325802, 0.1706014514462837, 0.158744222175765, 0.20874699130345853, 0.5221580716186147, 0.2067193284142127, 0.5143834264443168, 0.2297714890642264, 0.165906515266375, 0.150429637686615, 0.44582702385185236, 0.1256638198946588, 0.19996686931698882, 0.19353289275836882, 0.1832621194468208, 0.18468730725482363, 0.19626209547419216, 0.18203472407592936, 0.19928300848995872, 0.17401631961456054, 0.19099027848528238, 0.18435215564229435, 0.0888076668513722, 0.07289446509464537, 0.07366138045333215, 0.07379164791944715, 0.07327594947689087, 0.08554469791503216, 0.07481367250753623, 0.06663138876451136, 0.0690035351924273]}, "mutation_prompt": null}
{"id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.2877296079868134, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "b32a0dde-3f05-47df-8ca1-583103367003", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "8513380c-e81d-413e-af33-4683c1d24750", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.95  # Slightly increased damping for stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0  # Enhanced social impact\n        self.mutation_factor = 0.85  # Adjusted for better exploration\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.15  # Increased elite fraction for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def radial_local_search(self, size):\n        return np.random.uniform(-0.1, 0.1, size)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.20:  # Increased local search probability\n                step = self.radial_local_search((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Adaptive", "description": "Introduced a novel adaptive reduction and radial-based local search to accelerate convergence and maintain diversity within a 40% modification constraint.", "configspace": "", "generation": 7, "fitness": 0.23680933051791425, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7173842058678053, 0.6785001385169415, 0.741406892371699, 0.7292155146569012, 0.6847427387829574, 0.718114749607804, 0.7087476706021179, 0.67993239968275, 0.7272336274496068, 0.06476329568170835, 0.19817929014649893, 0.0505057166559012, 0.04218362619230753, 0.26805212136055434, 0.266410843712064, 0.004154000235002786, 0.015227192879537998, 0.03495038287158514, 0.14618453328856662, 0.11862253913684362, 0.1306213605513742, 0.0869027091380149, 0.10311207384901933, 0.06892761646070356, 0.1267626856727444, 0.1307534473526395, 0.1380246347002554, 0.1014283995891816, 0.10872775132174772, 0.08704678047955317, 0.1048840976044898, 0.09728850031078651, 0.10453695801193985, 0.11815491928697996, 0.12732019205564116, 0.10583831270328425, 0.9769995021797632, 0.9797597124889256, 0.985496110428759, 0.9853185818282778, 0.9773615301691133, 0.974936580325194, 0.9782474797357492, 0.9796144873568168, 0.9852070298130745, 0.30516008404964545, 0.29022436962054976, 0.22544190228439998, 0.2702234754713183, 0.2637383230856961, 0.21489630480540312, 0.30959098928930007, 0.29822271179370907, 0.2991549207436319, 0.1664789688535162, 0.6606577308651312, 0.650240674761456, 0.2135733140792352, 0.2036737341301249, 0.20655964968484508, 0.11133691532915468, 0.1478282185420432, 0.2815865732107724, 0.1742610746919594, 0.10106939457169106, 0.08846461698644037, 0.11736592587935879, 0.1645522404001284, 0.1682179782584763, 0.19237468164656124, 0.11839614509993657, 0.1731512877518877, 0.12077495818368411, 0.10134638405446261, 0.16644900903631255, 0.171608048339287, 0.251018078092354, 0.22711873721774822, 0.1867147671287056, 0.0880883543552432, 0.2009782745258042, 9.999999999998899e-05, 9.999999999998899e-05, 0.024847587294740903, 0.03086963968044243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001681689535734776, 9.999999999998899e-05, 0.05620249520386422, 0.037518610406822694, 0.0629064228142503, 0.06527399650795995, 0.051292787872238454, 0.0002640174548863561, 0.04372346170952479, 0.06303897790417956, 0.04229679404142794, 0.04199183096111514, 0.06032635430465072, 0.055844718318433295, 0.06556157208626534, 0.08018113880424083, 0.2196065421111254, 0.08648683760792142, 0.1632258046987054, 0.08215442411476614, 0.05757017561068822, 0.03908898731320787, 0.06351021551034575, 0.04112161844554052, 0.13399616334187214, 0.022689947863445026, 0.052398853429554415, 0.15513453724472892, 0.07544374249145935, 0.48996493054498347, 0.47256477854488144, 0.46385495888634276, 0.4762435218006057, 0.4399177790096329, 0.47327352896126895, 0.4617227977127809, 0.4576139947116614, 0.4751462803507529, 0.07506392662606609, 0.06562724618211446, 0.07575935223347241, 0.1390478794672274, 0.12374909558114322, 0.10311024382218892, 0.08379525121753117, 0.06582287516005059, 0.12627796123811807, 0.18426942342643315, 0.22579491279779684, 0.1805482649534007, 0.28330138605994415, 0.26983995220252444, 0.18649977007925023, 0.19258102197344307, 0.20162826347856488, 0.19687839201224366, 0.30235701847193275, 0.3339386820917203, 0.32675092786183657, 0.3170794009511473, 0.24404139885445353, 0.37192442039548423, 0.33428049155834016, 0.3832683104392154, 0.37347354298341284, 0.11445671338174757, 0.18344804544604376, 0.23041964920789748, 0.15020825473662158, 0.15394449191019943, 0.24526867744279401, 0.22016696724710372, 0.25135393329677347, 0.25278152509862417, 0.19215184530990048, 0.16503293848553768, 0.2206921811654362, 0.1720510912951464, 0.17945919901402008, 0.20623190547103187, 0.18928868923502062, 0.1781688268122802, 0.19702552302163134, 0.23387896066610903, 0.21784696966608696, 0.24048101173195247, 0.215943873739328, 0.19655207306348643, 0.19666687024567486, 0.21610748800547952, 0.46669721709587453, 0.19517421693066905, 0.7776484215643372, 0.1582509808687248, 0.15243053488744607, 0.21940019324254578, 0.7502022933069424, 0.19107193541341272, 0.13965681328443347, 0.16802970314708676, 0.2025459543188325, 0.4189719970682185, 0.2060142503376039, 0.16190785966205568, 0.40952863783766813, 0.16287653564946325, 0.1638292905147244, 0.1963552259561273, 0.5020801788317688, 0.1047236332323187, 0.17930393047781001, 0.1757712037833562, 0.18512464515605598, 0.17556398871381118, 0.17785149892017293, 0.1952632759892775, 0.1813799048065986, 0.17616914217542867, 0.20866668763131546, 0.07239047989346759, 0.07003904591927568, 0.06283997596928725, 0.0692602301366223, 0.07329803348278163, 0.08355961851536109, 0.0916631022208727, 0.08378794042334226, 0.07967543254919551]}, "mutation_prompt": null}
{"id": "b66bb04f-1a13-4e18-bc68-69dd36ce0e8c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "68eac750-6862-400b-a3b4-39897d0e988d", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "344ea0ad-e72b-49ac-820c-de89980af5ce", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "c33db426-c304-4202-9926-15b59d5c9807", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "8e9ddd30-0e6a-48ba-bcfc-30c04f6293cd", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "2333fb4d-cd53-464c-ba7b-7eb1314ef6db", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "c23b7ac1-8277-4429-8730-41626193814a", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "9c3c44a0-0a9c-48aa-8222-659c77c9117c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "3450657a-02ca-4d67-bd6d-abd82c21173e", "solution": "import numpy as np\n\nclass Improved_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.temperature = 1.0  # Temperature for simulated annealing-like inertia adjustment\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8  # Slightly reduced for better exploitation\n        self.crossover_rate = 0.85\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            # Temperature-based inertia adjustment\n            self.inertia_weight = 0.5 + 0.4 * np.exp(-0.01 * self.evaluations / self.budget)\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))  # Slightly increased minimum population size\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.2:  # Increased probability of levy flight\n                step = self.levy_flight((self.pop_size, self.dim))  \n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 5) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n            # Elite re-clustering for adaptive mutation and diversity maintenance\n            if np.random.rand() < 0.1:  # Occasional re-clustering\n                cluster_size = int(0.2 * self.pop_size)\n                elite_cluster_indices = np.random.choice(elite_indices, cluster_size, replace=False)\n                self.population[elite_cluster_indices] += np.random.normal(0, 0.1, (cluster_size, self.dim))\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Improved_Hybrid_PSO_DE", "description": "An improved hybrid PSO-DE algorithm with temperature-based inertia adjustment, elite re-clustering, and adaptive mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {}, "mutation_prompt": null}
{"id": "3fa20742-7091-4bcf-ae45-f38df3dd8fbb", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "492e5b70-d241-4c9c-aaed-f95840a08797", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "071af8ea-5855-4a75-bc8b-6ca2e5d191fd", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.2  # Increased elite fraction for adaptive selection\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def chaotic_mapping(self, size):\n        # Logistic map for chaotic sequence\n        x = np.random.rand(size)\n        r = 4.0  # Chaotic parameter\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor * (1 - (self.evaluations / self.budget))  # Dynamic mutation\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n                self.population += self.chaotic_mapping(self.dim)  # Add chaos-induced diversity\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_V2", "description": "Introducing adaptive elite selection, chaos-induced diversity, and dynamic mutation for improved exploration and convergence.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Enhanced_Hybrid_PSO_DE_V2' object has no attribute 'levy_flight'\").", "error": "AttributeError(\"'Enhanced_Hybrid_PSO_DE_V2' object has no attribute 'levy_flight'\")", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {}, "mutation_prompt": null}
{"id": "6383b4b7-0c2e-4e91-be51-a6bfc84a7dfb", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.95  # Adjusted damping for smoother transition\n        self.cognitive_coeff = 2.0  # Increased cognitive influence\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8  # Reduced mutation factor for precision\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.2  # Increased elite fraction for exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.memory = []  # Added memory for reinitialization\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.velocities += 0.5 * (np.random.uniform(-1, 1, (self.pop_size, self.dim)))  # Quadratic velocity update\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n            \n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                if len(self.memory) > 0:\n                    memory_sample = np.random.choice(self.memory, stagnant_indices.sum())\n                    self.population[stagnant_indices] = memory_sample\n                else:\n                    self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n                self.memory.append(np.copy(self.global_best_position))  # Update memory with best position\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "An improved hybrid PSO-DE with adaptive population size, quadratic velocity update, and memory-based reinitialization for enhanced exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.17373132369319289, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.32303595442712196, 0.3064564035775126, 0.3147561200587068, 0.3186228961735046, 0.32641544704808767, 0.31081517077289555, 0.33989216791192534, 0.30574394809390026, 0.32509480488527875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10394026791366306, 0.08322966404153431, 0.07957512615685958, 0.0951156769970859, 0.0889543217511416, 0.07925612330358667, 0.0889609589428978, 0.08039608592797576, 0.0804520465015417, 0.07628235482690582, 0.07261454234781672, 0.06942705834854568, 0.07421529891467749, 0.0673534628010779, 0.06749575172130917, 0.07679505313131718, 0.06806810612868519, 0.07476924005761354, 0.9794435132988992, 0.9749347067045445, 0.9784507023524637, 0.9708030948132511, 0.9779489828766348, 0.9714205211508505, 0.9797072921563423, 0.9741255975682274, 0.9713895754389771, 0.1760806496284928, 0.17692473101040218, 0.15876551871029465, 0.19345285329549544, 0.17928283012391744, 0.18486864393783653, 0.1828498644181279, 0.2123252918615457, 0.18130996816863876, 0.2240733901690808, 0.2302534448940502, 0.21651933623732145, 0.2523738296651765, 0.2034414420536641, 0.21783664050154627, 0.21958020078318408, 0.21251960135599068, 0.21173455305460742, 0.0964192873682681, 0.06136477776381144, 0.09890425695141514, 0.05924994252929827, 0.1118964280660164, 0.09101889140341213, 0.09663472953803487, 0.0955360787825057, 0.1069044734035206, 0.10855959298903783, 0.10518941011311145, 0.09570661114511281, 0.11647228229778561, 0.09539793298672161, 0.11507787646793144, 0.10482258119741439, 0.03978248563162612, 0.09741800278368029, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04852879906386265, 0.03684225433701327, 0.06453923119668015, 0.05615087438848387, 0.04994207228080616, 0.04483924656280591, 0.06878094587452777, 0.04814890158810392, 0.05559126889531396, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04848945410751371, 0.03230871471585561, 0.04961930419339822, 0.059091446647625334, 0.03886280733663994, 0.06492968760902273, 0.0413012935118835, 0.07626799189746492, 0.05916216022620324, 0.3087356596370504, 0.35667474449023406, 0.2999109758698082, 0.3119640337002123, 0.3380170397272798, 0.33860424222221963, 0.3332610462252382, 0.3086385319422258, 0.33163865229602074, 0.08419263500036867, 0.08883239722214076, 0.07691059154409374, 0.0821334030712173, 0.08130963155058957, 0.08119443493675749, 0.08475574706428379, 0.07602888369822158, 0.06784493866142971, 0.13594280552565396, 0.1432809200801034, 0.13428669967182283, 0.12892646969314958, 0.1341628244512958, 0.15409815427887663, 0.17528833112213615, 0.12311303543125596, 0.15976419343989923, 0.23913512269393888, 0.23122259372167508, 0.2225501425519103, 0.22900962680032355, 0.18306969688533659, 0.2242278163404149, 0.22686734689775656, 0.25542772507524136, 0.2355570838776272, 0.18744427579099, 0.1719327475344311, 0.15336960277052458, 0.16073388619943685, 0.14963637531734586, 0.16845530151809385, 0.17066642850383174, 0.18408578961854827, 0.16959154813859456, 0.1728347235005242, 0.20304516542353246, 0.20029807564761437, 0.19923823087410075, 0.1849416464985687, 0.18181741555496478, 0.19464903033277126, 0.17100875592374354, 0.1788208297380839, 0.17736180978064442, 0.17159646706007314, 0.17187634056106726, 0.17347666683250795, 0.1941009115346174, 0.1669518189221395, 0.17133436965759352, 0.17225146968371663, 0.17917578308115667, 0.4374322267229116, 0.18426226867389128, 0.1502803087356449, 0.18901151193012034, 0.2998438055351996, 0.19168580435148708, 0.3709552947524287, 0.15968780127346616, 0.16558637838723622, 0.340639179987953, 0.197266621533165, 0.1663319712539869, 0.1904065974545598, 0.29895778885613855, 0.14693776713492934, 0.20190397917661507, 0.1940350302460203, 0.20391095479321641, 0.18260364294031983, 0.1819412005784541, 0.18091540339726275, 0.17695422754030954, 0.17801600551570695, 0.17526734325729698, 0.18461556124462608, 0.17544054571521994, 0.19579904025835526, 0.07901593901591808, 0.08660857613672701, 0.07035088922910271, 0.0687685594847417, 0.08355569166302668, 0.07672296275146195, 0.06555169010971262, 0.08385273220454714, 0.07097404764624393]}, "mutation_prompt": null}
{"id": "518093c9-febd-4ce6-aa75-0e1ca8178822", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "106e7c46-7d86-4c67-b85c-0fd7fb358045", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "ade423e9-d892-432a-8152-219bd45ae9cd", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "59acadfd-8779-45a1-b92a-10c1af3631f8", "solution": "import numpy as np\n\nclass Improved_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia_weight = 0.8  # Adjusted for better exploration-exploitation balance\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 2.0  # Increased cognitive component for faster convergence\n        self.social_coeff = 1.3\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7  # Lower crossover rate for better exploration\n        self.elite_fraction = 0.2  # Increased elite fraction for retaining best solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    self.velocities[i] *= 0.5  # Reduce velocity for elite particles\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.2:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Use median for more robust stagnation detection\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step", "name": "Improved_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm with adaptive elitism, modified control parameters, and a novel diversity preservation mechanism for robust convergence.", "configspace": "", "generation": 24, "fitness": 0.27557330457368495, "feedback": "The algorithm Improved_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7660045107554333, 0.8212578837463608, 0.7744363979839726, 0.7547646784087138, 0.8250761104435786, 0.7640315246761111, 0.7690920716219907, 0.8102179986706026, 0.7706203512006049, 0.365041501246267, 0.5364057777522856, 0.3714887667728757, 0.40299784652841364, 0.5058940943604997, 0.477921158242123, 0.3893321597514199, 0.4964362460992816, 0.44308065984615297, 0.13418391776584337, 0.13097772769460847, 0.13669183023702536, 0.1321964531074915, 0.16023910759975457, 0.13250398479357228, 0.11040298825499872, 0.1461833393875982, 0.11299831047057829, 0.12812502259799663, 0.11485168992558015, 0.10338897137426684, 0.13998813177024272, 0.10215347520638629, 0.1307233233958386, 0.1018058405929465, 0.13347713370512515, 0.14155919290232122, 0.9745633663378938, 0.9652997484671945, 0.9670621986171073, 0.9619683401668516, 0.9655321891400459, 0.9559145664737885, 0.9750306073348226, 0.9751025708645238, 0.9741179570219936, 0.41196969630107494, 0.4440128907719263, 0.454822535813699, 0.3565765483087099, 0.41308896976336207, 0.4276219030458568, 0.3892474802281891, 0.3557527210899537, 0.41656285297535, 0.5144189705448277, 0.22781707937318685, 0.35647847397605037, 0.19182625897787597, 0.2680897216096094, 0.21254971797287636, 0.5165115497756152, 0.20846646545382852, 0.23635945767818778, 0.329614038553834, 0.1199244025136148, 0.1778945051181443, 0.12650590752120827, 0.1278754399443196, 0.12301640024297977, 0.18573777524610535, 0.14934884168322915, 0.2034339201833123, 0.1219510931022274, 0.11008114957942161, 0.1375684885947096, 0.15651088091489962, 0.17293304567902412, 0.16190907958774425, 0.19203898332100444, 0.14627339312693444, 0.1623829284903593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040277516676142655, 9.999999999998899e-05, 0.03973616692566884, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029729712859639656, 0.11614251691552147, 0.07597754123519584, 0.06769047243339321, 0.0719610924547811, 0.07560598716178224, 0.005947800702506667, 0.03792841522921575, 0.14030912783691218, 0.07685232249637464, 0.10983013728376878, 0.031571761723511504, 0.1813759988990028, 0.1273703927316845, 0.10939805405593817, 0.08289329174329774, 0.087368147033555, 0.09548305336783247, 0.21373754392007305, 0.1967093663698115, 0.07975779321765508, 0.14311196771841173, 0.008457613931953656, 0.14742844233761976, 0.05855276573222179, 0.05438644200853726, 0.21123724374231045, 0.08941965074444147, 0.5242853045622677, 0.47239952779677463, 0.523328467865867, 0.5257605711605823, 0.48963784341914074, 0.5547848372669413, 0.5717560268238371, 0.5010068284567557, 0.524422411068467, 0.14419028775162768, 0.13153162798065055, 0.07505531221377837, 0.09447634809605021, 0.13515044840183676, 0.10475399544519637, 0.08502073883169181, 0.12387551413274744, 0.10831504734104436, 0.16348219059756208, 0.16947384433619195, 0.18624847406428058, 0.1935436817727837, 0.17887769993433178, 0.20280596048945176, 0.1562963819441746, 0.1416924203884914, 0.19380586666316046, 0.2984852965123792, 0.345602910621744, 0.3399626254599877, 0.2821985384170661, 0.334921371431932, 0.3867849604475928, 0.407845347447216, 0.40443113170535683, 0.2776662148253951, 0.21955938938727082, 0.18953334844416336, 0.24348465864290625, 0.26119906190094067, 0.22929858103430356, 0.1837853337749692, 0.22294537378903445, 0.24901009915029348, 0.16841541813243166, 0.1960294683419005, 0.206086779815153, 0.16944297003888475, 0.20477414862475518, 0.201465444164445, 0.1816363590657899, 0.2115629765328143, 0.2699661862050978, 0.22645636209470554, 0.21658917361541896, 0.19838721306179385, 0.19446876801361246, 0.5249995131342418, 0.22860349163650995, 0.22086533804840625, 0.2040925360806134, 0.20491069272719398, 0.21838038684542893, 0.765863494445288, 0.1861138168426546, 0.18527789804798978, 0.8944986550991649, 0.19912106765487692, 0.19790914446650532, 0.1428474332306554, 0.19290510211378675, 0.8506680071713765, 0.46056964808151224, 0.2098019441215867, 0.1670022628175719, 0.6495081933861884, 0.16818024901927653, 0.15359691906789108, 0.20205295949468116, 0.6188257952878471, 0.3808068260895441, 0.1898351455751376, 0.20073694988279078, 0.18065752853789452, 0.17945070851345335, 0.19232248283581144, 0.17396950951550882, 0.19214684361873047, 0.1872728331769291, 0.19017264235632925, 0.0866104102067411, 0.06970980504531454, 0.07551692709717406, 0.07679039380513242, 0.09044078987374049, 0.07590674461838753, 0.07341517786488161, 0.08177018633610456, 0.07957704135717436]}, "mutation_prompt": null}
{"id": "d53f2ee3-1264-4693-95ed-e1a1c1bc5748", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "223899ba-fd72-4be9-bea3-63b7444f5d8d", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia_weight = 0.8  # Lowered initial inertia weight for better exploration\n        self.inertia_damping = 0.95  # More gradual damping\n        self.cognitive_coeff = 2.0  # Increased for faster personal learning\n        self.social_coeff = 1.3  # Reduced for smoother convergence\n        self.mutation_factor = 0.7  # Lowered to enhance stability\n        self.crossover_rate = 0.7  # Reduced crossover for exploration\n        self.elite_fraction = 0.15  # Increased elite fraction for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        stagnation_counter = 0\n        last_global_best_score = np.inf\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            if self.global_best_score == last_global_best_score:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                last_global_best_score = self.global_best_score\n\n            if stagnation_counter > 10:\n                # Reinitialize part of the population when stagnant\n                reinit_size = int(0.3 * self.pop_size)\n                indices = np.random.choice(self.pop_size, reinit_size, replace=False)\n                self.population[indices] = np.random.uniform(self.lower_bound, self.upper_bound, (reinit_size, self.dim))\n                stagnation_counter = 0\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if np.random.rand() < 0.2:  # Increased frequency of Levy flights\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE", "description": "A bio-inspired hybrid PSO-DE algorithm with enhanced adaptability through multi-phase learning, adaptive parameter control, and elite re-initialization to tackle complex optimization landscapes efficiently.", "configspace": "", "generation": 26, "fitness": 0.275813826314312, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7943550322756578, 0.7955925358651497, 0.7949561415316984, 0.803007879258077, 0.7950372522164739, 0.8031865956779407, 0.7588578223441744, 0.8013265341541086, 0.8113550979020988, 0.3520850828256361, 0.5197329304971068, 0.37765231478360883, 0.314743877535827, 0.4964585572994008, 0.3366462940770897, 0.36552561744625445, 0.4272821979789806, 0.582881653488686, 0.11408833499994764, 0.15034375645709463, 0.13679681019039547, 0.15634708346402748, 0.1195800608520553, 0.15279351476669456, 0.10603752920666998, 0.14115432739511302, 0.12524524119276925, 0.12436421571826795, 0.12678767496693544, 0.1266851348325797, 0.1154996448849257, 0.09872436771780957, 0.14214369309470254, 0.12293057872146074, 0.30943790490880585, 0.10371266594299655, 0.9741062853574401, 0.9644775715738648, 0.9725230929386208, 0.9719823206409792, 0.9634332679835685, 0.9460144863139869, 0.9761871335772496, 0.9801046869424506, 0.9655356523456404, 0.3913354349895136, 0.3315937854601424, 0.4339412020940412, 0.3568269006602276, 0.34707901046969936, 0.19090045156677093, 0.2944439671901371, 0.3664579443346111, 0.34927792969429516, 0.6963415225792917, 0.22668295598897048, 0.5989680291351605, 0.20745857219975983, 0.3601765544331309, 0.8068368650992763, 0.7620057907840084, 0.22671618611150068, 0.35463868586344605, 0.1885555869981883, 0.08876854721042182, 0.15959847252234727, 0.12195425727524967, 0.11812272211821295, 0.12076141837266663, 0.18349267702726912, 0.21845363633138826, 0.14223474208610076, 0.16255009544068344, 0.1097391600776133, 0.2786101148515735, 0.1576385264863429, 0.15546274965489415, 0.144759021886819, 0.24567949985073845, 0.1820195711862731, 0.16913146004142288, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041021713898792944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001240307549534525, 0.06934399633153321, 0.05526415932482365, 0.06652348713614864, 0.0793252613206783, 0.045611752912978365, 0.09057715461960214, 0.026232655006335537, 0.08967228446275399, 0.043787850854575705, 0.06650610742513241, 0.03130586461579665, 0.12952055768323711, 0.12838530814533622, 0.09895851415740942, 0.08294115222285436, 0.08670282995442014, 0.13196927165193006, 0.13611953713835623, 0.1163931569998855, 0.042046455490361234, 0.12470528173814288, 0.10186392795873456, 0.050146527291656806, 0.07922984402096589, 0.169714194091363, 0.052883117571285165, 0.10679179739865252, 0.5595916538323397, 0.49300121388735985, 0.5126249740868043, 0.49385185197220915, 0.4881265740933374, 0.49470478761401515, 0.49231640543110833, 0.5268892890912169, 0.6048187646506242, 0.15140541847763322, 0.11245589753110563, 0.12981975851428817, 0.13861819298173728, 0.08631740307426683, 0.13718203522906702, 0.15982775622703826, 0.11749179824683309, 0.08311356125636926, 0.16291060941174706, 0.3154163671804223, 0.1925638817120784, 0.15652383242952872, 0.20112940236131416, 0.1502283591482545, 0.20122229387419766, 0.16702509635028873, 0.1737194844600728, 0.3081329363381584, 0.2740635187802276, 0.4518694035005699, 0.23793672685028666, 0.3770987744688007, 0.2643094214990386, 0.4068796284967653, 0.3225350456303824, 0.4494761291348265, 0.21559508689230733, 0.16329822464431032, 0.26464967716693066, 0.2439138056422644, 0.2190869003081639, 0.2800244147977192, 0.25645182819267043, 0.2994780818381346, 0.18918034988344057, 0.19920991250166697, 0.1967209942496867, 0.20287835918505193, 0.2025974396318838, 0.18165226621042474, 0.22436547402314788, 0.1967995129796577, 0.20794431903804, 0.19411818928550506, 0.18316652113202514, 0.1925626174343421, 0.18408410369619, 0.21887127016641694, 0.20100815394315263, 0.5458046914799652, 0.2333221175616388, 0.2091534529638951, 0.2279767115484831, 0.7830074867941546, 0.1853194844045255, 0.14799672476352266, 0.8238495697704449, 0.7511318476943691, 0.1966161165573319, 0.14080699140848552, 0.1979060855546272, 0.2086939802759331, 0.43428190040716774, 0.16548930919163718, 0.18315445787975282, 0.35727033505669004, 0.16706117804220644, 0.1500547984547116, 0.10461392363923117, 0.12513334766149642, 0.5488065315192889, 0.1880929496489735, 0.20675004123277663, 0.1903000185367294, 0.17432929571957612, 0.1902070185782163, 0.17111606474091245, 0.2015910384129589, 0.18050556809286877, 0.19251104792981477, 0.06645667287926538, 0.08260601549677826, 0.08266554143746585, 0.08263673930585969, 0.09266667286029262, 0.07044797810748005, 0.13160617987282786, 0.08196354291464447, 0.07660873363646192]}, "mutation_prompt": null}
{"id": "4e63555f-4cec-4735-8478-377d14a3a2c7", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "4aee76d1-5850-4131-8864-6ff1ecad19c1", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "4d73db16-056e-4c14-b424-2aa9a4805581", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "c7d44617-3d43-42f3-8a6a-21384f6fc983", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "17b8407f-bd98-478a-9dcd-b6de233bdf09", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for better exploration-exploitation\n        self.inertia_damping = 0.95  # Increase damping for stability\n        self.cognitive_coeff = 1.7  # Increased for better local search\n        self.social_coeff = 1.7  # Increased for better global search\n        self.mutation_factor = 0.8  # Lowered for different diversity\n        self.crossover_rate = 0.85  # Lowered to maintain some parent traits\n        self.elite_fraction = 0.15  # Increased to enhance elite selection\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.7):  # Adjusted beta to diversify flight distance\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.2:  # Increased chance for Levy flight\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Advanced reinitialization strategy\n            if self.evaluations % (self.budget // 8) == 0:  # More frequent checks for stagnation\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "Integrate a novel swarm-diversification strategy with adaptive elite selection to enhance exploration-exploitation balance in PSO-DE.", "configspace": "", "generation": 31, "fitness": 0.2646499233806907, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7892871566549111, 0.7700185950544632, 0.8224612802820399, 0.8228008480114981, 0.7615156867372554, 0.8246299934865493, 0.7972904636570575, 0.765591899915137, 0.8348947961325567, 0.4977706466469968, 0.40432167489952786, 0.4161569711061962, 0.28761202966512367, 0.40270035704826557, 0.3424686239208329, 0.44508343962155916, 0.43054692611153356, 0.4435338676250241, 0.10376139126046402, 0.13782873969335485, 0.13500811867001872, 0.1147384034453004, 0.1483712448824177, 0.1380075869347427, 0.06755695222941671, 0.15177619624976957, 0.16719896822853075, 0.1570551369305373, 0.11211055219688337, 0.12309216677091683, 0.12240781151671576, 0.1056479687232269, 0.09960588111970392, 0.1325465688283326, 0.1468575502182361, 0.11282620731703263, 0.9838772589487521, 0.9773292382795797, 0.971020823950113, 0.9832708785980782, 0.9775063541711764, 0.9628296535002657, 0.9774334373082812, 0.9761061670532838, 0.9779622684571196, 0.39670033315029274, 0.42122279530034257, 0.3331292772698058, 0.3347744958411333, 0.3744044116923817, 0.31053065429699556, 0.4292907049010388, 0.39931319239169194, 0.3780687703464526, 0.2283505714832974, 0.22018994672696968, 0.21603621139599727, 0.19235758803423497, 0.2025903173666489, 0.8283797024603796, 0.12496389635385008, 0.12510621247963571, 0.21966848856753973, 0.23111196671821788, 0.11918891761247397, 0.120578713450603, 0.10304305659144652, 0.16181464578962856, 0.16696149263490367, 0.11961364052696555, 0.18299576691853647, 0.1866751995905026, 0.15976055320110394, 0.14841409825310015, 0.16668548236162128, 0.3397263218786296, 0.3293431657621638, 0.18306888952154265, 0.20442128590243858, 0.09092256368013318, 0.22652876935426414, 9.999999999998899e-05, 0.004924719577872216, 0.008239871512620844, 0.022767700876826003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03461209468729409, 0.007467882375931767, 0.07118583358112807, 0.05279664310932275, 0.07790316068696557, 0.03964588828776394, 0.03875420031350163, 0.02016621167162591, 0.03402520168502576, 0.043697628121616816, 0.0957763658874985, 0.031517172623091394, 0.046387855984195814, 0.0432576826464407, 0.07247394378208283, 0.09559367594442081, 0.06992116914859015, 0.09023385289916364, 0.17747860969775775, 0.16885557084850678, 0.07528771099743103, 0.04339701734301726, 0.13989731289608043, 0.08957183036716976, 0.08500983141443719, 0.21813552888311982, 0.1555304035775933, 0.05517018594857004, 0.09684347832096196, 0.5077618623591561, 0.544177568546295, 0.527827320706272, 0.4918753837366475, 0.4879619313135076, 0.49973232693753045, 0.49529315117603556, 0.5414348927933589, 0.5248876640885548, 0.06624150662965789, 0.08035507236112227, 0.12988724920699768, 0.10094941088295895, 0.09990590056499915, 0.13585858299305942, 0.10988225238611138, 0.14842474646623138, 0.11015816111261778, 0.18983041485287844, 0.3615725282235801, 0.18367422493707564, 0.26314483150778123, 0.22423080316179944, 0.1459864393225926, 0.19155811681908186, 0.1787000531954931, 0.24367435375607793, 0.2694899934253694, 0.3038196034267112, 0.388844258548416, 0.20798720518384206, 0.3443739960733281, 0.2154375392407697, 0.3896429957759354, 0.24922467179352947, 0.4300542990000049, 0.21354477598765442, 0.231743288769793, 0.3015060571732183, 0.2097605056225359, 0.13102639723781118, 0.23250271395751843, 0.20984210335659914, 0.2641167642629795, 0.29143299120999566, 0.18966027831472954, 0.18428493288639358, 0.19473973011969414, 0.20908237857336476, 0.20451224943943713, 0.18258280235479174, 0.19015900639193917, 0.2016479685778496, 0.1945338926328153, 0.18574077188569005, 0.19816937729708606, 0.19475071624216378, 0.20553965816464392, 0.23421666734314994, 0.21245167953520117, 0.20951957226431672, 0.2122956494587921, 0.20398901387318225, 0.8625194624145723, 0.16584662962308117, 0.15321146448473555, 0.853599707757146, 0.19913770236229744, 0.1648766533372622, 0.17143476337806896, 0.15772288953425684, 0.2102017980559734, 0.5599905988085874, 0.20732362481626687, 0.48534988954239866, 0.5656560170176761, 0.16726413364684556, 0.14839703803871784, 0.10373522404215185, 0.1266679917723481, 0.1538169380808445, 0.17725603990692307, 0.18833990524112032, 0.1872750161822686, 0.19509953066694308, 0.18975046337702017, 0.19343537556203094, 0.1909697824748059, 0.17545690868622965, 0.18462843447386257, 0.08893839292037631, 0.08217389487593407, 0.08130734588748456, 0.08425549718882197, 0.07211793515407794, 0.10015542950333223, 0.07731482854168226, 0.07459567349284713, 0.08207009637811591]}, "mutation_prompt": null}
{"id": "0c32f986-8634-4536-a80a-c469bd168ed0", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "1b1cc0d1-0cad-48a2-ae2a-83f6137729b0", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "d8235485-2871-43c6-8f1d-51d7e32aca68", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "ed3723d8-94a1-44a0-a113-466c75f53f61", "solution": "import numpy as np\n\nclass Dynamic_Chaos_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85  # Adjusted for better convergence\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7  # Slightly increased to enhance global search\n        self.mutation_factor = 0.8  # Reduced to balance exploration and exploitation\n        self.crossover_rate = 0.95  # Increased to maintain diversity\n        self.elite_fraction = 0.15  # More elites to preserve good solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def chaotic_map(self, x):\n        return 1 - 2 * np.abs(x - 0.5)  # Tent map for introducing chaos\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        chaotic_factor = 0.5  # Initial chaotic value\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)  # Ensuring bounds\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n            \n            chaotic_factor = self.chaotic_map(chaotic_factor)  # Update chaotic factor\n\n        return self.global_best_position, self.global_best_score", "name": "Dynamic_Chaos_PSO_DE", "description": "A dynamic hybrid PSO-DE algorithm with adaptive mutation and crossover strategies, incorporating chaos-induced diversity for robust optimization.", "configspace": "", "generation": 35, "fitness": 0.27736196369667665, "feedback": "The algorithm Dynamic_Chaos_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8761882804715454, 0.8613421471878306, 0.8430763176676366, 0.8601346370322238, 0.856862081776234, 0.8584968369816984, 0.8683127785882812, 0.8712258535183592, 0.8767830151611895, 0.6158372309991831, 0.7281079171744599, 0.48726112349850503, 0.4966733237530889, 0.6217275061497747, 0.5750548258947121, 0.39507269924369826, 0.3503015354299873, 0.5977547978379911, 0.13173584986110987, 0.10339916379556202, 0.14996666787748614, 0.15068323696178654, 0.12934072272990738, 0.070129232741456, 0.1148633894551333, 0.13732496379453119, 0.12371321366125176, 0.14426709449978048, 0.14056487684954044, 0.11995336091363784, 0.10662909181398916, 0.12855925979943184, 0.09568955254971823, 0.08858746934826067, 0.12339443515249804, 0.11205883895738156, 0.9784457763129173, 0.9721483329159957, 0.9784426734122074, 0.976864830195366, 0.9759826268351426, 0.9611831434452655, 0.9716018345971174, 0.9781167479805193, 0.9690146644054041, 0.4908459547931585, 0.5091794358207824, 0.255941301712894, 0.4188477058316452, 0.41472430555761763, 0.416437159638408, 0.34003098206317084, 0.4590052621631916, 0.36175012014024965, 0.7128067389863781, 0.16686573521881487, 0.37848826657867907, 0.2139429181168565, 0.2107832090559032, 0.19048596236116844, 0.13644990574665494, 0.1309560413526959, 0.23355116204018, 0.16653011397621853, 0.18056935792716322, 0.17830118452946664, 0.12207119333021421, 0.1278301416010812, 0.18834628347135418, 0.17862879747991678, 0.29289391459431735, 0.16730594169468582, 0.12683977084613907, 0.19805517709277531, 0.19132077568685313, 0.26407209034501533, 0.1772931359017672, 0.1890179562341341, 0.11338619379019588, 9.999999999998899e-05, 0.23152175712323897, 0.00014883176616353744, 9.999999999998899e-05, 0.009557193306974798, 0.04401049490466846, 0.06953249239584236, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030778375920624823, 0.0396224935617735, 0.10488917960851318, 0.07595149071115193, 0.10332935885184502, 0.09384501102870069, 0.037607050384228735, 0.03506342071007307, 0.11255367520612058, 0.049582678010195336, 0.06516511254091217, 0.055213625376071884, 0.024379762211155453, 0.03347664536158901, 0.07630068758872344, 0.22105285826231003, 0.0759048431186018, 0.09855753244251542, 0.07116995654976599, 0.09858047554957106, 0.09027077598453359, 0.16176529721771182, 0.0800518400053597, 0.11956017304692901, 0.07711648367925428, 0.1474731517959481, 0.1135536629461491, 0.1495489951613801, 0.08751007287569323, 0.5203553703423256, 0.5076127895100424, 0.5649800176529345, 0.5503029646927617, 0.5413369578490346, 0.5243784047608009, 0.545018705183677, 0.544690730774238, 0.5354375807546232, 0.13613029238325158, 0.06654615693196886, 0.06266021699395585, 0.08234649419324547, 0.10091082821919062, 0.11225284633210808, 0.11340582056014459, 0.08544315857031748, 0.0906507798728362, 0.14210368539541574, 0.18502701934250687, 0.16848532658120952, 0.17447122864796127, 0.263417692533518, 0.1713221719059964, 0.5143552536952863, 0.1503521640121418, 0.19293082169470777, 0.3915369480494154, 0.30730094632752936, 0.3127412302906818, 0.3937122928632464, 0.27889032414157844, 0.36084721287911325, 0.5294638816178414, 0.2895269134481604, 0.3610774007556621, 0.16150834800595515, 0.16994130858688516, 0.3361583361456947, 0.2157984882695657, 0.24745842501022774, 0.20971918738380657, 0.2640106819314516, 0.3335123257728664, 0.2458256063477151, 0.21370905867184686, 0.18983469612060977, 0.18778359790422527, 0.1961836534576431, 0.2042047211365804, 0.1915062774577304, 0.246905297517088, 0.17712970910766868, 0.19363838359565277, 0.19422502528205499, 0.22156086604992653, 0.2066204677128578, 0.22287119077717932, 0.19864250162731523, 0.219653939725016, 0.20694820156560068, 0.17096011974749703, 0.19751666692222947, 0.792712218837229, 0.15911166922478515, 0.1530261842257119, 0.8717217654165916, 0.1986958510450203, 0.16724793106336688, 0.14083374744688248, 0.17143263855061974, 0.21147956163295933, 0.7824065453875103, 0.2093165567158216, 0.11156310394531688, 0.5709411789883625, 0.35930182698149005, 0.15126003842959745, 0.10424132303207967, 0.10368249366479743, 0.1549449129974655, 0.17367774377827394, 0.1759935819798376, 0.18793216074700414, 0.17392719202803308, 0.1812491610521899, 0.18490182969044855, 0.19417277477589612, 0.16616050848572594, 0.18617061213982367, 0.10505639083142682, 0.0808848244573559, 0.1224905491626076, 0.09379968445460851, 0.10109396520197411, 0.0825046892076724, 0.0836187131571049, 0.08309192082862449, 0.08991552554134907]}, "mutation_prompt": null}
{"id": "01567ba2-5571-4f4f-89c1-cf22cc622c39", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "07521dc9-4b3f-407e-a7f3-a89a30a35acb", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "f2636428-5778-49a7-b031-835578d94928", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "4abd1341-ac67-494e-bfe2-c430a4e6554c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "6fb1b3ae-df64-430b-b5f1-623497ce5ff3", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "ba64f228-a602-4a12-80d9-a069e511a168", "solution": "import numpy as np\n\nclass Adaptive_Memetic_Algorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.8\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6  # Adjusted social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.2  # Increased elite fraction\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def chaotic_sequence(self, iterations):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(iterations):\n            x = 4.0 * x * (1.0 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def __call__(self, func):\n        chaos_seq = self.chaotic_sequence(self.budget)\n\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            adaptive_rate = 0.5 + 0.5 * chaos_seq[self.evaluations % self.budget]\n            self.velocities = adaptive_rate * (self.inertia_weight * self.velocities + cognitive_component + social_component)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Memetic_Algorithm", "description": "Adaptive Memetic Algorithm (AMA): Integrates local search based on self-adaptive learning rates and chaotic sequences for enhanced exploration and exploitation.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Adaptive_Memetic_Algorithm' object has no attribute 'levy_flight'\").", "error": "AttributeError(\"'Adaptive_Memetic_Algorithm' object has no attribute 'levy_flight'\")", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {}, "mutation_prompt": null}
{"id": "8bc8a21d-bab4-4923-a7a7-7ee6a543d9a7", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.95  # Adjusted for smoother convergence\n        self.cognitive_coeff = 1.7  # Increased cognitive coefficient for faster local search\n        self.social_coeff = 1.3     # Decreased social coefficient for minimized premature convergence\n        self.mutation_factor = 0.8  # Adjusted mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly decreased crossover rate\n        self.elite_fraction = 0.15  # Increased elite fraction for stronger elitism\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def adaptive_mutation(self, target, global_best, personal_best):\n        diff1 = personal_best - target\n        diff2 = global_best - target\n        mutation_vector = target + self.mutation_factor * diff1 + (1 - self.mutation_factor) * diff2\n        return np.clip(mutation_vector, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                target = self.population[i]\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = self.adaptive_mutation(target, self.global_best_position, self.personal_best_positions[i])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE", "description": "A novel hybrid PSO-DE algorithm with adaptive multi-strategy mutation and elite preservation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.2544468336197042, "feedback": "The algorithm Refined_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7720026276817897, 0.7639408906226967, 0.7957391308732502, 0.7779456037979504, 0.7753194551546223, 0.802324224081806, 0.7944691571806777, 0.7734278305807247, 0.7730806773346055, 0.1034365711479277, 0.0449058239040363, 9.999999999998899e-05, 0.09229676839486456, 0.08693071194896107, 9.999999999998899e-05, 0.03900682904171959, 0.15498209764669046, 0.12152510140579686, 0.17001056761033784, 0.15616676818873565, 0.14002523117396848, 0.13428109975325064, 0.08493283803829255, 0.09977263608479547, 0.15671842026184624, 0.10776757604102527, 0.13740366282743088, 0.07440255048968869, 0.0756330553456741, 0.09320615559738399, 0.11198587053162279, 0.09025565422059334, 0.12219352278382323, 0.10511750293849342, 0.10753170796227929, 0.10275231216994762, 0.9634431126927901, 0.9224802945917999, 0.9572790594701631, 0.8906309476266279, 0.9482639996222164, 0.9144871511457464, 0.9586414068732003, 0.9334622213200455, 0.9099716490800274, 0.39902184891207815, 0.2731992915858462, 0.3519445012255271, 0.4516760580133713, 0.22751036354586718, 0.16136354823791477, 0.352884215909848, 0.3268873654212743, 0.34871745980568836, 0.2424487221750884, 0.7062905236968391, 0.22150607101211583, 0.21097168065277072, 0.21073556994026732, 0.20907589717343622, 0.35266177830126166, 0.22885068533487296, 0.2231015751198746, 0.1622089897822272, 0.15049177743973563, 0.11284196658635537, 0.15593764506611418, 0.12106644445873149, 0.11783883391076944, 0.24626860306167964, 0.23651383908279855, 0.20649480867138204, 0.35484253099524843, 0.1664500332160953, 0.13322341777993973, 0.17319869235411767, 0.14129308201027702, 0.12960055977424867, 0.1282527487228643, 0.1374506188611584, 0.22423703230120762, 9.999999999998899e-05, 0.01093765112742151, 0.0100723692570025, 0.01834098595434841, 0.09344969624947552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02209115722495969, 0.12342375617950674, 0.03469042759375429, 0.05278783306468926, 0.10204349027038839, 0.00031692430334184785, 0.040705229448382285, 0.04469731817625111, 0.04227681267484895, 0.10202507330861477, 0.08112244578163774, 0.07107327594208146, 0.09163901753694792, 0.15828743547764912, 0.19021011964269818, 0.07669749772523649, 0.10256464653379338, 0.19034402851696663, 0.06949151838676426, 0.13498738064867155, 0.20393848092018907, 0.07001570196598639, 0.007737352795506247, 0.14809439191476048, 0.09799423872395796, 0.051428320058689136, 0.131524409139538, 0.0786124804790872, 0.45097942020026727, 0.5012429055011626, 0.483972972814823, 0.5239774593240405, 0.5289307510850151, 0.44830782763669563, 0.48952952790514814, 0.5014671965254985, 0.5117595509023526, 0.1320321812860331, 0.13242585824453457, 0.10365022096435661, 0.11004381544177655, 0.12836759821467347, 0.11976923029204611, 0.13481315091255952, 0.10849865611106602, 0.09709141481916417, 0.15875416352399685, 0.23969422961717168, 0.17588939449609164, 0.25854693209319046, 0.20549607925613766, 0.29243771512968353, 0.19085783117381028, 0.21322029217746308, 0.2546473655743363, 0.4951943727881166, 0.34000509132173873, 0.28997502054032176, 0.4542029626651718, 0.2380118679445522, 0.39315036246819013, 0.21717580811996806, 0.4234321989728739, 0.37538008487476515, 0.2013916961617006, 0.1669815991698842, 0.3004805772895899, 0.18021166947564438, 0.16519849751443128, 0.31868219989345503, 0.1968536861228305, 0.2546955082022031, 0.3806161176353955, 0.225621337136793, 0.18270726703544704, 0.2373997948138915, 0.21892335646568728, 0.22333703756194156, 0.21843564388245773, 0.2357506261180653, 0.20562053955167925, 0.226832762253935, 0.17639087534635123, 0.1768908458595574, 0.17911693147438346, 0.19667815866029248, 0.22049849516825948, 0.17173481441017635, 0.22273872839793152, 0.18634356113819261, 0.18648234267573194, 0.8724673765016006, 0.16528904529659794, 0.18312519760756274, 0.8685248659772761, 0.20010825815525302, 0.21765180299088327, 0.14122332856002673, 0.14483357130474794, 0.879494846481566, 0.49881046620381597, 0.20677707562948267, 0.4310849766424303, 0.20352592314317974, 0.43817457904844237, 0.14990118552572984, 0.32063005423245106, 0.10332335881955002, 0.39670247861562324, 0.20108986329821155, 0.18355247823385334, 0.22280098754103894, 0.20638876470075862, 0.19490550462680545, 0.18444540538625365, 0.19348449437057247, 0.19695576174926388, 0.19134539744776313, 0.09033350522498218, 0.08249914852124096, 0.09727167310788387, 0.08397929622383093, 0.0872303030045557, 0.09601650241539827, 0.08663501496780013, 0.0855806526819608, 0.08337601488104596]}, "mutation_prompt": null}
{"id": "2dfdc97e-3d90-4c49-9421-db90bff31e9c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "17c999de-a2d4-4d08-ad06-ecc559e95e7c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "f1bc127b-c7e3-404d-b8da-b43401b8cb5e", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "06ae81ae-83b6-499d-8d11-a6e98fc23c61", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "884d4b65-81f5-44a0-a287-d1afbc7c2f6d", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "9f79deec-8f83-48af-9049-1a4550d2fd82", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        # Modified initialization using chaotic map\n        self.population = self.chaotic_initialization(self.pop_size, self.dim, self.lower_bound, self.upper_bound)\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def chaotic_initialization(self, pop_size, dim, lower_bound, upper_bound):\n        # Using a logistic map for chaotic initialization\n        chaotic_seq = np.zeros((pop_size, dim))\n        chaotic_seq[0, :] = np.random.uniform(0, 1, dim)\n        for i in range(1, pop_size):\n            chaotic_seq[i, :] = 4 * chaotic_seq[i-1, :] * (1 - chaotic_seq[i-1, :])\n        return lower_bound + chaotic_seq * (upper_bound - lower_bound)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            # Adaptive inertia weight\n            self.inertia_weight = 0.4 + 0.5 * (self.budget - self.evaluations) / self.budget\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Local search via DE for improved trial vectors (elite only)\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in elite_indices:\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Chaotic reinitialization for potential stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population = self.chaotic_initialization(self.pop_size, self.dim, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "An enhanced PSO-DE hybrid with chaotic maps for initialization and mutation, adaptive inertia, and local search via differential evolution for faster convergence.", "configspace": "", "generation": 48, "fitness": 0.23961665557664247, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.6468678046988181, 0.6074419071654906, 0.648803626301105, 0.6772332221799525, 0.611378776949616, 0.6723191010143434, 0.6648545663375575, 0.573754346450662, 0.6556923847769175, 0.24012691697455935, 0.027762595978105153, 0.31474628985283204, 0.24156111980092188, 0.1314118647891459, 0.04105213436755317, 0.04053964733306692, 0.20579868332301499, 0.2808563610734286, 0.2867929785051222, 0.1032436341683306, 0.1496991190539596, 0.12808256897329207, 0.1125704113212318, 0.13425597521313848, 0.11270084175716588, 0.265322349965454, 0.1310194339961014, 0.09828932022956194, 0.10597512238213314, 0.1358842645313365, 0.12460999534224682, 0.09300128812050079, 0.09444978199539944, 0.1234688193197162, 0.11661866765097961, 0.09704874710327183, 0.9888104055892137, 0.9870324951315101, 0.9796062257352081, 0.9857843853486504, 0.9897065537693461, 0.9820125498612285, 0.9886074661636538, 0.9855376587393992, 0.9804667380262125, 0.36442087046981564, 0.2954043188250979, 0.3603557326277541, 0.34546426244203643, 0.29013803249911563, 0.37050714698018017, 0.36993652126427223, 0.3405857228746031, 0.33415834138144995, 0.3383051030995753, 0.22366440511193497, 0.20695589158321714, 0.15804529593539696, 0.19673238264439186, 0.22243694630887434, 0.6428784287809739, 0.11992370232504324, 0.44707822112304796, 0.07337873142120732, 0.1639682072615839, 0.15384942548194036, 0.1574501814987137, 0.10877308912647421, 0.11013703686729204, 0.1393560104878654, 0.1286424083957025, 0.15630531616419063, 0.1628965117949217, 0.11842298468175483, 0.12021223915740242, 0.18509565503523928, 0.16489274163129597, 0.1583501399290541, 0.2085318066684323, 0.23484340776006007, 0.11956006227275517, 0.013137376445295001, 0.005498350451669132, 9.999999999998899e-05, 9.999999999998899e-05, 0.04392999803443254, 0.00036062576390072376, 9.999999999998899e-05, 9.999999999998899e-05, 0.041143505734313135, 0.0318569434770859, 0.062303726792792835, 0.0416731455028323, 0.06523014255837478, 0.01573530825050562, 0.08799235303099462, 0.05847425370332637, 0.017261573213249948, 0.025033701048388868, 0.024339756759757303, 0.02432310935851234, 0.0231981550765189, 0.10570549824788755, 0.047917493654915266, 0.07854068031788408, 0.048716760189543296, 0.09060028498549344, 0.042883979199233035, 0.036876139969108435, 0.03717628300901765, 0.18560674492896811, 0.11569169731482976, 0.012145314643296157, 0.13005075392214627, 0.13340090511040492, 0.051856388449829316, 0.07443046529660935, 0.4303025359276632, 0.43773155266441843, 0.45860528638417786, 0.49019049967511763, 0.47206149443155176, 0.4776527391703913, 0.4723638646191409, 0.45915828440237616, 0.46870465584284204, 0.12195636945653587, 0.08659733933658498, 0.08410490295348949, 0.13939529083999624, 0.10502112812862274, 0.10313837976516715, 0.14410698222354945, 0.0851376039602103, 0.11639361414032923, 0.19366045871563553, 0.2684340951188162, 0.20950528944249802, 0.16090348339431626, 0.21464918505808606, 0.184375898286826, 0.21263202464672382, 0.2035191047636502, 0.1286075187343666, 0.3717663415175494, 0.23260921983296268, 0.38313583473102375, 0.31677742567596123, 0.2046178515170084, 0.19935840357200985, 0.3486643582417268, 0.34902636659818786, 0.3770164435940532, 0.1843176710667136, 0.16138551793945322, 0.18674664091119186, 0.18458003407676438, 0.20642224114351848, 0.18957683924245772, 0.1737673315175391, 0.21199141662726884, 0.24359127059607477, 0.18550144200832341, 0.21651582052394702, 0.19071859784578837, 0.1875411429450935, 0.14685162273525876, 0.21984058141429919, 0.20671083426114178, 0.20783811469583646, 0.2059165267943437, 0.2007002349379725, 0.4022270540406321, 0.3495606929724411, 0.4516906377631692, 0.18419049132460996, 0.20020528685551486, 0.20682226316499186, 0.1986664995261913, 0.2110483625192151, 0.1996079221673267, 0.6544498468512712, 0.17150482924320276, 0.15981216752916205, 0.17808980523559004, 0.18526029774083463, 0.14771696067759454, 0.6644758121537506, 0.6590930171480209, 0.20799544320413532, 0.16105277659145545, 0.1269959276833551, 0.1173853975955439, 0.41083032000148023, 0.13072481618128062, 0.15391729746869587, 0.4927315880895162, 0.18968657474721107, 0.2053089625431922, 0.19137824884554255, 0.18928923957849642, 0.2094136350831859, 0.1941791565998715, 0.17501735918897798, 0.20853504478520524, 0.17572613021220607, 0.19243566396783995, 0.08722594000524353, 0.08864424599872422, 0.07923805434226883, 0.08699434863785105, 0.07908646507005579, 0.08452342363032095, 0.0706811854578353, 0.08650976585882475, 0.08692509391215231]}, "mutation_prompt": null}
{"id": "fdb180cb-1b85-41bb-baa4-ea1d8dce5d23", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Reduced for faster convergence\n        self.inertia_damping = 0.95  # Adjusted damping for stability\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n        self.neighborhood_influence = 0.3  # New parameter for neighborhood influence\n        self.mutation_factor = 0.8  # Adjusted for diversity\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()  # Chaos-based initialization\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def initialize_population(self):\n        # Chaos-based initialization using logistic map\n        chaotic_sequence = np.random.rand(self.pop_size, self.dim)\n        for i in range(1, 100):  # Iterate to induce chaos\n            chaotic_sequence = 4 * chaotic_sequence * (1 - chaotic_sequence)\n        return self.lower_bound + chaotic_sequence * (self.upper_bound - self.lower_bound)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            neighborhood_component = self.neighborhood_influence * r2 * (np.median(self.population, axis=0) - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component + neighborhood_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE", "description": "A refined hybrid PSO-DE with adaptive neighborhood influence, chaos initialization, and multi-scale search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.25637629319908595, "feedback": "The algorithm Refined_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8283037792314398, 0.8043398182457967, 0.8142713830104149, 0.8326820723549964, 0.8383653079266651, 0.8284225879207742, 0.838396291508648, 0.7875182226212775, 0.8240518427274395, 0.3643439988063647, 0.33980835252128183, 0.49870748488839667, 0.46204278977645674, 0.3176278133919159, 0.26579829012068723, 0.22760505739779824, 0.488165105820875, 0.46949609428639094, 0.1390873497199091, 0.13017685258557576, 0.12862231953664982, 0.07431413139707965, 0.1528900759441434, 0.4445534581121815, 0.10584718299302187, 0.1072607037360096, 0.10487172573801107, 0.14740416777903032, 0.13091777464960774, 0.12667398075828495, 0.13341616199958117, 0.11522167164324071, 0.0977181602458983, 0.10491055548597794, 0.16704393388018524, 0.12426406371731169, 0.9690592114023094, 0.9768674400903884, 0.9791562310219718, 0.9860765634359673, 0.9820822099671555, 0.9781843129454663, 0.9864438732776564, 0.977819590196176, 0.979104068024563, 0.32928040952867177, 0.4431770222876924, 0.4625481739522349, 0.42544562432705557, 0.41647960973382814, 0.42625844967414517, 0.4299138812041682, 0.42112362886436305, 0.3713114234512681, 0.16835335038023658, 0.18795068298503703, 0.17304185289436513, 0.2653850750350689, 0.2072653414054565, 0.35180512121393404, 0.31957506882934306, 0.2219628232727493, 0.16680515904305648, 0.10010903104602054, 0.11871890000284857, 0.0914817553282703, 0.12153289449764437, 0.1623512761155942, 0.09590958174168118, 0.12245658050826169, 0.1935539885779508, 0.16942438382117875, 0.1935159913888197, 0.1222636336031524, 0.11274186063010672, 0.13583758724484107, 0.14050538634025778, 0.20247798467236633, 0.1399844108785946, 0.2457503865787558, 0.08766449350656114, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005711677829942197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03615198253897833, 0.0714035267907791, 0.07466327323765964, 0.06360346983066478, 0.038794273767292387, 0.03417194955771519, 0.04011361704749272, 0.03528701739849982, 0.09172058289019935, 0.03082890920488557, 0.054961525241409404, 0.04487066517466376, 0.08405852771778122, 0.07230222123820751, 0.19392920696946658, 0.24440300965151296, 0.09389278263953671, 0.06708892321891147, 0.051130678194788004, 0.03920768069543812, 0.041546325445380394, 0.11244231264758275, 0.10230701569354528, 0.00912215243412795, 0.05438075424809774, 0.1097236292241539, 0.07831267655793617, 0.5600459639951287, 0.5012003898824068, 0.5116730287725235, 0.5301714520342364, 0.5550252474994206, 0.5069814972348986, 0.5290940330337666, 0.5081025852419419, 0.5117467244961259, 0.12609784132596724, 0.07413569264610165, 0.1320305506736098, 0.12022339258850678, 0.09410414831342673, 0.0990724689900091, 0.13886832584472253, 0.12452914500539358, 0.10663166752981523, 0.29350031079348005, 0.19929240701080442, 0.15142645616054906, 0.20043509292603479, 0.20884124181843167, 0.19906173197912036, 0.23268151927653535, 0.21608080515235084, 0.18582653621405254, 0.22236408198599733, 0.3548235223380106, 0.403295526146056, 0.3150975886461913, 0.23928685045829357, 0.4626739158576275, 0.18825753290998648, 0.4089031950434825, 0.3584557529818655, 0.333935853363604, 0.2473921296246422, 0.2084359755857147, 0.14029772858012568, 0.1470509638230737, 0.17953295837413463, 0.23915533364455277, 0.35735041069947526, 0.23011272360463775, 0.1837158887674104, 0.2095528430230209, 0.18969860297456875, 0.16867377712539167, 0.18987531282881032, 0.1936553905983338, 0.21136276222767092, 0.19926697771858093, 0.23229122990981754, 0.17321529823344295, 0.2276722361115533, 0.18162009482469432, 0.19165260472346557, 0.23988780884636718, 0.20495571757602427, 0.18633938284354257, 0.6242823664883086, 0.18451836649071707, 0.15294291518951597, 0.16391388611861346, 0.20910265844440434, 0.15736866623549284, 0.16471233108633643, 0.12251060557972393, 0.16469607373365291, 0.1568048959213213, 0.15916809353002914, 0.15219234647416235, 0.5130450860980061, 0.11321538677367171, 0.7444924798679473, 0.1674416731033188, 0.20407643886760685, 0.11238060945192396, 0.16521431734102932, 0.2090429172449132, 0.19060559179395054, 0.18488139588183017, 0.19774016547154616, 0.2078487398195904, 0.17935119404949051, 0.17511343811490698, 0.17694846830870448, 0.17370076604435947, 0.18220769386404712, 0.08541939178703273, 0.07827304662394186, 0.0795024676443441, 0.07974223884016007, 0.07941438861872607, 0.08793832655418865, 0.08488871228372297, 0.07947871383975746, 0.07553699448883877]}, "mutation_prompt": null}
{"id": "9376c9b4-f91c-4be8-838b-cc5cbada0308", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "70de14c9-8633-4332-b14d-7a5132bfd2c7", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "8207e494-f27d-41ab-8621-99232510e135", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.98  # Adjusted damping for gradual decrease\n        self.cognitive_coeff = 1.4  # Slightly reduced to balance exploration\n        self.social_coeff = 1.6  # Slightly increased to enhance convergence\n        self.mutation_factor = 0.8  # Adjusted for better diversification\n        self.crossover_rate = 0.85  # Relaxed crossover for more diversity\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.chaos_factor = np.random.rand()  # Chaos factor for dynamic adjustments\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step * self.chaos_factor  # Applied chaos factor\n\n    def __call__(self, func):\n        stagnation_counter = 0  # To monitor stagnation\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                stagnation_counter = 0  # Reset on improvement\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n            else:\n                stagnation_counter += 1  # Increment on stagnation\n\n            self.inertia_weight *= self.inertia_damping + 0.01 * self.chaos_factor  # Dynamic adjustment\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation\n                mutant_vector = np.clip(a + adaptive_mutation * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if stagnation_counter > self.pop_size // 2 and np.random.rand() < 0.1:\n                self.population += self.levy_flight((self.pop_size, self.dim))\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Adaptive", "description": "Introduced adaptive chaos-driven dynamic parameter adjustments and self-adaptive mutation strategies to enhance exploration and convergence.", "configspace": "", "generation": 52, "fitness": 0.24186741750460247, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.7296599461991891, 0.7322325158889027, 0.7052345578470578, 0.7028024408083935, 0.7581777744895566, 0.7284807838035807, 0.7145294579847488, 0.752558136781773, 0.6990834975692262, 0.5003954330427037, 0.5392417066917108, 0.4522762835502502, 0.4708494962451302, 0.5532135024625935, 0.4529372130901552, 0.043581977194155797, 0.5022642961749144, 9.999999999998899e-05, 0.12808931420606373, 0.1366745383963356, 0.09936289368215057, 0.10431858104609815, 0.14488197201821518, 0.11946804165148317, 0.1015389743538957, 0.10558138804367323, 0.1491104617372293, 0.09361855736562152, 0.09293577683378063, 0.12442524568051139, 0.1003817633567583, 0.09555339160456022, 0.09909795256026788, 0.11629012151028906, 0.1093460149022425, 0.13733351253355908, 0.9701771080961046, 0.977023529050529, 0.9762688560423337, 0.9769215916686704, 0.9767231476400545, 0.9694261339564972, 0.9835989839313055, 0.9837174865611366, 0.9756262191597678, 0.3391213128754401, 0.34937788192159247, 0.09780214496322148, 0.2919916301809157, 0.25359785538783486, 0.3224735619254744, 0.08659560728686644, 0.34513472206228135, 0.08746856640273237, 0.2102332088331793, 0.16840970258377475, 0.2954833397446217, 0.19183878562999646, 0.19304213313713126, 0.1935220918408126, 0.13048692817372143, 0.22135579041890918, 0.21485879713508016, 0.1696737610225273, 0.11747926122115349, 0.1734618538566599, 0.15443776361909367, 0.09813436775256579, 0.14203135334015538, 0.20185405888999652, 0.22062850366958497, 0.26300233750183466, 0.17535992658478372, 0.15467654419908683, 0.04650244817506499, 0.18473533956608457, 0.23744630251275944, 0.15544195236104386, 0.1766208243059143, 9.999999999998899e-05, 0.1155122004412582, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030387538372037337, 0.03423495179929448, 0.1109354202005075, 0.03619778121671968, 0.03028507968981009, 0.023499601953323124, 0.03348039131626224, 0.04639392953032562, 0.045361577417434296, 0.036225066015161955, 0.02695173108982596, 0.0683463775295724, 0.059584809738516764, 0.05833059426232523, 0.05570462336118487, 0.07486088353682951, 0.07281466141010295, 0.2107986832837866, 0.06756528621738778, 0.03607732286203169, 0.03239472325898318, 0.17182078449277938, 0.08630538338990723, 0.12114728874400627, 0.0369602942025693, 0.04932015994977923, 0.08813460205822488, 0.5165656127236087, 0.47003350510427744, 0.4852497443594377, 0.45952814388196617, 0.20706837980114967, 0.5061608697467845, 0.49556461604137847, 0.45482988280485237, 0.4872328340395652, 0.08860924938852355, 0.07623386785987352, 0.07282243443939462, 0.10127918914483558, 0.08508427366621563, 0.09467445781557304, 0.0809658215343485, 0.14033777235353295, 0.08498659359757954, 0.18509924443206716, 0.17752277744983025, 0.1603128928851394, 0.3131800083107382, 0.15409543744585041, 0.16308476307250552, 0.20737012018466472, 0.1818290520791499, 0.142188930086933, 0.3515958722047019, 0.2530404735484799, 0.4364420029331434, 0.32123525121442853, 0.21656838337128892, 0.29616294841551105, 0.4298853617664897, 0.4410498655165438, 0.1931695725066377, 0.2663277692817102, 0.1700308634838611, 0.16069148738224504, 0.17691553871153265, 0.21760932124404964, 0.1783016005808422, 0.30490937713063715, 0.20275472310847886, 0.21017719396546308, 0.18118606117195069, 0.17243656650995398, 0.20934869729550631, 0.19048923185252353, 0.200353219169082, 0.17921212046706536, 0.1765408942055503, 0.18235036521244286, 0.20494558841888977, 0.20919995453523665, 0.5246355897280977, 0.22043833441864658, 0.18657620247653173, 0.20313254121407687, 0.18898049231284353, 0.21089953464725775, 0.19291677211398972, 0.21174456420574983, 0.7527967814239994, 0.1621553685825735, 0.15171863774305727, 0.6679277481331173, 0.1976862646974712, 0.19309053251634256, 0.16367147103863955, 0.15173363293142317, 0.6983978196483097, 0.3650204811693627, 0.20447553112314754, 0.15985767438050824, 0.5935238149839125, 0.10888908190030011, 0.14482049377580697, 0.19591751758853837, 0.20492496374661373, 0.15258650699611986, 0.18616289117742912, 0.18718819314015245, 0.1730053658595362, 0.173238073354826, 0.1660440556362337, 0.19578238406051474, 0.1790475155698017, 0.1751813127018882, 0.17421946117197262, 0.08185977012267753, 0.07721933173763795, 0.08141728566739292, 0.06281085602344649, 0.07851817698801755, 0.07249643563634223, 0.0801194901238923, 0.07776072277505297, 0.07790874246183721]}, "mutation_prompt": null}
{"id": "33164784-a742-4a4a-8ca3-8997295f64f4", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.8  # Reduced inertia for faster convergence\n        self.inertia_damping = 0.95  # Adjusted damping factor for consistency\n        self.cognitive_coeff = 1.7  # Increased cognitive component for diversification\n        self.social_coeff = 1.3  # Decreased social component for reduced premature convergence\n        self.mutation_factor = 0.8  # Modified mutation factor for balance\n        self.crossover_rate = 0.85  # Adjusted crossover rate for exploration\n        self.elite_fraction = 0.15  # Increased elite fraction for strong guidance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def gaussian_mutation(self, individual):\n        return individual + np.random.normal(0, 0.1, individual.shape)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_vector = self.gaussian_mutation(trial_vector)\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  \n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Refined", "description": "A hybrid PSO-DE algorithm with adaptive population resizing, Gaussian mutation, and stagnation-triggered perturbation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Enhanced_Hybrid_PSO_DE_Refined' object has no attribute 'levy_flight'\").", "error": "AttributeError(\"'Enhanced_Hybrid_PSO_DE_Refined' object has no attribute 'levy_flight'\")", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {}, "mutation_prompt": null}
{"id": "878bb80c-f9d9-473d-b3fe-459218332524", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Changed damping factor for more stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9  # Modified mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(10, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Adjusted step size\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Reinitialization strategy for stagnation\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.mean(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A hybrid PSO-DE algorithm enhanced with dynamic parameter tuning, greed-based reinitialization, and adaptive local search for improved convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8619785586692249, 0.8585068642274468, 0.8467266212799257, 0.8467813374087122, 0.8487602121220124, 0.862413257597405, 0.8219690262583946, 0.8565401002610348, 0.856991964770643, 0.5452247872144826, 0.5571975625307015, 0.5159474483435097, 0.49234448775375006, 0.5936422010418023, 0.5558242537554483, 0.5273873221927404, 0.5427312173272439, 0.6033857378192696, 0.13929053311083428, 0.5339727143024016, 0.1510743184077057, 0.12740321809206745, 0.06991650292574991, 0.1413578018050815, 0.11437839705297159, 0.13665912641252687, 0.13172137901788827, 0.11889918456620108, 0.11137844035897693, 0.1333755816197576, 0.12387632125771819, 0.12488199771770991, 0.12812822180166272, 0.10456191266775772, 0.1324508403457355, 0.12865177534049455, 0.9834359701625539, 0.9776477836309064, 0.9750844953774654, 0.9779727285442542, 0.9773186885016228, 0.974331390538914, 0.9769440010055975, 0.9752997868383285, 0.9757692372275044, 0.5167338480629713, 0.5371217504472994, 0.3943837695377167, 0.3506693553182325, 0.4855005556238209, 0.47857741830501366, 0.3747122214885593, 0.3862628664809963, 0.4387451921643233, 0.19424373586386168, 0.7337351389354919, 0.211068302543151, 0.19255822720340443, 0.19020375720265714, 0.16225625185626436, 0.1360169450905936, 0.20260210845351845, 0.22807626447819485, 0.21404703614039677, 0.12156705036873228, 0.17636403934985578, 0.27266709150839774, 0.18340875867462192, 0.10174907714344339, 0.12423994524586612, 0.17861486974804286, 0.16466946374770397, 0.21701519355621202, 0.17669710766129576, 0.20177997350426868, 0.17926282620180778, 0.23348337969181143, 0.22763066264140785, 0.20727235016221535, 0.13142721007815783, 0.30833516449132625, 9.999999999998899e-05, 0.007192097340111836, 9.999999999998899e-05, 0.019756504697483468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002692169269191691, 9.999999999998899e-05, 9.999999999998899e-05, 0.07386214070500663, 0.03135799618438251, 0.12560998419351777, 0.05980905784529256, 0.021875579864012562, 0.07998219265841255, 0.03244400308052753, 0.04607671306472916, 0.044454727406529115, 0.2511915254761209, 0.033869686947334054, 0.04749275396348962, 0.0846741567262227, 0.17543185129513061, 0.07504268840140849, 0.09991705711706489, 0.27019989240802367, 0.09605514399666304, 0.12987353982481542, 0.055336768193425034, 0.23993772147624182, 0.1276236773091165, 0.07711609619638615, 0.1561046131260908, 0.05420877438561911, 0.04829084206218848, 0.07908253174187996, 0.5166489818709399, 0.5020119331556552, 0.5100437426206397, 0.5325942760438873, 0.5110489425902294, 0.5087280067677005, 0.5507022744868313, 0.5028492558251234, 0.5416107503424048, 0.10513277244598507, 0.1275518082701883, 0.13904135123746442, 0.11000330857842822, 0.14309720511913715, 0.11180337828209708, 0.12799869171743172, 0.09896808525255252, 0.1664468554714824, 0.15802239464326573, 0.15669760498791252, 0.21325400703111264, 0.21669551707080847, 0.2495755014683737, 0.3364565129030397, 0.1757345046586397, 0.2500242873285594, 0.1479295024345313, 0.37587754997585954, 0.26375764714813843, 0.28179083114858505, 0.40048022494986635, 0.21597462405897017, 0.3798019243706531, 0.37015319652517387, 0.4828801045771979, 0.4310262451644712, 0.31439611846877047, 0.21619525120214356, 0.3328035420638875, 0.1639604168457226, 0.19241919561763676, 0.21472514351894667, 0.20048195415116876, 0.2902415387677876, 0.3354184604859667, 0.2064580308450229, 0.2262812429302402, 0.19404634021891443, 0.18331864862635328, 0.2055601199745174, 0.22009366973312283, 0.1920178432891012, 0.2014658568145069, 0.1925640844148564, 0.20477916511389826, 0.2061472914261161, 0.20792405535936564, 0.2122978778178678, 0.22231527573611298, 0.1902118363923342, 0.23553367886147347, 0.20813195479945212, 0.1848192959240459, 0.8377666571552544, 0.17209923666456073, 0.1534446373903371, 0.8313073986409709, 0.1983377533598425, 0.16768522035357125, 0.14156945993948133, 0.1451550074327892, 0.20971409678566444, 0.7014823690838298, 0.2092098541210653, 0.7917625816103737, 0.6098731395323796, 0.6520450927775971, 0.14957381787311552, 0.20193791054668941, 0.1258377257284361, 0.15505679610625744, 0.1838836340074964, 0.19505071150603703, 0.1990825133281129, 0.19980462549165834, 0.19989027071387955, 0.18905907463603988, 0.1972259741532173, 0.17994630120667843, 0.18931706373176116, 0.08019281389550792, 0.08744082618049287, 0.08444275040658145, 0.07782289496148365, 0.09439925216408662, 0.08289979809493964, 0.09138251338092962, 0.08409181607277127, 0.0942082934052203]}, "mutation_prompt": null}
{"id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for better balance\n        self.inertia_damping = 0.95  # Increased damping for smoother decay\n        self.cognitive_coeff = 1.7  # Slightly increased for improved local search\n        self.social_coeff = 1.3  # Slightly decreased for better individuality\n        self.mutation_factor = 0.8  # Adjusted for diversity\n        self.crossover_rate = 0.85  # Decreased to encourage exploration\n        self.elite_fraction = 0.15  # Increased elite fraction for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Slightly increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Slightly increased frequency\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # More stringent reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with levy flights and adaptive population size tuned for improved exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.30404053285401306, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "26a89810-1b7c-4d5b-93cd-7e30af21221c", "metadata": {"aucs": [0.8465514055317322, 0.8584130011172402, 0.8423142261310044, 0.8395027420198429, 0.850645292776092, 0.845377202323184, 0.8445896727419407, 0.8501548218405086, 0.8441260038836712, 0.6378214904063313, 0.6719660887969487, 0.7209082213565088, 0.6443921714066068, 0.540910572288418, 0.7140228770077925, 0.555282933969062, 0.6694879652891521, 0.6849294543901139, 0.48877427067160495, 0.13079178660528068, 0.12574775096788493, 0.1620086435732645, 0.6030889113474797, 0.16666252515654434, 0.11013355812713399, 0.12758457615744734, 0.14154898275713002, 0.09515817987284281, 0.12546023769867864, 0.08900491787290232, 0.10568230850017024, 0.1294920142511461, 0.1072560195752742, 0.1265371067933857, 0.11998721571607496, 0.16211748116213964, 0.9706205930803956, 0.9711596132593356, 0.9763638016606752, 0.9773292840439873, 0.9693885407169206, 0.9690909079250204, 0.9758157680902546, 0.9708946434165069, 0.9621901778949653, 0.5691669630482059, 0.46961283077312066, 0.4973910665523599, 0.4201121031995376, 0.48841970939645596, 0.54635807499036, 0.49297700607450934, 0.2809948398798733, 0.5540031264347163, 0.7700016186085874, 0.6042450036575349, 0.36201197003507735, 0.20897367790859933, 0.1906842214086013, 0.2116939255102721, 0.21686745976567556, 0.5797773445475052, 0.22480201322216475, 0.19199768632302672, 0.1132535996974624, 0.1215866916486289, 0.12323699455806036, 0.12900453221962238, 0.11242657754506713, 0.18407367242848827, 0.1599759521698112, 0.16068735105124177, 0.17381250333702303, 0.18204861700983133, 0.17020525643788875, 0.16168422248500358, 0.12663791210404884, 0.15339264930168772, 0.21857064385485037, 0.18375405393062783, 0.3363414146560162, 0.0066448027695472645, 0.021023046123416322, 9.999999999998899e-05, 0.01945475542292474, 0.061929949549283214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09121363671334981, 0.06397593709398275, 0.042149443983783175, 0.05143762340394897, 0.04380797652090318, 0.01678491988290609, 0.10091953101581563, 0.07730809689550477, 0.042843060189797555, 0.11964982592702378, 0.03295922221766412, 0.047004235087243273, 0.13586801168990037, 0.0763013704267943, 0.06993299686970844, 0.11386702279078997, 0.14056478961088437, 0.0684616472274947, 0.08566387462898872, 0.052331939060304866, 0.053643978676413684, 0.07646868607479373, 0.24279613942193456, 0.12281811044016977, 0.08109786269743746, 0.0911445830532237, 0.0791376340349349, 0.5848553982160338, 0.506187131059677, 0.5373150955140398, 0.5357449825367806, 0.5590209195373443, 0.5145205925231355, 0.5636575847517706, 0.5179756070581236, 0.5568726150149331, 0.0976084299760761, 0.11807982882600832, 0.13245037822782868, 0.13108948273007204, 0.15942152960803846, 0.13338593639256235, 0.1471891774227324, 0.1103062374145658, 0.0737846929517082, 0.1969334685209675, 0.29159139793854527, 0.24255458667486962, 0.25078346582532873, 0.18157280192786862, 0.21811127858423285, 0.20414818537330148, 0.16848275431421866, 0.17891320389410081, 0.4206132741145343, 0.3819301867428353, 0.43149302463243233, 0.35866223206657555, 0.4822241565020069, 0.33823336420104033, 0.35927637655450295, 0.4018891373117637, 0.48229511501195654, 0.24536107269510643, 0.2612058698138874, 0.27768433982807683, 0.17797859128010274, 0.18991696786966317, 0.20317856018110847, 0.37608269391676186, 0.2704823031056087, 0.46085708832812944, 0.1945204161039652, 0.17845885265181427, 0.22626436773272762, 0.20040143939224142, 0.17998899990826345, 0.20540594996069284, 0.213920447721771, 0.21347935741030177, 0.2233857656866418, 0.1860984119938397, 0.2234069564642761, 0.7317687827471626, 0.18935881253089204, 0.24747566734575654, 0.18823473608467334, 0.20609585099765204, 0.21945635498103144, 0.18039623620071565, 0.8583608680341572, 0.16232104545064407, 0.15149284679966402, 0.17216004746502567, 0.19925205109299904, 0.16965957072964577, 0.14195395658921783, 0.8449808466839779, 0.20937873130830642, 0.5641940330335429, 0.20938530030203906, 0.6090055813536369, 0.461313840752575, 0.16640737028280406, 0.15237113120992885, 0.2033850803338937, 0.6285279749570692, 0.7135113942856692, 0.17993636010398173, 0.17441195027584377, 0.17379411516602705, 0.18361695267423306, 0.19380382578374822, 0.17337473372656986, 0.18179711144100463, 0.20162411505196365, 0.200533495953514, 0.08232288617055761, 0.07922660717959007, 0.11684857998326315, 0.08523534782645548, 0.08553193776345891, 0.10532415733246181, 0.08605057346517586, 0.08589408345201888, 0.08395411412376175]}, "mutation_prompt": null}
{"id": "829a5252-0964-45f3-a98f-b676ef00bd61", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.5  # Reduced to balance influence\n        self.social_coeff = 1.8  # Increased to enhance global search\n        self.mutation_factor = 0.9  # Increased for greater perturbations\n        self.crossover_rate = 0.75  # Decreased for more exploration\n        self.elite_fraction = 0.2  # Increased elite fraction\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.neighborhood_radius = 3  # New: neighborhood size\n\n    def levy_flight(self, size, beta=1.7):  # Modified beta for flight steps\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step  # Reduced step size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:  # Shifted adaptive shrinking\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Increased probability for levy\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_V2", "description": "A novel adaptive PSO-DE with dynamic neighborhood influence and stochastic ranking for enhanced convergence and diversity.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Enhanced_Hybrid_PSO_DE_V2' object has no attribute 'initial_pop_size'\").", "error": "AttributeError(\"'Enhanced_Hybrid_PSO_DE_V2' object has no attribute 'initial_pop_size'\")", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {}, "mutation_prompt": null}
{"id": "a0f0c959-ce06-4e60-b301-38215a7ac155", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased start for more exploration\n        self.inertia_damping = 0.97  # Further increased damping for smoother inertia reduction\n        self.cognitive_coeff = 1.5  # Reduced for balancing with social learning\n        self.social_coeff = 1.5  # Balanced with cognitive learning\n        self.mutation_factor = 0.9  # Increased for more exploration\n        self.crossover_rate = 0.9  # Adaptive crossover rate\n        self.elite_fraction = 0.15\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Increased step for greater exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_threshold = np.random.rand()\n                crossover_rate = self.crossover_rate + 0.05 * (1 - 0.5 * self.evaluations / self.budget)  # Adaptive crossover rate increase\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE", "description": "A refined hybrid PSO-DE algorithm incorporating adaptive inertia and dynamic crossover rates for enhanced convergence.", "configspace": "", "generation": 57, "fitness": 0.2625869238676615, "feedback": "The algorithm Refined_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.7021231000789596, 0.7050203969909716, 0.7176492907269605, 0.6918943037498919, 0.7343089488453065, 0.7137955116346903, 0.7021760932577691, 0.7087866943134389, 0.7174971329560319, 0.35471390183792595, 0.3434631024184365, 0.4216185342542088, 0.3683164954601089, 0.3586964550544438, 0.33154385721325796, 0.32970853665388233, 0.050698922206610764, 0.394918282344789, 0.13381883862579702, 0.11592225603932871, 0.1664028597692453, 0.10325682265378056, 0.42173832000514266, 0.11776422944173226, 0.1204009015994365, 0.12972987286842164, 0.11040917853228804, 0.08853626268392312, 0.11312411974323755, 0.1110731952538625, 0.11722894298683773, 0.1078999966779558, 0.1100951410962916, 0.1367930428743146, 0.09270727269364876, 0.11433986644509009, 0.9791420001319112, 0.9761726018455765, 0.9777969482699597, 0.9702394448764213, 0.9770716145856208, 0.9701473368450191, 0.9866254905469993, 0.9830973647064133, 0.9764060895933172, 0.3734831914100424, 0.3781389579441585, 0.30460888285209264, 0.36370245786110245, 0.3433797071614636, 0.44801021931702567, 0.365406593090125, 0.32732152350767096, 0.35996744822437177, 0.5812766783755645, 0.22137239688420163, 0.47970008807850206, 0.20952315313546377, 0.21132979117057382, 0.20549195637504014, 0.22130848963968508, 0.6930496310767669, 0.5853195022647034, 0.17339605049061524, 0.09461803995798224, 0.15808752579994745, 0.12024762210143924, 0.18252495008373937, 0.09622614541797847, 0.18174054426889596, 0.19158472524258696, 0.17735016703827622, 0.16283077335590113, 0.18029733200982323, 0.18755871005561287, 0.18945827493073097, 0.11415870206648893, 0.14337772012052719, 0.19855474833774656, 0.17572993987907504, 0.23838336974420749, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007303723812140728, 0.06604953143109815, 0.05139677484157068, 0.07364695353564421, 0.07724346414826122, 0.08237559174911713, 0.007809230202160511, 0.09340959050333553, 0.079323971148057, 0.03771379603902314, 0.07026296851650282, 0.025768434460340717, 0.024093991593838515, 0.07651204781651555, 0.05934251022154202, 0.12021125355043971, 0.07429859265586036, 0.10110500687494917, 0.050629346983179, 0.16356025481084557, 0.03857548657202947, 0.11340379693714531, 0.1899216351855354, 0.03678265630494337, 0.05032511636760939, 0.05433699826343141, 0.0755605391578561, 0.07345655994618405, 0.4595106871418796, 0.4912673327931165, 0.46067475867101837, 0.5189062211104583, 0.5158460076697798, 0.47867525832090274, 0.48076115798769437, 0.49520942097591114, 0.4852489312953724, 0.11757283158394582, 0.06162582095820579, 0.11498313884731326, 0.1459658132045183, 0.10497755780656204, 0.13382145486066332, 0.11044458298324067, 0.09232506945758923, 0.11691353976164698, 0.2443711153478041, 0.1616534582156106, 0.14320060001923762, 0.24952094807116565, 0.21079361225701776, 0.13862354127748133, 0.20805879054138954, 0.18971699877189097, 0.14799967936239722, 0.3381555531264341, 0.3989818119161537, 0.3985523907229619, 0.3738529655328082, 0.3667711199831588, 0.30850039090519066, 0.207565824900257, 0.3382272213454862, 0.44602399333598175, 0.21017491223927798, 0.1906620307551281, 0.19712838391065035, 0.2787196449098589, 0.30525410445891643, 0.20378497930603412, 0.28908662925285167, 0.27182236949288885, 0.15314098591945824, 0.221677476904784, 0.1856749260757954, 0.20479303149350359, 0.16824854064251726, 0.18284686589371624, 0.22809696140974534, 0.19557359668292051, 0.1875266794028808, 0.1716914754803187, 0.18503814393527518, 0.19857200547614684, 0.18381829007615502, 0.20287566359355824, 0.5242640751491591, 0.1886253689151598, 0.19130011591764517, 0.21381723351277793, 0.21630718974808127, 0.7511882723633451, 0.1635037598230159, 0.15176314150089443, 0.7749386583393113, 0.1958250603544961, 0.1958965868463658, 0.19038562824288097, 0.15831982458655636, 0.6531133553580477, 0.71948152222324, 0.21106809454815878, 0.4670121650319097, 0.2055780015057873, 0.5120513117234982, 0.1510966193230039, 0.14963147057359638, 0.19092432254006686, 0.1527812453243661, 0.17095282495863262, 0.18841743977905212, 0.16929393793671355, 0.19008392160746634, 0.18069792278963337, 0.19982522131789215, 0.18240152083358785, 0.180939126895594, 0.1737776078340859, 0.08086659913463068, 0.0879877835621955, 0.08133659331193355, 0.07631498571360007, 0.06709786233126891, 0.07051864969956767, 0.09271955717303115, 0.08382478547532568, 0.07273348894613951]}, "mutation_prompt": null}
{"id": "0ee6dcf1-e06d-4813-b276-6b868352a25d", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.5  # Reduced for better balance\n        self.social_coeff = 1.5     # Equalized for balanced influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.85\n        self.elite_fraction = 0.1   # Reduced for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def adaptive_control(self):\n        progress = self.evaluations / self.budget\n        self.mutation_factor = 0.8 - 0.5 * progress  # Dynamic mutation factor\n        self.crossover_rate = 0.9 - 0.5 * progress   # Dynamic crossover rate\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adaptive_control()  # Apply adaptive control\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Increased frequency slightly\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A refined hybrid PSO-DE algorithm with adaptive mutation and crossover rates inspired by dynamic parameter control to enhance search efficiency.", "configspace": "", "generation": 58, "fitness": 0.27702470992978623, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8328209270995424, 0.8420480779336468, 0.8038359685123977, 0.8337239247729292, 0.8423956726245365, 0.8346087450441178, 0.8180801906014069, 0.822110668803984, 0.7967796589765268, 0.4506990215590747, 0.04601505201934719, 0.44331152560158404, 0.5220221968317462, 0.48721905639966556, 0.44046391211704716, 0.46628833797973823, 0.5336144008526044, 0.38724268502335946, 0.13277008133537727, 0.38906972908980775, 0.14486295006167582, 0.14249096861700306, 0.12801183345213396, 0.13949453442559312, 0.1489335396787156, 0.13843944968586497, 0.1710270703422715, 0.1228644024277542, 0.10864703956909816, 0.11662281278358788, 0.16045896562225392, 0.1369712795575868, 0.1244064987397111, 0.1388248523475748, 0.15107569569249668, 0.12547403642046795, 0.9845831165646999, 0.9738120899477789, 0.9783285772997228, 0.961792235841196, 0.9664635782161985, 0.9612487550866203, 0.9754564416053427, 0.9770274428151404, 0.9754048829654595, 0.38642786011329366, 0.47189717876250215, 0.4108707721963467, 0.4523716001756132, 0.49120508977065036, 0.3646300257865266, 0.43156412048817416, 0.46068994219727954, 0.44314087657082113, 0.16866222629727767, 0.5449018968341142, 0.1678489168732531, 0.19300653180398952, 0.18936880121862631, 0.20912950379123618, 0.1735093471308028, 0.7881922134961363, 0.35192402413837387, 0.18311729864287796, 0.0932743109257077, 0.11750361197620263, 0.18419199680086928, 0.12665457022989524, 0.0999245645308462, 0.16513161192574421, 0.1691904720822096, 0.21115354439806822, 0.18981674620677857, 0.2035934818256534, 0.17181943171426395, 0.13057106984975886, 0.14075192200820197, 0.2027504226642901, 0.22831714080975307, 0.14517036700274766, 0.19462594993744375, 0.004977466618185433, 0.04169452846963506, 9.999999999998899e-05, 0.037265218789706345, 0.011743376754593915, 9.999999999998899e-05, 0.002016855631639225, 9.999999999998899e-05, 0.011063408695752175, 0.06962000670281465, 0.04638375350886348, 0.0998172968848452, 0.0925474036631313, 0.015124614286936011, 0.03023085479330534, 0.10452215741104176, 0.08275519712303248, 0.09363751016684396, 0.1306987762332792, 0.16445094842914076, 0.04607119570875606, 0.08576538955565416, 0.13058873110499591, 0.07191941131392965, 0.08898878206552241, 0.16042467796679816, 0.09565803143289053, 0.3690144189793356, 0.08074320586834549, 0.09233765805281546, 0.024222286121315828, 0.11759729902719884, 0.16990571090462303, 0.05608704449919455, 0.08004902457615792, 0.08209031717793147, 0.49665375433391257, 0.5067066125122298, 0.5286511494631088, 0.5652331755706765, 0.5046089486442387, 0.5188437801959527, 0.5492899840593145, 0.524358733942406, 0.5420264518766822, 0.09173391524785124, 0.11229314019410053, 0.09699665946108638, 0.14854880412513194, 0.0768361573351356, 0.13089051445730382, 0.11258139699607961, 0.09835123456634975, 0.11322303483367846, 0.16849203648158617, 0.18152556970651545, 0.24460843620909123, 0.17354409353987632, 0.1607941580014578, 0.21067115993040575, 0.40740565966922915, 0.2470460567795576, 0.24108004759459845, 0.253074663339689, 0.36326165877898675, 0.4371786136049727, 0.2923032045899018, 0.28413370342327027, 0.45280489767471777, 0.3832983105947103, 0.29896638576947887, 0.3234060305111137, 0.2013589921236565, 0.2265876363220949, 0.2930423504642179, 0.25218698178485044, 0.17259655177867117, 0.1826094584950021, 0.34570056944311434, 0.24176551892184672, 0.24368797903954442, 0.2203757933542757, 0.23051396869179486, 0.21798422549507035, 0.20410367469400448, 0.2291133343420536, 0.2187204920559056, 0.19333325829992898, 0.18747693595131143, 0.20675597192637396, 0.20480516236506463, 0.2079389186620475, 0.5881233798632591, 0.2036451427938789, 0.18972428997599877, 0.1891643237992896, 0.17696793880170025, 0.20423635916600968, 0.2123125839037039, 0.8814261378660325, 0.1662644355406011, 0.15365077658289283, 0.842208590666319, 0.1987456854944546, 0.1683287626293457, 0.1728291747950832, 0.1639054604653849, 0.2108462552498922, 0.5902455277394671, 0.21248226034883788, 0.07333924051940177, 0.5434391005613912, 0.16894108818244835, 0.1523971428644263, 0.10440883171556392, 0.2089405624459354, 0.10375278023446333, 0.17938461908458936, 0.18873020104704163, 0.18398460422209573, 0.18464795431348635, 0.18842307038744344, 0.20210533400105568, 0.19986648792648198, 0.18231650490550333, 0.17653205309101483, 0.10967323792642325, 0.08031864248878484, 0.08047441300009617, 0.09231426835269174, 0.08076763538854725, 0.08318164377095438, 0.11310330113190581, 0.0963528204539218, 0.08769993027185885]}, "mutation_prompt": null}
{"id": "b3f645e7-03a4-4d97-a83f-917a1b8cc2cc", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.98  # More aggressive damping\n        self.cognitive_coeff = 1.5  # Reduced for controlled local search\n        self.social_coeff = 1.4  # Adjusted for better social learning\n        self.mutation_factor = 0.9  # Increased for enhanced diversity\n        self.crossover_rate = 0.9  # Increased to promote exploration\n        self.elite_fraction = 0.1  # Reduced elite fraction for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.7):  # Adjusted beta for different step pattern\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight = 0.5 + 0.5 * (self.budget - self.evaluations) / self.budget  # Dynamic inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate - 0.3 * (scores[i] / self.global_best_score))  # Dynamic crossover\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive learning rates and dynamic crossover to balance exploration and exploitation more effectively.", "configspace": "", "generation": 59, "fitness": 0.19373757873568315, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.4596404239045804, 0.4440772429542782, 0.46881844205132706, 0.4735847341044046, 0.5011410602817288, 0.49319639785101, 0.5007086893836432, 0.48565512149840784, 0.48548694040802054, 0.15633043863276597, 0.1248940586404157, 0.13587966103871663, 0.13304284975210046, 0.13464362073331282, 0.13716893645999428, 0.12937184731324702, 0.022912273319438126, 0.11249811595869375, 0.08949833415618036, 0.08798228139285802, 0.07833993009999995, 0.07486524110256254, 0.10000372561959303, 0.09746753052416768, 0.08598994426489937, 0.08732248071303417, 0.08003725412822749, 0.060252856041510094, 0.07417277809222234, 0.06678524072514624, 0.07942923892936393, 0.08179666836707089, 0.09325519832554785, 0.07699275235509562, 0.06815175839831222, 0.07000374617236937, 0.9777353597732416, 0.9772613570603438, 0.9831338768217353, 0.9780149902384639, 0.9764354003843501, 0.9778644962415022, 0.9775609608646635, 0.9780401219219715, 0.9706308004675442, 0.2772381533228765, 0.26090966266616733, 0.2661043598516072, 0.22269271719915051, 0.22182330565056874, 0.15317896163600364, 0.09403063312355042, 0.13956239534992798, 0.16748649537126548, 0.16202182819783972, 0.25454155158863034, 0.16416496264905267, 0.1962010609603715, 0.17806768360984748, 0.18083697691891853, 0.33080616578607114, 0.3008917211337677, 0.4285244571258341, 0.12390227070963589, 0.07166119831842899, 0.1196023075321182, 0.05834819024582216, 0.17557459990251134, 0.06434687484963053, 0.11830961421074737, 0.11120582174114735, 0.1270798924567229, 0.10011362643492572, 0.2282585914121431, 0.08188740861590127, 0.11045355582247463, 0.11629983887154227, 0.12819461195595483, 0.1281518492195033, 0.051272040684239295, 0.16115151328891353, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00048293512506547565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03887286210157892, 0.06298595330344592, 0.09053984718208974, 0.06181972441639261, 0.022963019352753133, 9.999999999998899e-05, 0.026908654061816417, 0.021669820032501952, 0.042282043296114735, 0.017185907771169684, 0.012516646741340676, 0.017877878047410922, 0.0313562758629341, 0.029105730482010372, 0.028648314786852258, 0.030145293352498492, 0.03379929740635723, 0.03984647408573161, 0.031918982977527266, 0.028137392127316474, 0.06832600586288662, 0.008074770948497623, 0.04568115138594786, 0.011583377032622577, 0.09108118206149629, 0.04265310715091164, 0.04949364933618672, 0.3489464023580877, 0.34764457571479157, 0.34487553840069884, 0.36792141144164525, 0.37257189066735485, 0.3776270629400931, 0.39324878457036183, 0.3628613382765081, 0.3842789262793812, 0.07031707051547686, 0.0846352481334347, 0.0685982120744626, 0.07065114778986459, 0.07740698869912499, 0.08350515048666951, 0.08285573337319807, 0.07456240639182943, 0.08934512972154207, 0.1436868482868653, 0.1749300940998415, 0.12844621002842183, 0.14654717563757336, 0.21445902212919732, 0.26348887813885835, 0.18214562798919143, 0.1400938825892818, 0.1506700590827048, 0.21869536013130675, 0.17120362152637758, 0.2404851925977557, 0.2147464489488452, 0.2547164198718238, 0.26691368200672283, 0.28847566507008815, 0.2924291816735828, 0.2724081265506979, 0.18894612416989043, 0.20853230018308977, 0.22685257747535348, 0.1530892161863996, 0.15663436907566264, 0.19475710931401535, 0.14866988989329988, 0.2095210270878478, 0.17478153398248775, 0.22007971486374767, 0.1950600748620045, 0.18218048330413839, 0.15945551201922903, 0.16807630007821606, 0.16680808001036307, 0.1782119344968529, 0.16843741266840684, 0.1712637164551648, 0.16798620959754063, 0.18345037364741745, 0.17424856727872806, 0.19060562028950545, 0.16904374084432328, 0.18573859500010637, 0.19181599165111884, 0.18125499417481705, 0.17800015659044732, 0.5641984700943912, 0.15778141896692177, 0.15064268814072168, 0.4515810623966521, 0.1922090583544077, 0.18836549308564376, 0.1665943780001108, 0.13997116747308336, 0.16605774156341646, 0.21807203230765615, 0.19759949458445747, 0.2830666394072273, 0.2319953738489895, 0.25871951370674195, 0.22945303880990964, 0.20148993234268264, 0.27573560912455175, 0.1369428270888995, 0.18300214453225205, 0.20157825112132322, 0.17898041990432267, 0.18806834288842533, 0.18766536230137454, 0.18094952235027606, 0.1817382675093977, 0.17940734709466744, 0.17679281240746803, 0.06307668882383222, 0.0659421454621072, 0.07602919718888423, 0.054757701119426905, 0.0599671788045536, 0.07153834676697102, 0.0706642786890066, 0.07488609618506759, 0.07207245289457465]}, "mutation_prompt": null}
{"id": "71ac1aa2-44e0-4dc0-bbb7-621503b360fe", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.92  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.8  # Improved local search capability\n        self.social_coeff = 1.4  # Increased for enhanced social learning\n        self.mutation_factor = 0.9  # Higher diversity\n        self.crossover_rate = 0.75  # Encourages exploration\n        self.elite_fraction = 0.2  # Higher elite fraction for robust convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.04 * step  # Increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Increased frequency\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.percentile(scores, 75)  # Considerably more stringent reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Refined", "description": "A refined PSO-DE hybrid with adaptive learning rates, enhanced diversity mechanisms, and tailored mutation strategies for improved convergence performance.", "configspace": "", "generation": 60, "fitness": 0.2952093959279513, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8815109231048527, 0.8190822429819417, 0.8228711861689373, 0.8829319015466554, 0.8249836395358909, 0.881711661402666, 0.8702997768924374, 0.8046171216711638, 0.7977411342860559, 0.5487315415120138, 0.4870657555256338, 0.49224884732236673, 0.6845880355054987, 0.6473252356180107, 0.460786784449574, 0.48659284564416616, 0.5690599813189108, 0.45164805888651705, 0.1472133974039831, 0.42960839992854416, 0.09154991339172847, 0.46694350504818805, 0.14020742498970107, 0.11680338242662858, 0.12745901784931557, 0.1374069266968332, 0.1541150636061095, 0.14297318679004178, 0.09324327880605054, 0.12702774013654894, 0.13378568482030928, 0.12873017066545633, 0.13478366767461625, 0.13977337161391312, 0.12210153437416871, 0.17434776024693965, 0.984915515434258, 0.9764423806001563, 0.9759242300562548, 0.9630460235300509, 0.9758458556541479, 0.9697507305220716, 0.9778379015311542, 0.9704347710858421, 0.9756469653257891, 0.44708694679567806, 0.45428491319838227, 0.31827886174973485, 0.3282240773781756, 0.40508883387098515, 0.38730910887101244, 0.26747957518856114, 0.515112354239026, 0.4050535442808978, 0.8372936612357784, 0.22608637170663293, 0.808853257789082, 0.21096779942252653, 0.27289529410755453, 0.27343280853315177, 0.2119339823541112, 0.8225594694332451, 0.22825307382748505, 0.2929043264316953, 0.12413641702128864, 0.1646111684005036, 0.17794881031669196, 0.16632140612550206, 0.10201143213302089, 0.167438620307796, 0.1785289865342422, 0.16728765906900755, 0.1782706723911368, 0.19785596599781452, 0.12720416736766715, 0.20892916072799672, 0.1998762661598682, 0.20168835085592962, 0.20467081328645842, 0.09777709951468427, 0.21854206610302485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054459605991782345, 0.04770925131369963, 9.999999999998899e-05, 0.06975733018204788, 9.999999999998899e-05, 9.999999999998899e-05, 0.09162984807123542, 0.052238618582831076, 0.07005951856906034, 0.11132388395587545, 0.028029559214392097, 0.018144651991304106, 0.06638784596878378, 0.11841591741216217, 0.06384325736917473, 0.03894361740733132, 0.1650867930998403, 0.04861222111712449, 0.3277013795925977, 0.18952734731988174, 0.2628427188929665, 0.2691575221723762, 0.08984117711968265, 0.09637297433754244, 0.042430983614488604, 0.04309571409499435, 0.07370045733949115, 0.011977082166066744, 0.05233420963473434, 0.0905750580796475, 0.18323447852783292, 0.08396673874678307, 0.08351900361513032, 0.5370273697323118, 0.5080069255505864, 0.5311118668507104, 0.52167773757968, 0.5175216517992063, 0.532909005577128, 0.5150175027467667, 0.507972285792914, 0.5140786675864155, 0.10276972639699034, 0.08250858888324952, 0.08491841665124844, 0.10723952525590374, 0.07997766099455716, 0.11395749249089804, 0.10706376115076854, 0.12626763723003875, 0.13805205586698321, 0.1422783845751091, 0.22672920502804883, 0.16538356437803214, 0.20592983720670377, 0.19449147788090726, 0.12883417969298372, 0.18502674609522485, 0.1560926863719646, 0.17623683316322603, 0.2191913631667166, 0.30064166808755277, 0.3523908707464749, 0.3690933298427802, 0.27159860484131226, 0.35037484777830974, 0.38835822491723626, 0.471238837673734, 0.46295843501003275, 0.1787190707788634, 0.19150807427472993, 0.20855220799201224, 0.24497425622962232, 0.20982138429778008, 0.2132493342478975, 0.2549820892482648, 0.3706990593356525, 0.2765085114343385, 0.1927378629702302, 0.18643589256128412, 0.1815631605666379, 0.2676207205636021, 0.2137232713198215, 0.1927334912570262, 0.19148159723309033, 0.19098272757190826, 0.20522150734150757, 0.19712604358842234, 0.22064525756695197, 0.20100046765931767, 0.24938417754624087, 0.726612969067052, 0.20690920485466857, 0.21481562952558242, 0.21276095006804485, 0.20703842314143506, 0.1839464890538538, 0.15427526129264202, 0.1521441026793, 0.8904559323092969, 0.19886459287423064, 0.16639846284929005, 0.14138114591937734, 0.8653733992234283, 0.880946867603915, 0.5748546981184265, 0.21042937897195757, 0.6112544625041147, 0.3976657812204273, 0.1677656086504472, 0.15357074769242285, 0.5540430313269178, 0.10427576262344451, 0.34552044573108764, 0.19746559190323976, 0.19338826996015013, 0.17741476699833125, 0.1999962427339459, 0.1977121818029116, 0.18077170991090297, 0.20148414355900945, 0.1808330554220745, 0.17502170281964335, 0.08263479822087716, 0.07468952468134993, 0.07555983787020082, 0.08933868306016834, 0.08158408921140237, 0.08354798350991566, 0.1498370978951289, 0.09183243886202141, 0.09179999812024542]}, "mutation_prompt": null}
{"id": "065abc61-b9cc-4d47-8819-56be8906425b", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia_weight = 0.6  # Fine-tuned for exploration-exploitation balance\n        self.inertia_damping = 0.98  # Better damping for stable convergence\n        self.cognitive_coeff = 2.0  # Increased to enhance local search capability\n        self.social_coeff = 1.5  # Adjusted to favor cooperation\n        self.mutation_factor = 0.9  # Increased for broader exploration\n        self.crossover_rate = 0.9  # Increased to improve convergence speed\n        self.elite_fraction = 0.1  # Reduced to allow more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.7):  # Adjusted beta for more effective random walks\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step  # Reduced step size for controlled exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Increased chance of applying Levy flights\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:  # More frequent stagnation handling\n                stagnant_indices = scores > np.mean(scores)  # Adjusted reinitialization criteria\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Improved", "description": "Enhanced hybrid PSO-DE with adaptive search mechanisms, refined exploration-exploitation balance, and stochastic reinitialization for improved performance.", "configspace": "", "generation": 61, "fitness": 0.2577455815533486, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.6971186744191096, 0.7247773211340434, 0.7308513025396246, 0.7379297723303947, 0.7594722210041541, 0.7319153550404746, 0.7121734843698501, 0.7721219211447348, 0.7330056955585904, 0.2864121994020944, 0.3321324350602015, 0.4263526361021869, 0.28087726119156053, 0.24554911379532807, 0.3335371845092354, 0.2561107231529688, 0.27610954583822866, 0.4209413946756957, 0.13302923978004344, 0.13173385887785827, 0.12941055375786437, 0.10494763482933234, 0.13547489685674796, 0.13427286833406693, 0.11051055627988826, 0.15029824188439767, 0.16392591516411414, 0.10932105056711228, 0.11811219408636442, 0.12273169529055905, 0.12630334540458787, 0.1190612346422587, 0.10429410532084327, 0.09928529362553928, 0.11897309757165697, 0.10598695497903032, 0.9734719989906709, 0.9844425347918405, 0.9719657937419078, 0.9754836080886062, 0.9727655812481416, 0.9693606792985546, 0.9837528509526686, 0.9839546494592478, 0.9741877463046643, 0.33985609915640314, 0.32287980349568846, 0.3103207512148475, 0.28451106731804143, 0.18217768821207803, 0.3009325462754746, 0.18008312823815975, 0.3386347668891736, 0.29282306353655563, 0.31424459345433653, 0.21464062735968015, 0.20567258447219305, 0.21146227234586157, 0.3534539676854783, 0.20365722195959635, 0.4244698681251585, 0.2067378914514808, 0.5629940159039714, 0.16988314379313485, 0.08936680225962079, 0.1710120436775675, 0.16613523044431955, 0.17435763537514126, 0.12003193990286887, 0.15749912570128655, 0.28923318996260416, 0.17955619638499898, 0.19501716989119589, 0.10951292786754352, 0.1853574941938333, 0.13065471353078317, 0.1710006806521891, 0.184729540034288, 0.16282220052159102, 0.18937126745193655, 0.2080616166008462, 9.999999999998899e-05, 0.05733145130168216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05794018073174323, 9.999999999998899e-05, 9.999999999998899e-05, 0.06351377707690808, 0.036600566659534706, 0.04818453146249735, 0.07726838703871397, 0.04811742126256735, 0.0031006246838874985, 0.04944550926364155, 0.057632671311436234, 0.029432742280803392, 0.03922952009077885, 0.030276506589747454, 0.19451474086682297, 0.10730487502064134, 0.11078006113722116, 0.0760294873702303, 0.07629976463465915, 0.07849215472167892, 0.05828116975415176, 0.09422273050181451, 0.0392505054602057, 0.11183668152013326, 0.21295272661530706, 0.1983417979615032, 0.1702965624358862, 0.09277418764020462, 0.10546677556673589, 0.07623791484922327, 0.47147654276098694, 0.4944962835265949, 0.4855057310304647, 0.4263976283490343, 0.485352148729826, 0.47553411597706763, 0.48933382824184224, 0.47948019232498984, 0.5161000461666896, 0.09172909126224604, 0.08932308182303172, 0.08396677779876938, 0.10718297554339373, 0.07182058617819986, 0.09720691969953454, 0.10127822167676426, 0.07236658822256792, 0.11998028704248664, 0.21546639237272713, 0.14018770761889732, 0.15435148865601245, 0.14830965353630332, 0.14268033042597306, 0.17034483527507072, 0.20198491192026002, 0.19906864323872087, 0.22051727543969668, 0.37778980942630025, 0.35506555645188376, 0.3681994846611668, 0.32183102443503864, 0.4040052853989331, 0.3670688501932584, 0.383236764203681, 0.4058761027705742, 0.3738006320040317, 0.1910795755989717, 0.2773753557302734, 0.2242661642174314, 0.1705214591379356, 0.17583160061524483, 0.20638780944666268, 0.2552576446632343, 0.3288377805867997, 0.2801053651467461, 0.1915997226439684, 0.17727786045055616, 0.19879665885807496, 0.18324700447282416, 0.18286639257306891, 0.1799014334211897, 0.19184771841693604, 0.22102279474321562, 0.20480764740484447, 0.23637991659039304, 0.23801693650505618, 0.23355507374763607, 0.22685135245003107, 0.2003959060278625, 0.2268903706740124, 0.17816970606586746, 0.3683140385580356, 0.19900485247122934, 0.7198976836545263, 0.1858935458499693, 0.18614708791032186, 0.8267267173248588, 0.1967939725831086, 0.19731691780774885, 0.1860396536203731, 0.15603964765729883, 0.7574928035016905, 0.4147466509831642, 0.5359205944200816, 0.2023813605274306, 0.2070572751459776, 0.3698094200907429, 0.12606376020602328, 0.2052958324542089, 0.20478073900085159, 0.41575670359978456, 0.18399101660215966, 0.17703363843150832, 0.18945426322604986, 0.17794301078535335, 0.18185415194673138, 0.1765408246526784, 0.18375640683786565, 0.20014341836411798, 0.17657382653719578, 0.07241490362033887, 0.08821435227213004, 0.0807060072205733, 0.07814223398727538, 0.07353049642709863, 0.09290473265040655, 0.07549681599002667, 0.076208215821992, 0.06759567566317548]}, "mutation_prompt": null}
{"id": "959fb0ac-ed9c-4201-91dd-73e1496b054a", "solution": "import numpy as np\n\nclass Quantum_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.6  # Reduced for more dynamic adaptation\n        self.inertia_damping = 0.94  # Slightly modified for stability\n        self.cognitive_coeff = 1.8  # Slightly boosted for stronger local search\n        self.social_coeff = 1.6  # Increased for better convergence\n        self.mutation_factor = 0.85  # Enhanced for diversity\n        self.crossover_rate = 0.8  # Slightly adjusted for balance\n        self.elite_fraction = 0.1  # Reduced elite fraction for diverse search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def quantum_update(self, size):\n        theta = np.random.uniform(0, 2 * np.pi, size)\n        r = np.random.rand(size)\n        step = np.sqrt(-2 * np.log(r)) * np.cos(theta)\n        return 0.02 * step  # Enhanced quantum step scale\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.quantum_update((self.pop_size, self.dim))  # Integrating quantum steps\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Hybrid_PSO_DE", "description": "Fusion of Adaptive PSO-DE with Quantum-Inspired Search Strategies for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'tuple' object cannot be interpreted as an integer\").", "error": "TypeError(\"'tuple' object cannot be interpreted as an integer\")", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {}, "mutation_prompt": null}
{"id": "df10d0bd-b428-488f-a91f-97656373ac02", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.3\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.85\n        self.elite_fraction = 0.15\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_seq = self.generate_chaotic_sequence(self.pop_size)\n\n    def generate_chaotic_sequence(self, n, beta=4.0):\n        x = 0.5\n        chaotic_seq = []\n        for _ in range(n):\n            x = beta * x * (1 - x)\n            chaotic_seq.append(x)\n        return chaotic_seq\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n            \n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n\n            for i in range(self.pop_size):\n                if i in elite_indices: continue\n                self.mutation_factor = self.chaotic_seq[i]  # Use chaotic sequence for mutation factor\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE", "description": "A refined PSO-DE algorithm introducing chaotic maps for parameter adaptation and dynamic elitism to enhance convergence speed and solution diversity.", "configspace": "", "generation": 63, "fitness": 0.2503448262126397, "feedback": "The algorithm Refined_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8571986535435865, 0.8042072072244869, 0.8563418485162314, 0.7924704486711038, 0.876455041496633, 0.8577787315567651, 0.8648762269273893, 0.8719064203268427, 0.8449659873347386, 0.5646315282644989, 0.033434290018486745, 9.999999999998899e-05, 0.16858668545197775, 0.2018481516767895, 0.277314185750712, 0.0427975407099348, 0.13264038685966206, 9.999999999998899e-05, 0.17913543606042515, 0.13494677855970516, 0.12048797781421328, 0.10628734025023223, 0.08622200612963493, 0.13864147183520958, 0.1704234555929861, 0.11235411305156362, 0.15660467297281044, 0.0922465356862936, 0.12759000095712758, 0.11699847520794715, 0.11536733081177009, 0.11015992858860135, 0.1071237635688822, 0.09131298626165085, 0.11189376238697057, 0.11069235810665323, 0.9622298110448917, 0.9543999191138431, 0.9777824230844182, 0.9131786890580762, 0.9505748192563435, 0.9529212345671525, 0.9537088582362532, 0.9629231764928021, 0.9540551244164392, 0.5240033177335209, 0.27710464060525697, 0.08962053254799518, 0.26741703489685464, 0.45636950742602955, 0.1760856395153252, 0.47941049738909214, 0.09690524664113909, 0.5316243846390387, 0.2240506208691746, 0.22461083082288946, 0.20625922605096225, 0.20773204492428265, 0.8590219582619987, 0.19266792470287852, 0.12883794673432003, 0.23255542630471526, 0.1938464625361248, 0.2491806854816635, 9.999999999998899e-05, 0.13319547574670598, 9.999999999998899e-05, 0.3185437613901545, 0.03954224570739573, 0.12421641658082772, 0.3359347282391273, 0.1589536927427163, 0.12507898712977528, 0.14393402422653234, 0.1130296676274376, 0.16145454627168787, 0.1451610443997985, 0.18407870068311905, 0.13303501415162022, 0.07551469671356714, 0.16006310690687264, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04682607067251743, 0.062237639383333265, 0.062984874508626, 0.08081819851654382, 0.016678826599546892, 0.011873215671247217, 0.024098433064830393, 0.040132480536305914, 0.050285025782273673, 0.048358729665497036, 0.0243730769968441, 0.046344146625617366, 0.125838025196934, 0.07601081509650065, 0.07457001617279979, 0.09566551357802888, 0.13848658863359886, 0.1299593721019764, 0.10571576072747024, 0.042211408312411325, 0.11117211933100757, 0.15480295152987222, 0.03698935279339388, 0.1277495773274171, 0.05523412037752096, 0.06272637110938772, 0.08253804926616848, 0.5369864003450608, 0.4983038861002217, 0.5019968648964073, 0.5344932797339683, 0.5497340624209625, 0.41090381560861033, 0.5036576531892482, 0.5038869232146264, 0.5025855432102164, 0.08945665624265353, 0.07590988158064516, 0.09119589087560309, 0.14308645635705597, 0.14892802833476837, 0.13343277142664123, 0.11113879734140153, 0.11447544662970899, 0.13067043738120498, 0.16123032347335886, 0.18093696972820172, 0.19038087231033574, 0.25939436695265683, 0.200627192567838, 0.19307512661527926, 0.22561954397367767, 0.22881536570592176, 0.24229939144867785, 0.33955472529191233, 0.3296562337248634, 0.3822351369092346, 0.3291816325900495, 0.3239570340822633, 0.24442557816803012, 0.5029480049304418, 0.35947495952042086, 0.2560392259071458, 0.272233695394938, 0.1841434620386041, 0.2040665792765861, 0.17414938913127476, 0.282000849463405, 0.32717563139430694, 0.2632892925294006, 0.2536469097641326, 0.22948303578574192, 0.20261216309345542, 0.23439273774041158, 0.20769388221456486, 0.1974823281872673, 0.18128865838414943, 0.23260536712792867, 0.24782082707596886, 0.19468328387915035, 0.20692319424205896, 0.1897027259358236, 0.20859912114384338, 0.20672249166935197, 0.20766469596675874, 0.2209360361021917, 0.1867904005771881, 0.24845756460739843, 0.18412202729469596, 0.19998101341427899, 0.857724170283199, 0.12613853428514632, 0.15323366015626982, 0.899554954679387, 0.19949463376133558, 0.19897766009651907, 0.1404755195041122, 0.15423651534684446, 0.8937785882723843, 0.43749087247186147, 0.20984176493435502, 0.07337099358110832, 0.10489215784398187, 0.23167137651927883, 0.14846468297265147, 0.10483077715464073, 0.10458402341758632, 0.34268464789460573, 0.18658895635883999, 0.18649427911923933, 0.1866056664526179, 0.16194061476754218, 0.2038602459183203, 0.19097972845368227, 0.1786682679141981, 0.189795923143536, 0.1864638893443451, 0.09295858302351312, 0.08058835305679035, 0.0983022604043765, 0.0800264135274954, 0.09211920622796965, 0.08910726715151973, 0.10611789711008945, 0.0987459465837981, 0.08157500835183751]}, "mutation_prompt": null}
{"id": "1f36e99d-9b88-4b43-9b01-0d119d28a10e", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for better balance\n        self.inertia_damping = 0.95  # Increased damping for smoother decay\n        self.cognitive_coeff = 1.7  # Slightly increased for improved local search\n        self.social_coeff = 1.3  # Slightly decreased for better individuality\n        self.mutation_factor = 0.8  # Adjusted for diversity\n        self.crossover_rate = 0.85  # Decreased to encourage exploration\n        self.elite_fraction = 0.15  # Increased elite fraction for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Slightly increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Slightly increased frequency\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # More stringent reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with levy flights and adaptive population size tuned for improved exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8465514055317322, 0.8584130011172402, 0.8423142261310044, 0.8395027420198429, 0.850645292776092, 0.845377202323184, 0.8445896727419407, 0.8501548218405086, 0.8441260038836712, 0.6378214904063313, 0.6719660887969487, 0.7209082213565088, 0.6443921714066068, 0.540910572288418, 0.7140228770077925, 0.555282933969062, 0.6694879652891521, 0.6849294543901139, 0.48877427067160495, 0.13079178660528068, 0.12574775096788493, 0.1620086435732645, 0.6030889113474797, 0.16666252515654434, 0.11013355812713399, 0.12758457615744734, 0.14154898275713002, 0.09515817987284281, 0.12546023769867864, 0.08900491787290232, 0.10568230850017024, 0.1294920142511461, 0.1072560195752742, 0.1265371067933857, 0.11998721571607496, 0.16211748116213964, 0.9706205930803956, 0.9711596132593356, 0.9763638016606752, 0.9773292840439873, 0.9693885407169206, 0.9690909079250204, 0.9758157680902546, 0.9708946434165069, 0.9621901778949653, 0.5691669630482059, 0.46961283077312066, 0.4973910665523599, 0.4201121031995376, 0.48841970939645596, 0.54635807499036, 0.49297700607450934, 0.2809948398798733, 0.5540031264347163, 0.7700016186085874, 0.6042450036575349, 0.36201197003507735, 0.20897367790859933, 0.1906842214086013, 0.2116939255102721, 0.21686745976567556, 0.5797773445475052, 0.22480201322216475, 0.19199768632302672, 0.1132535996974624, 0.1215866916486289, 0.12323699455806036, 0.12900453221962238, 0.11242657754506713, 0.18407367242848827, 0.1599759521698112, 0.16068735105124177, 0.17381250333702303, 0.18204861700983133, 0.17020525643788875, 0.16168422248500358, 0.12663791210404884, 0.15339264930168772, 0.21857064385485037, 0.18375405393062783, 0.3363414146560162, 0.0066448027695472645, 0.021023046123416322, 9.999999999998899e-05, 0.01945475542292474, 0.061929949549283214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09121363671334981, 0.06397593709398275, 0.042149443983783175, 0.05143762340394897, 0.04380797652090318, 0.01678491988290609, 0.10091953101581563, 0.07730809689550477, 0.042843060189797555, 0.11964982592702378, 0.03295922221766412, 0.047004235087243273, 0.13586801168990037, 0.0763013704267943, 0.06993299686970844, 0.11386702279078997, 0.14056478961088437, 0.0684616472274947, 0.08566387462898872, 0.052331939060304866, 0.053643978676413684, 0.07646868607479373, 0.24279613942193456, 0.12281811044016977, 0.08109786269743746, 0.0911445830532237, 0.0791376340349349, 0.5848553982160338, 0.506187131059677, 0.5373150955140398, 0.5357449825367806, 0.5590209195373443, 0.5145205925231355, 0.5636575847517706, 0.5179756070581236, 0.5568726150149331, 0.0976084299760761, 0.11807982882600832, 0.13245037822782868, 0.13108948273007204, 0.15942152960803846, 0.13338593639256235, 0.1471891774227324, 0.1103062374145658, 0.0737846929517082, 0.1969334685209675, 0.29159139793854527, 0.24255458667486962, 0.25078346582532873, 0.18157280192786862, 0.21811127858423285, 0.20414818537330148, 0.16848275431421866, 0.17891320389410081, 0.4206132741145343, 0.3819301867428353, 0.43149302463243233, 0.35866223206657555, 0.4822241565020069, 0.33823336420104033, 0.35927637655450295, 0.4018891373117637, 0.48229511501195654, 0.24536107269510643, 0.2612058698138874, 0.27768433982807683, 0.17797859128010274, 0.18991696786966317, 0.20317856018110847, 0.37608269391676186, 0.2704823031056087, 0.46085708832812944, 0.1945204161039652, 0.17845885265181427, 0.22626436773272762, 0.20040143939224142, 0.17998899990826345, 0.20540594996069284, 0.213920447721771, 0.21347935741030177, 0.2233857656866418, 0.1860984119938397, 0.2234069564642761, 0.7317687827471626, 0.18935881253089204, 0.24747566734575654, 0.18823473608467334, 0.20609585099765204, 0.21945635498103144, 0.18039623620071565, 0.8583608680341572, 0.16232104545064407, 0.15149284679966402, 0.17216004746502567, 0.19925205109299904, 0.16965957072964577, 0.14195395658921783, 0.8449808466839779, 0.20937873130830642, 0.5641940330335429, 0.20938530030203906, 0.6090055813536369, 0.461313840752575, 0.16640737028280406, 0.15237113120992885, 0.2033850803338937, 0.6285279749570692, 0.7135113942856692, 0.17993636010398173, 0.17441195027584377, 0.17379411516602705, 0.18361695267423306, 0.19380382578374822, 0.17337473372656986, 0.18179711144100463, 0.20162411505196365, 0.200533495953514, 0.08232288617055761, 0.07922660717959007, 0.11684857998326315, 0.08523534782645548, 0.08553193776345891, 0.10532415733246181, 0.08605057346517586, 0.08589408345201888, 0.08395411412376175]}, "mutation_prompt": null}
{"id": "33a1b8ad-7d87-407c-9981-a44f414a7fc1", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for better balance\n        self.inertia_damping = 0.95  # Increased damping for smoother decay\n        self.cognitive_coeff = 1.7  # Slightly increased for improved local search\n        self.social_coeff = 1.3  # Slightly decreased for better individuality\n        self.mutation_factor = 0.8  # Adjusted for diversity\n        self.crossover_rate = 0.85  # Decreased to encourage exploration\n        self.elite_fraction = 0.15  # Increased elite fraction for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Slightly increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Slightly increased frequency\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # More stringent reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with levy flights and adaptive population size tuned for improved exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8465514055317322, 0.8584130011172402, 0.8423142261310044, 0.8395027420198429, 0.850645292776092, 0.845377202323184, 0.8445896727419407, 0.8501548218405086, 0.8441260038836712, 0.6378214904063313, 0.6719660887969487, 0.7209082213565088, 0.6443921714066068, 0.540910572288418, 0.7140228770077925, 0.555282933969062, 0.6694879652891521, 0.6849294543901139, 0.48877427067160495, 0.13079178660528068, 0.12574775096788493, 0.1620086435732645, 0.6030889113474797, 0.16666252515654434, 0.11013355812713399, 0.12758457615744734, 0.14154898275713002, 0.09515817987284281, 0.12546023769867864, 0.08900491787290232, 0.10568230850017024, 0.1294920142511461, 0.1072560195752742, 0.1265371067933857, 0.11998721571607496, 0.16211748116213964, 0.9706205930803956, 0.9711596132593356, 0.9763638016606752, 0.9773292840439873, 0.9693885407169206, 0.9690909079250204, 0.9758157680902546, 0.9708946434165069, 0.9621901778949653, 0.5691669630482059, 0.46961283077312066, 0.4973910665523599, 0.4201121031995376, 0.48841970939645596, 0.54635807499036, 0.49297700607450934, 0.2809948398798733, 0.5540031264347163, 0.7700016186085874, 0.6042450036575349, 0.36201197003507735, 0.20897367790859933, 0.1906842214086013, 0.2116939255102721, 0.21686745976567556, 0.5797773445475052, 0.22480201322216475, 0.19199768632302672, 0.1132535996974624, 0.1215866916486289, 0.12323699455806036, 0.12900453221962238, 0.11242657754506713, 0.18407367242848827, 0.1599759521698112, 0.16068735105124177, 0.17381250333702303, 0.18204861700983133, 0.17020525643788875, 0.16168422248500358, 0.12663791210404884, 0.15339264930168772, 0.21857064385485037, 0.18375405393062783, 0.3363414146560162, 0.0066448027695472645, 0.021023046123416322, 9.999999999998899e-05, 0.01945475542292474, 0.061929949549283214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09121363671334981, 0.06397593709398275, 0.042149443983783175, 0.05143762340394897, 0.04380797652090318, 0.01678491988290609, 0.10091953101581563, 0.07730809689550477, 0.042843060189797555, 0.11964982592702378, 0.03295922221766412, 0.047004235087243273, 0.13586801168990037, 0.0763013704267943, 0.06993299686970844, 0.11386702279078997, 0.14056478961088437, 0.0684616472274947, 0.08566387462898872, 0.052331939060304866, 0.053643978676413684, 0.07646868607479373, 0.24279613942193456, 0.12281811044016977, 0.08109786269743746, 0.0911445830532237, 0.0791376340349349, 0.5848553982160338, 0.506187131059677, 0.5373150955140398, 0.5357449825367806, 0.5590209195373443, 0.5145205925231355, 0.5636575847517706, 0.5179756070581236, 0.5568726150149331, 0.0976084299760761, 0.11807982882600832, 0.13245037822782868, 0.13108948273007204, 0.15942152960803846, 0.13338593639256235, 0.1471891774227324, 0.1103062374145658, 0.0737846929517082, 0.1969334685209675, 0.29159139793854527, 0.24255458667486962, 0.25078346582532873, 0.18157280192786862, 0.21811127858423285, 0.20414818537330148, 0.16848275431421866, 0.17891320389410081, 0.4206132741145343, 0.3819301867428353, 0.43149302463243233, 0.35866223206657555, 0.4822241565020069, 0.33823336420104033, 0.35927637655450295, 0.4018891373117637, 0.48229511501195654, 0.24536107269510643, 0.2612058698138874, 0.27768433982807683, 0.17797859128010274, 0.18991696786966317, 0.20317856018110847, 0.37608269391676186, 0.2704823031056087, 0.46085708832812944, 0.1945204161039652, 0.17845885265181427, 0.22626436773272762, 0.20040143939224142, 0.17998899990826345, 0.20540594996069284, 0.213920447721771, 0.21347935741030177, 0.2233857656866418, 0.1860984119938397, 0.2234069564642761, 0.7317687827471626, 0.18935881253089204, 0.24747566734575654, 0.18823473608467334, 0.20609585099765204, 0.21945635498103144, 0.18039623620071565, 0.8583608680341572, 0.16232104545064407, 0.15149284679966402, 0.17216004746502567, 0.19925205109299904, 0.16965957072964577, 0.14195395658921783, 0.8449808466839779, 0.20937873130830642, 0.5641940330335429, 0.20938530030203906, 0.6090055813536369, 0.461313840752575, 0.16640737028280406, 0.15237113120992885, 0.2033850803338937, 0.6285279749570692, 0.7135113942856692, 0.17993636010398173, 0.17441195027584377, 0.17379411516602705, 0.18361695267423306, 0.19380382578374822, 0.17337473372656986, 0.18179711144100463, 0.20162411505196365, 0.200533495953514, 0.08232288617055761, 0.07922660717959007, 0.11684857998326315, 0.08523534782645548, 0.08553193776345891, 0.10532415733246181, 0.08605057346517586, 0.08589408345201888, 0.08395411412376175]}, "mutation_prompt": null}
{"id": "79f2cfdf-9f6c-4e25-aff5-8a883df67d2f", "solution": "import numpy as np\n\nclass Enhanced_Adaptive_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.92  # Improved damping for more dynamic adjustment\n        self.cognitive_coeff = 1.5  # Tuned for better local search\n        self.social_coeff = 1.4  # Adjusted for better global search balance\n        self.mutation_factor = 0.9  # Increased for greater diversity\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.elite_fraction = 0.1  # Reduced to enhance diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.2):  # Dynamic levy adjustments\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Increased step for more exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.15:  # Increased chance for exploration\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if self.evaluations % (self.budget // 10) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Adaptive_PSO_DE", "description": "An improved adaptive PSO-DE algorithm with dynamic levy flights and differential evolution strategies, enhancing exploration and exploitation through adaptive mechanisms.", "configspace": "", "generation": 66, "fitness": 0.28327127561832754, "feedback": "The algorithm Enhanced_Adaptive_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.815998539288663, 0.8347781244668742, 0.8016725256035337, 0.8153310902228569, 0.8443114720978944, 0.8279339858243213, 0.8118607986561168, 0.8498876474248487, 0.8050308882450874, 0.5349301606518291, 0.31185450835104733, 0.4704079502946109, 0.5302805965418629, 0.6551029323965365, 0.4857155102330184, 0.3345495379874974, 0.32381173820731224, 0.4885292519024921, 0.15358786301913696, 0.1586817871102998, 0.13371392278539063, 0.3203018397527053, 0.24728429407776997, 0.1163719111416811, 0.5300207945429016, 0.15514472040957972, 0.09747939079397305, 0.11171557532848819, 0.10008087982502623, 0.13320792781021373, 0.10937807249763354, 0.11661366862963352, 0.13321929111864483, 0.13067143135866666, 0.1248423657897958, 0.11941236376033448, 0.9766783648128173, 0.9831497163217716, 0.9852015684278121, 0.9621393837134429, 0.9676002362850029, 0.9675615215911495, 0.9867386887323376, 0.9827947952331808, 0.9739323823176808, 0.4739884946119155, 0.4871948997667629, 0.4145915544738292, 0.4806411632559551, 0.46929706712369623, 0.4220133325092844, 0.4675015860290188, 0.44898258455281426, 0.42920363276787266, 0.21677391844864724, 0.21955296498940335, 0.17085232976942266, 0.21251760884468474, 0.2751429395081716, 0.20528936922576724, 0.1735012785877449, 0.3251427839537139, 0.7117190539312961, 0.18667505694539832, 0.1281031647688149, 0.1772638805992467, 0.0971515877799769, 0.27866527070219216, 0.13091712934282373, 0.1697417459282453, 0.279237234686061, 0.12840185149817318, 0.18746322895140732, 0.6351646447628436, 0.1955903863784506, 0.17604575409479817, 0.1262820176466508, 0.19402081119035353, 0.1223769291625284, 0.08901868879108588, 0.22787888825616776, 9.999999999998899e-05, 9.999999999998899e-05, 0.0628922403926705, 0.05037749281928994, 9.999999999998899e-05, 0.040781412144910045, 0.0008327328946341472, 9.999999999998899e-05, 0.025686023803404012, 0.08514799506798643, 0.033510735717782736, 0.03970810184633644, 0.0904472423108662, 0.010851126888651752, 0.10295529029749761, 0.054700445660018304, 0.0658937456772144, 0.06888384610295584, 0.09053280829910915, 0.049098783107576094, 0.048144781666698, 0.10976382295315379, 0.07535697006581599, 0.0743852264684216, 0.12984869597344784, 0.09530086396301596, 0.06949060048953237, 0.08828559736594632, 0.10331361318283527, 0.13033483428041326, 0.007460648156161542, 0.16315858911221803, 0.14317971535551355, 0.20184306592373857, 0.08524528719813096, 0.08108181551737603, 0.4950366953157158, 0.49366666550326765, 0.49244542591624507, 0.5277832799799231, 0.5497011479911726, 0.4956281220624794, 0.5056501803942257, 0.5213484009802867, 0.5108612897478263, 0.07799013404375743, 0.1045982757707159, 0.09863498379592006, 0.11809277564682885, 0.11029806773754791, 0.11650358294946672, 0.12850353254605928, 0.10306721261725904, 0.1134515557756296, 0.19908040231157664, 0.20887410477470603, 0.1938177132385558, 0.2673097534338609, 0.1775891211658931, 0.18469333477861516, 0.24970272779421776, 0.16679589145375762, 0.1859808965012073, 0.19867234442482073, 0.2915104465963301, 0.3401451238336425, 0.4788199139696512, 0.3559011902097161, 0.34964777661706326, 0.42019530317832143, 0.45011589027786936, 0.3317926180175568, 0.24578207283543496, 0.3425386766180618, 0.23989235695181155, 0.27103891971929284, 0.22653732726500786, 0.2265751972956317, 0.3103580528097264, 0.2662968131767448, 0.3090338062558934, 0.21994927865098646, 0.23564631494266985, 0.19684088340259864, 0.2063365503603941, 0.23441269916388086, 0.1870242118356421, 0.19551447275816702, 0.19123262293736976, 0.19256466339054612, 0.18755733337151548, 0.1956567716380262, 0.20066541160406415, 0.5503039329685886, 0.20656995761519126, 0.2273034516029696, 0.21299347797350943, 0.1936685809846963, 0.21287724882620318, 0.16590050573123138, 0.16793696605850705, 0.15339190259696656, 0.8977893249740292, 0.19786439103607212, 0.19777170272101652, 0.14166402048362292, 0.1652559035503518, 0.8860319852237063, 0.6654989605899244, 0.21004459523297292, 0.0733386853614153, 0.4386116269317999, 0.438729984981982, 0.4099098323805246, 0.12310805435580985, 0.2036851245997534, 0.15281122914742795, 0.17627214016841497, 0.19398419748691287, 0.1844004625498954, 0.1730272523899481, 0.20157237929315486, 0.1769301847042538, 0.19051343508801133, 0.1837598415569397, 0.17997924315125313, 0.10260194172026482, 0.07545261870163922, 0.07783044438368492, 0.08750511624412882, 0.08918635452955115, 0.08796188018170747, 0.11681876213107367, 0.08292208576723281, 0.08514442912524578]}, "mutation_prompt": null}
{"id": "0729dc60-293c-47ca-9781-f92b8a917d8c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased initial inertia\n        self.inertia_min = 0.4  # Set a lower bound for inertia\n        self.inertia_damping = 0.92  # Faster dampening for quicker convergence\n        self.cognitive_coeff = 1.5  # Balanced for exploration\n        self.social_coeff = 1.5  # Balanced for social influence\n        self.mutation_factor = 0.6  # Reduced for stabilizing exploitation\n        self.crossover_rate = 0.95  # Increased for more trial diversity\n        self.elite_fraction = 0.20  # Increased elite fraction for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.0):  # Adjusted beta for better exploration\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Increased step size for greater perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight = max(self.inertia_min, self.inertia_weight * self.inertia_damping)\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Increased probability for perturbations\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.percentile(scores, 75)  # Adjusted for upper quartile\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "A refined PSO-DE algorithm with adaptive inertia and dynamic mutation for enhanced exploration and convergence efficiency.", "configspace": "", "generation": 67, "fitness": 0.26880933084996433, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.806429174384851, 0.7724431140001777, 0.7139647969600544, 0.7800091934425748, 0.7728787862649114, 0.7498953650316929, 0.7617653887165596, 0.7783819656991733, 0.7052473494464864, 0.22172429983214037, 0.39388942896041157, 0.38560582894523265, 0.3635117507695981, 0.5553236328034372, 0.2837760695371606, 0.04731092803166248, 0.5586873749089409, 0.3213140701471807, 0.13494316382102955, 0.14512197261192705, 0.10049850112362091, 0.1503639569989197, 0.15193653709820787, 0.14068803907135685, 0.09372289786043475, 0.12587087819484843, 0.30201832988929767, 0.12240018159630783, 0.09549970233745875, 0.11761642940499384, 0.10286367189412049, 0.10814288026993257, 0.13687622097315033, 0.13795153702223595, 0.1014899573178003, 0.15173433099906086, 0.979400690928982, 0.9714532518405685, 0.978255739165431, 0.9708085869448452, 0.971034338007926, 0.964611196237262, 0.9719203246877854, 0.9773876902447973, 0.9761246710216246, 0.3730201293800821, 0.38280735740993554, 0.3646411448131487, 0.3377907486859072, 0.4132012024531633, 0.34982618772097374, 0.29843991987883367, 0.3927113358466662, 0.3773947059439169, 0.21749973809836576, 0.22198339380832222, 0.16697942686560963, 0.272727616838602, 0.1918304775780344, 0.20284493835907447, 0.21410888680768614, 0.16949907670711395, 0.5794697528435756, 0.22731023206947476, 0.10926021479827175, 0.1863147759064635, 0.16743303435426005, 0.20680701605009633, 0.1766588580619135, 0.3387440634698681, 0.19182791173964664, 0.2007656096164867, 0.20340968667565762, 0.11394922406648933, 0.2010672835208821, 0.24338486385356772, 0.20006801344015934, 0.19557415973242975, 0.12692303105539982, 0.12679379705373683, 0.29228714344520124, 0.010946599401226886, 9.999999999998899e-05, 9.999999999998899e-05, 0.023090153615840436, 0.007632662372547783, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01538618828278182, 0.07045212411395874, 0.03891998049404466, 0.08291360638206136, 0.06518669657826559, 0.016099644874760122, 0.06897545846682829, 0.031189254385692755, 0.089205424016647, 0.07773935305188606, 0.02138846580374798, 0.02993984229693014, 0.04480770879539686, 0.07298844844325025, 0.11924307955533131, 0.07202357913844804, 0.09099730777666937, 0.10230343145165866, 0.09075544950791448, 0.21007596331700962, 0.044393383610142556, 0.03805450114020714, 0.15701005125351564, 0.050601036437316504, 0.187145020712429, 0.03954911777123338, 0.0788230575848422, 0.07801368982270274, 0.5116263435433834, 0.48875153631281687, 0.5276914624141724, 0.5544690063733935, 0.5178428902513317, 0.47157360327058695, 0.5185764967174139, 0.494873061127866, 0.5249426822716116, 0.11639208241051657, 0.09489459541095535, 0.15025295981375497, 0.09166848872218902, 0.12766996379239803, 0.16629475448739395, 0.1454696058692867, 0.0970496901729242, 0.10512039506829018, 0.16775494116277456, 0.18368859817225058, 0.16292294854229183, 0.17567983148672062, 0.3214811960202344, 0.15324557834318653, 0.17480366736594755, 0.18272172838610012, 0.1712099623248703, 0.26216625673179506, 0.2910552277628905, 0.3329119419204495, 0.3167828427691144, 0.19726630825505842, 0.2818133661054233, 0.3781020110500305, 0.28254508901857267, 0.4065979758051448, 0.2167520350338381, 0.23754334702706292, 0.20489374325977416, 0.19095148172928578, 0.28935058630158306, 0.20392088494203675, 0.20763803473056464, 0.35809297239972215, 0.2548556027577563, 0.19828182306642794, 0.18310179180961705, 0.20341237042874805, 0.1900343037733172, 0.21542997988887647, 0.1892386859483648, 0.18400431410388218, 0.19126073447379166, 0.24204838550127172, 0.21552584187919688, 0.23488707318208546, 0.21565732662225423, 0.2419854994868459, 0.20120661124353822, 0.5128874542836046, 0.4830645631553079, 0.19358126856833313, 0.20771075640024028, 0.6947991660411648, 0.16710680620381813, 0.15168158913887797, 0.8828667919435371, 0.2007145368748765, 0.8120331288790242, 0.14138823814695078, 0.16101398937189593, 0.2105055022300043, 0.7467976622155308, 0.20947107060470493, 0.6734684149434826, 0.47776543074858235, 0.1674913486539895, 0.15015390203063306, 0.10423694885165802, 0.10410926188547531, 0.644054772686383, 0.1918834169658553, 0.19959215468652114, 0.1774710443945794, 0.18766575908597183, 0.18527329355994748, 0.19407706039947026, 0.1855012441850672, 0.1888660382766919, 0.19539925393341695, 0.06850029764862264, 0.07401688510100479, 0.07415296199312726, 0.08206727598118324, 0.07978916655027657, 0.08862965543650703, 0.09875824798590016, 0.08145262751317295, 0.08023452234344963]}, "mutation_prompt": null}
{"id": "8cd38b15-c740-4271-aad6-46d40a806938", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.95\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.3\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.85\n        self.elite_fraction = 0.15\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.dynamic_mutation_factor = self.mutation_factor\n        self.dynamic_crossover_rate = self.crossover_rate\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n\n            # Dynamic mutation and crossover adjustments\n            self.dynamic_mutation_factor = 0.7 + 0.3 * (1 - self.evaluations / self.budget)\n            self.dynamic_crossover_rate = 0.9 - 0.2 * (self.evaluations / self.budget)\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.dynamic_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Improved", "description": "Introducing dynamic mutation and crossover rates with adaptive learning to enhance diversity and convergence.", "configspace": "", "generation": 68, "fitness": 0.3031261103512221, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.8468178741714175, 0.8426173460653594, 0.836618727469834, 0.8329757149801691, 0.8496189554575686, 0.8478404259436905, 0.847015838429126, 0.851494774156121, 0.8515124116072798, 0.6359313730908808, 0.5204334737909171, 0.6516456778268722, 0.637935224251347, 0.6553892586877137, 0.6718090019574319, 0.6449718946350029, 0.6531882710000526, 0.6925029617385166, 0.17234930586835107, 0.1713808283318523, 0.1311108955855822, 0.1717745460554716, 0.10873407956564951, 0.11799071489064716, 0.35338049554512563, 0.14372864554816678, 0.12914403946149544, 0.5506845042821648, 0.10758262376797689, 0.11340520107377361, 0.09548049403450554, 0.11966782719291713, 0.10790899932699416, 0.14362016416069945, 0.1024866659376692, 0.13291798705699198, 0.9789288045921407, 0.9705033929451066, 0.9932072083688513, 0.9774448955246763, 0.9756819627100907, 0.9688108209738324, 0.9767559387259588, 0.9760730483829856, 0.9704356191187609, 0.5124870995551738, 0.4620648551059032, 0.4275089853495412, 0.26710231109838833, 0.4113455506348074, 0.48952194839192176, 0.46227483373521294, 0.3546371854396525, 0.5396875253527836, 0.7596751949877674, 0.3651786544577267, 0.36843461553834955, 0.20571949614555074, 0.21500757927103387, 0.2667767974860543, 0.22661518698529826, 0.7666036346840418, 0.22652459125199265, 0.27923265233987515, 0.12311559513067494, 0.16691469152262783, 0.11872368526496613, 0.12475086715753314, 0.098574017443252, 0.18385204479308248, 0.17758648721901227, 0.2086156222735812, 0.1727819954455987, 0.26108942271662805, 0.17067836430440875, 0.13086212784386475, 0.1744572429977197, 0.1788921075900154, 0.12890768668731067, 0.09458201559088353, 0.12634902108701207, 9.999999999998899e-05, 0.06087186216375595, 9.999999999998899e-05, 0.0017256472748363727, 9.999999999998899e-05, 9.999999999998899e-05, 0.06528790343687396, 0.012980448936698474, 9.999999999998899e-05, 0.07461956861698982, 0.04752830902949734, 0.035735446262109005, 0.07965735489284254, 0.06232125586458548, 0.04665229487997402, 0.031197580937085467, 0.050340034994989735, 0.12212360811605172, 0.07138831198342055, 0.03399310981910275, 0.0465105192508779, 0.36780448802745447, 0.08482918988176114, 0.07156115601820134, 0.09308942784100305, 0.08175455805569798, 0.16598965735105753, 0.3007681840113062, 0.04114372087938212, 0.12798294448028358, 0.16827732673231588, 0.40760483343866505, 0.1359326600403945, 0.05567000368025821, 0.05504107368031852, 0.12520445607509534, 0.50595387237538, 0.5216301360768244, 0.5427400790092592, 0.5418634507233067, 0.5480671077692265, 0.5609111860050144, 0.5594393405499044, 0.5395837021325897, 0.5099492494754054, 0.10315723104246421, 0.11908260124223702, 0.08368114034565788, 0.1365970584642815, 0.06886737187809244, 0.1257930022944913, 0.07605264098814657, 0.10821330762315884, 0.10980646842788355, 0.15240900230372223, 0.3010087559974207, 0.20893707162274644, 0.14166018326617302, 0.22498271421753802, 0.23375461220000338, 0.2047679495913528, 0.17242674220091903, 0.20313893707534503, 0.25871519353060335, 0.26007778821597793, 0.4108607316586669, 0.41634987606091367, 0.4081846791845829, 0.27192277363787276, 0.37544159158602164, 0.4743989551758303, 0.4325796734997053, 0.28502648217737303, 0.22597248194729214, 0.31256844774012493, 0.20227564035983792, 0.2710457959944913, 0.21385646219745502, 0.24660854571401536, 0.28604268754444806, 0.3631359178059368, 0.20718012266450714, 0.2634632335386353, 0.198281606345157, 0.2326168523632156, 0.22986197598909575, 0.222955313598724, 0.20762056567399434, 0.22294958174145585, 0.19551755513586544, 0.17473859085053955, 0.22123185526192612, 0.21668659536798962, 0.19712546926244412, 0.19483886947032236, 0.1986339974768273, 0.18889503706878263, 0.6762105943090793, 0.23672884214459444, 0.7461363344684987, 0.18155204915035517, 0.15194748966164529, 0.8900866990437055, 0.19923530429133296, 0.19852861454464998, 0.14054779398494122, 0.8467254538971093, 0.8935924584223405, 0.517122544215437, 0.2104156375588806, 0.8352758825638973, 0.28013161428388744, 0.16694701767033016, 0.15016357870831254, 0.1042255175481257, 0.12649917896818919, 0.20930246497317562, 0.1979928777765615, 0.1857212699629861, 0.18315677907383687, 0.20724475381679375, 0.18787736602435567, 0.2145170159118316, 0.18712760062133227, 0.18604954525718242, 0.18031121072706013, 0.09265821043823252, 0.07804658125776587, 0.10520050303227313, 0.07486783455299306, 0.09281560787210752, 0.07586573268638008, 0.0923587350278241, 0.09184907317560898, 0.08334066368132154]}, "mutation_prompt": null}
{"id": "c1b84477-e124-4415-8250-8c3b783d2557", "solution": "import numpy as np\n\nclass Adaptive_MultiSwarm_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for diversity\n        self.inertia_weight = 0.6  # Reduced for more dynamic adjustments\n        self.inertia_damping = 0.98  # Slightly increased damping\n        self.cognitive_coeff = 2.0  # Increased for enhanced local search\n        self.social_coeff = 1.5  # Increased for stronger global influence\n        self.mutation_factor = 0.7  # Reduced for more stability\n        self.crossover_rate = 0.9  # Increased for better exploitation\n        self.elite_fraction = 0.1  # Slightly reduced elite fraction\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Reduced initial velocity\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.swarm1, self.swarm2 = np.split(self.population, 2)  # Introduced multiple swarms\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step  # Adjusted step for controlled exploration\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.quantile(scores, 0.75)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n                self.swarm1, self.swarm2 = np.split(self.population, 2)  # Reassign swarms periodically for diversity\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_MultiSwarm_PSO_DE", "description": "An adaptive multi-swarm PSO-DE algorithm with hierarchical updates and diversity preservation for improved convergence and robustness.", "configspace": "", "generation": 69, "fitness": 0.2670530335456506, "feedback": "The algorithm Adaptive_MultiSwarm_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.7554175353203474, 0.7210621408826461, 0.7157642193784806, 0.728962253929143, 0.71893547963334, 0.6899596981219699, 0.7362434060342544, 0.7124894802239385, 0.7264784449805064, 0.35948546882071875, 0.33139970795273566, 0.22631932136550137, 0.40598307423814084, 0.33368925506277014, 0.33929294903876983, 0.3665190542893554, 0.35079514891668684, 0.336746895241848, 0.10171037981976783, 0.10300117637593398, 0.12384760440927889, 0.12913930886531455, 0.10021570209098607, 0.11624973955395235, 0.1118494120616551, 0.1494853829847529, 0.15162795073030988, 0.11822859654078743, 0.1026467183286992, 0.1463362093699908, 0.11633173030021549, 0.09394993429633669, 0.08701407159488239, 0.15823742443679478, 0.08373734525834176, 0.13111713479594223, 0.9724493157862892, 0.9846387834840273, 0.9736006102343878, 0.9816060375740806, 0.9697712988146674, 0.963123889675123, 0.9764442988110882, 0.983682745054278, 0.97374459432156, 0.35938444720117213, 0.33640442064451015, 0.3218168946279939, 0.31988278294126304, 0.30376631434782, 0.32637304893645336, 0.3678622562592522, 0.30374954160129386, 0.3387523379606233, 0.48050454969856926, 0.3209393258603539, 0.16765327474547687, 0.21649681874781912, 0.25510452307964104, 0.7427537135670568, 0.2846569399955857, 0.4853511630052587, 0.7180991051916057, 0.17019948091921, 0.11393297400669067, 0.11741246469277833, 0.18431408684871398, 0.17011114749299672, 0.12293480423123926, 0.16943060605808147, 0.15885940377368857, 0.17087639139910626, 0.19037955217365365, 0.16735777513797911, 0.17867269737205627, 0.18561773694078854, 0.1170612850325129, 0.18006463547780727, 0.12011426350926246, 0.16333943614351776, 0.12388485538818694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002101051976572954, 9.999999999998899e-05, 0.003603923512026319, 0.01973501758855878, 9.999999999998899e-05, 9.999999999998899e-05, 0.07597660753311597, 0.0310624432919836, 0.11903978694967554, 0.03181537669354184, 0.10850819797687294, 0.0026002603367618615, 0.10528587453381422, 0.12778760055997795, 0.08625156328556427, 0.040446502041482146, 0.1978285147440757, 0.09917585795947748, 0.08799588382496937, 0.15511753831500086, 0.12967972619829948, 0.0723603405306148, 0.1042441561873384, 0.07418505730520464, 0.16227799705261237, 0.1718180805599726, 0.14251545466690818, 0.14264041851384213, 0.1071809453214142, 0.10495659487717945, 0.07602000636636075, 0.06381336821857109, 0.17857903450199197, 0.49788605718379697, 0.48512992936918864, 0.48388400021775124, 0.5287943149664316, 0.4795071831661688, 0.48790244008485084, 0.5099732490013826, 0.47958178690860553, 0.4790224202583562, 0.10174378028078512, 0.06406680134111231, 0.06769675474663239, 0.0761538383777266, 0.10714793376627074, 0.12054280477690993, 0.08743690496811374, 0.11642358277317744, 0.08509355733720259, 0.14297979485676915, 0.17587054475320052, 0.1293786115051524, 0.1697082526970929, 0.30490601014314733, 0.1562121720037376, 0.19502028500023272, 0.12299799748778606, 0.17373240867801054, 0.39217475757778497, 0.3768268367462556, 0.3358379372221558, 0.3888624608857998, 0.35416445045620737, 0.2847295056506628, 0.31494686916542736, 0.370722944351641, 0.37624239471339216, 0.2177126690809238, 0.16573222643360674, 0.2608647878384007, 0.23702293644154737, 0.2863228504205003, 0.20432793942948524, 0.2558709113382224, 0.2303777007679768, 0.1451040608402684, 0.19211468692167877, 0.20975366695502828, 0.1809159277094866, 0.19149421298444047, 0.19553003704190386, 0.16893116781414697, 0.17874904655133983, 0.1942202505380184, 0.17724536268908886, 0.18877829969082938, 0.24063532860361003, 0.18675289056326438, 0.20427484596344914, 0.17518592669571387, 0.4643407335472721, 0.21413229852865234, 0.24318634983828036, 0.19612652812290887, 0.826057736856183, 0.18603599201037535, 0.1866673016724758, 0.8184582368939615, 0.19868349118621087, 0.19702847142150226, 0.14126162849906054, 0.7350162690454831, 0.7968959580447387, 0.6524715325318036, 0.21128132826346313, 0.21148590171427883, 0.20500221796542117, 0.16762857758515493, 0.15084033490981075, 0.20781187927826517, 0.2011617673282693, 0.6578430880817705, 0.1854087923909744, 0.17854437561350078, 0.185541116036939, 0.1767619790973256, 0.20382820158827764, 0.1718539379008318, 0.20220601131596727, 0.19689768744700864, 0.1761986044860283, 0.08088787328406577, 0.07772763944492223, 0.07281542059962343, 0.09098309695439089, 0.08569718932439774, 0.07496621130742365, 0.07600920015317703, 0.07109839012144825, 0.0586343700815547]}, "mutation_prompt": null}
{"id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 70, "fitness": 0.3127763739830525, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "5b6fc35e-fe89-46f9-a055-670aaae32afe", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "f71ed41f-bb6f-4b70-845a-ee678d1fff60", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            if np.random.rand() < 0.05:  # Adaptive adjustment for chaos\n                x = np.random.rand()\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        adaptive_budget_threshold = self.budget * 0.5  # Adaptive threshold for strategy change\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > adaptive_budget_threshold:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic_Adaptive", "description": "An enhanced hybrid PSO-DE algorithm integrating adaptive chaotic maps and adaptive parameter tuning for improved robustness and convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": 0.2997044312593389, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8611114738320992, 0.8308742116783718, 0.8246363278862191, 0.8294703299310464, 0.8482500872512565, 0.8528080380123727, 0.836327649823534, 0.8628525721817046, 0.8105100744246284, 0.24488579070891014, 0.6197018583038727, 0.4944962021043353, 0.5699662076180239, 0.5532283398186839, 0.4618689906199862, 0.1997859234303747, 0.5428521499089312, 0.47011831421879924, 0.16267177457074977, 0.10108706482865981, 0.1314310146659392, 0.1251804936051294, 0.14188869940019044, 0.10499592727837825, 0.14284376720335035, 0.13288660485449855, 0.17950814484602906, 0.07816594709620261, 0.10075838020386418, 0.12115427414403512, 0.12610860571250304, 0.10835474445525706, 0.11709422974990391, 0.0885196839758371, 0.11391150803617489, 0.13900957775502043, 0.9754592937959405, 0.979012400766747, 0.983095948421167, 0.9754037962367103, 0.9767577171467271, 0.962458645236236, 0.9769922079535912, 0.9699603085929529, 0.9793776523661711, 0.5389106149987943, 0.5955141470267538, 0.3914205699583505, 0.49700726742720425, 0.4428672528541663, 0.5059823280633504, 0.50337187578127, 0.5579004323540169, 0.475094994637587, 0.3614236142273166, 0.9009080480966808, 0.22245411789114, 0.20995244112303557, 0.19333788647700423, 0.2580896182410066, 0.8007811120895397, 0.1255733854151051, 0.558714275347656, 0.1969541419472195, 0.11431033366176091, 0.22526586913553748, 0.27149361310996256, 0.1294451316558467, 0.1314169886675638, 0.12835548494429172, 0.2557314365357005, 0.2707698143569389, 0.270228058312457, 0.12699436498192207, 0.20768482625587192, 0.13131312224830582, 0.29210998673918953, 0.13098700240911598, 0.2650368012266784, 0.004739645305165907, 0.19471349249482872, 0.04531202768751319, 0.06274600378079487, 0.26026678116997337, 0.0037604980344001504, 0.0716595325340269, 9.999999999998899e-05, 0.0367802999613992, 9.999999999998899e-05, 0.06926617282093817, 0.11961417949147435, 0.15054855979613735, 0.11145942527147124, 0.22902958008943874, 0.10046644522329606, 0.29411967635134806, 0.2325803387445179, 0.175905283912682, 0.11934847278167326, 0.05311561688369726, 0.16824918672096378, 0.15062841239741998, 0.14691631788993786, 0.16817446419290372, 0.13426831505140946, 0.10172406354428809, 0.10325251154056292, 0.17043604887165187, 0.16331013043495424, 0.05173777235616539, 0.2622146544941546, 0.19741396684578827, 0.12121046764141208, 0.059352800807192074, 0.07999778946758884, 0.05586160309033672, 0.08212593088667441, 0.5375808720164337, 0.5979131123575667, 0.5560447892387865, 0.6466039924067027, 0.5886761952908145, 0.5399872446829908, 0.5982305293034429, 0.5758271283500491, 0.5536216956283767, 0.07707949483026622, 0.11104145784113584, 0.10666652134048149, 0.10333928359567512, 0.12620151182662254, 0.18100006051762307, 0.061830336637867744, 0.08681842923734961, 0.09273676243956541, 0.32867986439056707, 0.1938402297077102, 0.17768902848934953, 0.3127253402046244, 0.18704612745288596, 0.18563183791473326, 0.35023614120232893, 0.16369419372737315, 0.2024809211095242, 0.323825301389421, 0.44236321134110446, 0.31473984635569285, 0.4319031069468887, 0.3257560927775832, 0.33072224389883054, 0.4347231678926491, 0.3488905610231816, 0.3740475294164394, 0.19157732227263868, 0.1952958440254874, 0.2855497232260066, 0.23734932683006116, 0.17312051550664642, 0.24832269194913714, 0.2833251260251888, 0.28618023184628316, 0.281579788687932, 0.24450911046088808, 0.1729937651207274, 0.214137124684053, 0.2080229060386981, 0.18840504581905848, 0.23576682110123215, 0.2095841052074089, 0.18827884458323185, 0.23062999891164915, 0.2146679164615315, 0.17325884119389645, 0.20494997747980193, 0.18229027958470811, 0.19503778292347373, 0.23813521309522523, 0.21608684905369335, 0.17691538380769145, 0.18476939116854096, 0.1675069085569032, 0.1263350356362265, 0.15204043710363113, 0.1555990844417956, 0.1989839913650885, 0.1981928607965211, 0.14144005952713046, 0.1633725388083329, 0.8943896616512201, 0.8300697072490983, 0.2116207502399846, 0.07342121860566808, 0.20701267237435106, 0.16706210593339432, 0.15423846428473953, 0.7521173270974981, 0.8395788973841571, 0.6945925253451022, 0.17887693633676427, 0.1810674041978867, 0.1757968689820082, 0.20919413025917744, 0.20645273225001826, 0.23895922773605294, 0.1775320154004596, 0.20078780131113838, 0.1914626235394533, 0.11608462853829482, 0.09796113240508908, 0.0735361742456887, 0.08986469885998616, 0.10218249197467755, 0.08854526797585027, 0.1035018824536379, 0.08809508252920639, 0.11000733535579332]}, "mutation_prompt": null}
{"id": "be0c4410-db68-4dde-a652-bc30a3effd45", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # More gradual damping for smoother inertia adaptation\n        self.cognitive_coeff = 1.7  # Slightly increased for better personal search\n        self.social_coeff = 1.3  # Slightly decreased to balance exploration\n        self.mutation_factor = 0.8  # Reduced for more controlled diversity\n        self.crossover_rate = 0.7  # Reduced to increase mutation impact\n        self.elite_fraction = 0.15  # Reduced elite fraction to diversify focus\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Reduced step for more precise exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.random.choice(np.argsort(scores)[:elite_count], elite_count, replace=False)  # Randomized selection for better diversity\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "Enhanced Hybrid PSO-DE with adaptive inertia and randomized elite selection to improve convergence and diversity.", "configspace": "", "generation": 72, "fitness": 0.2905761845221525, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8397439769408727, 0.8342435136934508, 0.8299105459630812, 0.8323020941088873, 0.8555913783982796, 0.8172782188803505, 0.8277865806616442, 0.847242353451951, 0.8179700517715743, 0.4262802705098946, 0.42680213632196773, 0.39814296064150323, 0.42983644422427436, 0.621237529330286, 0.4547244381525356, 0.3530380532326325, 0.6340978297150026, 0.04389338372252427, 0.17167248647034083, 0.11749902231525833, 0.12280756556198735, 0.1331030235981432, 0.13210825783242308, 0.13498696111297082, 0.11323312760389204, 0.10729468092505245, 0.0860861005842698, 0.11157469984565671, 0.09704118867483436, 0.12467239544943043, 0.12447395722346644, 0.14503127084576029, 0.11395235738008413, 0.13263632090460398, 0.08228492102745999, 0.12879502824084144, 0.9778568400062416, 0.9607920098370555, 0.9787841080511794, 0.9785885213054583, 0.9786062363449801, 0.96308577384064, 0.9791614415839143, 0.9784453167963174, 0.9785444834992256, 0.507348868956853, 0.5166914252164694, 0.5273160212012269, 0.4897006271367498, 0.4489175518803692, 0.5375001376483198, 0.4563704182334104, 0.4860409304007537, 0.38970536939279476, 0.839027767190571, 0.34799170282269964, 0.8319952568282221, 0.20728737674099718, 0.27596833794432507, 0.21035914876888395, 0.22432435565661724, 0.6753192851034111, 0.8592120185184386, 0.20985948502621588, 0.18038299289579462, 0.21014240635709092, 0.10959006717443665, 0.1267062654140052, 0.21419870556898446, 0.11013193751147787, 0.22859871368396834, 0.18125480782372916, 0.20368127410887737, 0.11624280275875731, 0.3704678882820692, 0.1969003574151913, 0.125777460178504, 0.17461875939299554, 0.2054627966992021, 0.18155761307697038, 0.12638537239274594, 9.999999999998899e-05, 0.059973893220137686, 0.13541232503895895, 0.00020550447325839993, 9.999999999998899e-05, 0.045157184190805166, 0.022057773351936927, 0.07927507076603524, 0.0880336291106727, 0.16205811880556398, 0.12072186836519705, 0.10673370540713145, 0.07758182182192108, 0.1425471098991904, 0.10641290598619435, 0.0915557951852497, 0.12805166677676394, 0.1283908370536463, 0.03631401122033351, 0.0683963975264904, 0.07510835109389735, 0.12264317767916966, 0.16198288240789893, 0.07165155677035451, 0.10070842424479454, 0.07118912914074249, 0.06751053984469912, 0.22819743660295866, 0.041757048038087996, 0.19634264743287155, 0.06847448088208752, 0.0922126931158378, 0.11687337783061502, 0.14671551910993164, 0.0806102265235672, 0.08085938854867114, 0.5268730068026304, 0.6537695233108316, 0.5396311467523669, 0.5289151654182925, 0.5935819103376421, 0.5251272514080167, 0.5395550623126197, 0.5173075814422856, 0.5554673181140739, 0.07553053667422793, 0.1044712021353531, 0.13908005713486238, 0.0957710391344293, 0.10991532247433566, 0.1533688331895422, 0.10508219018815912, 0.12066259387544565, 0.10033853393048608, 0.1604018760490471, 0.1603632042955776, 0.21011384691675838, 0.18004404693270704, 0.4182721273797688, 0.34605390796223545, 0.39415037380851303, 0.19621386849212707, 0.24822095467758576, 0.35449440528233944, 0.38476595523744594, 0.4104669616387131, 0.3622977923631966, 0.2666187723487715, 0.2843231842965178, 0.4556510327399015, 0.3799477440505128, 0.4270314992662928, 0.25837788915364845, 0.20675815650157947, 0.28370981690329755, 0.28287922659389797, 0.21990870642718396, 0.3032942552161568, 0.2994143490609954, 0.2897035302688288, 0.15145533862462413, 0.24481444456543955, 0.205992848495557, 0.30080010910726873, 0.1960717577822837, 0.2029909839770495, 0.23399493465361831, 0.19850226545864658, 0.23399465139715014, 0.2049443801950911, 0.1898900829443727, 0.19853361772880462, 0.17962346817781583, 0.24058471885743948, 0.19142356745595268, 0.21138606663043902, 0.24544122065847784, 0.22429426864547053, 0.190693935739369, 0.19541937796712672, 0.17296564420811356, 0.15218844856418579, 0.7451992235628364, 0.19901431724679708, 0.1971721323172826, 0.14206753727144128, 0.16639500831482223, 0.16683613878673498, 0.8864085532863251, 0.2101417105214064, 0.20225699973180133, 0.2075296907967481, 0.3778109864884829, 0.15272702384737002, 0.20767116628829352, 0.20084708314914135, 0.21043702181757806, 0.18148308632975385, 0.19124177324948355, 0.19802092443695662, 0.20188560411979228, 0.18852474069558622, 0.18003869153576346, 0.19211942790260705, 0.1904038302358052, 0.1913623818163629, 0.09070272728836448, 0.0795281888505891, 0.08920193778392482, 0.0871191382484896, 0.08323535367225354, 0.08174015620055397, 0.09097753791859375, 0.07830045360815152, 0.09393075968134779]}, "mutation_prompt": null}
{"id": "cabbaf96-480e-4db9-9579-285e95f7f478", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.8  # Reduced for better adaptation\n        self.inertia_damping = 0.9  # Adjusted for better convergence control\n        self.cognitive_coeff = 1.8  # Heightened for improved personal best search\n        self.social_coeff = 1.4  # Reduced slightly for better balance\n        self.mutation_factor = 0.85  # Adjusted for balance between exploration and exploitation\n        self.crossover_rate = 0.9  # Increased for higher probability of mutation\n        self.elite_fraction = 0.15  # Reduced elite fraction for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            if np.random.rand() < 0.1:  # Add more chaos intermittently\n                x = np.random.rand()  # Reinitialize with a new random state\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.05 * step  # Increased step for aggressive exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.percentile(scores, 75)  # More aggressive reinitialization strategy\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Adaptive", "description": "An adaptive hybrid PSO-DE algorithm that incorporates nonlinear chaotic sequences, fitness-based dynamic population resizing, and enhanced mutation strategies for improved exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.2929627107306963, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8114648845203901, 0.8544623041897298, 0.8026015275484063, 0.8375451201367082, 0.8257787420035007, 0.8187028347438212, 0.7812747704174728, 0.8348577802251892, 0.8171831411707196, 0.2980064845304793, 0.2174033591111012, 0.3899820436855943, 0.043760489775961475, 0.36067799568141856, 0.4694455075848424, 0.16022035174732518, 0.3064086937121938, 0.33170503942556995, 0.14039548038582583, 0.12104601982907337, 0.263538374924393, 0.09912137758898976, 0.09797344039396172, 0.12200203581900315, 0.11493848031585696, 0.11855481429153047, 0.11497935686537308, 0.08750653574599421, 0.10802186353872567, 0.0991526349320242, 0.12552326473226372, 0.11064398905064132, 0.09007705057359527, 0.11359722169170416, 0.0997739013376826, 0.09234488435925581, 0.9778070756921078, 0.9703808193581803, 0.9777675251368905, 0.967259467017687, 0.97007814865904, 0.9770112816537573, 0.9789422854664398, 0.9847880840193528, 0.9623952744769866, 0.4723644337420815, 0.4200543177099689, 0.4230234090223899, 0.3889593272487859, 0.3795365085864866, 0.3998214057976085, 0.3492723279453147, 0.3609219248310923, 0.41703312088397504, 0.22304131056356236, 0.7782895308654828, 0.24872763212150717, 0.19408775617299856, 0.18950687046268755, 0.19044571148306255, 0.5661666389191766, 0.7657884961468845, 0.713528304591508, 0.328108542824159, 0.18317534323944917, 0.21439525855628583, 0.09719625798785658, 0.2824746226136453, 0.270957584592337, 0.12671702506381877, 0.19010303988239796, 0.23512162783690005, 0.2116942480295756, 0.33611520669291617, 0.12949108839345969, 0.19417437639347523, 0.2901670353515077, 0.18919370721537276, 0.2811437877083388, 0.21047298181977814, 0.19232781356622008, 0.0008646325730448101, 0.0020670269109689388, 0.07747441483507667, 0.036407254342695206, 0.010981656946454366, 0.021155587962313982, 0.02825236002853959, 0.04566100310102661, 0.08271778888516979, 0.41792424565481867, 0.40577286240387167, 0.23168821766038772, 0.22621449966996188, 0.15639465159462018, 0.05633789809788481, 0.1334121007087653, 0.41368803158152034, 0.16505436186511546, 0.03396712691894466, 0.034120035304117446, 0.13402958281445698, 0.0728911375305441, 0.13425342210824798, 0.11231436613951173, 0.1747754966691758, 0.0984462671408679, 0.09273438032341108, 0.1192402117591348, 0.1572019518279547, 0.11133104864992727, 0.25294636085276256, 0.25405927044293664, 0.2422695072365858, 0.05655754459215645, 0.05565511461257955, 0.08671287489127422, 0.5996182386236202, 0.5706287435243061, 0.5503677208088869, 0.537501956051017, 0.515561829833325, 0.6249252012589928, 0.6152771992643558, 0.6139509685576066, 0.6110827739563248, 0.13272045557797774, 0.1269225461052269, 0.10763918403466666, 0.1616420885489357, 0.08065035206459292, 0.11699827542915608, 0.08339914715652652, 0.1541969144983767, 0.10011446735683627, 0.21607734886146368, 0.22105846878024804, 0.16700248720527966, 0.25005267137815934, 0.3111461379806888, 0.29617590411962613, 0.2064019628474162, 0.1783729865621021, 0.23581486959365805, 0.30431749952242804, 0.36688059006308193, 0.3443122341331223, 0.34494035899717124, 0.3770473298382859, 0.36937692942491884, 0.32952530170655336, 0.4109292548656748, 0.35873732840709316, 0.18092384067348022, 0.20127591003580603, 0.20740888635533883, 0.17338023023391158, 0.20224830407284478, 0.18028033047419523, 0.22671717967146876, 0.32576529771714624, 0.2459025344387511, 0.2113233723081226, 0.1842475110862628, 0.20770622641835423, 0.21274461720748383, 0.18740082532153568, 0.2023201295069773, 0.2172731723459319, 0.18653699079060349, 0.22204938475130687, 0.21727111783435116, 0.22067387005284422, 0.19071388993664817, 0.17522783754761617, 0.1902682987141947, 0.18764537927421865, 0.50695737588568, 0.2802573392303892, 0.1732141012959082, 0.1624833470143856, 0.16745641670137779, 0.15357220222272405, 0.19807187820520866, 0.20053252335768834, 0.19612221069659608, 0.1417760364598677, 0.1851997196008457, 0.895725049012302, 0.876477093661896, 0.21200591154008863, 0.5156242384865923, 0.8325301697370598, 0.1673079778140374, 0.855994392850186, 0.21016450306784007, 0.1273552309441427, 0.20868300289228248, 0.18240747528145618, 0.18385970991589295, 0.17453391288816422, 0.20528742887233953, 0.17216053705279266, 0.19670781786996383, 0.222574435869492, 0.17654572630134713, 0.1810496940781563, 0.07684967395958409, 0.08867916453141478, 0.08954101259219716, 0.06952739527912744, 0.08103182794430974, 0.07619467387883394, 0.08719149403389614, 0.08036373651174777, 0.09298158901982934]}, "mutation_prompt": null}
{"id": "c3755637-7bc4-48a7-bb96-28b8faaaf8a3", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "96da7024-bd41-4fc2-810d-2d6aeafc0b12", "solution": "import numpy as np\n\nclass Enhanced_Chaotic_Hybrid_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for better exploration-exploitation balance\n        self.inertia_damping = 0.9  # Increased for prolonged exploration\n        self.cognitive_coeff = 1.7  # Enhancing local search\n        self.social_coeff = 1.7  # Enhancing global search\n        self.mutation_factor = 0.8  # Reduced to maintain diversity\n        self.crossover_rate = 0.9  # Increased for stronger exploitation\n        self.elite_fraction = 0.3  # Further focus on convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.05 * step  # Slightly increased for better exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Increased probability for exploration\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Chaotic_Hybrid_PSO_DE_Adaptive", "description": "An enhanced chaotic hybrid PSO-DE with adaptive local search using Lévy flights for amplified exploration-exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.3080875522789311, "feedback": "The algorithm Enhanced_Chaotic_Hybrid_PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.810412867552224, 0.8143795596091505, 0.8496300897498524, 0.8400156753223659, 0.8165374039524925, 0.8341394566708107, 0.8365273468521723, 0.81146819398758, 0.8088412991457299, 0.1843567495659476, 0.3804210184688348, 0.47984218697912295, 0.34808185540696035, 0.36982173594824075, 0.041563353695769134, 0.30820913842436626, 0.3955892031437036, 0.3963163199859414, 0.12376865362523004, 0.1266013571202318, 0.13561591057529132, 0.10617181146446764, 0.11764926481884053, 0.10473722775072969, 0.12797399583334268, 0.13462005079599915, 0.07057338139267355, 0.10234431740909933, 0.11788991162605711, 0.09318046109730771, 0.08871583315562004, 0.13612173935225147, 0.12768552772852038, 0.1037999151718435, 0.11065947625078898, 0.09222552658291461, 0.985811743434787, 0.9619895076553364, 0.9810258847184062, 0.9718888084260502, 0.9804309266878738, 0.9795749827225463, 0.9856523928810342, 0.980227952099876, 0.9797135759164566, 0.41515749662591284, 0.4494366327765219, 0.44472633807730566, 0.4175760538472525, 0.511830491334509, 0.3793309631210253, 0.3840288253426576, 0.43212322962230665, 0.3577016048792424, 0.8097648094085628, 0.1706258561368733, 0.6070369719965305, 0.2122215047892555, 0.8369839648009768, 0.20917853911947737, 0.1361615407795158, 0.8131087666227071, 0.199051304828601, 0.2101549174489774, 0.1157437119872049, 0.2198750558395961, 0.2561298862752306, 0.268022560474094, 0.09807831320568894, 0.23083087016888615, 0.47155672043533736, 0.32680997146280655, 0.2464809974968355, 0.20585154007036877, 0.3414725341225924, 0.2547448335432144, 0.2560519532879685, 0.31934813489300273, 0.2491606263626489, 0.27080762398916425, 0.1965254089965781, 0.12663740420354674, 0.07354880218355486, 0.0796961663910637, 0.03597802333046041, 0.0859854597497337, 0.09339221123678854, 0.07744747494448934, 0.007383215834321888, 0.1375650658456643, 0.213870680176119, 0.14309958880415086, 0.24300053434819002, 0.17550471635203335, 0.09169830234028853, 0.2863539087441186, 0.16567668978956518, 0.23412215279166426, 0.1898253577428971, 0.03406292222190588, 0.032842020278062045, 0.19953903138013185, 0.09480292445202743, 0.07729598023001805, 0.26562019063550624, 0.09460408627791672, 0.09165815799023824, 0.07153605190206214, 0.18813717125827922, 0.14956768660321362, 0.15812578215809592, 0.18693869426440046, 0.23348139861677442, 0.16513483676758767, 0.20339183779648606, 0.16537494327235946, 0.0818649561373277, 0.5775919487046147, 0.5340780293285073, 0.6019269237128414, 0.6507368746737379, 0.6228445560998506, 0.6081634429673983, 0.6376228416739278, 0.573111305741739, 0.5626382586412602, 0.11333831836439989, 0.08406544473310895, 0.09671084294014876, 0.07722276180833254, 0.1459166343095314, 0.13036273602586113, 0.12471097263766884, 0.11993484027005108, 0.11734322543098519, 0.154118490026511, 0.1885484755978939, 0.202103647533329, 0.4018914859857131, 0.3644374312572142, 0.16194684737045228, 0.1538866459034438, 0.18299643119725073, 0.22870251292714971, 0.4046837951551415, 0.3071611674554541, 0.30586395791439747, 0.3582012972376558, 0.2459219039275362, 0.3077259057345696, 0.41998269839251656, 0.40690529592445124, 0.28955984425005166, 0.20694938310971733, 0.24357842203518143, 0.2983295643402115, 0.28199835655373806, 0.19510403966010537, 0.29848395679541706, 0.31957897023465376, 0.4037143530550651, 0.23375075957617897, 0.1875982443205444, 0.222841270557534, 0.24042193559613423, 0.20170468347208736, 0.2227272551378322, 0.21476084105339255, 0.19229101960778117, 0.23412787978053295, 0.21446615966760674, 0.24590063907152593, 0.19292691869172662, 0.17093282604253057, 0.2393817506837641, 0.20675175480470798, 0.18458338515327055, 0.20445405940896721, 0.20269724284810298, 0.1895484805317973, 0.9126916019818507, 0.8314547399665967, 0.15200633630756966, 0.8940375622826066, 0.1991363858054508, 0.19771605777192758, 0.1423734758343851, 0.16210391321912088, 0.9022857751255943, 0.8573946570553035, 0.16506661420609403, 0.20951792957218263, 0.20116590584216343, 0.165883003626917, 0.15396345850667803, 0.21187175554603377, 0.7663488143247347, 0.8174657477764429, 0.18710447256025098, 0.17929525539806002, 0.19106641125442347, 0.19746016582849446, 0.1861400893474746, 0.1780179330224566, 0.19089294694457304, 0.19399845354083878, 0.1788833540224265, 0.09207670277161328, 0.09500764523130278, 0.08778594594049882, 0.07840228464024002, 0.08684780747609933, 0.09021198993125235, 0.08449506503542847, 0.08619077661157082, 0.07672974232034013]}, "mutation_prompt": null}
{"id": "025b5f9a-cf95-492c-a21d-bd7d41bde082", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "24c517d1-9559-4561-9e76-843dc708638a", "solution": "import numpy as np\n\nclass Enhanced_MultiStrategy_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 2.0  # Adjusted for adaptive cognitive search\n        self.social_coeff = 2.0  # Adjusted for adaptive social exploration\n        self.mutation_factor = 0.8  # Dynamically balanced diversity\n        self.crossover_rate = 0.9  # Enhanced exploitation rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(0.3 * self.pop_size)  # Increased elite fraction for focused convergence\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(30, int(self.pop_size * 0.8))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_MultiStrategy_PSO_DE_Adaptive", "description": "An enhanced multi-strategy evolutionary algorithm blending adaptive PSO dynamics with chaotic DE and adaptive restart mechanisms for improved global convergence and robustness across diverse functions.", "configspace": "", "generation": 77, "fitness": 0.2955940737816858, "feedback": "The algorithm Enhanced_MultiStrategy_PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.7643620955977708, 0.7772884054385661, 0.8418118317781649, 0.7521619166851932, 0.7781053650783478, 0.8565436217859148, 0.7982186679855389, 0.7775127013286447, 0.8068206495961364, 0.3469763655601885, 0.38025523624165747, 0.4628506999970152, 0.2259132700382751, 0.46202724373033266, 0.3910491190453885, 0.1549453760275975, 0.27340464510169116, 0.3473630945292523, 0.1021390831153538, 0.10808504518869744, 0.12145670777472184, 0.12258015063343974, 0.11745350052353065, 0.09757965550142467, 0.1303360579862296, 0.10180527593660538, 0.12222344337653779, 0.11081180540037772, 0.049962011053164, 0.09873522898734188, 0.09639359878454834, 0.09912660570372267, 0.09963922582206064, 0.09663424624146733, 0.0956721306258752, 0.1224158073293029, 0.9875330502382044, 0.9555037377149775, 0.9809595828781967, 0.9772820606146074, 0.9854763705591755, 0.9797263825087569, 0.9874542665536539, 0.9801868700443546, 0.9817552258004039, 0.3730725412684701, 0.28560992500606963, 0.3356045452673949, 0.3411979338392197, 0.4024447629268847, 0.3020757860302, 0.29864536469071745, 0.3325628529227804, 0.3372969356653407, 0.17054109880099877, 0.6846354590485316, 0.3802707967107132, 0.2617921215881246, 0.2773068426323996, 0.7458719637686991, 0.7989089517296346, 0.7205950303279809, 0.22440681975134558, 0.27152417934717854, 0.3247280680572482, 0.1966054793852664, 0.11295330053823838, 0.3243575024292713, 0.20203633271455868, 0.22384213588306234, 0.2420767987689011, 0.3310526235978839, 0.2679221435775009, 0.202996636618077, 0.2709306665790856, 0.2179673160453156, 0.30817859254568714, 0.12391699049765026, 0.3476495231793145, 0.24559967026592788, 0.22828356801472716, 0.04701080593580098, 0.16800496770995033, 0.06360587834951437, 0.03336870022564087, 0.04801300781898299, 0.03731944521312247, 0.05146048040836271, 0.12832193360886301, 0.07790073955125176, 0.20760182813538863, 0.1594723400456205, 0.22036417735342684, 0.24182020698133566, 0.16309287594361754, 0.1748183210826264, 0.17591573071428934, 0.2926675382394054, 0.33421736592427576, 0.041770992708147436, 0.08506344269760335, 0.04640877090533446, 0.1016280439006938, 0.09125553967585875, 0.09035883573253689, 0.09146114138807593, 0.07064098531006424, 0.06877617162818517, 0.19759571672252985, 0.13889762991198928, 0.21297267620936655, 0.11013406857129171, 0.24544018594117, 0.17745046026656142, 0.1581788680822408, 0.0557884558530688, 0.08408931011666532, 0.6190498489149696, 0.6651303693680806, 0.6309934392220471, 0.5254143813881105, 0.6008143167317075, 0.5779248174778548, 0.5175155449171254, 0.5777347609587107, 0.573290748702664, 0.11280085329930012, 0.15349186926888836, 0.127576785574407, 0.07219444858268764, 0.09949791523403728, 0.10391213993725124, 0.11202607047233837, 0.12944900453579888, 0.10226103083285853, 0.1680073602240274, 0.14690318721850704, 0.1793054485138933, 0.18919846177314426, 0.26264182813052805, 0.2552561635806697, 0.381991916728207, 0.20575900278728043, 0.18807651583056884, 0.25435414632913955, 0.1970238208675259, 0.36826577851145237, 0.46169845098553075, 0.2612716411963334, 0.23882268626519476, 0.2957267520369653, 0.3906643988414815, 0.28368754354626813, 0.17540069260514823, 0.32777628788773006, 0.2515663240509659, 0.21982587247263596, 0.1905137364603765, 0.31027978598054884, 0.34965194010670775, 0.29206170463993686, 0.3106646729007796, 0.19988132431355166, 0.18980718707685007, 0.18563395699936114, 0.20311253155376807, 0.21057998438072656, 0.18505540249937336, 0.1908506786529186, 0.22418370185956127, 0.22684810673994227, 0.24274947252452095, 0.20273147682217163, 0.2029436507396769, 0.18813775684048673, 0.17757016032321626, 0.21270930523341214, 0.20182778076312557, 0.1801417610390441, 0.20385834342629716, 0.7795937786174029, 0.16829229366905185, 0.15399687164792664, 0.8669117594460511, 0.1977784907336344, 0.1966140723490788, 0.141904477356803, 0.1609962263947713, 0.2089381890585984, 0.8359744708511745, 0.20994532547994604, 0.20510392150618495, 0.7803282238526315, 0.7426591769973605, 0.16735731210609717, 0.21067575509201975, 0.1263349856386412, 0.8579507117639251, 0.1846807925414129, 0.18714096942271397, 0.18410161757545696, 0.18673107515719845, 0.19516223086289697, 0.19740133026998108, 0.20010021493135355, 0.17016335749907863, 0.1774488591675648, 0.09592568206263763, 0.085587109463096, 0.08015442445924181, 0.07117524041365053, 0.08924492961280006, 0.08194634678547918, 0.07496573234332204, 0.08622252873207092, 0.08782807397881676]}, "mutation_prompt": null}
{"id": "0a70842e-010a-451d-8876-f28335084e3f", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "85dca94a-cec1-4b48-b699-73d3ca2a1fc0", "solution": "import numpy as np\n\nclass Adaptive_Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.8  # Adjusted for better balance\n        self.inertia_damping = 0.9  # Improved dynamic stability\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6  # Slightly higher for better global exploration\n        self.mutation_factor = 0.85  # Minor adjustment for improved balance\n        self.crossover_rate = 0.9  # Increased for greater exploitation\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n        self.energy_threshold = 0.05  # New parameter for diversity preservation\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted for exploration balance\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n            \n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:  # Adjusted threshold for shrinkage\n                self.pop_size = max(30, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:  # Slightly more frequent exploration\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                median_score = np.median(scores)\n                energy = np.mean(scores > median_score) / self.pop_size\n                if energy < self.energy_threshold:\n                    stagnant_indices = scores > median_score\n                    self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Enhanced_Hybrid_PSO_DE_Chaotic", "description": "Adaptive Enhanced Hybrid PSO-DE Chaotic with Dynamic Neighborhoods and Energy-based Reinitialization for improved balance and convergence.", "configspace": "", "generation": 79, "fitness": 0.3042887511725147, "feedback": "The algorithm Adaptive_Enhanced_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8399900723857257, 0.7942150897134568, 0.8509181474348284, 0.8425815790505959, 0.8361318024228311, 0.8301308211331491, 0.849368919816849, 0.831527466899848, 0.8454391783764359, 0.46264678856748254, 0.37949344562936416, 0.5003262842533107, 0.5497843137125253, 0.45460834192097965, 0.0609776998218724, 0.4406220922274755, 0.4213013265165295, 0.5758717899880066, 0.12327299497710409, 0.07690710332981965, 0.09437012285441337, 0.15789151272017132, 0.10710133512342801, 0.09906769613143751, 0.11417788476504942, 0.11084303122382444, 0.1340936950107684, 0.09265433902890963, 0.0834639094691021, 0.10492481172808987, 0.09026986537814463, 0.11772271360158393, 0.10069434813539935, 0.11832499554528753, 0.12603839241951897, 0.12817057774566787, 0.9814220656528355, 0.9637167411238802, 0.9790659681836287, 0.9701985205288711, 0.9779840690890483, 0.9532791614187838, 0.9714883872795078, 0.9787490545118974, 0.9780237181708253, 0.49209459155123614, 0.497994300138181, 0.35767596797953005, 0.4466072358740687, 0.44455926293927683, 0.5820212559942606, 0.37783576479719005, 0.3433677474473884, 0.572912178905191, 0.863487599030202, 0.22131276520125198, 0.1691642481602843, 0.20967838810227168, 0.27678328591196877, 0.1891401028715084, 0.2383933590217725, 0.22422442136612908, 0.8516108152216132, 0.12981017046193466, 0.20620682314409344, 0.18264054910406635, 0.12019909049562905, 0.4538793123815963, 0.4458480853553225, 0.28861157153774775, 0.3483584320725269, 0.43262361868638854, 0.30703069340753386, 0.30291490920934194, 0.12250666159789014, 0.4547000456053023, 0.44714531739705365, 0.22442721206071392, 0.33791090862668194, 0.2527483272864821, 0.25525836196635066, 0.045777725639256084, 0.09670568181707262, 0.07127926984655897, 0.12130882748042204, 0.043811262191194134, 0.006293909185795421, 0.03547486176790138, 0.038371252369619246, 0.07133045456583098, 0.14543163245040835, 0.23400943330252166, 0.16842182076149015, 0.1533599570537506, 0.22411366785397713, 0.01903422326481463, 0.11589773802823233, 0.27260709478969325, 0.08459573040958202, 0.033538081186341495, 0.18453487896278586, 0.048456971907715474, 0.11421174082138719, 0.26541817125983147, 0.21910322611583022, 0.09391683005178109, 0.18556982965700008, 0.128201495833962, 0.15674684578967357, 0.23092813380680488, 0.13779850806834915, 0.19184298218823936, 0.14540558440853546, 0.14905607369870488, 0.05580880161947499, 0.23931441889447047, 0.081608043166563, 0.5866202250222867, 0.6099852262279295, 0.696884692227645, 0.5969192290784595, 0.5784717561453783, 0.5903369844888536, 0.6271645110679374, 0.6410806269522678, 0.5677974574435238, 0.08848479343587168, 0.08642201274095973, 0.06561011615702206, 0.10288405631301956, 0.1345259927477478, 0.08725316153212626, 0.10750518682563048, 0.1165346243660923, 0.11013398891079529, 0.2620373789145942, 0.29681491845904495, 0.32604810519160565, 0.2614205638585214, 0.27569064011917754, 0.17826762412900843, 0.3813044439719372, 0.149475665077885, 0.19101566389846414, 0.2762549549325335, 0.31479061012179743, 0.36331130354656005, 0.27845507035451234, 0.2807339973385998, 0.2983849884240457, 0.3657130365110771, 0.2708909837986645, 0.312134654284829, 0.18504828340097157, 0.2436156202371239, 0.24171584516391575, 0.21778281716907766, 0.2496292222570743, 0.3409727283174364, 0.27128529708685134, 0.40874037526830354, 0.21460436141204797, 0.20256328858308292, 0.19398975132882668, 0.20745571194015178, 0.195124090439171, 0.20804063048039267, 0.20262580128886898, 0.19208127596628877, 0.19571973031004275, 0.2035998969852305, 0.1782535288428968, 0.18875848436664477, 0.18823198675529584, 0.24263048954923694, 0.21908447355853655, 0.19622746749084163, 0.19143726570449604, 0.21581047961287192, 0.17959452729975567, 0.8869648286204206, 0.16519406449266194, 0.14999340644811932, 0.9223008056126255, 0.19809802411187394, 0.19814029623893537, 0.14171501346404236, 0.16229334609792256, 0.20956745095424612, 0.8355288781510702, 0.2105824459819019, 0.07346071069535087, 0.1029380393885656, 0.1640038055012485, 0.20895819564827212, 0.7783909299656554, 0.2067518709197168, 0.7543504198391747, 0.19018899009342272, 0.17598934268421218, 0.19018513865760267, 0.19017824976270437, 0.1868535949082747, 0.18063534760899513, 0.17839689426552652, 0.22682410873292091, 0.19562801521838957, 0.10213574452341256, 0.08568394584598149, 0.0881686430117603, 0.08519320385721763, 0.08605916089031085, 0.08850259083989676, 0.10042531420040668, 0.10323948722385035, 0.07004655723082343]}, "mutation_prompt": null}
{"id": "ac9c10c5-bdf9-4ca4-9cd8-9ae300f63212", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "1686d4eb-abb2-4407-85d6-386475e70052", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE_Adaptive_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted for better population diversity\n        self.inertia_weight = 0.8  # Fine-tuned for adaptive exploration\n        self.inertia_damping = 0.9  # Improved dynamic balance\n        self.cognitive_coeff = 1.7  # Enhanced local search capability\n        self.social_coeff = 1.4  # Balanced global exploration\n        self.mutation_factor = 0.85  # Adaptive for situation-specific diversity\n        self.crossover_rate = 0.7  # Tuned for deeper exploitation\n        self.elite_fraction = 0.15  # Optimized for strategic convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget):\n            x = 3.9 * x * (1 - x)  # Enhanced chaos for sensitivity\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted step for controlled exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Strategic exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.quantile(scores, 0.75)  # Smart reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE_Adaptive_Chaotic", "description": "A refined hybrid PSO-DE algorithm with adaptive chaos-enhanced mutation and smart reinitialization for balanced exploration and exploitation.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (6,1) (15,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (6,1) (15,5) ')", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {}, "mutation_prompt": null}
{"id": "b6d44f4f-5ec1-4f8b-b551-f76b21fcc95b", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Fractal:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.86  # Further adjusted for dynamic adaptability\n        self.cognitive_coeff = 1.6  # Slightly increased for better local search\n        self.social_coeff = 1.4  # Slightly decreased for balance\n        self.mutation_factor = 0.8  # Reduced to maintain diversity\n        self.crossover_rate = 0.85  # Optimized for improved exploitation\n        self.elite_fraction = 0.15  # Adjusted elite fraction for diverse convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted step size for refined exploration\n\n    def fractal_exploration(self, size):\n        return np.random.standard_normal(size) * (np.random.standard_normal(size) < 0.2)  # Fractal steps\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:  # Adjusted schedule for pop size reduction\n                self.pop_size = max(25, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.2:  # Introduced fractal exploration\n                step = self.fractal_exploration((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.percentile(scores, 75)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Fractal", "description": "An enhanced adaptive hybrid PSO-DE algorithm utilizing stochastic fractals for balance between exploration and exploitation across diverse optimization landscapes.", "configspace": "", "generation": 82, "fitness": 0.269838315788302, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Fractal got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.6808961403556825, 0.6551802002543213, 0.7843968889367278, 0.6341807818174316, 0.7363563132210472, 0.7613685795116979, 0.6600492859188798, 0.8069508989272464, 0.698145022650164, 0.190377284935617, 0.08424546909884179, 0.25017752918070313, 0.2620580775728295, 0.20542053636997526, 0.24811104783822768, 0.14478159882320274, 0.10668429500853327, 0.16034916736254012, 0.134304083330404, 0.16398424586268334, 0.12404541056595442, 0.11412383146261129, 0.09515829139591936, 0.11477107577503853, 0.10199239718169884, 0.1416761631475183, 0.13390087949966856, 0.12649435120158292, 0.09060543435316648, 0.09257806819753656, 0.10046320024835809, 0.11455309585748641, 0.14826287793144421, 0.12692783451579404, 0.12672438656670204, 0.14397648391106066, 0.9870114712263527, 0.9528453237057355, 0.986169605241779, 0.9828546378215202, 0.9843037668366648, 0.970429029328035, 0.9866923335062214, 0.9713849981588755, 0.9768418267929388, 0.3790664896378202, 0.36122751992767266, 0.3867391432286058, 0.330211775535884, 0.34565293453651713, 0.3707471760594916, 0.31862559856883577, 0.3416795729882557, 0.37432301033435045, 0.27785137974206964, 0.2651493931481824, 0.7332151064280634, 0.2105308312467732, 0.27052051077882144, 0.5386902259061637, 0.6618489550757611, 0.31264736254458614, 0.3586616350563755, 0.12589519635081392, 0.1132449457932102, 0.12011424797905124, 0.07153362494661719, 0.15623733883240332, 0.11715132511082871, 0.2615133367925545, 0.19513641488868005, 0.26583026668119547, 0.11202771162720038, 0.12697624115094897, 0.16004720176998632, 0.20169462670950467, 0.1854995481067523, 0.20387411162470548, 0.1281134542753123, 0.12573439750870075, 0.1559716347275405, 0.03179553963126369, 0.037279212423738106, 0.05621379095871348, 0.027324293815280565, 0.011216200106862528, 0.05795027917106621, 0.06889008642408467, 0.11713256748950152, 0.048461573637468947, 0.07663555165990854, 0.13731211998774795, 0.23446642812068874, 0.16465052006764458, 0.1470073054897263, 0.17429896700306635, 0.0728936805293775, 0.11542259884863071, 0.1402174778896278, 0.030295119524555436, 0.22565851542856286, 0.17681894556769961, 0.09296157024123164, 0.0691605742298429, 0.07914394249202017, 0.0825925078585682, 0.08554813797291172, 0.11376319246506428, 0.14833660345948696, 0.26331677054875213, 0.18655917765518992, 0.12622980485580848, 0.2549277092403386, 0.15890443853279246, 0.054301743286078286, 0.09739439759889157, 0.07842303631575198, 0.5209740975787575, 0.4557498517449404, 0.4804420523760019, 0.5457073861527866, 0.4925625239089422, 0.5062794492695302, 0.5460375753581785, 0.4628123188563701, 0.5115760618702342, 0.10551271283727692, 0.12523520754286988, 0.1244375582096503, 0.08198815337804755, 0.09211154152385059, 0.1244380072993847, 0.14799775900612222, 0.09700333990193089, 0.1260410685912784, 0.23499178279685573, 0.16768491956957055, 0.21117182823440872, 0.3265121798243076, 0.16554104841697515, 0.2605557055934429, 0.3784787638260052, 0.20838298385365905, 0.23036945151586274, 0.32039039378207945, 0.37821327250513737, 0.33180257310484995, 0.3701156944614218, 0.28637604832793373, 0.35136238842418765, 0.34632935263036646, 0.3715688208597533, 0.3238500009174081, 0.21403845421962886, 0.249380848404831, 0.2820925659684934, 0.24599056465174785, 0.2046309815923435, 0.2541707337976412, 0.25752234910490557, 0.256222742994505, 0.26998330244480273, 0.19569303279773287, 0.19542196578895177, 0.2082878094595888, 0.19871398439833554, 0.20436374529012968, 0.19381390491056116, 0.22032245634781167, 0.19968297310313587, 0.2223822792920963, 0.21802452706969366, 0.20376713955378012, 0.18403885124189057, 0.21556623059615754, 0.2846376462050949, 0.20307500055786132, 0.24813488079920643, 0.19497254427348176, 0.22048817558392264, 0.16253439679863202, 0.18358557159237476, 0.15333526619847393, 0.8961681708709073, 0.19940723583475228, 0.19146634259089135, 0.1423832793381654, 0.16264154577397671, 0.20839352029074643, 0.7516796136719454, 0.20979823079267124, 0.8283113947236947, 0.7710617335161977, 0.7223481591014869, 0.15076846542201916, 0.205263907600164, 0.1645285045588849, 0.1272808597344499, 0.17912280074764564, 0.1801017789173709, 0.18264339915103167, 0.18860138584936026, 0.18319739709816552, 0.1807090370611788, 0.19354879924192414, 0.18327605676165937, 0.1929192863173057, 0.08976879452244613, 0.08927449181979752, 0.08154477117554992, 0.0825221426977163, 0.08664587279579505, 0.10085167541211781, 0.0848134617625721, 0.07355553894144973, 0.07470690953640546]}, "mutation_prompt": null}
{"id": "453186dc-890b-4136-a89d-4e43a74a7699", "solution": "import numpy as np\n\nclass Refined_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for diversity\n        self.inertia_weight = 0.8  # Slightly reduced for better balance\n        self.inertia_damping = 0.9  # Adjusted for finer control\n        self.cognitive_coeff = 1.3  # Reduced to shift focus to global search\n        self.social_coeff = 1.7  # Increased for improved global convergence\n        self.mutation_factor = 0.85  # Slightly decreased to control randomness\n        self.crossover_rate = 0.9  # Increased for more crossover operations\n        self.elite_fraction = 0.25  # More elites for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(int(self.budget * 1.5)):  # Reduced pre-calculated chaotic sequence\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Reduced step for more control\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        phase_switch = self.budget // 5\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(15, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Increased exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % phase_switch == 0:\n                stagnant_indices = scores > np.median(scores)  # Periodic reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Refined_Hybrid_PSO_DE_Chaotic", "description": "A dual-phase adaptive PSO-DE algorithm exploiting chaotic sequences with elite reinforcement and periodic restart for enhanced convergence efficiency.", "configspace": "", "generation": 83, "fitness": 0.30457180451729393, "feedback": "The algorithm Refined_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.7844744697982118, 0.8161818984047919, 0.8451568759434871, 0.788032617878655, 0.8025294811762165, 0.7472232057218164, 0.7877219374037177, 0.8418379834901286, 0.7460623129304774, 0.4299352212470928, 0.13008809620769557, 0.5423889210608692, 0.2599874119658393, 0.47957670424459997, 0.6557205010267588, 0.211410622928502, 0.5206894992348022, 0.5775288332682634, 0.08080407267090084, 0.14999203504087277, 0.14306465131847368, 0.12817327327899475, 0.07185143614095835, 0.14314684587170434, 0.13040570062472434, 0.10101512442882299, 0.13656282688150567, 0.08747574115910883, 0.10975028551947019, 0.0777941559572195, 0.10446625536764476, 0.0496139871715402, 0.07276896210798112, 0.10906987196067808, 0.10453428355580252, 0.09590362074705006, 0.9754262058353519, 0.9652605683234151, 0.9805641690459953, 0.9751760232888937, 0.9659193947122909, 0.9651996252706476, 0.9755269715005295, 0.984790231453419, 0.9841795235985843, 0.4812564035071353, 0.44734011593537437, 0.33151485456543406, 0.4562244517288174, 0.45496048814748424, 0.5362621526784124, 0.46078103533650006, 0.40756303589492116, 0.38940987676671623, 0.1697326173680913, 0.13683523603010583, 0.22416104501773426, 0.19400582169470537, 0.8162695709296484, 0.18789554399832364, 0.17851224813666866, 0.14050538071599317, 0.8289010005267279, 0.33427924939875786, 0.4038944439041463, 0.183765157429709, 0.10174604854705738, 0.5174902443427307, 0.15083454746589653, 0.2744698782562969, 0.10512682778830973, 0.19477706525502025, 0.11113689018661754, 0.33124222509507784, 0.12625228356363294, 0.12923943922218672, 0.1278654495307403, 0.12691248669090016, 0.23909163109513287, 0.5210362879178364, 0.1724536191627607, 0.06147731179400906, 0.17395991133851862, 0.08716471815743976, 0.03932819016122735, 0.0004747420823699722, 0.02498340770185692, 0.038264190014056454, 0.1301140137537612, 0.009874864459923804, 0.20538392747496637, 0.43457714069741493, 0.3901559747552621, 0.3782094445731864, 0.4719800568358151, 0.06106198464956725, 0.16643258943629302, 0.37302410146612397, 0.26081667845732404, 0.05282790590146669, 0.18160415447523126, 0.047761620967537444, 0.1266388727046528, 0.08702264510610913, 0.08885038137225287, 0.10898327464582402, 0.18303200125747132, 0.07340151567387931, 0.2792837758582324, 0.3375901230303894, 0.21424078287998316, 0.1735807211346595, 0.25591998067663246, 0.2379942198859173, 0.08572765571390295, 0.05472219234421538, 0.07729874730655517, 0.5971901020036103, 0.5742960703732691, 0.6590485241945455, 0.5601415047735258, 0.5724442682997247, 0.5633702768340205, 0.5729096502590667, 0.6124449189590775, 0.790012394615714, 0.1197691104702493, 0.1085182085876506, 0.09576142961002554, 0.11308446923303872, 0.07611990447524841, 0.10216273131761333, 0.14281807658135726, 0.09543464612234298, 0.07601713043651126, 0.22146498970688833, 0.32995464597975466, 0.18972422710339354, 0.19968143677623107, 0.24428335790618516, 0.1651023620543285, 0.17369657397371174, 0.21414550280340516, 0.20447884048912157, 0.33890538749798926, 0.19940226083023083, 0.4429133829634636, 0.3667748229186102, 0.4479733058898625, 0.27943000096767423, 0.26133842463834966, 0.3106184421042393, 0.48056683913326415, 0.3388514804464178, 0.1654592452904995, 0.3128711116097378, 0.228514514558682, 0.33961438266910904, 0.34937288083099405, 0.23503415051739862, 0.2676173517850462, 0.13495720982204074, 0.21914442225897135, 0.24612716162386983, 0.19582064623163964, 0.1963659429196839, 0.1954450307463652, 0.21631139485654527, 0.18921324372860504, 0.24165276056504392, 0.2160949744656273, 0.564074687009199, 0.20467270464582865, 0.2024261756176856, 0.19148492012425, 0.18048545436473928, 0.19183141026835016, 0.2146202656673829, 0.18097737585904639, 0.2204901715230262, 0.16380043692642465, 0.1856162994329218, 0.16589274588699665, 0.8796755751684358, 0.16730960988712362, 0.16888607358526986, 0.14216931063402882, 0.1597888364805896, 0.8532020113560974, 0.8240940315789513, 0.20991679231581128, 0.16620574258920573, 0.6546102005994134, 0.1662633327707943, 0.153607221787329, 0.20735986694496444, 0.7978738835916088, 0.6967541228330718, 0.18877583879488025, 0.17485247124761505, 0.1862725566458504, 0.17689922346844345, 0.1919097297461967, 0.20531761213079747, 0.21216164353385392, 0.19994383422114304, 0.17461765358047177, 0.08754985879341859, 0.09274200266573318, 0.09481043156904811, 0.07899893421202542, 0.08737026272364379, 0.08433043658139272, 0.08237298205943722, 0.08609796250133839, 0.07544004666194815]}, "mutation_prompt": null}
{"id": "5ad74a8e-0bec-417b-96a3-e32ae7dc4379", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.chaotic_sequence = self.init_chaotic_sequence()\n        self.adaptive_inertia = True  # New parameter for adaptive inertia\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def adaptive_inertia_update(self, success_rate):\n        if success_rate > 0.2:\n            self.inertia_weight *= 0.95\n        else:\n            self.inertia_weight *= 1.05\n        self.inertia_weight = np.clip(self.inertia_weight, 0.4, 0.9)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        success_count = 0  # Track successful updates\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n            success_count += np.sum(better_scores_idx)  # Count successful updates\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            if self.adaptive_inertia:\n                self.adaptive_inertia_update(success_count / self.pop_size)\n            success_count = 0\n\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "Introducing adaptive inertia and a hybrid chaotic-and-deterministic mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.1639166921500633, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.20.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.6313336023520175, 0.35330241304105103, 0.362816026598325, 0.3657646350972592, 0.36676863919935543, 0.32772956293043587, 0.3466195592085721, 0.3544173449994342, 0.30758677414695257, 9.999999999998899e-05, 9.999999999998899e-05, 0.002194586371458751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07086241778546665, 0.062231737759405936, 0.08363830429553587, 0.07873495191239033, 0.0482140317570231, 0.0777979515414654, 0.07460024049872915, 0.08132137907097037, 0.08133805669306116, 0.06632932636700573, 0.043643673582858145, 0.03724037084562437, 0.05331379563080951, 0.06905241319721078, 0.07243335253328698, 0.03935525863382483, 0.05683554525362777, 0.03949595015455876, 0.9771644923144347, 0.9707401788200427, 0.9859478842140403, 0.9716636820727065, 0.9794643548303954, 0.9688612191678109, 0.9770042842734024, 0.9794677693411187, 0.976381726499638, 0.1316962729958061, 0.1276096802641974, 0.1000549730879704, 0.11233017681063229, 0.13541561527835544, 0.12952426778562365, 0.09001488796725532, 0.09479505311017533, 0.10864633135269652, 0.16537000135227264, 0.18216708323167563, 0.18200707976915953, 0.1949400531718326, 0.24123265136978456, 0.20871750146375456, 0.12257018849627743, 0.21831049997028007, 0.2089821531543885, 0.05209113532483589, 0.03690598776333387, 0.10826764616430773, 0.04719986335493631, 0.16784496949210548, 0.06806081214674764, 9.999999999998899e-05, 0.14822126312956407, 0.12612362614317574, 0.11516926507315361, 0.10393198535319537, 0.09795181285956456, 0.028071024829305347, 0.09499233047624434, 0.11109885165580158, 0.12529081145229215, 0.031206913310451112, 0.10148176027175904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04461834263902287, 0.05427127560211997, 0.01628709966105002, 0.08030736981560771, 0.004770978027536343, 9.999999999998899e-05, 0.05044297604073689, 0.06345463485501512, 0.06793795824881232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031976903857772188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045945788620271766, 0.010317525466911004, 0.15363914005238188, 0.042740462823460446, 0.027168507354791815, 0.04895517426544105, 0.03895728949232291, 0.028811283022785017, 0.05650737555847807, 0.32891967110650056, 0.3277901975537647, 0.2854357629660478, 0.36299894904278995, 0.3622858218416928, 0.3331881289252985, 0.29747906335383667, 0.3496923336692245, 0.2932019022458814, 0.05222884626290614, 0.07110701316123103, 0.05754510368196153, 0.07087345246148702, 0.08154554373099598, 0.07619183098431659, 0.08716965291311318, 0.06846043287159065, 0.06263039105616863, 0.12780133238975, 0.1160625547906966, 0.1481317362561826, 0.14062350627655673, 0.1398302228879944, 0.1443952002930199, 0.15405011031823013, 0.12260100147781172, 0.17275844588680578, 0.21891944451339518, 0.17076647937677247, 0.24788201864551862, 0.24292739030417532, 0.1920767540751298, 0.17608057118498988, 0.26362559581484324, 0.23995824039248215, 0.26335803693472404, 0.15715876187148203, 0.14318352959027214, 0.17679939480097961, 0.14795783655438133, 0.13842133413572666, 0.14639434971401866, 0.16763932409144255, 0.16130192609573746, 0.11370960713419442, 0.17681606320700505, 0.1825371818269671, 0.17827349842724816, 0.16983794852744394, 0.18237931565529408, 0.16345931733259567, 0.20186835452895546, 0.15587681808502496, 0.17806056394573366, 0.16693103014863953, 0.15828475429426092, 0.1629395820162466, 0.18008840426091177, 0.15816647052626254, 0.167209339288929, 0.17126791676599262, 0.1614054770265949, 0.1647783589467775, 0.29170672502181083, 0.16080275463011418, 0.1430129861988444, 0.3374520694341723, 0.19714918575319385, 0.1886354575096334, 0.13947521391297235, 0.15028351415261854, 0.1288360606365463, 0.21003670221415727, 0.17038118395592228, 0.16659212242453247, 0.28049672372590884, 0.22323294907905078, 0.10103793238513792, 0.2000571282196142, 0.210075710882608, 0.19369396913467285, 0.17318265103777686, 0.170084427143946, 0.1858750951566106, 0.170547841745728, 0.17615268629085712, 0.20141545542353168, 0.18257246456898313, 0.17590279080396687, 0.18018655239750625, 0.049205829506100085, 0.045594699315327114, 0.05609452215652122, 0.06460631239551262, 0.06059500160194187, 0.048918407526736485, 0.06166026620259635, 0.06461478086598105, 0.061505238198792944]}, "mutation_prompt": null}
{"id": "7f213873-f301-4d3b-a9b7-db391fbbf750", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia_weight = 0.8  # Adjusted for better exploration-exploitation balance\n        self.inertia_damping = 0.9  # Slightly higher damping for stability\n        self.cognitive_coeff = 1.7  # Increased for improved local searching\n        self.social_coeff = 1.4  # Fine-tuned for global exploration\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Higher crossover rate for exploitation\n        self.elite_fraction = 0.15  # Adjusted elite fraction for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Adjusted velocity range\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted step size for exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if self.evaluations < self.budget * 0.7:\n                elite_count = int(self.elite_fraction * self.pop_size)\n                elite_indices = np.argsort(scores)[:elite_count]\n                for i in range(self.pop_size):\n                    if i not in elite_indices:\n                        idxs = [idx for idx in range(self.pop_size) if idx != i]\n                        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                        mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                        trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                        trial_score = func(trial_vector)\n                        self.evaluations += 1\n                        if trial_score < scores[i]:\n                            self.population[i] = trial_vector\n                            scores[i] = trial_score\n                            if trial_score < self.personal_best_scores[i]:\n                                self.personal_best_positions[i] = trial_vector\n                                self.personal_best_scores[i] = trial_score\n                                if trial_score < self.global_best_score:\n                                    self.global_best_score = trial_score\n                                    self.global_best_position = trial_vector\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Chaotic", "description": "An adaptive hybrid PSO-DE algorithm employing chaotic maps with enhanced exploration-exploitation balance and population diversity management for superior convergence.", "configspace": "", "generation": 85, "fitness": 0.30714821954973587, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8171518977285905, 0.8150008968698028, 0.8294919489729078, 0.8461713374888179, 0.8366938285651878, 0.8248842203667496, 0.8398942612258269, 0.7888702820852156, 0.8164446472346445, 0.27281599226451814, 0.4768520907925685, 0.49830045501639086, 0.4099983838734541, 0.49150153212394754, 0.2939469143085687, 0.4330624954154829, 0.42231827845787406, 0.39435923724129285, 0.10084081118855193, 0.08696345505207215, 0.12563402912340393, 0.09871288212245932, 0.11633380492323342, 0.10955274932010672, 0.10140098970333944, 0.10504673894397853, 0.13941621535989035, 0.12304135623972778, 0.0400304132708692, 0.09765014260200444, 0.08339572948610152, 0.11220391016186582, 0.08266197563001043, 0.08120268695190058, 0.10892259906449364, 0.09868370314612407, 0.9745117198802234, 0.9655610197393613, 0.9757566697723027, 0.9729407635110481, 0.9649409635873695, 0.9709476147594456, 0.9748273681517292, 0.989985541055039, 0.974762387062191, 0.46306897052715723, 0.4523489274403333, 0.41794747275117483, 0.4844674915493712, 0.3496366018909002, 0.3525176082560012, 0.48213182993221393, 0.386371178160694, 0.32971930849198927, 0.1719919676502495, 0.22503733515297586, 0.5387658612765582, 0.19205272661487205, 0.21355782041686266, 0.8708450889687024, 0.8000722000251909, 0.23139241756927242, 0.8520310076774658, 0.38456855782128885, 0.152561604889085, 0.1305018771935449, 0.2856563657656498, 0.12328101024718585, 0.10351569941379313, 0.3302336836680583, 0.12312438317552155, 0.24499431568682806, 0.4623183531564037, 0.10593737070956921, 0.2294795165628175, 0.13001576856125552, 0.21952840280581976, 0.2530754910341838, 0.2809354673783153, 0.12502262118966423, 0.18121507607663345, 9.999999999998899e-05, 0.06902966914400566, 0.10099916115192742, 0.0228660591454114, 9.999999999998899e-05, 0.00011391765776569418, 0.14993867015883244, 0.1047809940875879, 0.004396175294725468, 0.2109847650822515, 0.16135836770835799, 0.31497365027053514, 0.2617961828312074, 0.22266598464068044, 0.12090972564226343, 0.14082968654393102, 0.27603807088902677, 0.24344281551267233, 0.04710588454631437, 0.1393110362667972, 0.06897126311247226, 0.1161907946512003, 0.07168825023331049, 0.11688260114432947, 0.1525896607528059, 0.3862667212704165, 0.15968993681793386, 0.1862922507326109, 0.15770229928224822, 0.11963179833992221, 0.18439762090185374, 0.21845352038781796, 0.10982898650824535, 0.059891472575084426, 0.04961545126528999, 0.1092342217784833, 0.5286419171313542, 0.5905083544294971, 0.5589252535264325, 0.5337450245277398, 0.6013458774652085, 0.5471080918780555, 0.5946456444472217, 0.5686871086364576, 0.5801433418037623, 0.10725537291923304, 0.11384666057851667, 0.104064790430072, 0.1293558929075549, 0.12852686178235162, 0.13673199341890885, 0.09318103784473775, 0.13373832885189385, 0.09193970476263325, 0.13176901075138214, 0.180380301246586, 0.16156048159292224, 0.18690770786847155, 0.26200012777644877, 0.20904100182262153, 0.2027100310182116, 0.18607638455306408, 0.1837114772062307, 0.23239620306527875, 0.3195580244219943, 0.28110175343062516, 0.24854254086977634, 0.30958404104858606, 0.30717338400706484, 0.3760763760747019, 0.4701699983657709, 0.3864316666035158, 0.27017298050095984, 0.2186821860968282, 0.21202072242905656, 0.18126836749558184, 0.3408610458940541, 0.22823429578093968, 0.25934153834034357, 0.2554381521454482, 0.2018833906799966, 0.22792518069835055, 0.25632831563220815, 0.19255866700223034, 0.20521500670715886, 0.20755961597242356, 0.20714333267780705, 0.20655034266751549, 0.18581832585340163, 0.27646926108120584, 0.19507340388760164, 0.19206392704454434, 0.20204574480159943, 0.24102863136053965, 0.20913102882291124, 0.2197806180832882, 0.21242742320218555, 0.17291043000886586, 0.19428445966990282, 0.7345154948696325, 0.8610404590732615, 0.1870079968867585, 0.886933372485881, 0.16715149895298131, 0.8585027777294008, 0.16183055775803368, 0.16553068469462817, 0.862952763572984, 0.8156621822306377, 0.21153722556357568, 0.0734593547116712, 0.7668137076028056, 0.16489151687612447, 0.14455846944171558, 0.20902437296218823, 0.8384303999074056, 0.704968441549654, 0.18783085989548898, 0.1708504203408152, 0.2262949469671819, 0.2031835541181105, 0.20133213914793513, 0.19002250348071892, 0.1900499903778572, 0.17837051037795137, 0.17622113460823408, 0.09484084292083639, 0.08867296692724669, 0.09815345310011547, 0.08950210260642621, 0.09031171716700648, 0.09878799505390035, 0.07939778852043533, 0.09352781038636127, 0.09937926041854439]}, "mutation_prompt": null}
{"id": "a79c8144-f3c2-4cea-80f9-b6f31fe506e3", "solution": "import numpy as np\n\nclass Enhanced_Synergistic_PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.7  # Improved for local search balance\n        self.social_coeff = 1.4  # Optimized for global exploration\n        self.mutation_factor = 0.85  # Adjusted for controlled diversity\n        self.crossover_rate = 0.9  # Increased for better exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.feedback_control = 0.1  # New dynamic feedback control\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        stagnant_count = 0  # New stagnant detection\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n                stagnant_count = 0\n            else:\n                stagnant_count += 1\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * (1 - r2[:, np.newaxis]) * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if stagnant_count > 5:  # New feedback control mechanism\n                self.feedback_control += 0.05\n                self.mutation_factor += self.feedback_control\n                self.crossover_rate -= self.feedback_control / 2\n                stagnant_count = 0\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Synergistic_PSO_DE_Adaptive", "description": "A synergy of chaotic PSO and adaptive DE with dynamic feedback control to enhance search efficiency and solution accuracy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Enhanced_Synergistic_PSO_DE_Adaptive' object has no attribute 'inertia_damping'\").", "error": "AttributeError(\"'Enhanced_Synergistic_PSO_DE_Adaptive' object has no attribute 'inertia_damping'\")", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {}, "mutation_prompt": null}
{"id": "429ba2a2-a7ae-448c-b156-57ee136b622e", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.04 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n            \n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(20, self.pop_size // 2)\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Chaotic", "description": "An adaptive hybrid PSO-DE algorithm with chaotic maps, dynamic group learning strategy, and adaptive population sizing for enhanced convergence and robustness on diverse optimization landscapes.", "configspace": "", "generation": 87, "fitness": 0.2957266693076444, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8496558232450016, 0.7830181800421577, 0.8593728099758171, 0.8266139168026073, 0.8282259384084506, 0.8577768874095755, 0.8307371249978588, 0.8488717268231406, 0.8624934748262588, 0.4267154050955049, 0.5351189345621872, 0.6236488058491841, 0.4627695302753755, 0.43791267610491513, 0.38245358582657984, 0.4600915926199115, 0.2610856854882293, 0.6360444607087286, 0.1761564718464258, 0.10357589531863287, 0.13288417197438196, 0.12020432546789961, 0.17301046766750183, 0.15345841272671712, 0.09154731606370914, 0.1563293003728451, 0.13146097845096483, 0.12744808038386857, 0.12106621533718576, 0.10619118700845576, 0.1563774236073756, 0.11470307308216798, 0.10326249204595439, 0.10325260297936734, 0.1361416957320558, 0.08171661324179369, 0.9866270885927169, 0.9706104478437564, 0.9866512551993494, 0.9704860646582273, 0.979475165113717, 0.9696940080139905, 0.9718529811024226, 0.9865151925611181, 0.9702748215620576, 0.4771774632244805, 0.4523124264179591, 0.4290780001520871, 0.4376675907573837, 0.35212026190265466, 0.36932538740929177, 0.48029086780474894, 0.41515035774595477, 0.5243715613677404, 0.22224490982034328, 0.22437587934133796, 0.1684712226250391, 0.2766720461806641, 0.21359927473173934, 0.7870147322571166, 0.1267751993703694, 0.19470438325929496, 0.20886754025663978, 0.26456444254589295, 0.11919062655392187, 0.21766463537349423, 0.113606785691995, 0.27665558725134065, 0.3638580100411902, 0.3044134142792102, 0.352317026454364, 0.22891802276062, 0.2310224254322426, 0.205848261502656, 0.12315383817748171, 0.2926976338901027, 0.20003956149719648, 0.17948110174745502, 0.12875825269958774, 0.23140451367924486, 0.20979058070059775, 0.1175997671419916, 0.12658426471968665, 0.08343340632137097, 0.04032112843499758, 0.04642295453978018, 0.018921935132398593, 0.042501077264682885, 0.16641066647747016, 0.038177092518952516, 0.17278586682523456, 0.1278449899510239, 0.2548586409570651, 0.1973434817383587, 0.1560185949437728, 0.06813739702130495, 0.14647855444024627, 0.1372338165084861, 0.14635190914037688, 0.1655446347348063, 0.03938908162234589, 0.04987679622311603, 0.10214427172578999, 0.30866914064495465, 0.25587669459286067, 0.09689925771201446, 0.08850329430480364, 0.09802332968424166, 0.17435858629850987, 0.12394075688438444, 0.09081677364413898, 0.12180263823967996, 0.15168322779444698, 0.24974852369275058, 0.11567824440148033, 0.05491658774715502, 0.08480864326917947, 0.594567674366176, 0.5586728950007283, 0.5470916353110904, 0.5490261354829089, 0.5563574068410122, 0.5750085678078745, 0.6301284642081728, 0.5680932540417628, 0.5622694190710129, 0.1017306167353288, 0.08851098682979808, 0.12008788758626687, 0.16252101242573336, 0.09000773897037528, 0.13762346662023606, 0.17672627620176262, 0.1774037452127113, 0.08129848672789575, 0.15726561645392323, 0.22214381865397304, 0.18075560146273506, 0.22182122360429302, 0.487422054899329, 0.1837388462592785, 0.22309456439240494, 0.23639852415438667, 0.2306958317088914, 0.34740155334886613, 0.26112055878890306, 0.34613037245063416, 0.3913365585352533, 0.45049982475087735, 0.33690196907086156, 0.33497633421968953, 0.30629101552638227, 0.3089564725021584, 0.2848602318447391, 0.15203729828197432, 0.2104971065197042, 0.15247748823176244, 0.31628039327191826, 0.2728496032511426, 0.272375313381953, 0.2752580926663788, 0.25959705496184904, 0.2172328988177884, 0.1854193976654136, 0.2192476682831741, 0.23402178932648554, 0.21027355106108947, 0.20620873737715784, 0.1884204908214806, 0.20189546968219518, 0.21848617132511416, 0.1971009855018936, 0.35571683878690175, 0.19710002192857, 0.2055865320614545, 0.19546275924912948, 0.19065985394996443, 0.20420562015600408, 0.23446773972409996, 0.20560838910169654, 0.9091078802721424, 0.16623514434438713, 0.15229456897772253, 0.8728478912986433, 0.1987554736622904, 0.19751895137848197, 0.14127899637083652, 0.20189934197207138, 0.14797877357550948, 0.887377868146689, 0.20822025190328486, 0.1674907602580552, 0.10348179113199352, 0.6896773399009734, 0.14642836854164265, 0.10412519150655408, 0.21193273291296366, 0.5332365303598697, 0.18887464986612257, 0.17128862009660806, 0.18249758157707152, 0.1938516713866647, 0.22039669841636544, 0.179746423499628, 0.17290920155324807, 0.20221289586162927, 0.18117304517816657, 0.09633690041527132, 0.07896903686472634, 0.09270307780834663, 0.0868171796442293, 0.07314278704363641, 0.14595647370164477, 0.08792928335553574, 0.09514760160434255, 0.1024055193956761]}, "mutation_prompt": null}
{"id": "21611273-3200-4a6e-9062-018884e74979", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Adjusted for improved balance\n        self.cognitive_coeff = 1.4  # Reduced for better exploration\n        self.social_coeff = 1.7  # Slightly increased for enhanced convergence\n        self.mutation_factor = 0.8  # Adapted to control diversity\n        self.crossover_rate = 0.9  # Increased for more aggressive recombination\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.7):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # More frequent exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.percentile(scores, 60)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Chaotic", "description": "A multi-strategy hybrid optimizer integrating adaptive PSO with enhanced DE and chaotic mutation to enhance convergence and exploration in complex landscapes.", "configspace": "", "generation": 88, "fitness": 0.30661451918310556, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8270207378351883, 0.8285731115867658, 0.837604647926637, 0.8374601191469685, 0.8115057495066333, 0.8321419019486664, 0.8318507427329817, 0.8049242670604163, 0.8474612022152539, 0.5309201986973398, 0.07088519955414907, 0.4239327717135517, 0.5020694420661749, 0.09424761053348507, 0.2495042761649675, 0.5294327620608205, 0.4155918787755536, 0.19227336937773665, 0.11827088668559915, 0.0992928644611244, 0.08917891190817917, 0.10682168651616741, 0.1019230729625209, 0.06746449355046757, 0.08801804075084163, 0.1540978697057661, 0.06338905240893977, 0.10187921348480744, 0.06153631398373749, 0.08593658428278872, 0.09216202324340561, 0.13466872778959482, 0.12192033876061792, 0.09716275144078312, 0.10325036348003724, 0.12821557158701147, 0.9836288317240134, 0.9623175794084395, 0.9843196386182419, 0.9783571760866415, 0.9782470514888213, 0.9361139196928757, 0.9791280724866791, 0.9787167484223747, 0.9781527366151415, 0.48776353908263526, 0.44659232323221887, 0.3088747975257954, 0.5111463478249934, 0.43500432348868867, 0.4099026164226167, 0.4333032964361866, 0.45942470373252386, 0.32604753107876294, 0.8432670704413929, 0.13610785776107936, 0.5372034982559103, 0.21080455346008964, 0.5920133197889356, 0.19154050998716365, 0.8656262440392508, 0.8446396127828739, 0.17210770982590362, 0.39162370464048013, 0.3120500631420715, 0.2880244287789818, 0.12335666519851896, 0.12668102208119147, 0.1892140016059778, 0.24239582471351329, 0.4097579282495307, 0.3136956753112612, 0.24988553424595716, 0.12819496427469856, 0.2453935311197638, 0.3784181588736729, 0.31199377588774624, 0.12939395820225252, 0.1267336785059031, 0.303728317317711, 0.12639251226365922, 0.09476969974261285, 0.10992133844451324, 0.13247705578510904, 0.04589196832402376, 0.04278204543703412, 0.04713397798056762, 0.13695661975067264, 0.1055403501702249, 0.07037397380992627, 0.1215710824291828, 0.17385624292500634, 0.0983662111358814, 0.16006987261594463, 0.17876630704163798, 0.06126193643364275, 0.21417002539858798, 0.16459133681174065, 0.241922446071828, 0.03389186329808669, 0.14371251516033734, 0.1778681272182121, 0.11674220437557759, 0.07330852365029294, 0.07375313229711533, 0.11912565009366882, 0.16578025690833897, 0.08789921404831202, 0.1894409402884144, 0.13045433655457217, 0.13532608775873434, 0.15055549811820546, 0.25176316705292845, 0.1816899747933961, 0.07880255082192256, 0.053771618187179016, 0.20965386152804466, 0.5996516258330602, 0.5488385453019666, 0.6472239080781642, 0.6105813415606323, 0.5464009245987205, 0.6351174911890842, 0.6330556720637541, 0.5933193194758549, 0.6455058965811766, 0.09847211505014652, 0.10806949931115284, 0.06967903817141419, 0.13301551142692603, 0.08572052982119427, 0.10265510365768482, 0.1307863232020542, 0.13542488051814872, 0.11287502029881202, 0.22385357915736948, 0.5188075411530966, 0.3151560332208212, 0.3094433530398024, 0.23206960524927056, 0.1973178923405413, 0.16153730047714254, 0.1480829961431911, 0.18888185281308856, 0.41877376279773704, 0.3217905797944337, 0.30605856789062125, 0.29236285544493357, 0.3979140871280109, 0.2899400456870047, 0.4296741510357355, 0.25316503818986813, 0.4041297639365473, 0.22253811571336224, 0.24991790651023305, 0.3133880211799859, 0.2575097229450165, 0.17106088568633326, 0.22594406723150473, 0.2789191304374632, 0.27382518393778443, 0.22882302154034428, 0.2155853849001158, 0.24522599943293222, 0.19677434724516318, 0.21898202046747062, 0.19869620958757828, 0.23687575557491314, 0.2116207539038295, 0.21353241677370172, 0.23252537908781, 0.19593281017769804, 0.1765245836488777, 0.19115700733365226, 0.20564296530543247, 0.18712091962942523, 0.18162240716973876, 0.19512140432386382, 0.19852772453591683, 0.18827208935420536, 0.8785016835630556, 0.8312149306456559, 0.1510782833252502, 0.8846217614565954, 0.19811459294672495, 0.19784015790722198, 0.8746963807315521, 0.16232301279831973, 0.20964057058496044, 0.8425475029799993, 0.20926305229518227, 0.8441474567236253, 0.19407452931406388, 0.6997884213734746, 0.20671445977493252, 0.1041211286929562, 0.1040118601256027, 0.09412372035068584, 0.19627025030541456, 0.1908781332440479, 0.20967005747793832, 0.1878082367974102, 0.2225567283049663, 0.1809368133176038, 0.17768486850604692, 0.16936474060398, 0.1857012604336591, 0.08781440340360258, 0.10016805144165497, 0.10064369572925336, 0.10613510656816039, 0.08607139881220682, 0.07826996637507944, 0.08092182430685912, 0.10175812235753168, 0.09840487221171479]}, "mutation_prompt": null}
{"id": "f0a8e85f-788b-429f-b79f-22c19b77795b", "solution": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.elite_fraction = 0.2\n        self.memory_factor = 0.3  # New adaptive memory factor\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n        self.memory_archive = np.copy(self.population)  # Adaptive memory archive\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def adaptive_mutation(self, individual):\n        idxs = np.random.choice(range(self.pop_size), 2, replace=False)\n        mutant_vector = np.clip(individual + self.mutation_factor * (self.memory_archive[idxs[0]] - self.memory_archive[idxs[1]]), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            self.memory_archive[elite_indices] = self.population[elite_indices]  # Update memory with elite\n            \n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                trial_vector = self.adaptive_mutation(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, trial_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Adaptive_Hybrid_PSO_DE_Chaotic", "description": "Integrating adaptive memory and mutation strategies with the existing chaotic PSO-DE framework to enhance global search efficiency and convergence accuracy.", "configspace": "", "generation": 89, "fitness": 0.28741275988690834, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8523773163410365, 0.8682205014631559, 0.838275404340451, 0.7604186268651956, 0.8473551962199702, 0.8322709491032512, 0.7778197987631488, 0.8119143945498474, 0.8367279993383305, 0.31404239031116954, 0.07760465223173141, 0.3721235699557548, 0.4389155443201316, 0.30303672997787345, 0.310857471556532, 0.33894753038664494, 0.4007864296874838, 0.28306856960628546, 0.09168096841254192, 0.10835560842695957, 0.08881404394092063, 0.09900573399936385, 0.10816467749297076, 0.10912513685111003, 0.08606548628004151, 0.1158781965160246, 0.10659566660525654, 0.10179877380489089, 0.09136443625555624, 0.06068636414210837, 0.07485508564848276, 0.1270645415126701, 0.08436580286820172, 0.07828762697591596, 0.08344256675055661, 0.13956007283408123, 0.9863552425484793, 0.9784740500660963, 0.9868826647860374, 0.9706551533168848, 0.9762912773335547, 0.9475636946169853, 0.9712276849682479, 0.9786756614460792, 0.979849460375894, 0.44627489981832635, 0.416366903492441, 0.32821277981607166, 0.4316437778628107, 0.424737107495183, 0.38255381509061304, 0.46003704693120995, 0.36628657330908365, 0.32207831316175384, 0.22855809772140634, 0.18559867309262557, 0.22782904060523346, 0.2110051739087241, 0.7448100186935909, 0.31441238476859246, 0.13202352299814502, 0.6854010877094262, 0.16259024420467683, 0.3012423198943833, 0.11427965580526012, 0.11495778791434474, 0.12091190720143663, 0.1270415828508059, 0.19843242196935362, 0.2316933798358386, 0.13103197821973045, 0.3251447939718478, 0.2737152150343505, 0.2952974735646461, 0.1266224118321314, 0.33416313235600037, 0.2975386302229518, 0.12927203268851917, 0.27462824973311417, 0.22753624412563145, 0.2283270833892025, 0.0626247972325269, 0.05329824611102285, 0.15299590881833314, 0.050407417577260416, 0.1295971130665543, 0.02609014979174029, 0.04298889563133357, 0.004209577361656391, 0.011040361271208554, 0.1900172867986648, 0.1757404404723124, 0.19575721083170583, 0.16579506933591326, 0.014589126084884496, 0.10045830216165508, 0.2447188572390696, 0.22377098103316773, 0.1473845134978572, 0.04578621071327382, 0.09280512546347819, 0.2158198149662507, 0.10996673771743115, 0.07854129817910194, 0.0722119386792347, 0.0986429633010133, 0.14053287656318514, 0.07419609959071971, 0.0888678693844257, 0.10073848890521986, 0.23217097877459947, 0.11314689089200491, 0.03743406228561763, 0.10075236686100653, 0.05430816405396344, 0.08136862792516586, 0.08197414676076864, 0.5553323080095094, 0.5668673567417349, 0.550844107847979, 0.5612147106141243, 0.5850696490877085, 0.5750416835401848, 0.5864997415605417, 0.5498728109142753, 0.55596093876347, 0.0778441549531328, 0.08360985996001802, 0.07849082163572563, 0.09511723052348642, 0.12087812685443355, 0.10300221064031323, 0.06201386854179891, 0.1422552743213602, 0.14804021161751368, 0.27997487187274606, 0.24747620065105747, 0.17072087220641918, 0.17035066983924496, 0.4232574158887641, 0.16491189951161755, 0.39435052808568016, 0.3154863037775494, 0.16001185886829605, 0.41056280205287543, 0.28266929135786856, 0.3142211250429313, 0.3482113269103936, 0.2544603929999065, 0.3806516240396792, 0.20987157921882005, 0.2987692172585432, 0.24428240721036276, 0.2391646749567513, 0.19122671296774474, 0.29932828473804807, 0.15976715092886207, 0.21854477254456794, 0.25132936353154356, 0.26801612149661136, 0.19922343503626927, 0.23326262033894418, 0.19423986541810312, 0.1969199438025966, 0.24114206475514788, 0.2796446381253732, 0.19573069422289002, 0.20171599119937533, 0.2164286397491898, 0.20799495549532654, 0.26657058645267984, 0.18727394856124824, 0.20481159946523642, 0.18360689800841934, 0.24841281399844828, 0.18111260822137154, 0.18724061988652752, 0.17769739436067133, 0.19535192142660485, 0.19680550240650396, 0.16345008445606213, 0.1638708609889229, 0.1486881963806116, 0.8837468655683206, 0.19895263673182895, 0.19716114972392862, 0.863070168528526, 0.8054507355076695, 0.8503003565403183, 0.8790954927782725, 0.209644520159886, 0.18507701521411524, 0.6863865173436572, 0.16755419144953998, 0.7023707220492645, 0.20760511752928346, 0.20568851943138622, 0.21000879068659595, 0.1865834381555771, 0.2044107932016931, 0.18187492855678988, 0.1829429734589355, 0.19669454730697455, 0.19455284155664354, 0.19724951769838228, 0.2013912532249671, 0.17799685403109888, 0.09728292648976788, 0.07180041657511615, 0.08238695437981092, 0.08877122338176213, 0.094543627584457, 0.08695891388660892, 0.09619031694462232, 0.08649132413107363, 0.10529863850790366]}, "mutation_prompt": null}
{"id": "4aacd7de-299f-4876-890b-2a8221087601", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n        self.entropy_threshold = 0.1  # New component for adaptive feedback\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def entropy_based_adaptation(self, scores):\n        normalized_scores = (scores - scores.min()) / (scores.ptp() + 1e-9)\n        entropy = -np.sum(normalized_scores * np.log2(normalized_scores + 1e-9))\n        if entropy < self.entropy_threshold:\n            self.inertia_weight *= 1.05\n            self.crossover_rate *= 0.95\n        else:\n            self.inertia_weight *= 0.95\n            self.crossover_rate *= 1.05\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.entropy_based_adaptation(scores)  # New component for adaptation\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic_Improved", "description": "An enhanced hybrid PSO-DE algorithm with dynamic population sizing and adaptive parameter tuning via entropy-based feedback for robust performance across diverse optimization landscapes.", "configspace": "", "generation": 90, "fitness": 0.29143292162636203, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8649400653833539, 0.8056056374512899, 0.8351537527619637, 0.6826739354103974, 0.7652743207250643, 0.8121332201046946, 0.8571530075296204, 0.785489226793729, 0.7007325886082456, 0.16431854657523037, 0.2254661285037063, 0.3569752866114717, 0.08898965133926362, 0.07094703767192245, 0.03429786671410362, 0.06156802826000407, 0.11138722655840105, 0.061587276902529964, 0.09324349078895589, 0.11556492519559036, 0.12014087473903201, 0.09659227346993482, 0.09824770257383042, 0.08787111250771418, 0.09079042114758318, 0.11957329743395073, 0.12938147318213578, 0.101862777061558, 0.09375059886339254, 0.12018298449080134, 0.1578511294113818, 0.10018478310798196, 0.09421148850492811, 0.06592111193178407, 0.08068908086521354, 0.07468207631093648, 0.9789346078899183, 0.9686563678351661, 0.9859426323397488, 0.9686635482842225, 0.9795059649770788, 0.9720390352150007, 0.9716976505049987, 0.9865145531240455, 0.9691476822428013, 0.5010605035872442, 0.42845276460658677, 0.3778135909113992, 0.5096877589692221, 0.4888005793183994, 0.4965037872499597, 0.3427566338311572, 0.4729496169054561, 0.4412351604742418, 0.22524882428478255, 0.18727868474517295, 0.22531748317974665, 0.19212320016592344, 0.27147376314083727, 0.21071079992665376, 0.12576797432856457, 0.1816485813839196, 0.834855300181103, 0.24138549873956294, 0.19045191570119624, 0.20444395071944177, 0.23848009731654096, 0.2743544038286475, 0.18333826369632433, 0.19033474063786215, 0.20441105694160822, 0.41955670489941443, 0.2714278701480204, 0.40074250425567304, 0.1327278815249261, 0.2369136463410194, 0.2149006979938154, 0.2298054044905351, 0.34898410394390456, 0.1301531564848134, 0.3265124586722804, 0.1259403944787949, 0.0967831571334058, 0.07085030241843393, 0.06358674614775262, 0.10025368296227333, 0.024041597719638763, 0.19787224176475005, 0.005055261355732754, 0.08033260268650178, 0.4523877394041588, 0.42083495420884487, 0.3572726652834385, 0.353253569545223, 0.20504776896738786, 0.1541727651366146, 0.15916835159900988, 0.29174351411901567, 0.3412064017423472, 0.058007606437536885, 0.2817146378967986, 0.052440507224310706, 0.10865630107558066, 0.2016622873997166, 0.11613147831446802, 0.10122381372821987, 0.09899324242678176, 0.08597994111848695, 0.19035403265758855, 0.32261312707898604, 0.2976805024521101, 0.2302123821433637, 0.13085924034655405, 0.2968630341229276, 0.18187488060040025, 0.14315812009710482, 0.08341564969062643, 0.6694631819367203, 0.6583265944032562, 0.5917136033943601, 0.6358873370843041, 0.6276584993629031, 0.5779806642099395, 0.5537750547006081, 0.6442324239498511, 0.5470564702942728, 0.08037876010746181, 0.1291024842290701, 0.06624279760608331, 0.08392942291851246, 0.09103868434897833, 0.07738636907608365, 0.15986168433971693, 0.1418298944345957, 0.0907321190268483, 0.18476428476541773, 0.17379298425083034, 0.22705609157336426, 0.4348325807628163, 0.1929876520514866, 0.1974330308522233, 0.2773626772702876, 0.18444785867881996, 0.20618471144347472, 0.29030168328457595, 0.2634510926528526, 0.32397553690649905, 0.33453054939211, 0.3502007466287709, 0.3976449133370378, 0.27266245316488436, 0.42473028964831117, 0.3559576516171091, 0.24121326676048627, 0.15052143178842603, 0.2536223095781437, 0.1617895251153637, 0.19376128431509154, 0.3628008759793845, 0.29370035767060865, 0.3095088832717048, 0.35996568555259323, 0.18705980474095651, 0.20297157219768014, 0.21363107472636922, 0.26783746478497994, 0.2239122422948856, 0.19445424128228095, 0.2316565952377151, 0.1924582266084791, 0.20984449346624523, 0.18342904873505805, 0.1802294812904427, 0.18995596133345316, 0.21941346881559431, 0.1714460231590983, 0.1931938140617473, 0.208109349759922, 0.21574339381873364, 0.20307933604499895, 0.8460000094121279, 0.1260568559204348, 0.15002387951815876, 0.9143008154544883, 0.1995878589308373, 0.19901450125555853, 0.14217797536967192, 0.16148413347742718, 0.16778225428781823, 0.8945681175812313, 0.2101197712052223, 0.2113364018865379, 0.10405355166846963, 0.7698011537604056, 0.7690408537962719, 0.20819076207899911, 0.2002731015997209, 0.21120923140977177, 0.18469334038021923, 0.1749474348772837, 0.1891598767132826, 0.20296817721956328, 0.19723392104533155, 0.1921102011504171, 0.19479705372392742, 0.21137648379257934, 0.22313648988849366, 0.10353714430773275, 0.09999729694267534, 0.09075323557021453, 0.07588437036032503, 0.0902967517166724, 0.09280368878233436, 0.06713916699872657, 0.10231539021540537, 0.09632745998546766]}, "mutation_prompt": null}
{"id": "20b71d69-4bb8-403e-8cd5-7a4b4b44f2ff", "solution": "import numpy as np\n\nclass Adaptive_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.8  # Adapted for better exploration-exploitation balance\n        self.inertia_damping = 0.9\n        self.cognitive_coeff = 1.2  # Adjusted for improved local search\n        self.social_coeff = 1.4  # Optimized for dynamic exploration\n        self.mutation_factor = 0.8  # Balanced for controlled diversity\n        self.crossover_rate = 0.7  # Tuned for robust exploitation\n        self.elite_fraction = 0.15  # Reduced for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget):  # Reduced sequence length for efficiency\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx = (chaotic_idx + self.pop_size * 2) % len(self.chaotic_sequence)  # Adaptive chaos control\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.05:  # Reduced frequency for Levy flights\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:  # Less frequent reinitialization\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_DE_Chaotic", "description": "Introducing adaptive differential evolution with balanced exploration-exploitation and adaptive chaos control to enhance convergence and diversity in high-dimensional landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'Adaptive_DE_Chaotic' object has no attribute 'levy_flight'\").", "error": "AttributeError(\"'Adaptive_DE_Chaotic' object has no attribute 'levy_flight'\")", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {}, "mutation_prompt": null}
{"id": "9bf9dfd4-e129-46ce-a6c8-a0baede6acf3", "solution": "import numpy as np\n\nclass Improved_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.85\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.85  # Decreased slightly for finer control\n        self.crossover_rate = 0.9  # Increased for better exploration-exploitation balance\n        self.elite_fraction = 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted step for controlled exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.4:\n                self.pop_size = max(25, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))  # Dynamic levy flight to enhance diversity\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:\n                stagnant_indices = scores > np.median(scores)  # Enhanced reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Improved_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm with adaptive population resizing, dynamic levy flight integration, and enhanced reinitialization strategies for efficient convergence.", "configspace": "", "generation": 92, "fitness": 0.30946616109669695, "feedback": "The algorithm Improved_Hybrid_PSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8559087222550936, 0.8483134022103802, 0.8465993345432341, 0.802994427854587, 0.8491255267096074, 0.8689104417816973, 0.8395328235281262, 0.8543548643818322, 0.8244865813298122, 0.5054813421659272, 0.38485566531527293, 0.4177648918914959, 0.3385301148313109, 0.45092124586312543, 0.3029615964828061, 0.4755684616843442, 0.31835652121434643, 0.40923431090324625, 0.12011422221178147, 0.12431643529403169, 0.14025066072724313, 0.10537939180065226, 0.12731209104281993, 0.1335041318193093, 0.1028754264423446, 0.10544988513567843, 0.13733541475190703, 0.10405455586794576, 0.057343872723620404, 0.10845872888936625, 0.07821144637689126, 0.06384249287937294, 0.12616644681944178, 0.10403917816536601, 0.0858806018103111, 0.08186271941766521, 0.9796296602525765, 0.9640797411784878, 0.97862675683028, 0.9707135472478176, 0.9775038963844863, 0.9622945919094428, 0.9713926024557906, 0.9786899724830199, 0.9683979165071412, 0.49337943626128833, 0.5067437669427292, 0.369434372088996, 0.502801324908869, 0.5075298711912498, 0.49556963323826453, 0.5657140316411531, 0.48719133057537334, 0.48978541931130226, 0.8675160496952319, 0.3441600887169315, 0.85658362711561, 0.21665689029407242, 0.277550832077206, 0.1906827936789679, 0.12509999260123073, 0.23185543170289113, 0.2290946665073632, 0.1306194955566089, 0.19984117402082824, 0.2293983408494501, 0.1291740051497432, 0.33950431222183775, 0.12931394694321752, 0.2039290644519054, 0.27678087758028647, 0.511229892892892, 0.13131759683254518, 0.21895684623044998, 0.13147249451716414, 0.22527076359763998, 0.23646508322498971, 0.3101972061163617, 0.2734578454618497, 0.2799478223701827, 0.23337851788046138, 0.07934289719066401, 0.03377660713287134, 0.0776651918636393, 0.05892311323136834, 0.012653063497753858, 0.04542887837166831, 0.04705921238226851, 0.07803975944331909, 0.08134777538411797, 0.2586243943060076, 0.2764955061574388, 0.19072412833724472, 0.23204866648259836, 0.2777758074599135, 0.302983102603814, 0.5182896827165879, 0.12434061213304937, 0.27031222977664815, 0.11645105045520088, 0.08759119696479978, 0.060100215139557656, 0.11485031271679969, 0.09565942726157906, 0.07685243181096046, 0.26835933177924076, 0.13700976282209498, 0.25815125009223794, 0.2163306733205843, 0.0581836162855911, 0.25914920588072143, 0.2012194211706545, 0.1251470095889572, 0.1582111538000398, 0.11669726677715475, 0.05428022618872619, 0.08202723968367986, 0.5578779373209379, 0.5886342604105355, 0.6360880404888414, 0.6861894546044847, 0.6201309803216108, 0.5395646041798963, 0.6531799280810674, 0.6916887643935401, 0.611108106025646, 0.10803551230292818, 0.1391892059547103, 0.06404437050413414, 0.12050468499479339, 0.0948574948609372, 0.13036601520830626, 0.0825228842696426, 0.1270741862576129, 0.14934667387696066, 0.18211077993424862, 0.1671338199760214, 0.20300649856759412, 0.1422766641166121, 0.2262058736314445, 0.45493234141751293, 0.3275542310387296, 0.14624505836401802, 0.20236766535981554, 0.4022306812664538, 0.2918414489866219, 0.40677545942370485, 0.26550539419526753, 0.3727042514285088, 0.27676078562389017, 0.2881817697092558, 0.3748197242083531, 0.4249733539277394, 0.186821607833196, 0.2201585425735918, 0.30562594340621474, 0.20715865532598465, 0.19394063852453391, 0.2980508809305873, 0.2660247459283479, 0.2636269013955739, 0.17456812027116397, 0.18660441114119886, 0.21208083157821744, 0.20263832530374748, 0.2784326477270187, 0.20075404637409877, 0.20414915125027844, 0.23038022808967962, 0.20780964667525925, 0.26317378113911927, 0.7011065986979589, 0.16667767946260958, 0.18806518323464694, 0.20021276751644268, 0.19702469117988608, 0.19738078753862942, 0.20174487573419142, 0.21242122023203658, 0.18053829265383114, 0.9018488897509593, 0.12643200048711056, 0.1533213718995119, 0.1717459538468078, 0.19969399275031718, 0.19843835756885275, 0.14206690655140608, 0.16247053036396097, 0.8620684424087515, 0.8887800588080955, 0.21081876738777527, 0.16787076607361706, 0.6960486406969644, 0.5945947535392927, 0.20767375219768702, 0.207349967683647, 0.2073580289275586, 0.7514319914470906, 0.19979461251033404, 0.19963234797232987, 0.17652203188728421, 0.18572615500893885, 0.18303395604509665, 0.196424985189962, 0.18036263004321684, 0.19053596449580934, 0.18713382923947564, 0.11528339429553291, 0.0918924151492514, 0.13042889603691654, 0.08880668555476057, 0.10554716609415427, 0.1146416073815173, 0.10514931437682717, 0.10183596597500533, 0.08739263326255753]}, "mutation_prompt": null}
{"id": "42dc1fdf-125e-4af6-803f-b6fb55baabe7", "solution": "import numpy as np\n\nclass Improved_Chaotic_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased for initial diversity\n        self.initial_pop_size = self.pop_size\n        self.inertia_weight = 0.85  # More dynamic balance\n        self.inertia_damping = 0.88  # Adjusted damping for gradual reduction\n        self.cognitive_coeff = 1.4  # Tuned for effective local search\n        self.social_coeff = 1.7  # Enhanced for global search strength\n        self.mutation_factor = 0.8  # Adjusted for diversity control\n        self.crossover_rate = 0.9  # Increased for better exploitation\n        self.elite_fraction = 0.25  # More elite fraction for robust convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Adjusted velocity bounds\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.05 * step  # Adjusted step size for controlled exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        dynamic_pop_size = self.pop_size  # Dynamic population adjustment\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += dynamic_pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+dynamic_pop_size], self.chaotic_sequence[chaotic_idx+dynamic_pop_size:chaotic_idx+2*dynamic_pop_size]\n            chaotic_idx += dynamic_pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * dynamic_pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(dynamic_pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(dynamic_pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.5:\n                dynamic_pop_size = max(30, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:dynamic_pop_size]\n                self.velocities = self.velocities[:dynamic_pop_size]\n                self.personal_best_positions = self.personal_best_positions[:dynamic_pop_size]\n                self.personal_best_scores = self.personal_best_scores[:dynamic_pop_size]\n\n            if np.random.rand() < 0.15:  # Slightly increased probability\n                step = self.levy_flight((dynamic_pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 6) == 0:  # More frequent reinitialization\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Improved_Chaotic_Hybrid_PSO_DE", "description": "An enhanced chaotic variant of hybrid PSO-DE with adaptive inertia, diversified perturbation strategy, and dynamic population sizing for better exploration and exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.30744226136494146, "feedback": "The algorithm Improved_Chaotic_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.7507090012341877, 0.7916237734716247, 0.8266366372549349, 0.793799857611057, 0.847288032054874, 0.8253543230540169, 0.7770680219259543, 0.8170565166130954, 0.8229191142446208, 0.3802872850271346, 0.21875475915630782, 0.473060722560396, 0.25148671242571485, 0.4978689207761777, 0.5084311997607331, 0.24681018268746502, 0.5719654767508717, 0.5529075158037611, 0.10853357093991856, 0.11757110594251585, 0.12560150171340811, 0.15346920790379592, 0.12490520897554414, 0.10163728103393055, 0.14158894451291815, 0.12112528831870517, 0.1051906659188675, 0.07847924539441065, 0.12121184643176808, 0.09922916091083622, 0.09552566560689735, 0.11402913574868812, 0.06591176730521875, 0.10899114583768499, 0.12571425152361093, 0.10430468457417008, 0.9755316780822743, 0.9576465362359479, 0.980661132331718, 0.9750952353652917, 0.9724252103292763, 0.9667685754799412, 0.9754267281892499, 0.9847735465721329, 0.9758687664291633, 0.4002869621972168, 0.35811178138676825, 0.34576785465160076, 0.3992930082543962, 0.46132184127271125, 0.40583414272178153, 0.47478623120213015, 0.469228237489582, 0.40019860927787787, 0.31003997972495745, 0.22812096608931776, 0.8214691936298797, 0.27178389434729966, 0.576436371554425, 0.2605416963170394, 0.7821485065996959, 0.23682826405771362, 0.8382800004329106, 0.44468493921308994, 0.11900470420276255, 0.20071463291631786, 0.16708664787764282, 0.3037537956762385, 0.12593120044275896, 0.20759300173326944, 0.18948005671508616, 0.12876795411145125, 0.3234842661281918, 0.1652400184542102, 0.2580888378923595, 0.26447934204913903, 0.3101783388114814, 0.21608236480344445, 0.2081839956358288, 0.3483410406094084, 0.25756763120102055, 0.07184744008339694, 0.0006041093585154034, 0.060081594124679616, 0.038091367425637124, 0.0016363620720105665, 0.08633876274086671, 0.02473571038203859, 0.01546568509565549, 0.008255261228944044, 0.13075724324849758, 0.0869446356029957, 0.5568133220256628, 0.27583879275058754, 0.1697669617602351, 0.49433601042567765, 0.3481734683477239, 0.2658722424841884, 0.2855648932359819, 0.04145564069267005, 0.06700281646921669, 0.10705614364108806, 0.13489780820726105, 0.28054071268482506, 0.1455119756547003, 0.09462682340431405, 0.11541807334128085, 0.09428666407315867, 0.1475178015139187, 0.22788645004948815, 0.16968220697201408, 0.21574688080172144, 0.25667035921135883, 0.20580187808543415, 0.05446856681051215, 0.07890101670422245, 0.054127951467724644, 0.5397661036038758, 0.5669713066374626, 0.635715399043864, 0.6020342743523608, 0.6397448073195083, 0.5440376347411784, 0.5657338642438782, 0.6472546967049868, 0.6585985152695137, 0.15747853081558005, 0.07397559882002591, 0.11077607425609148, 0.0951668441504746, 0.12440272594889756, 0.08994405610479239, 0.09942273629750487, 0.11326485807750464, 0.13316771184245646, 0.2904679236803772, 0.14516326452329753, 0.17709735290061412, 0.19185772220094888, 0.23905724005416418, 0.16205212377283518, 0.3529177221914803, 0.281648285681116, 0.16766156061171988, 0.23173510847319057, 0.257579907617443, 0.37995413356093566, 0.39205167977690614, 0.33657369124483827, 0.43797401464650176, 0.441337854672339, 0.3245690546499359, 0.3730660733839233, 0.18601963860771242, 0.14360155890884585, 0.31926287951073984, 0.2155008368261424, 0.1866182080745894, 0.2944039589269194, 0.27840357810676386, 0.27333120590323945, 0.20245777936877007, 0.22514718148588309, 0.21921301950448857, 0.20576917539509654, 0.2377384161714955, 0.24750299173283696, 0.19069168678292336, 0.1924104040422755, 0.2224991532316435, 0.20429341133320833, 0.1969650469695805, 0.1852843983232486, 0.2169799201839846, 0.18590657344505912, 0.2056402847274077, 0.19304129650032742, 0.20180511091495668, 0.1709612340219302, 0.18790993892672647, 0.20465487278843686, 0.18678116154908864, 0.16742081795129327, 0.8602892304457104, 0.19973352803455013, 0.8657011709620697, 0.14212459457351256, 0.1616652009733489, 0.20852304932291643, 0.7828702510204326, 0.7756214746635536, 0.1655699894084519, 0.20877622651428807, 0.16604668518759902, 0.16647421422287612, 0.8011874810659159, 0.20510222860290572, 0.7776184755139468, 0.18080994202841938, 0.21428451343973087, 0.18520246900147763, 0.18708476749833702, 0.19680180414172987, 0.19659955659706752, 0.20925859629167198, 0.1904991113636546, 0.19713760724236706, 0.09515311140057237, 0.09239778439731816, 0.08509050662231843, 0.09129264193560738, 0.08753910622396366, 0.09025981011123296, 0.09447691339833786, 0.0902455347182557, 0.08454560393504984]}, "mutation_prompt": null}
{"id": "309e44ef-1599-4f1d-9bab-670149f6e024", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Adaptive_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.9  # Adjusted for improved stabilization\n        self.cognitive_coeff = 1.7  # Enhanced for stronger local improvements\n        self.social_coeff = 1.3  # Refined to stabilize global exploration\n        self.mutation_factor = 0.85  # Slightly reduced for controlled diversity\n        self.crossover_rate = 0.9  # Heightened for better exploitation\n        self.elite_fraction = 0.25  # Refined for sharper focus on elites\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 3.9 * x * (1 - x)  # Modified logistic map for enhanced chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Adjusted step size for balanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.5:\n                self.pop_size = max(25, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.15:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Adaptive_Chaotic", "description": "An Enhanced Hybrid PSO-DE algorithm with adaptive learning rates, diversity preservation, and dynamic chaotic sequences for robust convergence.", "configspace": "", "generation": 94, "fitness": 0.2950167529684767, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_Adaptive_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.7775652050437112, 0.8560995352484558, 0.8503898180291249, 0.7523585637381593, 0.856647728334309, 0.8110696171084685, 0.8056389962973748, 0.8387729618708711, 0.655943726484317, 0.2767548104631391, 0.4146941325648371, 0.2098729260522364, 0.3540405293369947, 0.31009115290658373, 0.15223196926207605, 0.24371415993499135, 0.273475979400011, 0.04702232415456331, 0.10798991190957041, 0.09755008265448761, 0.07995568792194063, 0.11717636106637708, 0.08387859647998708, 0.1439413236391578, 0.11706860805985853, 0.1757959466812501, 0.13479797627944956, 0.11644350333304132, 0.08314506835577817, 0.09358655616261424, 0.09719383340454202, 0.10007364969886112, 0.10985281242402112, 0.11444453480047034, 0.08432098962327295, 0.09125660053197004, 0.9735683947029377, 0.9566673061900148, 0.9836220001464414, 0.972750403080289, 0.9757787223855255, 0.9547874358968584, 0.9766179263747349, 0.9850262833518498, 0.9755194478287053, 0.4442400807783412, 0.5118887370566436, 0.4350481399450057, 0.41157425578719375, 0.3255455565387563, 0.30313499966776747, 0.4523714505971851, 0.46198210606632406, 0.4017111945639412, 0.6968987301014129, 0.8909260759545745, 0.6473468376388478, 0.19267339466391065, 0.5091325210649458, 0.26668110607390316, 0.11562382190166487, 0.7838041188511411, 0.22869136998832051, 0.19558192131406382, 0.15899217511105634, 0.19986620968200774, 0.11581255833267823, 0.20202215151367087, 0.12739874821019326, 0.17606132322592327, 0.1267208950054619, 0.18423411080745278, 0.20122318421402496, 0.11581533268913902, 0.25671085402563787, 0.23973531373223123, 0.194539417777447, 0.1329356999918928, 0.17201076773492974, 0.19044699712507507, 0.19019840586624936, 0.11677279814522845, 0.13169086014822373, 0.08094728458470213, 0.03991888973050828, 0.0103654846879363, 0.034001040323532794, 0.07627341730616222, 0.035061340985502065, 0.010088094879334153, 0.12363019567372413, 0.22962774481939685, 0.06211366357576775, 0.2847787933608371, 0.18287490852871846, 0.12388756847000093, 0.20968403556401183, 0.16128353570322562, 0.11794541362584587, 0.04624835692012563, 0.03461717544271381, 0.11564615199978268, 0.1284262854896131, 0.10168382643778417, 0.09136377950538177, 0.12489458876737103, 0.21711469068814027, 0.22096663373956638, 0.13100233815661555, 0.16781853236810262, 0.1491145925848123, 0.18337363746749857, 0.1619658492437267, 0.08262816896855807, 0.29554686187748, 0.14050601902343718, 0.07909660275979657, 0.5368106024275578, 0.5590581380978807, 0.5334653499034793, 0.5763379001888869, 0.6443476933612191, 0.5785851197131793, 0.569286043795955, 0.6211889324423878, 0.6115069055220841, 0.09780404058181613, 0.0788791066548914, 0.07598365261201179, 0.11537867836709681, 0.08271100566516576, 0.11853560924375728, 0.09369479878073306, 0.14892068573744688, 0.12394157107490356, 0.20477612954154867, 0.24338034353098215, 0.16605839692543523, 0.18995380545162355, 0.31176244917339513, 0.17797458531227273, 0.40747088954311717, 0.2190667819675658, 0.20445047993758103, 0.388219108194068, 0.26512542971468467, 0.4662649515608219, 0.41783182639223504, 0.3612121541321137, 0.34692348141714724, 0.3804120866286146, 0.3677001004438679, 0.3660629299308584, 0.2726214124717441, 0.20613697566561706, 0.2435494596098563, 0.23366700989512723, 0.2701254961623828, 0.23365967654370356, 0.31324542153694124, 0.32694825428165664, 0.189698442225544, 0.2005778286149218, 0.1992256300608648, 0.21215853955247, 0.20326269258232288, 0.20083480355863625, 0.2029956804546258, 0.22095098885793762, 0.19546386965918483, 0.3121678019837395, 0.1938656594941045, 0.17496745758496568, 0.20319877000179098, 0.20983075407987373, 0.49769079923059134, 0.185910178011921, 0.18951780161444032, 0.21089997672415206, 0.18331144320033432, 0.8619882403561387, 0.8660309358490903, 0.1673986116198355, 0.1723686727693723, 0.20014168351370754, 0.19805237532022935, 0.14208896190045994, 0.18891578927755792, 0.8752206966317921, 0.778196982679811, 0.2092651642277319, 0.12452989707222639, 0.16576892028917223, 0.4529146336342348, 0.1503167546109353, 0.20485943367337855, 0.7369099280550769, 0.6971201487347718, 0.18760897620518902, 0.17474719131767502, 0.18268777437939498, 0.19514764339054125, 0.19200487197193294, 0.19444601412904594, 0.2292740905959486, 0.17677363280212866, 0.19028553930547942, 0.12389594862816489, 0.09001784748270891, 0.08066769523005346, 0.0934463290521782, 0.08462126142805426, 0.09189072761403783, 0.15420748121933825, 0.09828479078205876, 0.10222458344726715]}, "mutation_prompt": null}
{"id": "ded0dfae-999b-47c9-8445-f4538e3d5799", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.inertia_damping = 0.85  # Adjusted for dynamic balance\n        self.cognitive_coeff = 1.5  # Optimized for diversified local search\n        self.social_coeff = 1.5  # Balanced for global exploration\n        self.mutation_factor = 0.9  # Increased to boost diversity\n        self.crossover_rate = 0.8  # Optimized for exploitation\n        self.elite_fraction = 0.2  # Increased elite fraction for focused convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.03 * step  # Further increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                step = self.levy_flight((self.pop_size, self.dim))  # Enhanced exploration trigger\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 8) == 0:\n                stagnant_indices = scores > np.median(scores)  # Regular reinitialization\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_Chaotic", "description": "A hybrid PSO-DE algorithm enhanced with chaotic maps and dynamic parameter adaptation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.877516421931762, 0.8134038280725666, 0.8452201296416874, 0.8518715416860866, 0.8566650925742267, 0.8314301102759637, 0.8717022189873946, 0.8372814319043242, 0.8129618343659313, 0.6905778713714759, 0.6161563109392484, 0.5310023040722236, 0.6328843731523779, 0.49928380157809227, 0.5175210611718155, 0.7164469054030986, 0.47754587417527206, 0.5094617808011974, 0.14400069262601645, 0.11458137644405741, 0.12312720832534763, 0.13749892725820645, 0.12862108720753296, 0.13182484201001987, 0.12112754806923642, 0.15810724571704182, 0.11304814297441501, 0.13981499128945363, 0.08463121739539892, 0.11173813257492016, 0.11403344120190773, 0.14044444337919215, 0.13246144325632336, 0.15444397948180233, 0.11186149283664781, 0.1456725977247324, 0.9866270885927169, 0.9706104478437564, 0.9855359848623892, 0.9709020480244991, 0.979475165113717, 0.9775839162188593, 0.9715532716766377, 0.9865151925611181, 0.9702258649998021, 0.5749850484236123, 0.5373474350482278, 0.45826348667468975, 0.3398072355969689, 0.44157046178111437, 0.4330107862611786, 0.5372879059332019, 0.5314194089251435, 0.5149568384387978, 0.2254420873873474, 0.8601065393899435, 0.8246712616223016, 0.20923680461399263, 0.22031191523405147, 0.20964192570042994, 0.22757645493049583, 0.2402381361761654, 0.756409539825715, 0.2757941224084748, 0.11620719579783656, 0.18435610647453204, 0.11187016528819804, 0.4481314211387818, 0.11604082065922372, 0.18794035716395507, 0.3680551686473774, 0.33791323077701907, 0.21052198177211046, 0.2392614024480597, 0.11996200170620064, 0.19083108713617591, 0.19714290685346436, 0.2771826069772476, 0.23273754168062677, 0.26248063267370547, 0.21267841353954986, 0.06246056477493944, 0.03516634205157276, 0.0871359187945292, 0.062420422861569236, 0.04306275881658783, 0.015081502411478542, 0.025803047693637726, 0.15228690806970535, 0.04080140468240079, 0.15623676226057392, 0.21650142034810516, 0.19748008304634423, 0.2782671359333547, 0.16883874378407215, 0.11180915650636292, 0.2663318694590291, 0.2124488772856814, 0.17761415802703817, 0.048543161149308456, 0.04187946301592438, 0.11968715892415172, 0.11256428143519404, 0.3950385267365355, 0.2718141050298264, 0.09686827015792077, 0.09511219598665066, 0.1159448749626415, 0.1812380175359607, 0.11041068997398529, 0.128813900572312, 0.19818022571317973, 0.17111754259115952, 0.17089127549150784, 0.05385446355538892, 0.05460705798486265, 0.08317199616842885, 0.6124036314611488, 0.5553420686160553, 0.6164363920743876, 0.5332369993650141, 0.5602961903585546, 0.5409447691615887, 0.5837046184898715, 0.667386977822794, 0.6209960978499323, 0.08175499639365968, 0.10874203274155059, 0.14000681615098076, 0.12332818063255713, 0.10696927587942695, 0.09532539827861997, 0.14326295286872992, 0.1409966354558121, 0.10394884939573401, 0.159535141243342, 0.2238521345420348, 0.21411165441486735, 0.2678572591809739, 0.33361220021182647, 0.2192855535877435, 0.40388648232923974, 0.2000328346957705, 0.20851698168224342, 0.25755825083034134, 0.5465747398641656, 0.3246518001950349, 0.34161638597597477, 0.26403281237974074, 0.31223801820885544, 0.20756348469167318, 0.4129046283551635, 0.22200245125148366, 0.17526724501705826, 0.1509516644313027, 0.2639345585311439, 0.17582585115848415, 0.2814413702701516, 0.2569895174556537, 0.36681613534923385, 0.21351964474044083, 0.2874739928201858, 0.19860812937061623, 0.1958229511312929, 0.21758137351044515, 0.2054905581946621, 0.2095705187534227, 0.18129019217853315, 0.2175393672856485, 0.20897926079715312, 0.2160607391536673, 0.18016150531300212, 0.24084361035191593, 0.17867483419910002, 0.19943912753846815, 0.21702601501128116, 0.20249218681406023, 0.1977728849687982, 0.24231514014209743, 0.2468317779364828, 0.8977621452444717, 0.16614309001700822, 0.1501289870582927, 0.9164246583453961, 0.1987371777788124, 0.13104459299846294, 0.1406703765941264, 0.7831410357391164, 0.14733876339915897, 0.68310524858755, 0.20919946115841126, 0.20797167846998088, 0.10393647369674053, 0.7375568222633054, 0.15247587488668635, 0.20457347345992927, 0.21202664328314336, 0.7670950051947467, 0.17421476856872453, 0.18788634011902228, 0.18283980552955326, 0.174653113722124, 0.20271338517588078, 0.19626358110992836, 0.20878654674279684, 0.1972769447306839, 0.19639556700505456, 0.09078091463223659, 0.07227263012490204, 0.06859422499135726, 0.08890048114690474, 0.08715426656354519, 0.09329235844546824, 0.08520030013003166, 0.09725214952460137, 0.07637664417166212]}, "mutation_prompt": null}
{"id": "f3819f58-9f06-4a2d-915c-17ed99f6ed63", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7  # Adjusted for balanced exploration\n        self.inertia_damping = 0.98  # Increased for gradual convergence\n        self.cognitive_coeff = 1.4  # Modified for local search refinement\n        self.social_coeff = 1.6  # Enhanced for global exploration boost\n        self.mutation_factor = 0.8  # Adjusted to moderate diversity\n        self.crossover_rate = 0.9  # Optimized for higher exploitation\n        self.elite_fraction = 0.15  # Reduced to increase diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step  # Reduced step for controlled exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n            velocity_adjustment = 0.5 * np.std(self.population, axis=0)\n            self.velocities = np.clip(self.velocities, -velocity_adjustment, velocity_adjustment)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.2:\n                step = self.levy_flight((self.pop_size, self.dim))  # Exploration enhancement\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Enhanced", "description": "Improved hybrid PSO-DE with adaptive velocity adjustment and diversity enrichment for balanced search and robustness.", "configspace": "", "generation": 96, "fitness": 0.31537323511045645, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "46561613-c630-4357-bbc9-ca2b92e75fd9", "metadata": {"aucs": [0.8118639974806052, 0.8755134851711387, 0.8560901667246684, 0.7637868431899485, 0.8751945591631525, 0.8304606172735697, 0.8253717566800292, 0.8413582849122933, 0.8399334384474582, 0.3355458565532441, 0.45251416698696023, 0.48112587282629926, 0.3230962976070908, 0.4842916153669816, 0.35306197196475064, 0.3053329254476733, 0.4274708487568275, 0.5151798331817263, 0.1104209048590079, 0.14239191848705524, 0.11666617832224002, 0.13157172274149564, 0.11247189470528685, 0.1291326438265873, 0.13452930515690675, 0.1098604032820586, 0.09144348140799374, 0.10033596029523928, 0.14286627874039082, 0.11591015031627305, 0.11570606246844728, 0.095310942960526, 0.08056112365939427, 0.14782563324262354, 0.10136614872372507, 0.09140069691509178, 0.986983601082471, 0.9348881702653106, 0.9854387046248089, 0.9544507142610308, 0.9857304337939875, 0.958931386293381, 0.9707753545907067, 0.986699630935564, 0.9790196895102892, 0.4977566604762884, 0.5629315725753927, 0.4587933054886606, 0.4566550197619571, 0.500112921362424, 0.4961772091804979, 0.4639115931550758, 0.4749241723043037, 0.5036861779900039, 0.1717495845135445, 0.881851040452348, 0.22553493897723942, 0.26723307963512155, 0.2100643247926568, 0.20625904382057847, 0.1261382121519602, 0.7975375468125208, 0.7978483905702647, 0.4259623860197337, 0.12022268252093904, 0.15815997976640195, 0.5090312858905761, 0.4987100472043833, 0.32102561541317454, 0.3351241404078934, 0.5628421661832088, 0.3938810702972293, 0.45005195724652647, 0.2167789131318324, 0.1296550360355534, 0.3662415998706354, 0.35735407885125114, 0.385415416850286, 0.48771809127655996, 0.5416603926470103, 0.5617635431789438, 0.0662390858589974, 0.04887336571865941, 0.1550829210391197, 0.08625130679472437, 0.010504928159694837, 0.0541872484121424, 0.10112322385773387, 0.07201408877313131, 0.08722164064741789, 0.306809308895311, 0.22042064507494719, 0.11471872364779123, 0.11537919905949745, 0.12241966827075901, 0.16051988372090997, 0.11897423841205179, 0.17487952294004172, 0.07403429291111807, 0.27872440160256207, 0.09488574876545153, 0.08396739482990301, 0.1196038298446016, 0.09631674852155336, 0.09066263253480389, 0.09764875076738078, 0.14440872571318286, 0.07003385591242639, 0.13063906768703804, 0.13531122868200873, 0.18982581541761745, 0.17732057214543928, 0.15554096967447917, 0.18678472480021846, 0.25817822821073677, 0.2944049903159468, 0.08169438854451472, 0.6237436950172079, 0.6252797645064343, 0.6109386557752152, 0.6055768740644858, 0.5846958178225299, 0.5997494467038234, 0.585766009890962, 0.6348587575483762, 0.6397609717308681, 0.08960882581142482, 0.07505474321159633, 0.09059250725550905, 0.10832879208276502, 0.09346457808698505, 0.09555763205536238, 0.10457223761238388, 0.10342802860612987, 0.1013040405646719, 0.2647372998056644, 0.1950353940538332, 0.18802667245020788, 0.17573720676640625, 0.25385385638746705, 0.1946259968997699, 0.22506397138583845, 0.25383591870603595, 0.22712288744357656, 0.3191811874954865, 0.33277778265028524, 0.41752699642147195, 0.4723430587306453, 0.17811021079995393, 0.4415029517913659, 0.246978475319779, 0.4642099156433428, 0.39687498310814107, 0.18001675046644217, 0.199552032723343, 0.29777272909605224, 0.15418449922523247, 0.1939548650020344, 0.3287533743011313, 0.285773835572788, 0.2788205031339629, 0.2990049378942493, 0.19602853074301696, 0.17756745468733093, 0.21023556169922497, 0.21817350405135338, 0.20145459761346152, 0.20565217804115987, 0.1996397300309356, 0.18649878704967182, 0.2185342980488476, 0.207639484705328, 0.18310121392057832, 0.18416463038162967, 0.19658637256262246, 0.1871088868965488, 0.1829701758423058, 0.2439783128837908, 0.2491822939491185, 0.6820572352537974, 0.16250377892209522, 0.16673680368478272, 0.15270807037678247, 0.9196859463601719, 0.19957289383303, 0.19782416799270663, 0.14226386638935595, 0.16495143097935983, 0.21012606229501674, 0.8793857048442729, 0.21128921308091697, 0.803553732871225, 0.20734903782661984, 0.1679100181093376, 0.21002745853165372, 0.10439865324317366, 0.09421778425085536, 0.8664379944500431, 0.17791504905900235, 0.21425408389133827, 0.17727974180364947, 0.19519870000500472, 0.22125692855907142, 0.17570502348680783, 0.1903989344484417, 0.20263914189155552, 0.19785442807592668, 0.11105018205029615, 0.08851687197293323, 0.09018848514578426, 0.0793439823934512, 0.09238452032785882, 0.09311980968784594, 0.09103128250624504, 0.08962918545298759, 0.09742665889783364]}, "mutation_prompt": null}
{"id": "84783479-ddb6-4d72-9cd3-52d627f9c4f1", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Enhanced_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased for better diversity\n        self.inertia_weight = 0.8  # Adjusted for better balance\n        self.inertia_damping = 0.99  # Fine-tuned for convergence stability\n        self.cognitive_coeff = 1.6  # Slightly increased for local search strength\n        self.social_coeff = 1.4  # Decreased for controlled global influence\n        self.mutation_factor = 0.9  # Enhanced diversity\n        self.crossover_rate = 0.85  # Adjusted for exploration\n        self.elite_fraction = 0.20  # Increased to maintain elite diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def dynamic_dimensional_search(self, dim):\n        return np.random.uniform(self.lower_bound, self.upper_bound, dim)\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations % (self.budget // 5) == 0:\n                dim_to_search = np.random.randint(1, self.dim)\n                self.population += self.dynamic_dimensional_search(dim_to_search)\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Enhanced_V2", "description": "Enhanced adaptive PSO-DE with dynamic dimensional search and stochastic elitism for improved convergence efficiency.", "configspace": "", "generation": 97, "fitness": 0.2440827261859024, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Enhanced_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "f3819f58-9f06-4a2d-915c-17ed99f6ed63", "metadata": {"aucs": [0.6754745094515409, 0.6214857768462771, 0.6561704133145005, 0.6765167484332455, 0.68467049542854, 0.6440029746602445, 0.6666898282561228, 0.671365417703736, 0.6649640084525787, 0.3401018225541812, 0.28731896611487795, 9.999999999998899e-05, 0.0336759677015005, 0.3690588198544853, 0.029268610093008962, 0.20934663623018435, 0.010075875409137347, 0.1756011522335139, 0.060796372226664785, 0.10479870213116449, 0.09134663888924244, 0.10738304767593021, 0.10094785715310628, 0.0681088571108508, 0.10167156887054551, 0.09698463434422577, 0.08933009003973968, 0.07196468062295258, 0.09042075364909685, 0.08971162136092958, 0.11328660834902415, 0.08075654880887706, 0.08549075784096771, 0.10008538472738382, 0.09005793209971469, 0.08630531263186692, 0.9833789634219208, 0.9631671386629395, 0.9740808153283657, 0.9750961686029741, 0.9702054521361618, 0.9747469662173672, 0.978423986273892, 0.9843567072719314, 0.9755796878016624, 0.2706156585879005, 0.23869454339668417, 0.18731507492933397, 0.2569323402666338, 0.20721953469377563, 0.1385816579583936, 0.11514042406692482, 0.21848021433411036, 0.08422295490657083, 0.16620945856425717, 0.16851477488181843, 0.20338429829563143, 0.19662629881538174, 0.6775476215291215, 0.18999572680965016, 0.5036914635362608, 0.5267352328401158, 0.638582488685203, 0.2510354312132008, 0.07812368558672245, 0.11361674340616645, 0.10454423748296393, 0.1141525091909491, 0.07799841600375712, 0.32603671571202597, 0.12546764102240726, 0.24143777843908287, 0.30519086194225686, 0.02033045830865432, 0.09312179451590707, 0.12088057146257947, 0.23831273887274396, 0.1929398718285451, 0.2388298070591912, 0.23164732025873958, 0.1616675679348456, 9.999999999998899e-05, 0.053146675744481064, 0.029346886090382163, 0.2368155669698101, 9.999999999998899e-05, 0.058467072825516664, 0.13556303466066677, 0.00630448759008273, 0.0028386252062405637, 0.2087463051507099, 0.17214932729461274, 0.08889086897775178, 0.2696959205015653, 0.3251885578275622, 0.060856591398705806, 0.13942620939657502, 0.07754311876908027, 0.08863850136166052, 0.05529533349383542, 0.022366953354621133, 0.08142103792175226, 0.12413981587929135, 0.05368287784647907, 0.06584648899239687, 0.06676316629409573, 0.1822796531779226, 0.049940751737168054, 0.10989861331631479, 0.03300342167628767, 0.14370458063081515, 0.16808520922520986, 0.0337709649405189, 0.27410671694332345, 0.04552742795273934, 0.17935206201222442, 0.06710006181286321, 0.5276704278209374, 0.5084287318736518, 0.5440229734660342, 0.5854058891406131, 0.4463949460074267, 0.20478521442129083, 0.5291501388558556, 0.5503047152848131, 0.5444810569166743, 0.0741706593131517, 0.10830113905955874, 0.09394258586322923, 0.0910480330136576, 0.11261590589206882, 0.12405136790253124, 0.06260491297512072, 0.10473774095931054, 0.10597454757964386, 0.14505964207270938, 0.16045948761782325, 0.15836375615894904, 0.22549655480555153, 0.14339935728903308, 0.1431290083756983, 0.18108543794390708, 0.14055208851752465, 0.20653118042225327, 0.3306612734357923, 0.29053541442988295, 0.31214824335963176, 0.3765097604067531, 0.2927919138968206, 0.3043831990054269, 0.38786890933686236, 0.37844566175676153, 0.3699021052037593, 0.18452870566470825, 0.21515037217366995, 0.285504453580829, 0.20691970012698768, 0.19173078413083133, 0.22762617254920314, 0.23693496438189965, 0.2718984638981774, 0.1485252794165003, 0.19138001851131992, 0.1800799105636406, 0.1869814132939971, 0.2010063639175852, 0.1947965062881155, 0.18991775326186122, 0.18615438814841967, 0.1958528491414897, 0.20732237535241427, 0.1904754223372075, 0.2362887950837672, 0.174388303475139, 0.19024946998816605, 0.18783377177369542, 0.2005866173143248, 0.20081382236010636, 0.2081692258744683, 0.17883511149998, 0.1610563718262692, 0.18593897224069367, 0.203586177003252, 0.7073290872864885, 0.165615830486612, 0.1918901544714232, 0.14089575464898518, 0.16024580733209137, 0.7220999485858624, 0.6939277026720068, 0.2114385719041737, 0.15567166714371683, 0.5671783666306539, 0.16288633563508992, 0.15164480445850947, 0.2054186126105244, 0.19338388790572447, 0.5686525221172112, 0.1692469108656356, 0.16439967043857628, 0.1833877538989772, 0.17121857545888974, 0.17919194999630295, 0.18451570838066478, 0.18948773514610595, 0.1837119477261654, 0.17819805896904195, 0.08515714073462399, 0.06836023433544758, 0.07802791332393155, 0.06993132276463598, 0.06862232728565609, 0.06840806230082674, 0.0760069892205345, 0.07842033327716724, 0.08305257128429189]}, "mutation_prompt": null}
{"id": "2351569d-2f2d-4d8c-a447-d7d88d4da0f7", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Enhanced_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.6  # Reduced for better convergence control\n        self.inertia_damping = 0.99  # Enhanced for finer damping\n        self.cognitive_coeff = 1.5  # Slightly increased enhancing local search\n        self.social_coeff = 1.8  # Boosted for better global exploration\n        self.mutation_factor = 0.9  # Increased for more aggressive mutation\n        self.crossover_rate = 0.85  # Adjusted to balance exploration/exploitation\n        self.elite_fraction = 0.2  # Adjusted to maintain diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        x = np.random.rand()\n        sequence = [x]\n        for _ in range(self.budget * 2):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.02 * step  # Slightly increased step for enhanced exploration\n\n    def __call__(self, func):\n        chaotic_idx = 0\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = self.chaotic_sequence[chaotic_idx:chaotic_idx+self.pop_size], self.chaotic_sequence[chaotic_idx+self.pop_size:chaotic_idx+2*self.pop_size]\n            chaotic_idx += self.pop_size * 2\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n            \n            if self.evaluations > self.budget * 0.6:\n                self.pop_size = max(20, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.25:  # Increased probability for Levy flight\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 10) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_PSO_DE_Enhanced_V2", "description": "Enhanced hybrid PSO-DE with dynamic chaotic exploration and improved diversity control for robust convergence.", "configspace": "", "generation": 98, "fitness": 0.26646861502208813, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Enhanced_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "f3819f58-9f06-4a2d-915c-17ed99f6ed63", "metadata": {"aucs": [0.6588201888229954, 0.5961698471872174, 0.6545953891332652, 0.6583198919551563, 0.6228388965736795, 0.6476350816181917, 0.643158886425159, 0.6658054142785297, 0.6343040480652274, 0.20874912417854385, 0.04934219959825881, 0.19649384635109435, 0.23645964343742665, 0.18349038213241886, 0.16501894121502847, 0.0437725745943488, 0.14835940313928753, 0.13500188107665634, 0.10511248211106772, 0.10300565203084244, 0.1100992404618697, 0.2014355723526473, 0.06259202420491472, 0.10931212925371825, 0.1076748239713583, 0.10146729659118248, 0.07649484830103359, 0.09617760823066179, 0.0935236139413339, 0.10352196741636688, 0.09830609143666846, 0.1123937108548938, 0.08057641299375373, 0.13560443332841443, 0.09482190075146812, 0.10732072935767334, 0.9870190673012361, 0.9623625650289416, 0.986842941731999, 0.9787688541790638, 0.9797338247809112, 0.9708740395595794, 0.9797927306939243, 0.9796367261013852, 0.977889705130649, 0.3315957533536362, 0.24166993387954494, 0.24350878294512512, 0.29629748956404733, 0.2416391886624596, 0.32551999262432496, 0.27948803184302873, 0.3298452074837456, 0.25116954954702164, 0.17114777618283894, 0.6804516306665793, 0.5395517598532755, 0.45520474565407754, 0.599601143058847, 0.19083989495535714, 0.6972116087890962, 0.6919672464225384, 0.14583949888660153, 0.3681476068091172, 0.26887739392037435, 0.12037155842573921, 0.10654555009659672, 0.3096544666598734, 0.22127901271530714, 0.22448065164939468, 0.2790000711209577, 0.31779309643739495, 0.3186318706343042, 0.2130146180507494, 0.39303248836002325, 0.18179280892518135, 0.18930412004688213, 0.12686589500257672, 0.2611884328792462, 0.12276668025068449, 0.28757712183502393, 0.057230991661082586, 0.07324754634785147, 0.08691726391246068, 0.029316942449797323, 0.009175397455720269, 0.0316735279502427, 0.07437136553605961, 0.02548737947230617, 0.0656349939543115, 0.07630479259092249, 0.1641202451783642, 0.23242182193214622, 0.1097328068957788, 0.06676292292951003, 0.037756270878313236, 0.2102468253501919, 0.1346367521720796, 0.13195996790496534, 0.029365861061697585, 0.07208514174366643, 0.04533590873546922, 0.06433976402268471, 0.07635159587788443, 0.12579701695293388, 0.08151969624422506, 0.09919022393509058, 0.0640630523383825, 0.18654535129357142, 0.18092476167536953, 0.19651857503199488, 0.2210026941710772, 0.19570312489278285, 0.14933386978779706, 0.052368904506026825, 0.1086463936096197, 0.07821200186449973, 0.5172840244004004, 0.49583991025695173, 0.5071715316920336, 0.5177833317255753, 0.4912319773239434, 0.4800534407723732, 0.5230085076151594, 0.5321477398943071, 0.49568351081652196, 0.10145197066108835, 0.10258280190583968, 0.13210418640986754, 0.08075297340889209, 0.10861033021932287, 0.10386286424605773, 0.09045141251355693, 0.10352528106649628, 0.09642407084038718, 0.2989449611382409, 0.19061696033656017, 0.26108661192109406, 0.21231793721934245, 0.2184573076645575, 0.1705447497627861, 0.23620476809931334, 0.15596415509634332, 0.15222233907930327, 0.288756003610685, 0.26433147724307404, 0.3693368819618833, 0.3373916570456389, 0.22852201646845904, 0.3529677762777975, 0.2986015588889168, 0.2770179261058706, 0.36874667698278407, 0.2186327812507367, 0.23170475893034503, 0.3010985197912005, 0.2630849414118356, 0.17936946479474902, 0.23326008186846403, 0.22474731423026206, 0.24810779620540369, 0.3005758264491124, 0.23171827067687045, 0.1841767637403129, 0.17971866835601813, 0.19778704187054896, 0.2050264582284801, 0.24493423280681936, 0.20694199164815874, 0.19090158847909178, 0.2068112303400097, 0.18215897523205016, 0.21575775612038428, 0.19781995863789703, 0.19049368931181287, 0.205049073744333, 0.2221371300050291, 0.19556548824449504, 0.2054153709805452, 0.195952632754973, 0.8059831808892073, 0.16257703606424256, 0.15166016686727657, 0.8214751473892307, 0.1997194984745071, 0.19827515519199235, 0.14183925497665728, 0.7403061823603425, 0.20739695051356666, 0.7853304539154807, 0.20869227909913002, 0.20944084553062914, 0.20053437432634347, 0.1659447530054725, 0.1414556181258989, 0.2092437601910082, 0.5560649699232847, 0.6839962061142317, 0.19249180033686075, 0.18187192386983375, 0.1897076073804178, 0.18405816688630205, 0.20123131212458178, 0.18157549929312566, 0.19137917239772884, 0.21744685580007206, 0.18889020805035073, 0.08650688910989757, 0.08129059838203068, 0.07357209398468445, 0.07439507900290754, 0.08514184507670275, 0.06986290550569196, 0.07539682977347872, 0.07640300975067127, 0.07724271591733234]}, "mutation_prompt": null}
{"id": "f780ebd6-c03a-444a-8cdd-bd5fd11aeab9", "solution": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Slightly increased for exploratory phase\n        self.inertia_damping = 0.95  # More gradual decrease\n        self.cognitive_coeff = 1.5  # Enhanced for better local search\n        self.social_coeff = 2.0  # Stronger push towards global best\n        self.mutation_factor = 0.85  # Higher diversity\n        self.crossover_rate = 0.85  # Balanced exploitation\n        self.elite_fraction = 0.10  # Reduced to increase diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.initial_pop_size = self.pop_size\n\n    def levy_flight(self, size, beta=1.5):\n        # Levy flight to enhance exploration, adjusted scale\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return 0.05 * step  # Adjusted step for larger potential jumps\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.population)\n            self.evaluations += self.pop_size\n\n            better_scores_idx = scores < self.personal_best_scores\n            self.personal_best_positions[better_scores_idx] = self.population[better_scores_idx]\n            self.personal_best_scores[better_scores_idx] = scores[better_scores_idx]\n\n            min_idx = np.argmin(scores)\n            if scores[min_idx] < self.global_best_score:\n                self.global_best_score = scores[min_idx]\n                self.global_best_position = self.population[min_idx]\n\n            self.inertia_weight *= self.inertia_damping\n            r1, r2 = np.random.rand(self.pop_size), np.random.rand(self.pop_size)\n            cognitive_component = self.cognitive_coeff * r1[:, np.newaxis] * (self.personal_best_positions - self.population)\n            social_component = self.social_coeff * r2[:, np.newaxis] * (self.global_best_position - self.population)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                self.evaluations += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best_score = trial_score\n                            self.global_best_position = trial_vector\n\n            if self.evaluations > self.budget * 0.7:\n                self.pop_size = max(30, int(self.initial_pop_size * (self.budget - self.evaluations) / self.budget))\n                self.population = self.population[:self.pop_size]\n                self.velocities = self.velocities[:self.pop_size]\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n            if np.random.rand() < 0.3:\n                step = self.levy_flight((self.pop_size, self.dim))\n                self.population += step\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % (self.budget // 12) == 0:\n                stagnant_indices = scores > np.median(scores)\n                self.population[stagnant_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (stagnant_indices.sum(), self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhanced Adaptive PSO-DE with chaotic mutation and non-linear dynamic parameters for superior convergence and exploration balance.", "configspace": "", "generation": 99, "fitness": 0.2592095719975781, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "f3819f58-9f06-4a2d-915c-17ed99f6ed63", "metadata": {"aucs": [0.6618559710202736, 0.7294013582562946, 0.6729175353479764, 0.6960545260419193, 0.7044755934753533, 0.652574754038378, 0.6948663172178023, 0.6591212168764529, 0.6167373840061405, 0.03371767042426477, 0.122549111478918, 0.03486413299328994, 0.04496520280497007, 9.999999999998899e-05, 0.19461593437618963, 0.1419298715769226, 0.16368716580473497, 0.12746021064242397, 0.10874954163393946, 0.15506475116303375, 0.13807175742541988, 0.10667971820908628, 0.13346502970276086, 0.12971632108494902, 0.12090056334788224, 0.16496398204762408, 0.13772163193352793, 0.15678181911044553, 0.07962086384156719, 0.11682647580351035, 0.09384890253913547, 0.10387932954258683, 0.10671538831352678, 0.14999920424817503, 0.09437366462081154, 0.11095255101924306, 0.9852137091169703, 0.9699620986631614, 0.9853699301532396, 0.977293069934341, 0.9784099188360312, 0.9694986209719803, 0.9782507337547373, 0.976577269629112, 0.9862204696105131, 0.336928782797279, 0.3412584526256591, 0.29253614918647275, 0.2912092567974698, 0.30883979301896813, 0.2662560002599982, 0.30499389768111174, 0.2916282495910695, 0.2951093726392777, 0.6068660886564381, 0.17121696738067638, 0.6515519151765948, 0.23414381798463857, 0.18657441957756915, 0.19986209273608924, 0.12538640197902517, 0.7048839613049604, 0.7235662757630161, 0.18606852386346207, 0.11739194473722514, 0.11791370045268212, 0.11532299979638083, 0.12081358793827346, 0.20212853961261767, 0.2195547759310108, 0.18559869886545122, 0.18593827567474974, 0.2148461937893107, 0.30958188070040316, 0.18680414725473915, 0.204031515218014, 0.19430387946714878, 0.19334981466690893, 0.28925261447273465, 0.2264069236426598, 0.09122723031678703, 0.03746508038194529, 0.059418896447686165, 0.11697297757387082, 0.11864260007022953, 9.999999999998899e-05, 0.002579402564096722, 0.03128344962713059, 0.037295669771232665, 0.06992111509586663, 0.1620916763175022, 0.08640796584584565, 0.17901604106063407, 0.1196917385412235, 0.10944506824737288, 0.20350994540656575, 0.2124074567020403, 0.18276766230943187, 0.15533167480680443, 0.02932622165231047, 0.031421474188271126, 0.17408272961495952, 0.10229250766950826, 0.0790463777773126, 0.07529910629230507, 0.06980472219600231, 0.16667047529352208, 0.07851253405070313, 0.17045323494675357, 0.12709630813467443, 0.06583694364752757, 0.21182564816499772, 0.11023541551722738, 0.12962069051844827, 0.05012332562591981, 0.2440012145559748, 0.07689380234809817, 0.5429259222637779, 0.5197294936675942, 0.5093698098502724, 0.4771735073769522, 0.4790927355231275, 0.48036529519158844, 0.511556583299778, 0.5136783018560693, 0.5067678379400529, 0.07573372049334304, 0.10488225325620437, 0.08091333974992598, 0.08973617574115866, 0.07955906017467984, 0.12805061779208005, 0.11085987805086783, 0.14781414025812678, 0.09796113079984903, 0.20978865898991028, 0.2714146136788047, 0.19945481198741144, 0.23145078981469114, 0.25366235191212905, 0.15678273551598687, 0.15243610593846246, 0.17316748883784927, 0.20898861417521541, 0.20241699675519997, 0.2636973735304535, 0.3663246321453194, 0.3372338485048706, 0.25319283256076885, 0.3077420945168645, 0.3464955911408848, 0.3642905771172158, 0.3497861604378202, 0.2183714641046991, 0.23757658209872157, 0.22679478656507757, 0.181367406002513, 0.2315836834608055, 0.22885007642551514, 0.24481489797364475, 0.22756795856936507, 0.2839836222654347, 0.20794473831461302, 0.18736106161681432, 0.19934978672416725, 0.17841120416441025, 0.1928639554174868, 0.1882294774696638, 0.19823043298367027, 0.21404275513810833, 0.18779326059738555, 0.22583734760562324, 0.21700750783495137, 0.23607561640186536, 0.2040427876047718, 0.17776358038781437, 0.2120897978387023, 0.17639230912446013, 0.18572062139211654, 0.19277288676093507, 0.16442516650664907, 0.18379274129055012, 0.15207445702379196, 0.8110410610449876, 0.19806287201048978, 0.19446502294632295, 0.14181540813319737, 0.1606261192948687, 0.8405104502946527, 0.731973398015302, 0.20552822199626242, 0.19820341791411922, 0.7003858057817787, 0.7861524867920804, 0.14857976318693056, 0.20858552971433098, 0.2046756424200551, 0.2072272789030306, 0.1991970990001437, 0.18428093656693456, 0.1854547464582762, 0.20225454338773197, 0.1814963397688103, 0.18350108170645718, 0.1837531862992755, 0.18815747643406633, 0.17377227487314173, 0.09075130984095903, 0.07476618866142126, 0.08837894910072808, 0.08332967808006886, 0.08818315424671963, 0.08227181677145068, 0.08139989432330108, 0.0953022021277864, 0.0802965777110719]}, "mutation_prompt": null}
