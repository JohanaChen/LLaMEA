{"id": "1576242f-029a-496c-af2a-f78716a4380b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 19, in __call__\n  File \"<string>\", line 29, in update_pbest\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 19, in __call__\n  File \"<string>\", line 29, in update_pbest\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5d7d7766-1d9d-4f7c-a500-62798e78638b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.pbest_update_prob = 0.2\n        self.crossover_update_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if random.random() < self.pbest_update_prob:\n            if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n                self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                if random.random() < self.crossover_update_prob:\n                    self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "2ee90388-d67b-479a-a300-2a28c9338e89", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.probability = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                if random.random() < self.probability:\n                    self.refine_strategy()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def refine_strategy(self):\n        for i in range(self.n_swarms):\n            for j in range(self.dim):\n                if random.random() < self.probability:\n                    self.swarms[i][j] += np.random.uniform(-1.0, 1.0)\n                    if self.swarms[i][j] < -5.0:\n                        self.swarms[i][j] = -5.0\n                    elif self.swarms[i][j] > 5.0:\n                        self.swarms[i][j] = 5.0\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "7af9a6d6-fede-4a12-80d3-41c6c36ec7ff", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refine_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n            self.refine()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def refine(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.refine_prob:\n                self.refine_individual(i)\n\n    def refine_individual(self, i):\n        idx = np.random.randint(0, self.dim)\n        new_x = self.swarms[i].copy()\n        new_x[idx] += np.random.uniform(-1.0, 1.0)\n        if new_x[idx] < -5.0:\n            new_x[idx] = -5.0\n        elif new_x[idx] > 5.0:\n            new_x[idx] = 5.0\n        if self.eval_func(new_x, func) < self.eval_func(self.swarms[i], func):\n            self.swarms[i] = new_x\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates and probabilistic refinement.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "4bc6ecdf-c89f-4fda-912b-4e656c981739", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refine_rate = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n            if random.random() < self.refine_rate:\n                self.refine(self.pbest[i])\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def refine(self, individual):\n        for _ in range(int(self.refine_rate * self.dim)):\n            idx = np.random.randint(0, self.dim)\n            individual[idx] += np.random.uniform(-1.0, 1.0)\n            if individual[idx] < -5.0:\n                individual[idx] = -5.0\n            elif individual[idx] > 5.0:\n                individual[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "7aaa0cc6-9dd6-4861-b3e4-3251a4837226", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.probability = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                self.refine_strategy()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def refine_strategy(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.probability:\n                self.mutate(self.swarms[i])\n            if random.random() < self.probability:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "819635f3-e28a-4e4f-8db4-572b82c271b7", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refinement_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                if random.random() < self.refinement_prob:\n                    self.refine_strategy()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def refine_strategy(self):\n        for i in range(self.n_swarms):\n            for j in range(self.dim):\n                if random.random() < self.refinement_prob:\n                    self.swarms[i][j] = (self.swarms[i][j] + self.pbest[0][j]) / 2\n                    if self.swarms[i][j] < -5.0:\n                        self.swarms[i][j] = -5.0\n                    elif self.swarms[i][j] > 5.0:\n                        self.swarms[i][j] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates, combined with probability-based refinement.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "196170e7-bf4e-4aee-81b5-eef3989f79f8", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.change_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                self.change()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def change(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.change_prob:\n                for j in range(self.dim):\n                    new_value = self.swarms[i][j] + np.random.uniform(-1.0, 1.0)\n                    if new_value < -5.0:\n                        self.swarms[i][j] = -5.0\n                    elif new_value > 5.0:\n                        self.swarms[i][j] = 5.0\n                    else:\n                        self.swarms[i][j] = new_value\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates and 0.2 probability of changing individual lines.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "c4d6d9c6-d8a5-478d-bffc-4d0d632efb41", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refine_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                self.refine()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def refine(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.refine_prob:\n                idx = np.random.randint(0, self.dim)\n                self.swarms[i][idx] += np.random.uniform(-0.5, 0.5)\n                if self.swarms[i][idx] < -5.0:\n                    self.swarms[i][idx] = -5.0\n                elif self.swarms[i][idx] > 5.0:\n                    self.swarms[i][idx] = 5.0\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates and probability-based refinement.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "0dd5c601-053c-40e3-b0bb-d28162aed622", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refine_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n            if random.random() < self.refine_prob:\n                self.refine_pbest(i)\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def refine_pbest(self, i):\n        new_individual = self.swarms[i].copy()\n        for _ in range(10):  # refine the individual 10 times\n            new_individual = self.evaluate_fitness(new_individual)\n        self.swarms[i] = new_individual\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 5)\nbest = ms(func)\nprint(best)", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates and probabilistic refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
{"id": "bdc1da7b-8bbf-4978-8c8d-c0c675f2fb92", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.n_swarms = 5\n        self.pbest = np.zeros((self.n_swarms, self.dim))\n        self.best = np.inf\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n        self.refine_prob = 0.2\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            self.initialize_swarms()\n            for _ in range(100):  # maximum number of iterations\n                for i in range(self.n_swarms):\n                    self.update_pbest(i)\n                self.update_best()\n                self.adaptation()\n                if random.random() < self.refine_prob:\n                    self.refine_swarms()\n            self.evaluate_pbest(func)\n        return self.best\n\n    def initialize_swarms(self):\n        self.swarms = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.n_swarms)]\n\n    def update_pbest(self, i):\n        if self.eval_func(self.swarms[i], func) < self.eval_func(self.pbest[i], func):\n            self.pbest[i] = self.swarms[i]\n\n    def update_best(self):\n        if self.eval_func(self.pbest[0], func) < self.best:\n            self.best = self.eval_func(self.pbest[0], func)\n\n    def adaptation(self):\n        for i in range(self.n_swarms):\n            if random.random() < self.mutation_rate:\n                self.mutate(self.swarms[i])\n            if random.random() < self.crossover_rate:\n                self.crossover(self.swarms[i])\n\n    def evaluate_pbest(self, func):\n        for i in range(self.n_swarms):\n            self.best = min(self.best, func(self.pbest[i]))\n\n    def eval_func(self, x, func):\n        return func(x)\n\n    def mutate(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] += np.random.uniform(-1.0, 1.0)\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def crossover(self, x):\n        idx = np.random.randint(0, self.dim)\n        x[idx] = (x[idx] + self.pbest[0][idx]) / 2\n        if x[idx] < -5.0:\n            x[idx] = -5.0\n        elif x[idx] > 5.0:\n            x[idx] = 5.0\n\n    def refine_swarms(self):\n        for i in range(self.n_swarms):\n            for j in range(self.dim):\n                if random.random() < self.refine_prob:\n                    self.swarms[i][j] += np.random.uniform(-0.5, 0.5)\n                    if self.swarms[i][j] < -5.0:\n                        self.swarms[i][j] = -5.0\n                    elif self.swarms[i][j] > 5.0:\n                        self.swarms[i][j] = 5.0", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm\" Harmony Search algorithm with adaptive mutation and crossover rates and probabilistic refinement", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "1576242f-029a-496c-af2a-f78716a4380b", "metadata": {}, "mutation_prompt": null}
