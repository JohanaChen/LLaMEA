{"id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 0, "fitness": 0.09422983617014642, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.12.", "error": "", "parent_id": null, "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "540a87e7-a77e-4375-9dd1-f45042556b8b", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "58f74df3-6843-42ab-b06f-286d7a0984b7", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "a954ae2d-c9b4-40a8-bae5-9dfaf06945d2", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "8e39078f-0b81-4ba4-b9b1-2ceb6f4cd336", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced mutation strategy with dynamic scaling factor\n        dynamic_F = self.F * (1 - self.eval_count / self.budget)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Strategy for Improved Convergence.", "configspace": "", "generation": 4, "fitness": 0.09215159556274448, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.15646176546232493, 0.15425905559566577, 0.16270248948166588, 0.1474402859068752, 0.15430530105422602, 0.16912838497586946, 0.16070709567613972, 0.1540178881725014, 0.14984788986171316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04123249054513378, 0.04771761779457029, 0.03952346839152798, 0.04640555258245527, 0.043351574375700364, 0.0370812540754798, 0.03671236295028446, 0.03676879963247082, 0.04535595920447233, 0.026819090044346017, 0.03060793393842809, 0.02315795099816098, 0.0358993737972747, 0.026434854405252062, 0.026155330827203227, 0.023469647461259235, 0.031259370533895714, 0.042765525086699174, 0.17353564729145743, 0.1559023302280691, 0.3137255326648555, 0.11504503883166617, 0.13476265379321373, 0.21097382053508362, 0.11963692736119624, 0.8064458727751151, 0.10667304460283389, 0.0751635581422303, 0.07391762464758922, 0.09148658580225877, 0.07563860305546166, 0.06145839410323184, 0.060500346263062554, 0.08949820388346119, 0.05896124047262252, 0.07157152003342293, 0.11389738007832506, 0.09640472991240168, 0.10504927700527511, 0.10148000838095139, 0.1201869103759543, 0.1401373875718186, 0.16062615494427102, 0.11392480533257454, 0.10959860034468416, 0.003467853556363143, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001961295783974637, 9.999999999998899e-05, 0.01829908886464704, 0.018695616760414868, 9.999999999998899e-05, 9.999999999998899e-05, 0.002882187255115798, 9.999999999998899e-05, 9.999999999998899e-05, 0.07170171337697573, 9.999999999998899e-05, 0.00269757043134089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03542830487501847, 0.08249285799876849, 0.06914823248734792, 0.03593648791773196, 0.03207358114737069, 0.019833398492934418, 0.04439598004548895, 0.040248411066368006, 0.02606439195005983, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17723519648738906, 0.19362647358419705, 0.18469637492597135, 0.1818678306005297, 0.16861353529449297, 0.17560736060439197, 0.19029298584135557, 0.20274196408891698, 0.18830039838096357, 0.03869738285200397, 0.043579397196763736, 0.036163964559528194, 0.04171668667386408, 0.03399243920787909, 0.043981099251769074, 0.03357877146297472, 0.04506675757264966, 0.0458732564439861, 0.14353244366275664, 0.1558394865252476, 0.12086002942866036, 0.14915473520684042, 0.142257832043589, 0.16267638429231623, 0.12944821511504145, 0.12026942797274098, 0.12871595835838257, 0.1633911749959125, 0.17000561695062388, 0.15945890425748022, 0.163914888674644, 0.17447957222367572, 0.1671010776797459, 0.16099843240523182, 0.18715690738864754, 0.16135518216509448, 0.10273222576535246, 0.09856050243942005, 0.09590575196812501, 0.12312277193064258, 0.10304423094599935, 0.11930937942914244, 0.1086618744255815, 0.1351246511365416, 0.1155591623131309, 0.1631003926808, 0.15077430861333918, 0.15762762754639348, 0.1457516013579745, 0.1354674908898056, 0.16121918100824717, 0.16172436481003227, 0.1627595918317999, 0.15091042031783475, 0.14920982528444238, 0.14335136597678866, 0.11791546697063371, 0.12425887669711522, 0.13851788459191283, 0.1155758703791866, 0.14552798140141587, 0.14372498158286584, 0.13498262492852942, 0.15176536073689928, 0.1553062343358823, 0.2004689193279976, 0.17071511483555146, 0.1634160999311296, 0.1576479316711511, 0.13176644684872785, 0.2481473155051519, 0.1560914576059227, 0.19750082878365693, 0.17935310364017276, 0.15026371617798906, 0.15232304119686157, 0.1603498464896056, 0.14919375425870007, 0.146392341159699, 0.15661707518902512, 0.15157724616659818, 0.1932131212553141, 0.18917283867307, 0.18260167848289277, 0.18618050845285405, 0.19096305119189827, 0.17730400704310778, 0.20473081868845744, 0.1771493959405872, 0.1840979646714639, 0.04912384882929488, 0.044706247173021296, 0.04514553572162383, 0.04609335539757342, 0.060609757491616234, 0.04620780300389138, 0.04174162560358341, 0.05036979169048539, 0.04995142350743231]}, "mutation_prompt": null}
{"id": "2485f461-c12d-4eb7-9530-b2ca46b8e84c", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "7f18e001-088c-4f29-934e-0c9dc262d9f8", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Modification: introduce a scaling factor for broader exploration\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c]) + 0.5 * (self.population[0] - self.population[a])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved Hybrid Differential Evolution with Adaptive Population Resizing, enhancing mutation strategy for better exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.09032725340486003, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.17666219000533223, 0.20563356854933001, 0.1717122726069874, 0.14596874304039065, 0.16974533701601435, 0.15697002987985287, 0.15942161294856794, 0.14871893681328696, 0.16369964430668038, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029670085956921888, 0.03891969627835934, 0.032020699649579876, 0.02885999988095478, 0.030447506849746953, 0.04055851562713375, 0.03050061906708179, 0.052827980620766324, 0.03842227638971596, 0.0171444830664208, 0.0393082140487373, 0.03377928032412525, 0.02489395758798818, 0.04039956444016224, 0.02461283490590016, 0.02586097065816162, 0.024191552959967333, 0.019055601875160977, 0.09730683376532379, 0.8183105412587607, 0.12791858283320567, 0.11750670826508702, 0.15395722083908914, 0.10173364606308277, 0.1354224284290635, 0.14387016247012396, 0.11421698476162256, 0.06944317565063396, 0.07945443803200358, 0.0720665583221245, 0.07573849685452283, 0.09371973090041996, 0.06603695067154225, 0.05772768421320995, 0.0864724892562263, 0.10111615248499495, 0.11303071274549115, 0.13233993362276308, 0.12423719361899421, 0.10710144865361215, 0.11321856056493385, 0.10067453337341759, 0.13238643254413196, 0.10791136505735643, 0.11159260950097905, 0.001861191804545026, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003274656410130805, 0.0022631844311347127, 0.0009679105846749358, 0.00995705334036101, 0.0033975068301111966, 0.015941572429887696, 9.999999999998899e-05, 0.023184757514332355, 0.007918885880710103, 0.010453308369016256, 0.00022143047124478787, 0.0042188342051786565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04984529807945781, 0.049132365076564044, 0.04936460984968016, 0.038056318118866894, 0.03510313474393112, 0.025188821693563845, 0.02604956739411768, 0.023204262921799668, 0.04917280400308588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001188495955531943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1853215237838184, 0.19562203839381054, 0.18747814803365837, 0.19187664727829512, 0.1914146688423386, 0.18892407250332433, 0.19928570192052297, 0.19532216591783658, 0.21608702992819473, 0.032332100206705405, 0.04474153700495864, 0.03752380962339008, 0.04365355264514115, 0.0407148091996834, 0.040054658073959026, 0.04969273754923065, 0.036570799914075414, 0.04127607253226884, 0.14573246394484085, 0.13800138303852671, 0.14037413463101656, 0.15509633546917212, 0.1592021203292967, 0.1478125124248021, 0.14297097354857413, 0.14478108495392195, 0.13142938237305757, 0.15609725748648384, 0.15795941459030727, 0.14900848060419591, 0.16657807364537913, 0.14819542862395663, 0.15311949610106768, 0.1391571642024212, 0.17377774300845283, 0.152998481469368, 0.09691846745416621, 0.09601409044559062, 0.09573219106925568, 0.13056863272934438, 0.10616894429105939, 0.11698199907439177, 0.09771175994881176, 0.12471823460340326, 0.10265764076041084, 0.1619118861833605, 0.1572139700736621, 0.16175613413130163, 0.1679004115699374, 0.15371655188425903, 0.15883712714918197, 0.18789057341757465, 0.14162649550475248, 0.13316199973146814, 0.1349113409690268, 0.13545199618288484, 0.1394034669731269, 0.16394921465429158, 0.14089462494043326, 0.1492970059012736, 0.1446701167622636, 0.13685020960582883, 0.14317314959148175, 0.1371565526410291, 0.18132082479915668, 0.1554589282259209, 0.13086920551096315, 0.17901671974733158, 0.16376029821483784, 0.14876860684960558, 0.21707595491036424, 0.1347310879390594, 0.1253375178012599, 0.20399034134543703, 0.13892119484663723, 0.16681188383797085, 0.12228618670635183, 0.1646920921468643, 0.14180612503602574, 0.13165482086974056, 0.16333923339697665, 0.18722851491963133, 0.2017958232317224, 0.19264869285960484, 0.185960860176834, 0.16629387057582645, 0.19780221036929813, 0.18957689891813811, 0.20503271659801658, 0.19077371215126748, 0.04747061320331736, 0.050871043156216156, 0.04068538564900315, 0.047493612298766474, 0.056151660605819, 0.0452778676544372, 0.0422504697707371, 0.04323244047489261, 0.05535645475811979]}, "mutation_prompt": null}
{"id": "07a2b6ba-c64f-48fe-825d-f3946b480c75", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_max = 0.9  # max crossover probability\n        self.CR_min = 0.1  # min crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_min + (self.CR_max - self.CR_min) * (1 - self.eval_count / self.budget)\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Differential Evolution with Dynamic Crossover Rate for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 7, "fitness": 0.09114055802387361, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.17113643405601053, 0.17200004982328754, 0.16168077427384542, 0.17603286492070314, 0.14709364502151856, 0.15255291646515712, 0.1553562283307529, 0.15427580201385171, 0.15897973930085263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05095513364418769, 0.04591219371373101, 0.026115711741268033, 0.03325386303170674, 0.036013598668308444, 0.050505202725995124, 0.033826735450253054, 0.031089985643514728, 0.03457332447443584, 0.04640313193644019, 0.03684785989824413, 0.02791619158946923, 0.026919717904910434, 0.0270633127706551, 0.03633170544988462, 0.03799907976304806, 0.030587745387075982, 0.02426052804855605, 0.17353553772556296, 0.17152002483321516, 0.8997609393715535, 0.12619554928963894, 0.21753515186423233, 0.21098404995971054, 0.11341207129144948, 0.12279220896577825, 0.12537184058606732, 0.04990943588095598, 0.05532896988934921, 0.058001056346346225, 0.08709043657397852, 0.08213377954231438, 0.06230217646953351, 0.07292266275125858, 0.06626599374311426, 0.057605392078974416, 0.15433824777382943, 0.11292984194743205, 0.12124942296393115, 0.13430769353912453, 0.09661858284314062, 0.10424678984493474, 0.14859654167346448, 0.10496537206087908, 0.15911147256545954, 9.999999999998899e-05, 9.999999999998899e-05, 0.003951457168199002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037682021407774435, 0.03433357773812751, 0.01217809526067426, 9.999999999998899e-05, 0.011067316206058275, 0.011869345524339603, 0.0014980733021117132, 0.008128596137483846, 9.999999999998899e-05, 0.008837547731111228, 0.01740883416419181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029462464947648148, 0.05392266638045817, 0.0943160714988891, 0.07525779740886351, 0.03286604352741451, 0.036517461680026786, 0.019949531850640412, 0.07835341976859489, 0.07478782471376177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17276631326523606, 0.15972343804125944, 0.16955058777500798, 0.1786764195086964, 0.20999137986616867, 0.17577769501307683, 0.18970633613010335, 0.18826700479789327, 0.16491759571094755, 0.03556790770039164, 0.040285997557227726, 0.03813585927979912, 0.04281753195113558, 0.048053468849062475, 0.045511635902763525, 0.06215579738538324, 0.03324535351176661, 0.04330529832976149, 0.12530683405469523, 0.15692790653100308, 0.12560083827910873, 0.141591463576625, 0.13087492846459958, 0.1508812981297737, 0.1403016575883994, 0.1350906769372201, 0.15643015198298638, 0.1588534444314862, 0.1869651338287489, 0.14876811737754125, 0.15665150616777412, 0.14750097269898466, 0.15224293608431327, 0.14991279180240547, 0.17479360619543072, 0.15796722833157362, 0.10875668436291797, 0.12914116313863688, 0.1026590576146642, 0.09636267376562213, 0.11111143395261502, 0.10219867929849058, 0.09848040005473757, 0.11474772011011047, 0.10428757385406207, 0.15365012217031548, 0.14701489577478766, 0.1469341478273516, 0.15147553144431714, 0.1493232866205424, 0.15493222117522965, 0.14450137734718826, 0.1387886798349076, 0.15573668696532694, 0.1456323642624553, 0.11904052678189181, 0.13208759889854427, 0.11595420458389127, 0.12034993876487698, 0.12981750048759655, 0.14467663470255798, 0.11920446581108701, 0.09733030985081681, 0.12923993213086482, 0.15151207581887915, 0.1723236950611874, 0.15912059597444272, 0.18219552487925716, 0.15169456071269138, 0.21065746774955174, 0.17351663806318118, 0.14153659490017145, 0.11386986863814019, 0.16563021860579374, 0.12550196663954516, 0.16859064924164635, 0.16404293918300228, 0.12812447129073257, 0.14265026524781843, 0.15819291810881264, 0.2360248146776004, 0.1807165979854397, 0.18483427667326546, 0.19278268210411142, 0.1811300933537081, 0.17906355166418764, 0.1838842097190414, 0.1904033600259848, 0.17649086326718966, 0.18894227847536516, 0.04710615430514631, 0.05039640924949984, 0.04390647478228349, 0.05022899253582069, 0.042873201588632726, 0.04933417102109705, 0.052258869217402526, 0.051903739771769875, 0.048777372427275756]}, "mutation_prompt": null}
{"id": "959bd02c-6fc1-469e-804f-04216ab575c1", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "c073a932-daa9-4cbf-9b03-3ddf636fdbbc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "e8b00fef-7164-421d-af46-c73006d570b3", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "5895646f-278e-413c-b06a-56c5b08bcd7a", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "5ecd64fb-1569-422d-8894-aae21e957691", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "93050aea-3957-4fc1-b350-13c58cfedde0", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "86f80278-2594-49f9-ba5f-7107f9b42580", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "7e4c3116-084f-4cc7-b297-4a775667a5af", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "5456de71-2916-4e43-b0bd-67ebdd8c5dc0", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "dd773788-b1c8-4700-97c4-d86fc27922dc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "3c3a9b4a-7256-469e-b0bb-bbc321c221be", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "496df17b-2ce5-4b62-aa78-a9e1cdb8d9f1", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self._dynamic_F() * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _dynamic_F(self):\n        return 0.5 + 0.3 * np.sin((self.eval_count / self.budget) * np.pi)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Factor for Improved Black Box Optimization.", "configspace": "", "generation": 19, "fitness": 0.09080571390496583, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.1722228385329212, 0.19906515379589385, 0.14038964496147133, 0.149707703699422, 0.16618201741356098, 0.22201639663805373, 0.16213077134970866, 0.1659211513353792, 0.14694681823873268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039674140491796406, 0.030882727566478807, 0.045099014422748995, 0.042299425895377496, 0.051241672202610444, 0.02915478077679745, 0.03217614808297187, 0.033416781366053305, 0.03089548837681888, 0.025717495011356784, 0.026058630256956317, 0.05394827493922716, 0.03075258989858831, 0.02227545947295162, 0.02385767255117166, 0.03529190562537898, 0.025929449395526882, 0.020857554387303967, 0.14246337612571336, 0.133974056827718, 0.1800571792000304, 0.15198376141969872, 0.15002707949321015, 0.5719575446599323, 0.13765015551320392, 0.8026978998328974, 0.11526898882690584, 0.06423569928309003, 0.08537778649616923, 0.051748986112594486, 0.06395003787691511, 0.0818882170239531, 0.048980349264469036, 0.08672740670305756, 0.047191766761681575, 0.06060103900087521, 0.1382957397465816, 0.10664625290497609, 0.09878332099780052, 0.11861689538845699, 0.09734430532601801, 0.13573511217624634, 0.09954285053373091, 0.09516799264534259, 0.14772122177930236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003579847311221407, 9.999999999998899e-05, 0.007753241132225974, 0.006884667962802404, 9.999999999998899e-05, 0.010094921681920832, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010582976217107132, 9.999999999998899e-05, 0.0037716810507195664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04762870063745284, 0.052204878508808394, 0.04400102993428845, 0.025920866549169697, 0.01275542049435685, 0.014527216358601991, 0.037435138824324476, 0.03848041955688064, 0.07275517769387663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17463070098875355, 0.15996580168378782, 0.2012879638012458, 0.17488684881641037, 0.16977558400913784, 0.18163603964714226, 0.18739286368912733, 0.2070570535680134, 0.1818753471609278, 0.03683066449462802, 0.04094140034547378, 0.03757772249213287, 0.035576417310263064, 0.04620922106500491, 0.03258690633648642, 0.0323625034176257, 0.0339664769679241, 0.031500638697196104, 0.1266844905043406, 0.12613586497047602, 0.16635919250720677, 0.12194238579581584, 0.13233305869301437, 0.16779807744175756, 0.1277060717814018, 0.13819102310622855, 0.1493836292511651, 0.14811555538008447, 0.14944677359131364, 0.15806795979236776, 0.1457456297814278, 0.1578719729737943, 0.1584166278759951, 0.1669231834023187, 0.18538851467955564, 0.18250500263973535, 0.09501086704677364, 0.08796692762392833, 0.11279574376172674, 0.11810503400233141, 0.10859010628921839, 0.09690814617689647, 0.10387518164532628, 0.14119070074072226, 0.11507887468502087, 0.14926252521247807, 0.14049566681853198, 0.14786236986203805, 0.1483642478711521, 0.1476360328952695, 0.15710010828559406, 0.1640206003835616, 0.14062065634099286, 0.1417246086672349, 0.11544986498586618, 0.13127341780650625, 0.14291203242258876, 0.12062627243415791, 0.13173048593137482, 0.14988555416951388, 0.1448840557093488, 0.1473981516165802, 0.13656166371709166, 0.17178972038021512, 0.1438814589489551, 0.1219604607155983, 0.15552698861296999, 0.17395879548958604, 0.16602536121010236, 0.13787922462815427, 0.2117846213581016, 0.17391860817423077, 0.1632618699286189, 0.15505442100997935, 0.132566251784752, 0.11379211572709558, 0.1432515120776352, 0.14712410117539698, 0.15334350849946554, 0.13611047862168546, 0.13062085599178974, 0.20323873161449446, 0.19034738316647015, 0.17965872009174566, 0.18101398349160647, 0.18767636065088078, 0.17695713599158447, 0.17609405854892868, 0.1746846184035803, 0.19676563116884394, 0.04766990441498309, 0.0773684729353683, 0.05534106716646603, 0.04683961828491612, 0.046565836729836385, 0.04098154567952461, 0.04527525805193322, 0.06838049964613768, 0.04621890740039414]}, "mutation_prompt": null}
{"id": "0b3374fc-9dca-4dc5-8b1d-7a1253ea2cbf", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n        elif np.random.rand() < 0.1:  # Introduce a small chance to accept worse solutions\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhance the selection strategy by introducing a greedy approach for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.09422983617014642, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.12.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "cda8502e-b9fc-4b19-9c72-f44953f93712", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Population Resizing for Efficient Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.14569530915103002, 0.15139062969511363, 0.13490075102723387, 0.14770203424378991, 0.1647510449059698, 0.16552049913982358, 0.15231823562309832, 0.16676983173605864, 0.15079298344270142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034289594315345506, 0.043569421955857446, 0.03241032372813757, 0.0334231443467925, 0.042119931673171185, 0.04093529413745256, 0.0335382655270956, 0.029826871388089038, 0.030410047185992828, 0.01589963498941982, 0.020517938501421473, 0.035511676580164186, 0.02607812579779112, 0.01906718088244308, 0.01786774939355984, 0.03839465971640077, 0.024556567248729344, 0.026944193421269858, 0.17646037670549664, 0.826487296398947, 0.8997609393715535, 0.16008198366918824, 0.15256388913398222, 0.571911612392313, 0.1431513174521153, 0.8072017915811617, 0.1214919328615437, 0.06672588775509503, 0.07979462844398533, 0.05336024438354903, 0.042683879949092396, 0.07215287221903322, 0.046558812928556126, 0.06191048761291895, 0.049710748663153614, 0.056731178447522734, 0.12987196360862618, 0.11318788296857396, 0.12121950690389838, 0.12101168414758379, 0.1171961506253143, 0.11928627580100093, 0.10813303735112845, 0.10316337954420962, 0.10700825320579166, 0.003706555294102687, 9.999999999998899e-05, 9.999999999998899e-05, 0.002422089594204979, 0.0007407432171016026, 0.00473299245281944, 9.999999999998899e-05, 0.0023043880710312825, 0.010800037577314625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000911986849213231, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656429375176414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0319568791290652, 0.05023356909145682, 0.0943160714988891, 0.02146451102531355, 0.02621982759911312, 0.015747117581430548, 0.04129326421523494, 0.028505491530433913, 0.05455053246436614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.175234003648309, 0.16738952208195879, 0.17595542174006062, 0.1729134989124772, 0.17580643305071386, 0.17164133333454812, 0.1885237250164742, 0.2137546314207338, 0.1876749143065829, 0.034826888779437515, 0.035299845708861355, 0.030285029445602185, 0.039799201475960944, 0.03579302587269162, 0.051384212239293126, 0.05373528780715664, 0.027083488573173997, 0.029178968930663518, 0.13844849505496315, 0.15692790653100308, 0.12811483222022102, 0.1477613462357984, 0.13438970505094616, 0.13572454049590066, 0.13829431447729568, 0.1243372031493114, 0.1443945031402265, 0.14621336658055284, 0.15437425795112703, 0.1606024912793209, 0.15324901882147146, 0.1508250255671686, 0.14925266868687725, 0.1453183935956247, 0.17377774300845283, 0.15195638108788667, 0.10247486810745798, 0.09481124964060894, 0.09932269815436412, 0.10421431294175454, 0.11032940286915105, 0.10388482306239966, 0.10766734468299133, 0.10071679521864862, 0.09210250911189521, 0.15175627807290715, 0.13809954657289258, 0.16165937389186258, 0.15247515242646292, 0.14522040861134977, 0.14040975963788038, 0.13779967525059655, 0.13243277803428133, 0.14276139620985218, 0.13639383174551767, 0.10561915962851176, 0.11394606963878928, 0.10858939745501861, 0.1220312225065523, 0.10369669342604104, 0.14291192555661614, 0.09490004962681164, 0.0954049118064837, 0.1545429596083715, 0.13395457390064458, 0.12776744788499395, 0.1531354998779363, 0.16819647772028745, 0.1576122615683262, 0.1438950063656239, 0.16283439257660626, 0.12836824192411678, 0.1303773083568054, 0.1338964558798299, 0.13730940295961191, 0.16198122088281708, 0.1555465062808029, 0.22125303267533136, 0.13625146026549684, 0.1456104207010288, 0.1401846377958118, 0.19188041045474424, 0.1783294821871927, 0.17085300927034863, 0.18543044790181273, 0.18392596866812505, 0.1887067462002877, 0.18126688042392125, 0.18289632545672263, 0.19077940134994376, 0.04409392335198814, 0.04923285051027504, 0.0500353599168637, 0.0424481271887851, 0.04640774209286902, 0.04069307865483773, 0.05983774108694562, 0.03887899468675804, 0.04366590295031714]}, "mutation_prompt": null}
{"id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Scaling for Improved Convergence.", "configspace": "", "generation": 22, "fitness": 0.10443004072315522, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.14.", "error": "", "parent_id": "9df47c1e-8ff0-49a7-99a3-8671b90d5574", "metadata": {"aucs": [0.16254195745501843, 0.15145158359343713, 0.14893571884952983, 0.15766743047728926, 0.1632538457890652, 0.1608753618280816, 0.1814838854078421, 0.15925292430193272, 0.16831754847511438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0336518257754862, 0.05185509623224238, 0.0397101526598832, 0.044004550590779234, 0.03463411984436138, 0.03793322488211093, 0.03749945071763883, 0.03201726714194919, 0.03567091384004362, 0.016064388950155606, 0.022867181424710226, 0.026693493308334815, 0.03207917749187783, 0.02070258867905872, 0.020571268265947573, 0.02974735276492735, 0.02524733870846252, 0.02983197856663178, 0.1843663614388401, 0.7629442348737178, 0.16071237322315013, 0.8326355702838537, 0.9286425631841153, 0.21710661362989392, 0.8878637713976227, 0.8142228013011801, 0.833671122626628, 0.06226400706673374, 0.04938197369783992, 0.07184751563086644, 0.08943843763869086, 0.0697074991960579, 0.05549196959910074, 0.07885440902916852, 0.0691808920078032, 0.09810766394489967, 0.11813785049930026, 0.11156234505255558, 0.11091770337901874, 0.12207514804459874, 0.13955067587347347, 0.09418798929921102, 0.13431401434117418, 0.10226003560106312, 0.10504898847601163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038648905872665784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014184037613551581, 0.031148255092178112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04103433095112363, 0.02714531425247857, 0.10476690140727374, 0.04085945876265651, 0.01571370972694408, 0.029352070074037506, 0.03081432505602666, 0.021404876222434588, 0.03648441273059655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004152538524451188, 0.010276472197203068, 0.179064694708864, 0.17501076891288736, 0.17838958380490677, 0.17412863615349528, 0.17629729389557802, 0.1770882915941394, 0.17220243193797247, 0.16621422296969357, 0.19749091356528437, 0.03154485868615242, 0.03690793370391532, 0.05467564622406118, 0.03921590654744411, 0.032271203668554294, 0.031412337544337254, 0.0411018021259415, 0.036039271058198374, 0.03200832970702572, 0.12093310905848953, 0.12861776133577896, 0.12042256122587602, 0.14122410956746045, 0.1438762842034852, 0.1551889818449541, 0.1522185100225243, 0.14307930516993728, 0.13317338911900733, 0.15501654826137257, 0.16720788440823764, 0.15615455579064252, 0.14881657430357176, 0.16860629617576794, 0.15763654407070293, 0.14590514439024005, 0.17377774300845283, 0.19457086061082973, 0.10134826005390118, 0.09707766332007084, 0.10044205021035268, 0.10377598307751401, 0.10474468978458185, 0.09903439691079508, 0.09754546623133209, 0.1171263574122342, 0.13805149288002116, 0.16296839568968824, 0.1379061813532202, 0.13890863483193283, 0.14067519001609308, 0.1560142639625094, 0.14297772516663265, 0.1421520537627139, 0.150578554347078, 0.19343175884923192, 0.11897954624365359, 0.1076960627819028, 0.10408648901544892, 0.1326492686808649, 0.1384326125670503, 0.1202457514461619, 0.13646133799785132, 0.14350572961707297, 0.13441760610965792, 0.16267246510015576, 0.1540547021966966, 0.16305907686419108, 0.14810834719618438, 0.1814790288795537, 0.14608534295169173, 0.1311532786175701, 0.13424036010642737, 0.13803807945609148, 0.14540972020763854, 0.13480394843864452, 0.17127097286536885, 0.14315171208350497, 0.11584540396766219, 0.12424955409072169, 0.1379102840850761, 0.1645803283702768, 0.1657034934676631, 0.1808805140689438, 0.18587943243433902, 0.1928971849996849, 0.1749463070567504, 0.1850976121040071, 0.17752291925420582, 0.1805262744375954, 0.19026516565041252, 0.19225088100187893, 0.03671915575633189, 0.036222038057604156, 0.0602099277094561, 0.04053489650735809, 0.05080584156710333, 0.050865174351171105, 0.04153161046365095, 0.044662715045628465, 0.04587640406243698]}, "mutation_prompt": null}
{"id": "0f9ab35c-4128-42d2-aac9-8199f495543c", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            # Strategic restart of population when nearing budget end\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Strategic Adaptive Population Restart for Better Exploration and Exploitation Balance.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 24 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 24 is out of bounds for axis 0 with size 20')", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {}, "mutation_prompt": null}
{"id": "126f410b-5493-47d1-88ff-861549b1c099", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.uniform(0.7, 1.0)  # Stochastic crossover probability\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Stochastic Crossover Probability for Improved Exploitation.", "configspace": "", "generation": 24, "fitness": 0.08887481945252525, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.15527889771152992, 0.16962376585218242, 0.18423983387273524, 0.15262585650458027, 0.14794789184713097, 0.206275464113717, 0.17839284581145598, 0.1653532851123899, 0.19324389014878074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035324748281997054, 0.04744206331767331, 0.026982008030395965, 0.03623703057026473, 0.04829238358894816, 0.03991365719533391, 0.04343914047588093, 0.041897759185380745, 0.02409272475988633, 0.01869588578156689, 0.015480966570818211, 0.021776283260223517, 0.032697851276723644, 0.021068599998708692, 0.03050832484475774, 0.018521015460551293, 0.017578559093212043, 0.02431739869625016, 0.1481038502724652, 0.22028909117272066, 0.1672283505878056, 0.1521952853325389, 0.4165264152112167, 0.1346248075867954, 0.28188340262961376, 0.29259880284881334, 0.16350060986836756, 0.05887519420129461, 0.07115266654391994, 0.0622217787789765, 0.10277794397347895, 0.05647855577913086, 0.03947892560533528, 0.07614044584321367, 0.056100765007113695, 0.06418687027991032, 0.12046300841898794, 0.11392992612849262, 0.12595673426019638, 0.11169819781839851, 0.10534747066120531, 0.10092404692603418, 0.1057007718190216, 0.10650219571899888, 0.1092925104285909, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003348705801458074, 9.999999999998899e-05, 0.0280417166630752, 9.999999999998899e-05, 9.999999999998899e-05, 0.007069265890872312, 9.999999999998899e-05, 0.007093201785167924, 0.027951495957867167, 9.999999999998899e-05, 0.024261105785601256, 0.040451473007663274, 0.038088548265294064, 0.00031462711720964265, 9.999999999998899e-05, 0.016352896314193677, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03602379979973702, 0.022611708884990755, 0.027653942304666113, 0.0136867449590109, 0.03998346875936298, 0.03042147179672705, 0.05669135249029911, 0.0673498222148704, 0.045534251800733005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003983738283761196, 9.999999999998899e-05, 9.999999999998899e-05, 0.0053692584946472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19260376519130928, 0.1598375227039862, 0.16758480888984761, 0.18459478122980344, 0.21056306045288053, 0.16904784438443543, 0.18862811832831883, 0.18428310133911674, 0.1951473914658397, 0.04143615566398762, 0.04375778453127421, 0.04175825409806844, 0.048739591272232374, 0.052026640048945194, 0.04468960603429473, 0.039747871118312794, 0.037835335925365476, 0.043840051392986634, 0.1257548777976606, 0.1411847307427212, 0.1367836600948854, 0.13591839912291126, 0.1136666348310702, 0.14225539131868314, 0.14893788126344698, 0.15144830355520522, 0.1434227033457406, 0.15773410727055504, 0.16004840692439537, 0.15700949261484998, 0.15839833724239127, 0.17793427953737717, 0.1499834200443807, 0.13633592764357905, 0.17445690499928956, 0.1549440905411792, 0.110640423810346, 0.10345139015075233, 0.082999292451862, 0.09710059416910477, 0.12200002497023521, 0.08757406845754867, 0.09449441634460165, 0.11525155268480591, 0.10325254327846944, 0.14025046649415107, 0.15099503569907902, 0.16163742335038256, 0.14876823216310364, 0.1448453541541288, 0.14590693786475162, 0.14088120455339792, 0.1488159071958427, 0.14759098170801954, 0.14755149648353194, 0.13051472465091596, 0.13123395931698778, 0.12200360512547437, 0.13677682674534009, 0.14383424612682705, 0.12863838273302186, 0.11503426112771797, 0.14068517724679008, 0.148829431046542, 0.19437933001105834, 0.1475082288297479, 0.15085490737666984, 0.16297934920238843, 0.13453140251140483, 0.1392804905062901, 0.15586585975883827, 0.16296628783133105, 0.19908756570188502, 0.12623975261755382, 0.12684508562873886, 0.13133320296453765, 0.14822345320645114, 0.12499526927673354, 0.1459122988593815, 0.11550782297044948, 0.20799923141523236, 0.20608766041067605, 0.1882696075355048, 0.18247895770866696, 0.19173521647670444, 0.18646112982628882, 0.17433138978841267, 0.178343299465055, 0.19037964480718894, 0.191046762233387, 0.04889527891003198, 0.053733988425262225, 0.04320728409682706, 0.03868906588844401, 0.07303404959387316, 0.041413643791809784, 0.051290239509786395, 0.0343382519404839, 0.0399232833816906]}, "mutation_prompt": null}
{"id": "edec1d09-0350-4e0c-af4e-d6883d74fda4", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        self.elite = None  # to store the best solution\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        self._update_elite()\n\n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n        self._update_elite()\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def _update_elite(self):\n        best_idx = np.argmin(self.fitness)\n        if self.elite is None or self.fitness[best_idx] < self.elite[1]:\n            self.elite = (self.population[best_idx].copy(), self.fitness[best_idx])\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        return self.elite[0], self.elite[1]", "name": "HybridDEOptimizer", "description": "Introduced Elite Preservation Mechanism to retain best solutions across generations for improved convergence.", "configspace": "", "generation": 25, "fitness": 0.10443004072315522, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.14.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.16254195745501843, 0.15145158359343713, 0.14893571884952983, 0.15766743047728926, 0.1632538457890652, 0.1608753618280816, 0.1814838854078421, 0.15925292430193272, 0.16831754847511438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0336518257754862, 0.05185509623224238, 0.0397101526598832, 0.044004550590779234, 0.03463411984436138, 0.03793322488211093, 0.03749945071763883, 0.03201726714194919, 0.03567091384004362, 0.016064388950155606, 0.022867181424710226, 0.026693493308334815, 0.03207917749187783, 0.02070258867905872, 0.020571268265947573, 0.02974735276492735, 0.02524733870846252, 0.02983197856663178, 0.1843663614388401, 0.7629442348737178, 0.16071237322315013, 0.8326355702838537, 0.9286425631841153, 0.21710661362989392, 0.8878637713976227, 0.8142228013011801, 0.833671122626628, 0.06226400706673374, 0.04938197369783992, 0.07184751563086644, 0.08943843763869086, 0.0697074991960579, 0.05549196959910074, 0.07885440902916852, 0.0691808920078032, 0.09810766394489967, 0.11813785049930026, 0.11156234505255558, 0.11091770337901874, 0.12207514804459874, 0.13955067587347347, 0.09418798929921102, 0.13431401434117418, 0.10226003560106312, 0.10504898847601163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038648905872665784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014184037613551581, 0.031148255092178112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04103433095112363, 0.02714531425247857, 0.10476690140727374, 0.04085945876265651, 0.01571370972694408, 0.029352070074037506, 0.03081432505602666, 0.021404876222434588, 0.03648441273059655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004152538524451188, 0.010276472197203068, 0.179064694708864, 0.17501076891288736, 0.17838958380490677, 0.17412863615349528, 0.17629729389557802, 0.1770882915941394, 0.17220243193797247, 0.16621422296969357, 0.19749091356528437, 0.03154485868615242, 0.03690793370391532, 0.05467564622406118, 0.03921590654744411, 0.032271203668554294, 0.031412337544337254, 0.0411018021259415, 0.036039271058198374, 0.03200832970702572, 0.12093310905848953, 0.12861776133577896, 0.12042256122587602, 0.14122410956746045, 0.1438762842034852, 0.1551889818449541, 0.1522185100225243, 0.14307930516993728, 0.13317338911900733, 0.15501654826137257, 0.16720788440823764, 0.15615455579064252, 0.14881657430357176, 0.16860629617576794, 0.15763654407070293, 0.14590514439024005, 0.17377774300845283, 0.19457086061082973, 0.10134826005390118, 0.09707766332007084, 0.10044205021035268, 0.10377598307751401, 0.10474468978458185, 0.09903439691079508, 0.09754546623133209, 0.1171263574122342, 0.13805149288002116, 0.16296839568968824, 0.1379061813532202, 0.13890863483193283, 0.14067519001609308, 0.1560142639625094, 0.14297772516663265, 0.1421520537627139, 0.150578554347078, 0.19343175884923192, 0.11897954624365359, 0.1076960627819028, 0.10408648901544892, 0.1326492686808649, 0.1384326125670503, 0.1202457514461619, 0.13646133799785132, 0.14350572961707297, 0.13441760610965792, 0.16267246510015576, 0.1540547021966966, 0.16305907686419108, 0.14810834719618438, 0.1814790288795537, 0.14608534295169173, 0.1311532786175701, 0.13424036010642737, 0.13803807945609148, 0.14540972020763854, 0.13480394843864452, 0.17127097286536885, 0.14315171208350497, 0.11584540396766219, 0.12424955409072169, 0.1379102840850761, 0.1645803283702768, 0.1657034934676631, 0.1808805140689438, 0.18587943243433902, 0.1928971849996849, 0.1749463070567504, 0.1850976121040071, 0.17752291925420582, 0.1805262744375954, 0.19026516565041252, 0.19225088100187893, 0.03671915575633189, 0.036222038057604156, 0.0602099277094561, 0.04053489650735809, 0.05080584156710333, 0.050865174351171105, 0.04153161046365095, 0.044662715045628465, 0.04587640406243698]}, "mutation_prompt": null}
{"id": "9001fabb-05d2-49ad-b170-450205fd5daa", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        self.diversity_factor = 0.1  # factor for adaptive diversity\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        mutant += self.diversity_factor * np.random.uniform(self.lb, self.ub, self.dim)  # diversity introduction\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Adaptive Diversity Introduction for Improved Exploration.", "configspace": "", "generation": 26, "fitness": 0.0969512853081419, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.15054740992386595, 0.16918298857854608, 0.16306431174850444, 0.1571681526239339, 0.17575409036992717, 0.16089562686618464, 0.13980361796834784, 0.14764076570018236, 0.1524755879286087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03023440776452191, 0.026734060006171068, 0.04145880289529891, 0.057272749591628425, 0.027694793545810392, 0.059607122920977584, 0.03063339508755747, 0.03984843488977208, 0.02996965523454531, 0.019824018967259716, 0.0158678578321072, 0.03194938721273155, 0.022221087201280576, 0.03816413586431733, 0.01877547703369764, 0.02910677353230584, 0.021235166328934296, 0.013326051482051793, 0.6287785525533774, 0.5776199913924791, 0.2166083015168333, 0.19209627126541606, 0.8723895467331804, 0.3731986961921492, 0.18327050814808166, 0.6587772846058029, 0.4776252251039368, 0.057287822677524525, 0.06877319586907127, 0.07289627834878942, 0.07008558550980537, 0.05163861745511, 0.06542958850436154, 0.06531566824473589, 0.07371221109947224, 0.0549876273944746, 0.10810182244844713, 0.11829422079550023, 0.10654982529925461, 0.1019294224254732, 0.09355492469664062, 0.09572444092904842, 0.12113268835747026, 0.11616682024508918, 0.10787871882524469, 0.017848191393032953, 0.012090844145844493, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032896797554392565, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021825582714450897, 0.002802054718029634, 0.01098697499770973, 9.999999999998899e-05, 0.00033100674096164795, 9.999999999998899e-05, 9.999999999998899e-05, 0.04085009703599374, 9.999999999998899e-05, 0.045038089139254556, 0.00944165640104877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027660174524182235, 0.048223022945503735, 0.04141045773771623, 0.0578538222144489, 0.04888775403539225, 0.045395280426793416, 0.07378964518869668, 0.07561413754236457, 0.05797083415484283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16716191648617207, 0.18079189543222218, 0.16843090652972714, 0.1711083606175966, 0.17383835402140835, 0.1740261599894165, 0.17983251311837356, 0.17314212950249674, 0.1745055869406077, 0.036636967837569534, 0.043366951405481635, 0.04127433084169696, 0.035987339374640936, 0.03538941564448328, 0.030826404643889305, 0.034308359487838946, 0.03460454220311626, 0.031895234545244455, 0.13582504078001312, 0.1271018645650911, 0.13125408313311104, 0.1402385505009448, 0.13134062255135137, 0.14275699088995242, 0.14603470935578244, 0.1422626216027293, 0.14927820677733183, 0.15565454185542982, 0.14170800654250448, 0.15386609156228082, 0.16576197009780191, 0.17275035412409745, 0.18245490279668564, 0.15552284959804896, 0.17579353541249965, 0.16034115476284694, 0.09462441303853653, 0.0994148198841569, 0.08267386329690074, 0.11094674994480047, 0.1137131668243786, 0.11375041664765595, 0.10867247718765116, 0.09458298338849258, 0.09951701838527438, 0.1412142611149957, 0.1463961008923983, 0.14574819055488009, 0.21981019949665181, 0.1497278128950713, 0.14240434951512726, 0.1466125050357785, 0.1525874721362368, 0.17792049530430631, 0.13155921713314833, 0.14715582499351354, 0.10884228672867224, 0.12560869495912974, 0.142675380427997, 0.10016603410758163, 0.06993210823593854, 0.12648275655457075, 0.12759704024880503, 0.16068899738413944, 0.140314358727601, 0.15390409704379926, 0.128449281742952, 0.17132028560287837, 0.15028901767399405, 0.13862179629764815, 0.1551420992400515, 0.1495428523472807, 0.13248839829669556, 0.13356798793965918, 0.12807813868831508, 0.12894326444340254, 0.1643837788064153, 0.10552114133332657, 0.14867328271402658, 0.11117090520708206, 0.162469283396261, 0.2024795641887993, 0.18697183505354376, 0.1842866459019451, 0.18053993076384556, 0.1753078742134967, 0.1823023545871012, 0.18801866633859188, 0.19050819238159833, 0.16844427290733566, 0.037418948251706, 0.04485098517086805, 0.04386755341716908, 0.04100826594003415, 0.04747894979356293, 0.03826902944966626, 0.039313859079970426, 0.04459135887550325, 0.03849420179070984]}, "mutation_prompt": null}
{"id": "bd4876ed-dcd1-4db6-bddb-c4d6d2c3f9d9", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n\n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.6, 1.4)  # mutation adaptation\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        dynamic_CR = self.CR - (self.eval_count / self.budget) * 0.5  # adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Adaptive Crossover Rate and Mutation Adaptation for Enhanced Convergence.", "configspace": "", "generation": 27, "fitness": 0.09340568527961078, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.1706202530178036, 0.15713489382942147, 0.14396790873726473, 0.174382751097087, 0.16190348270184063, 0.15273007672444217, 0.18970268530339507, 0.17215383380745275, 0.16424754447200285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05003693061327963, 0.033922394333950834, 0.04242753946728006, 0.048559701678590694, 0.04456467620007154, 0.03722105911097007, 0.04937917230803035, 0.037332799267521644, 0.032921082047594474, 0.022533688448563183, 0.041399957990788216, 0.026653421812235734, 0.028405097857385098, 0.029167405858376738, 0.0170861759459362, 0.020749596651310265, 0.027172153739872584, 0.03086180012393247, 0.14128015163285035, 0.1335593530097705, 0.16196591847267106, 0.2065512870432723, 0.8271363797430984, 0.18914178843276097, 0.8874270317915501, 0.16278573289974085, 0.15086309386616337, 0.07264310705800858, 0.09697304101417581, 0.05724123110498913, 0.10149815455222655, 0.04963308727648197, 0.07662860845311592, 0.06937980432354474, 0.06757997760954604, 0.09327975875485262, 0.11183874598145482, 0.09384502174674669, 0.08377045550490292, 0.11643514912873265, 0.13962287443305454, 0.11349241344018524, 0.10151873305247971, 0.11538648781180327, 0.10021865114993322, 0.02181466598291315, 9.999999999998899e-05, 0.0005624109731273697, 0.00010913031473469559, 9.999999999998899e-05, 0.02054740388296028, 9.999999999998899e-05, 0.0027044577895414257, 9.999999999998899e-05, 0.00040669697879403, 0.0049461769366018205, 9.999999999998899e-05, 9.999999999998899e-05, 0.01869802487682226, 9.999999999998899e-05, 9.999999999998899e-05, 0.012930728886020315, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06100822067310452, 0.045404563982414436, 0.03785070149728231, 0.06376061491963225, 0.034527829351489014, 0.05370910974353338, 0.03708560248199988, 0.03222351712521265, 0.049943747820973106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0070712930616581016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1837347322649776, 0.16912691202496533, 0.18727978297304249, 0.17272573859985751, 0.1937757837668317, 0.1928659843622086, 0.18275999145750388, 0.17862390036181153, 0.17872577641041698, 0.045252080735646794, 0.03803851520472201, 0.029031984868797878, 0.037592344878938255, 0.03537203320007887, 0.044952943137656076, 0.027029055047202433, 0.039448316610044665, 0.037261104310781445, 0.14954547923264327, 0.11856135663588996, 0.1360231902736183, 0.13260346328637662, 0.15891445760831469, 0.18325678369498988, 0.1411385243090505, 0.12692269421746316, 0.13961965079487504, 0.15644453008063375, 0.15415854996876188, 0.15338220055895269, 0.14371049315816276, 0.16602648826880317, 0.15844059635323138, 0.15304753562159334, 0.17397422545541408, 0.1719224213438929, 0.1176249525423202, 0.11631331435799508, 0.09827838287055579, 0.08701193930558115, 0.11331931277560037, 0.09939065721078821, 0.10676505013381299, 0.11635585832074957, 0.11801676505804715, 0.14137051919835408, 0.13436482401660432, 0.15312399584531644, 0.17974483655798068, 0.16195915854413012, 0.1547902802298382, 0.15319189449527004, 0.16865540659125144, 0.14464034742150111, 0.12369741721686078, 0.11822635329038533, 0.1246778839100563, 0.1136114909089716, 0.1391992808253224, 0.12268828617164707, 0.11795491646567313, 0.13302331505770504, 0.13678652229218735, 0.1630203452966843, 0.12677004129992853, 0.1759960545137712, 0.14379477006143082, 0.15001115238826368, 0.13647217186860794, 0.1356529632231308, 0.14590209309262425, 0.13174884261535968, 0.12406937601928636, 0.13997710668771346, 0.17354578630508344, 0.1604827194611531, 0.190039458522689, 0.13422894405820318, 0.16886410734400104, 0.15384187912388791, 0.15447243490455076, 0.20264816170210287, 0.1959084033600279, 0.1809633384074847, 0.19101045685720763, 0.17650922018826787, 0.17301102389451628, 0.20632846256981108, 0.18405180172389413, 0.18287155013170597, 0.045304964756426314, 0.060334593031260764, 0.04322288274776476, 0.04461158734595172, 0.04399500736329043, 0.0592508911917603, 0.04712879196192499, 0.051999092906427014, 0.05287594106375204]}, "mutation_prompt": null}
{"id": "7a04adad-3940-4790-aa52-6e81b22d1093", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Scaling for Improved Convergence.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.16254195745501843, 0.15145158359343713, 0.14893571884952983, 0.15766743047728926, 0.1632538457890652, 0.1608753618280816, 0.1814838854078421, 0.15925292430193272, 0.16831754847511438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0336518257754862, 0.05185509623224238, 0.0397101526598832, 0.044004550590779234, 0.03463411984436138, 0.03793322488211093, 0.03749945071763883, 0.03201726714194919, 0.03567091384004362, 0.016064388950155606, 0.022867181424710226, 0.026693493308334815, 0.03207917749187783, 0.02070258867905872, 0.020571268265947573, 0.02974735276492735, 0.02524733870846252, 0.02983197856663178, 0.1843663614388401, 0.7629442348737178, 0.16071237322315013, 0.8326355702838537, 0.9286425631841153, 0.21710661362989392, 0.8878637713976227, 0.8142228013011801, 0.833671122626628, 0.06226400706673374, 0.04938197369783992, 0.07184751563086644, 0.08943843763869086, 0.0697074991960579, 0.05549196959910074, 0.07885440902916852, 0.0691808920078032, 0.09810766394489967, 0.11813785049930026, 0.11156234505255558, 0.11091770337901874, 0.12207514804459874, 0.13955067587347347, 0.09418798929921102, 0.13431401434117418, 0.10226003560106312, 0.10504898847601163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038648905872665784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014184037613551581, 0.031148255092178112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04103433095112363, 0.02714531425247857, 0.10476690140727374, 0.04085945876265651, 0.01571370972694408, 0.029352070074037506, 0.03081432505602666, 0.021404876222434588, 0.03648441273059655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004152538524451188, 0.010276472197203068, 0.179064694708864, 0.17501076891288736, 0.17838958380490677, 0.17412863615349528, 0.17629729389557802, 0.1770882915941394, 0.17220243193797247, 0.16621422296969357, 0.19749091356528437, 0.03154485868615242, 0.03690793370391532, 0.05467564622406118, 0.03921590654744411, 0.032271203668554294, 0.031412337544337254, 0.0411018021259415, 0.036039271058198374, 0.03200832970702572, 0.12093310905848953, 0.12861776133577896, 0.12042256122587602, 0.14122410956746045, 0.1438762842034852, 0.1551889818449541, 0.1522185100225243, 0.14307930516993728, 0.13317338911900733, 0.15501654826137257, 0.16720788440823764, 0.15615455579064252, 0.14881657430357176, 0.16860629617576794, 0.15763654407070293, 0.14590514439024005, 0.17377774300845283, 0.19457086061082973, 0.10134826005390118, 0.09707766332007084, 0.10044205021035268, 0.10377598307751401, 0.10474468978458185, 0.09903439691079508, 0.09754546623133209, 0.1171263574122342, 0.13805149288002116, 0.16296839568968824, 0.1379061813532202, 0.13890863483193283, 0.14067519001609308, 0.1560142639625094, 0.14297772516663265, 0.1421520537627139, 0.150578554347078, 0.19343175884923192, 0.11897954624365359, 0.1076960627819028, 0.10408648901544892, 0.1326492686808649, 0.1384326125670503, 0.1202457514461619, 0.13646133799785132, 0.14350572961707297, 0.13441760610965792, 0.16267246510015576, 0.1540547021966966, 0.16305907686419108, 0.14810834719618438, 0.1814790288795537, 0.14608534295169173, 0.1311532786175701, 0.13424036010642737, 0.13803807945609148, 0.14540972020763854, 0.13480394843864452, 0.17127097286536885, 0.14315171208350497, 0.11584540396766219, 0.12424955409072169, 0.1379102840850761, 0.1645803283702768, 0.1657034934676631, 0.1808805140689438, 0.18587943243433902, 0.1928971849996849, 0.1749463070567504, 0.1850976121040071, 0.17752291925420582, 0.1805262744375954, 0.19026516565041252, 0.19225088100187893, 0.03671915575633189, 0.036222038057604156, 0.0602099277094561, 0.04053489650735809, 0.05080584156710333, 0.050865174351171105, 0.04153161046365095, 0.044662715045628465, 0.04587640406243698]}, "mutation_prompt": null}
{"id": "c9fb2c1d-2c43-41f0-96b2-4b4a35a53ccb", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # dynamic crossover probability\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved Hybrid Differential Evolution with Adaptive Population Control and Dynamic Crossover Probability.", "configspace": "", "generation": 29, "fitness": 0.09173911622033978, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.16898889664964978, 0.16954563121612443, 0.1831461431536452, 0.15342734040728556, 0.1446012622130185, 0.15916959507370154, 0.1787449053672765, 0.15820375087550764, 0.191153534144339, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04371288927304651, 0.04744206331767331, 0.028184733883966695, 0.04351983819513627, 0.048875079048078085, 0.041123409699457825, 0.04225264224130387, 0.051934186460479204, 0.028991761991688736, 0.013791206023588187, 0.021235158250929143, 0.016553226955764666, 0.020770177535289425, 0.04217763229678806, 0.029226400748042614, 0.017050450237628634, 0.02395436637784243, 0.02752922213882336, 0.1410610850272811, 0.34471330336782535, 0.18024099771921975, 0.190223132133174, 0.435298081672967, 0.16522616253585387, 0.33643083743997726, 0.2922002431156798, 0.5382942875221979, 0.06054507420105859, 0.070463684170468, 0.06196152007145361, 0.10253081991613744, 0.06112310484799077, 0.08168001805464287, 0.07362408120036545, 0.0519467992891387, 0.05828655398366378, 0.11657152129070036, 0.11326661565917495, 0.1266961171839588, 0.11454349130776009, 0.09990243969312429, 0.1009366428696229, 0.09319443159199492, 0.10594122989278276, 0.10780764992166003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0044399581029122, 0.007069265890872312, 9.999999999998899e-05, 0.003932838977004027, 0.044179708328836, 0.013096618674494076, 9.999999999998899e-05, 0.040451473007663274, 9.999999999998899e-05, 0.00031462711720964265, 0.003924415798177483, 0.009120191185245097, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02512481247020737, 0.029430007824480353, 0.028119316018623053, 0.01228429988367985, 0.045712233904921074, 0.022537214949205575, 0.059009996566759426, 0.05161114239924791, 0.04720042646763978, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0053692584946472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19268616049941834, 0.16676305860565777, 0.20991693357381813, 0.18621212653637265, 0.20357584625479908, 0.16708298786026976, 0.18515598493451912, 0.2119186018180892, 0.1950042729132312, 0.0379899986397122, 0.038445788818529225, 0.042167362912009065, 0.04424593294501433, 0.05215896172127754, 0.04451912136309488, 0.05856221992401167, 0.029239026019333147, 0.043840051392986634, 0.13206417924323177, 0.13690968990648922, 0.13690274207223807, 0.1402681714645807, 0.1320904371202436, 0.14423959424225485, 0.1495708058862909, 0.15179283713724145, 0.14340641360864048, 0.1669469994839019, 0.16203553065419696, 0.15655421679321257, 0.15428743850322535, 0.17689493331842132, 0.14936278987525242, 0.15426672384414575, 0.17445690499928956, 0.15850568926095787, 0.09915753917466952, 0.10128473831742213, 0.08283783402471889, 0.09522925448050279, 0.12200583488662542, 0.10205179874217463, 0.10066746466753229, 0.11525155268480591, 0.1031647989493778, 0.14360729473705547, 0.15109496853990334, 0.1609465138131012, 0.13480915059729937, 0.14486350459285113, 0.16460500271325074, 0.14414426873612085, 0.13928625896453817, 0.14645311065817745, 0.1347090254337483, 0.13135667076123736, 0.13123395931698778, 0.12125326505516787, 0.14741787981704035, 0.1477052845799519, 0.1312105743271712, 0.11503426112771797, 0.13669563081513914, 0.13761504464907015, 0.13051513857493025, 0.1475082288297479, 0.1504282850908537, 0.1516827633666744, 0.14401207725818765, 0.1385548655984441, 0.15619706413844703, 0.15990954074156438, 0.14321425627322315, 0.1262254364896529, 0.18068130260738002, 0.13252071611195915, 0.14366385996411757, 0.15411596010026063, 0.1380326026161831, 0.12200972925945586, 0.2081688668226368, 0.20608766041067605, 0.19230452054814318, 0.18491494816353837, 0.1711978466580395, 0.18468217698324274, 0.17971298736899444, 0.18014487646817812, 0.18031964870477402, 0.1868143603688437, 0.05038244164783734, 0.04072538281832727, 0.044241431650331675, 0.04820982733616508, 0.07177031843499349, 0.044505185606122155, 0.050736187693445345, 0.03456581111082979, 0.043816542950103066]}, "mutation_prompt": null}
{"id": "78da08e7-3e82-4558-870e-425b8b1b40dd", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n            self.CR = 0.8  # adaptively adjust crossover probability\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n            self.CR = 0.95  # adaptively adjust crossover probability\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved Hybrid Differential Evolution with Adaptive Crossover Probability for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 30, "fitness": 0.09488005444836117, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.159351982354915, 0.18825127374954487, 0.1475080913276513, 0.16560644207486352, 0.15090176172964653, 0.15806084612300275, 0.1827290222655259, 0.16839311181888172, 0.16831754847511438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03383806682897683, 0.03209204716645564, 0.03970942972383329, 0.04345174936583773, 0.03849196650508824, 0.038422573657364234, 0.04146000492775781, 0.03607702785578115, 0.03663799162054859, 0.021857556117211296, 0.05227853100835489, 0.0431382572909893, 0.03207917749187783, 0.023453332064600874, 0.023556112233396598, 0.03071720791273236, 0.029046028993129913, 0.02422331089961094, 0.2959655402553033, 0.22253136215257663, 0.14961231603240865, 0.16622950254895696, 0.8183421678462977, 0.17763108484226087, 0.5315257554357773, 0.3135617684814047, 0.4615411213038487, 0.05272489003419489, 0.13830961585627444, 0.08548396329121821, 0.04803823250023653, 0.05805533082536618, 0.05929837448142716, 0.051788530129087795, 0.06644551278593713, 0.0712098405384548, 0.14061152642728536, 0.11019354187504793, 0.1155756456742063, 0.11493937301740409, 0.1411438540967851, 0.11299061426679369, 0.11258315948670439, 0.11574651861394836, 0.10526630220994448, 9.999999999998899e-05, 0.018341853560111643, 9.999999999998899e-05, 0.0038648905872665784, 9.999999999998899e-05, 0.02226238363073829, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014231235949700993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01049563872731707, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052709015256397485, 0.0339459090527886, 0.052425848557297816, 0.052001987615894585, 0.04392405962621326, 0.034014627655621354, 0.03782088061929012, 0.028301299325808715, 0.015941492239515354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1812125034666826, 0.17200251775293696, 0.18970135393966425, 0.16698509819908158, 0.17133602286461536, 0.18160401249544744, 0.18576803072520043, 0.17377919771322792, 0.19785893045957814, 0.042824372459067894, 0.042868775072183785, 0.04312521036781802, 0.03880501212782672, 0.030113151107502012, 0.039405530156636615, 0.04046369778157155, 0.029862540125118908, 0.040520940815045425, 0.14473034542864804, 0.11918851174221712, 0.12256796721913799, 0.12557904859456104, 0.15079268801349222, 0.199543996662632, 0.15269101531139073, 0.14212851623938882, 0.13392270767649295, 0.15789145432122909, 0.1462612572407732, 0.1616805364379934, 0.15750069215386808, 0.16673560931974551, 0.15092986081801396, 0.1587530296300389, 0.17377774300845283, 0.15006081398833504, 0.10340439947761082, 0.10404133471915589, 0.10742558037086825, 0.11858299833390396, 0.10048866196794659, 0.09333359483646053, 0.1137739751843796, 0.10686810411979641, 0.11879998391924562, 0.1656343255923497, 0.1407377128951115, 0.14046878062335322, 0.15383430031588574, 0.15422737784572094, 0.1353497243222841, 0.15433920318381733, 0.14740887859714225, 0.16047828883811577, 0.12507000175199523, 0.13757402037247501, 0.12466282723374911, 0.13664575082448793, 0.11243673026509438, 0.13178283523202772, 0.14588209636932647, 0.11907452808792385, 0.13546579860815233, 0.16267246510015576, 0.1279570636816374, 0.162040838873724, 0.12930772832523996, 0.1893864750046359, 0.14784868647225125, 0.16203509636001057, 0.16601375966705056, 0.1948091793927169, 0.16094052060309127, 0.14409933010745368, 0.13204049088527048, 0.15266401884924619, 0.12564961605927216, 0.1637167518590581, 0.14552128371566886, 0.18637734533301653, 0.16263603992913045, 0.17751750928555943, 0.18063346510860834, 0.18094511296969973, 0.20970465100952063, 0.1925099806181092, 0.18041133608439863, 0.19624180295478832, 0.18527265975753693, 0.1987002981263225, 0.04419551355777929, 0.052767168713956036, 0.043732601004711436, 0.04106984050005136, 0.042359201742075525, 0.05337478795819117, 0.048246887016357154, 0.044306138422229524, 0.07625270383241678]}, "mutation_prompt": null}
{"id": "8f8f8b72-9ba1-4324-91d8-7b3e4e4324b0", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Scaling for Improved Convergence.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.16254195745501843, 0.15145158359343713, 0.14893571884952983, 0.15766743047728926, 0.1632538457890652, 0.1608753618280816, 0.1814838854078421, 0.15925292430193272, 0.16831754847511438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0336518257754862, 0.05185509623224238, 0.0397101526598832, 0.044004550590779234, 0.03463411984436138, 0.03793322488211093, 0.03749945071763883, 0.03201726714194919, 0.03567091384004362, 0.016064388950155606, 0.022867181424710226, 0.026693493308334815, 0.03207917749187783, 0.02070258867905872, 0.020571268265947573, 0.02974735276492735, 0.02524733870846252, 0.02983197856663178, 0.1843663614388401, 0.7629442348737178, 0.16071237322315013, 0.8326355702838537, 0.9286425631841153, 0.21710661362989392, 0.8878637713976227, 0.8142228013011801, 0.833671122626628, 0.06226400706673374, 0.04938197369783992, 0.07184751563086644, 0.08943843763869086, 0.0697074991960579, 0.05549196959910074, 0.07885440902916852, 0.0691808920078032, 0.09810766394489967, 0.11813785049930026, 0.11156234505255558, 0.11091770337901874, 0.12207514804459874, 0.13955067587347347, 0.09418798929921102, 0.13431401434117418, 0.10226003560106312, 0.10504898847601163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038648905872665784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014184037613551581, 0.031148255092178112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04103433095112363, 0.02714531425247857, 0.10476690140727374, 0.04085945876265651, 0.01571370972694408, 0.029352070074037506, 0.03081432505602666, 0.021404876222434588, 0.03648441273059655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004152538524451188, 0.010276472197203068, 0.179064694708864, 0.17501076891288736, 0.17838958380490677, 0.17412863615349528, 0.17629729389557802, 0.1770882915941394, 0.17220243193797247, 0.16621422296969357, 0.19749091356528437, 0.03154485868615242, 0.03690793370391532, 0.05467564622406118, 0.03921590654744411, 0.032271203668554294, 0.031412337544337254, 0.0411018021259415, 0.036039271058198374, 0.03200832970702572, 0.12093310905848953, 0.12861776133577896, 0.12042256122587602, 0.14122410956746045, 0.1438762842034852, 0.1551889818449541, 0.1522185100225243, 0.14307930516993728, 0.13317338911900733, 0.15501654826137257, 0.16720788440823764, 0.15615455579064252, 0.14881657430357176, 0.16860629617576794, 0.15763654407070293, 0.14590514439024005, 0.17377774300845283, 0.19457086061082973, 0.10134826005390118, 0.09707766332007084, 0.10044205021035268, 0.10377598307751401, 0.10474468978458185, 0.09903439691079508, 0.09754546623133209, 0.1171263574122342, 0.13805149288002116, 0.16296839568968824, 0.1379061813532202, 0.13890863483193283, 0.14067519001609308, 0.1560142639625094, 0.14297772516663265, 0.1421520537627139, 0.150578554347078, 0.19343175884923192, 0.11897954624365359, 0.1076960627819028, 0.10408648901544892, 0.1326492686808649, 0.1384326125670503, 0.1202457514461619, 0.13646133799785132, 0.14350572961707297, 0.13441760610965792, 0.16267246510015576, 0.1540547021966966, 0.16305907686419108, 0.14810834719618438, 0.1814790288795537, 0.14608534295169173, 0.1311532786175701, 0.13424036010642737, 0.13803807945609148, 0.14540972020763854, 0.13480394843864452, 0.17127097286536885, 0.14315171208350497, 0.11584540396766219, 0.12424955409072169, 0.1379102840850761, 0.1645803283702768, 0.1657034934676631, 0.1808805140689438, 0.18587943243433902, 0.1928971849996849, 0.1749463070567504, 0.1850976121040071, 0.17752291925420582, 0.1805262744375954, 0.19026516565041252, 0.19225088100187893, 0.03671915575633189, 0.036222038057604156, 0.0602099277094561, 0.04053489650735809, 0.05080584156710333, 0.050865174351171105, 0.04153161046365095, 0.044662715045628465, 0.04587640406243698]}, "mutation_prompt": null}
{"id": "ddc757a4-66e1-49cf-a65b-7473d127614e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def _adaptive_crossover(self):\n        # Adaptive crossover probability based on evaluation budget\n        self.CR = 0.9 - 0.4 * (self.eval_count / self.budget)\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            self._adaptive_crossover()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid DE with Adaptive Crossover Probability for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 32, "fitness": 0.09400859841427242, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.1489318654129944, 0.15767083755029287, 0.1475166033864752, 0.16868500834294176, 0.16043160723391325, 0.1539701650135188, 0.17857021436910747, 0.16806813413542332, 0.1870893422179457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03405597636976565, 0.05185509623224238, 0.04985710708548252, 0.06553409066155746, 0.03178516972130041, 0.041585444649048786, 0.03846116402307542, 0.036320310668679356, 0.036768301574865436, 0.021290929765311217, 0.052031278687433735, 0.026956050927080644, 0.03207917749187783, 0.022194479453059635, 0.015578916837471812, 0.031456405520020825, 0.026411158788257616, 0.026284634462808043, 0.1766080101108891, 0.22287370542300655, 0.14552831367012165, 0.14119168756551914, 0.8292245323854414, 0.1798421123859214, 0.8878637713976227, 0.16758666233313657, 0.1621319423419696, 0.05891415891240814, 0.09988448940680505, 0.06992900882164998, 0.08928398595510734, 0.06735309520696686, 0.06254091755802549, 0.056274416774635405, 0.0656336754069542, 0.09810666887238095, 0.14061152642728536, 0.09305716501347727, 0.10120751829079488, 0.10598161838160958, 0.1387607488602458, 0.09498494095387688, 0.10992704337035997, 0.11546874266330964, 0.09929764888171866, 9.999999999998899e-05, 0.018341853560111643, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016829037732356666, 9.999999999998899e-05, 0.001300445328505484, 0.00029626045958253133, 0.002688718484604058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01049563872731707, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05536428397331128, 0.03578074312811208, 0.06281865417052124, 0.07061006851481144, 0.0236035510533098, 0.013388094833528874, 0.04123037754618031, 0.049120393035832266, 0.020482623751665985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029603873299273165, 0.0002721451391994867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18340195707281004, 0.17474300510137641, 0.17986129879619095, 0.16582973488099728, 0.18245938025069408, 0.18673184963236777, 0.17735611927123462, 0.16202424381900127, 0.1990095793392821, 0.04361279821793085, 0.042357083165817544, 0.03807235746164639, 0.03586427276075488, 0.0364481328513977, 0.040214485768875985, 0.040768114700796665, 0.02772580700778038, 0.039052532485728486, 0.14574471245158638, 0.1404583582035882, 0.13222599847134042, 0.1285215649833843, 0.1541746103300473, 0.19842117167550966, 0.15223891009111645, 0.14466774563424356, 0.15423456866786234, 0.15786850582960288, 0.15398112189621949, 0.15648038292598832, 0.1516899115451863, 0.16906598432288333, 0.1729799733701579, 0.15241302372546284, 0.17377774300845283, 0.19457086061082973, 0.10443589065869907, 0.10410798754572892, 0.10577215902545145, 0.09784798354469926, 0.09981505546962621, 0.11138611264447862, 0.105897678544989, 0.1171263574122342, 0.13805149288002116, 0.1632167041234861, 0.1407150850821416, 0.14514900079767012, 0.15180986484345138, 0.1560142639625094, 0.14505539360556974, 0.1458230602935966, 0.18362579254273093, 0.19343175884923192, 0.12850904496633353, 0.12703858655013134, 0.12773965321769543, 0.1361368462328696, 0.13785030860333958, 0.13025347891414418, 0.13639310059907095, 0.12396807787126995, 0.14014529712596835, 0.16283383411730068, 0.13452531903145404, 0.16312101418769054, 0.14229332562524777, 0.14653077120175695, 0.14611561080265767, 0.13982400410342266, 0.14949854283736708, 0.1315257019903633, 0.12797312214237078, 0.17000227471974416, 0.17046557977216636, 0.12894676936189842, 0.1431127616109461, 0.15665317914258137, 0.14761712023445084, 0.19837161028380879, 0.16328043778711765, 0.18512920434641877, 0.1836717695443726, 0.18007206312446178, 0.18121409014876666, 0.1715238954604843, 0.19444868332562115, 0.1871719487250586, 0.1866681716138141, 0.18654184367512794, 0.043046037325486175, 0.04223577649645016, 0.04551002008534155, 0.04056242439275903, 0.05376536526581199, 0.050865174351171105, 0.0448767722228689, 0.05172925690418828, 0.046078990564942024]}, "mutation_prompt": null}
{"id": "51dd6126-8416-48ad-bccd-07611fde6637", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, 0.6 * mutant + 0.4 * target, target)  # weighted crossover\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Scaling and Weighted Crossover for Improved Convergence.", "configspace": "", "generation": 33, "fitness": 0.0970266138885101, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.19508665088540533, 0.18086902729205911, 0.18392722015622232, 0.15247882671016888, 0.1480599754986346, 0.2113406754674424, 0.16528846332537817, 0.16161922987528154, 0.18592764042228505, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05833997362779231, 0.050459217184588345, 0.045934036497104036, 0.05613595931459636, 0.051235064213032255, 0.06665202046167928, 0.04881857589255012, 0.05005229013990886, 0.061515588913672925, 0.057217452143598524, 0.04027936142861832, 0.04291730924952897, 0.0434404268959363, 0.03150922485516605, 0.03814386167581396, 0.031148610227616724, 0.03230690789186519, 0.03654732495759727, 0.06844350851274683, 0.055784869654228575, 0.06895773472261135, 0.0670664504536218, 0.05831967732040044, 0.05346893908202799, 0.07338678412732647, 0.06239089633461503, 0.051910060278611336, 0.07413602815056597, 0.10417892322541888, 0.09390927858925568, 0.09521280714084701, 0.10026563439297076, 0.09717277644597122, 0.051222792075220624, 0.0601381614503651, 0.035550260726818994, 0.12659774879366104, 0.13255807528182684, 0.1764870210875248, 0.15627972068356288, 0.12254955952771829, 0.13995124363820888, 0.14108465504036272, 0.12351534866122116, 0.11764891476457418, 0.027372194308187825, 0.04068504389973937, 0.0011346143323258673, 0.03159438983489238, 0.01898179475064421, 0.02892632895767222, 0.007288978874644969, 0.022088653104758715, 9.999999999998899e-05, 0.042573849159237565, 0.009085030989507525, 0.011953595361404612, 0.0174764622710194, 0.025489739990453897, 0.03875627004053861, 0.010177730178347333, 0.00427945804278973, 0.01751538004764075, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06964348227150463, 0.07289864504601207, 0.09040779360264095, 0.057566045454353065, 0.049781513586360404, 0.016964555310355345, 0.07850446145064582, 0.04656823914888797, 0.09701253531103904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015409244684699841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00891919391629703, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22806176656183474, 0.2316141851339223, 0.21793254993291555, 0.19348497868375802, 0.17645890974150136, 0.18567577966936, 0.22166694233029538, 0.2426020884494473, 0.20840638829440694, 0.0522631902846411, 0.03029379669177812, 0.031800433595098876, 0.050391458894646024, 0.059668932818028986, 0.05309025144513235, 0.06142120387984473, 0.06068439996121089, 0.047020576451893836, 0.12074015181859288, 0.16954294988684793, 0.1528330365779832, 0.13625965435644316, 0.12652777589457986, 0.14137034248414893, 0.12564503227330281, 0.1690697739703566, 0.12988157797187905, 0.16753860367422968, 0.162901191812045, 0.17632231508803764, 0.16967366336899636, 0.19832636678553917, 0.19668582027074089, 0.1608973472344336, 0.17602192415152385, 0.17341441275748215, 0.11120564776853992, 0.11518306267078227, 0.1154212061730241, 0.11889081010785407, 0.1296326690609776, 0.12698009509404617, 0.11545536852465033, 0.11328503790216216, 0.11890843926869399, 0.1940335193383047, 0.16023631436321617, 0.18341226095943808, 0.16164193326377096, 0.18642697119616292, 0.1972677621480381, 0.1680217128628383, 0.1773475235151709, 0.1704503095640344, 0.16934008395379896, 0.16048409324719892, 0.16394223467081015, 0.15927988078603195, 0.15921021371785604, 0.157493685960439, 0.16469407603933928, 0.1492659675504714, 0.15693697278522412, 0.15738057592392307, 0.15311507795392731, 0.1682695465892644, 0.20383815353245427, 0.21934126883726623, 0.18054760751880017, 0.16370930320966637, 0.24495527783605653, 0.2759052583545092, 0.23393681212131812, 0.2670297317570295, 0.19670963644288963, 0.2150675226502481, 0.17421968478706895, 0.17806093958446145, 0.1526391458614429, 0.1716088717178189, 0.14794013185232047, 0.19177858543597914, 0.18936662702907825, 0.17849025421739095, 0.18746938288210302, 0.2021853195266632, 0.18360417602483403, 0.18682834777196, 0.21145703670881744, 0.17719918762927478, 0.05354406615406293, 0.05985068202936905, 0.06254018936406924, 0.05639467219076055, 0.06180419436084217, 0.06815145480318752, 0.059401913832999864, 0.06129514511168288, 0.05348118333245622]}, "mutation_prompt": null}
{"id": "b29b8b97-0e9c-4f42-912c-acbf9e2e89c8", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.9, 1.1)  # modified dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        if self.eval_count % 1000 == 0:  # random restart condition\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "HybridDEOptimizer with Adaptive Mutation Factor and Random Restart for Diversification.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 24 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 24 is out of bounds for axis 0 with size 20')", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {}, "mutation_prompt": null}
{"id": "a5b00630-b88c-4a6f-9cd0-89b29ff7c96c", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant + 0.1 * (target - mutant), target)  # differential crossover\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Resizing and Differential Crossover for faster convergence.", "configspace": "", "generation": 35, "fitness": 0.08883317738000415, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.1751110614134299, 0.1852092291942532, 0.16591843421107844, 0.1791550691392957, 0.18246537060425394, 0.16830586376055945, 0.18203247622413965, 0.1842379972983179, 0.1605959800124278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03993388629826278, 0.036814714498907275, 0.03368163555166592, 0.04435375212221804, 0.04869579538591007, 0.037986403575707706, 0.047150507983581, 0.03685824127979853, 0.04351682167775872, 0.048316445043139145, 0.04435578438906962, 0.052162586563535895, 0.04444513163206287, 0.03146279450103684, 0.03727264321286983, 0.023640030700484926, 0.03125178326062927, 0.027678248813052364, 0.10082081839737256, 0.09889533010671692, 0.11170641816520999, 0.10655928316724117, 0.10324553223961264, 0.09184889390220508, 0.10781907956020165, 0.09699952715955773, 0.10357210589820476, 0.06784434190876254, 0.05915482910116121, 0.060727507975939954, 0.08833077805181588, 0.06999719908806434, 0.068231516433228, 0.08568214387022943, 0.053507348910378116, 0.11078201956796419, 0.11504467243049332, 0.10344027382946608, 0.10808903992323826, 0.12380324902643025, 0.12745109217367923, 0.11572219898262714, 0.1480163905188594, 0.12428153630190786, 0.10485049329439333, 9.999999999998899e-05, 0.034323073587985364, 9.999999999998899e-05, 0.010687505788628204, 9.999999999998899e-05, 0.007205531782330965, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014759109757444766, 9.999999999998899e-05, 0.0007368137601005964, 9.999999999998899e-05, 9.999999999998899e-05, 0.008895591686432058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05196866296359326, 0.09035655115778696, 0.0560972602248998, 0.06367916913515004, 0.04965296459194035, 0.04112480449341105, 0.05870421351736699, 0.032456053018849684, 0.06404514012698981, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17685455218462887, 0.19459825218468407, 0.1940978392530066, 0.19303180618597393, 0.1906087633995136, 0.1846320730066715, 0.19199840170488847, 0.174360736901223, 0.18508254962711457, 0.03716080696449375, 0.040463079951642666, 0.038161823416430485, 0.04782029852357972, 0.05093671142756795, 0.0319657823902868, 0.0407000955197343, 0.04906619890357977, 0.03881840556761873, 0.11822711126043761, 0.14734976328358884, 0.182735853956833, 0.14033404989509524, 0.12019071903580547, 0.13540812680408598, 0.16083040177085783, 0.12848705428389606, 0.14100484539884073, 0.15054893279815096, 0.15116769063627944, 0.15357306681079896, 0.16228797053009125, 0.1692878194084496, 0.1778523264804559, 0.15043389480544433, 0.17848791623497184, 0.1548570746775595, 0.09377886563200477, 0.10242818776622242, 0.10723108976048445, 0.10725497476464807, 0.10712834201955235, 0.10765446616888219, 0.09705700385777039, 0.11591142688419731, 0.10317839512458482, 0.16365299791426313, 0.1525972700128626, 0.15161845673597363, 0.1474396914805729, 0.16474922088927924, 0.1659264359632321, 0.1453225700845473, 0.1430419797398721, 0.15095841636920448, 0.13468143975120894, 0.14441912906706078, 0.14272876417510127, 0.14618358812625898, 0.13416052177066573, 0.13993842109454158, 0.12168253999259537, 0.148403466289582, 0.1398098528054288, 0.22616978275071797, 0.19649003232649875, 0.18902776070249372, 0.18524138119513756, 0.3268191226510878, 0.1565839133925958, 0.1495922185491878, 0.17208193702192842, 0.16108882072878838, 0.15925124955848202, 0.14345349916917405, 0.17101931999440967, 0.14848267234895107, 0.16912198202843742, 0.1739314585118369, 0.13646732895543845, 0.14326221587316323, 0.16033459004155848, 0.1858555015897898, 0.18664374101431458, 0.17744489962328147, 0.179133905695537, 0.18866457652147273, 0.19195027200107884, 0.18500303254954975, 0.17651793681677996, 0.17984227000229525, 0.056187945537751194, 0.05648439924615889, 0.05651042407834661, 0.052001623900694516, 0.05343832978600804, 0.04494119084020787, 0.05425828049022097, 0.04651656830164774, 0.04726706693567706]}, "mutation_prompt": null}
{"id": "0e7e3ee7-354f-47f9-b456-74df9d883c00", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5)  # dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 - (0.8 * (self.eval_count / self.budget))  # adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n            if self.eval_count % (self.budget // 10) == 0:  # novel restart mechanism\n                self._adaptive_population()\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Adaptive Crossover Probability and Novel Restart Mechanism for Better Exploration.", "configspace": "", "generation": 36, "fitness": 0.09004311910260689, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.157948628726734, 0.14794843336021168, 0.1612362065074342, 0.1596434894757236, 0.15147548695225144, 0.15562816513787547, 0.15590189878443417, 0.16806813413542332, 0.17350374420707304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037988577065372175, 0.05185509623224238, 0.04406887955335881, 0.04536582291512681, 0.04148189540425373, 0.042709682067540555, 0.03266616136085054, 0.037151424334393446, 0.03814163002617932, 0.022248486582285287, 0.024684939228115765, 0.024824631748284975, 0.023772012206676796, 0.02366223071456386, 0.022544008321559117, 0.03026542171944968, 0.032906405079169754, 0.0317080605436193, 0.128369785857125, 0.13265392386926067, 0.14552831367012165, 0.1805454842777917, 0.5733166974593131, 0.2525302951115317, 0.13868078086559021, 0.14196747883193517, 0.1621319423419696, 0.06459603797512259, 0.10838629140600675, 0.05856550900896795, 0.11038781809347242, 0.0811021291444175, 0.05856810214237318, 0.061122982536390924, 0.07199687838602131, 0.09810666887238095, 0.11442525979093665, 0.1022207212004671, 0.10386887603161576, 0.15190607828967984, 0.10930475647699145, 0.12627613068203514, 0.12526271419024726, 0.11546874266330964, 0.10543226394365268, 0.008937559234143966, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03715452761767213, 9.999999999998899e-05, 0.007061216726172992, 9.999999999998899e-05, 9.999999999998899e-05, 0.005129555480156922, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019255623475735728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0737378720801638, 0.03981937577889805, 0.05006904820507774, 0.07061006851481144, 0.023707693789232098, 0.030789570383782272, 0.013410325315581728, 0.04646210626802949, 0.044385378768839634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17906972682557842, 0.17822762747842757, 0.19235342942935407, 0.1734350900209174, 0.1980998599113143, 0.16397125656176248, 0.18863568254657115, 0.18287171167649807, 0.18807229041648843, 0.035014353860260194, 0.0357138072407035, 0.03291992383666098, 0.037324569185211875, 0.035875461816706644, 0.04998963907547371, 0.04592491330898063, 0.026295788286448074, 0.03555892047256626, 0.12129080780276214, 0.16316200296136163, 0.12878412739422618, 0.1228622386860847, 0.15209756712899947, 0.13856610820112236, 0.12789727835705322, 0.1695066472244513, 0.13348832833371893, 0.1557494696671421, 0.15097227579638361, 0.15619202938055865, 0.15177119385880433, 0.16337074541471885, 0.15878369854880525, 0.16326300825644124, 0.17377774300845283, 0.19457086061082973, 0.10474470850676643, 0.12032395888564229, 0.10420494375201939, 0.117866183898644, 0.1058121209030991, 0.09490421565332197, 0.11822561884279026, 0.12041226909568381, 0.13805149288002116, 0.14872225780541626, 0.15405163660877375, 0.13983754801475567, 0.15497451835966258, 0.1513009462029098, 0.14494010063879958, 0.14462148611402403, 0.14895302706367108, 0.15541171979572643, 0.13801294279504583, 0.13936996905237342, 0.12281432733684816, 0.1378921405372816, 0.1415630688227788, 0.12507754496187495, 0.15107488814243186, 0.11368972135888544, 0.13315208828123104, 0.16826944764141094, 0.16180946167490873, 0.16263096523511067, 0.1518322314907522, 0.16040072384613613, 0.14436527721059755, 0.1842695859226664, 0.15700123454545156, 0.1980437787294207, 0.20286344618407637, 0.11950283292611752, 0.1642428778776266, 0.1559947811219159, 0.18926770627651623, 0.16340706705367225, 0.14447754119597045, 0.14881701846122508, 0.17112116501912, 0.18056834680274592, 0.17841512003271642, 0.18410627065089447, 0.18193833123490133, 0.19075092364914348, 0.18305847270356246, 0.19583550099129576, 0.19308405509290738, 0.1947929465413225, 0.04024314210308533, 0.03980449910708794, 0.044280295606258235, 0.04213568567357617, 0.05377695461853871, 0.055518645072279105, 0.04021088130360162, 0.05056001847939173, 0.05622879117569668]}, "mutation_prompt": null}
{"id": "21812b21-333f-4e1f-845d-8e02afa9d0ee", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.6, 1.4)  # refined dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved Hybrid Differential Evolution with Adaptive Population Initialization and Strategic Mutation Scaling.", "configspace": "", "generation": 37, "fitness": 0.10476235235362436, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.14.", "error": "", "parent_id": "668eecde-2229-409e-b6e9-0708a27ab5d9", "metadata": {"aucs": [0.1757134717480041, 0.15073534007196054, 0.15041232299749374, 0.17458354158202238, 0.16675260864112884, 0.16430799805824847, 0.1905090426115078, 0.1587625649359996, 0.16310498077816538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032860197356226695, 0.03313329600278303, 0.030332837245863442, 0.04443678079057023, 0.04655665354647187, 0.03707618269886537, 0.040719088104313905, 0.03755993154530857, 0.03167974853246103, 0.025101050584961926, 0.021326644887064816, 0.023859408695803497, 0.02199382165610808, 0.026889812998269758, 0.025686184600756112, 0.020245356847019003, 0.025030703132356003, 0.01681673300595543, 0.18821090112475158, 0.7605045348439614, 0.16196591847267106, 0.8299411310015673, 0.927516884586154, 0.20980792938123594, 0.8874270317915501, 0.7642364747034951, 0.8314323780289965, 0.07808977627753899, 0.04708809060516028, 0.05724123110498913, 0.05358171864739636, 0.05368628553891086, 0.050222143093400895, 0.07496672702330631, 0.060533821286693046, 0.09125680731762298, 0.10527220922951197, 0.09910984265014144, 0.12301134466776531, 0.11725371781757388, 0.15149863226820037, 0.11000428314406652, 0.11439646252969338, 0.08964719801021781, 0.10462119903250511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015151601836954631, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052560953789788756, 0.04739562065766423, 0.051822017214047444, 0.05452167858780377, 0.05194312319330163, 0.005114731099874037, 0.03603428855043278, 0.06011922862131036, 0.046417797468244815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18230754196298715, 0.18298643809779946, 0.18048927408481363, 0.17249398175823805, 0.1891713091275108, 0.1861931526216335, 0.1698873443105524, 0.16464151166662666, 0.19991485970579825, 0.035437921474204215, 0.04243054303981886, 0.04611362716251022, 0.038281926484792006, 0.031077638785097728, 0.044142463257235254, 0.03599442733778191, 0.040168023524861374, 0.03141608914110727, 0.16530883101120797, 0.1437841263370947, 0.1360783686630137, 0.17286448813164246, 0.1544419102136082, 0.17195321757313564, 0.1590150184756356, 0.1309668940540638, 0.14511852852430251, 0.15011772282322922, 0.1512533614931344, 0.15032261481019427, 0.15531842351148883, 0.16135632988128257, 0.1497122391306801, 0.16125736904516508, 0.17377774300845283, 0.1719224213438929, 0.12041528140843838, 0.10033485095548089, 0.09101991678758836, 0.1018801823089045, 0.10470748975303523, 0.08837291481516363, 0.10191025622169414, 0.11635585832074957, 0.11875045190238487, 0.13940794764173292, 0.1416030840664504, 0.15256474445362167, 0.17974483655798068, 0.14301442786409158, 0.13945790370618105, 0.14651188767697165, 0.16865540659125144, 0.15210139778311038, 0.11418777255108015, 0.12607568189296448, 0.1257330519358748, 0.13884506531381957, 0.13916830170468597, 0.12205284712708342, 0.12349972385951313, 0.14459961651004072, 0.14113940818624016, 0.16307356155359043, 0.1493100474734378, 0.1735002900470305, 0.15942163896161232, 0.15975490593847785, 0.1466023546528975, 0.15080226948665099, 0.13279455316047206, 0.14593276227772056, 0.11495937077233298, 0.14932772601970412, 0.17600843821477685, 0.12911105820789204, 0.14188826073492578, 0.14443224293454582, 0.14028866070210133, 0.1459373417883244, 0.16957401769311364, 0.18987346950476613, 0.17316401665513426, 0.1909513289700786, 0.1945244771150203, 0.1742747998857076, 0.1802894585689513, 0.1768561457947464, 0.17940911584027686, 0.18387454121665148, 0.04134953816870457, 0.060334593031260764, 0.0533865926201339, 0.03806047418357228, 0.04017415935176816, 0.05766334498612502, 0.061327786793281436, 0.0407002960386309, 0.048450902366787174]}, "mutation_prompt": null}
{"id": "e8d81a22-0b9d-4d1b-9b60-9afca8440e45", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.7, 1.5)  # refined dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Adaptive Evaluation Scheduling and Refined Mutation Strategy.", "configspace": "", "generation": 38, "fitness": 0.1055735053621003, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "21812b21-333f-4e1f-845d-8e02afa9d0ee", "metadata": {"aucs": [0.17918970558824587, 0.14630071578569226, 0.15691536266507278, 0.19312465802174772, 0.16198613556990782, 0.15158265470386445, 0.17982823791878422, 0.16047592030885405, 0.16719272686802322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044960442925867206, 0.03232104375328948, 0.03071789139400316, 0.04280544229599814, 0.043077094368055624, 0.04401512699583998, 0.03590596449091121, 0.04650817367666893, 0.03039393699545767, 0.042533087670739045, 0.030410913403928874, 0.015248016075373405, 0.02972478624453634, 0.031827255105083885, 0.017397722626700474, 0.027429683577984587, 0.027550590644143447, 0.014053315052368287, 0.21207280008653429, 0.7645742717284403, 0.17091354477650222, 0.8320275902880233, 0.9364616731200177, 0.8719991998934709, 0.8883909667198568, 0.7614379335432857, 0.8359286263497036, 0.07725242441898539, 0.04969143604421644, 0.05980602253627476, 0.04926656160435028, 0.06019530489738334, 0.07009625547469933, 0.08035881746248508, 0.06264642267842568, 0.060124897177153414, 0.11659124051652958, 0.10733631782721553, 0.08567565081002226, 0.10494278403383173, 0.1219433662424877, 0.0983575239861586, 0.09851542477355701, 0.11609079381486775, 0.09776088605512356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031680483298952566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00047104357492611104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050891233311374684, 0.01715631947701035, 0.04777580843650098, 0.03615330416934981, 0.014105397508968776, 0.03184769123829301, 0.03644957533883331, 0.026853537738963817, 0.03980286754283313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.178531758914101, 0.16551353502763744, 0.18198369143972815, 0.17675791637106086, 0.18309627436237852, 0.19105308851565783, 0.16869138523940785, 0.16223970765442342, 0.20417614290295827, 0.030315512986603066, 0.03802371695518525, 0.033432845791561694, 0.03363349658401471, 0.030924938610401242, 0.09257365606597179, 0.03676268320206599, 0.02791144223883113, 0.038132201998719584, 0.17136330098453312, 0.16031461223191457, 0.13454160304608775, 0.13494295093395592, 0.15984998089192703, 0.13119140520577277, 0.17226047525961763, 0.13398614322406666, 0.13938495418234798, 0.1524662644459397, 0.1534396872162057, 0.1472031370067196, 0.15355861394562142, 0.15807906618209178, 0.1544620937498028, 0.15847688498902357, 0.17377774300845283, 0.15457798616530072, 0.1140983863983851, 0.08842771515631231, 0.09305347607300896, 0.11598165853369569, 0.08884223508212397, 0.09538315300721045, 0.09666360164175603, 0.09417987023355212, 0.09630565710329775, 0.15644865448574363, 0.14865090413726645, 0.14424482986239784, 0.14405747404126434, 0.14992357400981104, 0.14846397911258136, 0.1482887542118948, 0.1424859242894999, 0.1485155595243497, 0.13355789865802403, 0.10386620610111308, 0.1188201426493044, 0.13859397172649401, 0.12799147158394575, 0.1131565524249798, 0.11954389677506683, 0.137801009922207, 0.10873629637178894, 0.16063056962897504, 0.12779363535630894, 0.15677243654431916, 0.12899335895229214, 0.13937845696577822, 0.1239374860999034, 0.12575406957327617, 0.1401579631172839, 0.12329279072045829, 0.10461160408301007, 0.15097295850202808, 0.1514233508766465, 0.12382455354037192, 0.11685200942080787, 0.16142368081554248, 0.1522319898972173, 0.17945379055872113, 0.16094944351707896, 0.17955546423506585, 0.19980014349323905, 0.19565655119187209, 0.17519366033998596, 0.18102011995185274, 0.199478176714464, 0.1742179233878567, 0.17785730468075855, 0.17141216460809428, 0.03982081553879491, 0.05793206350610269, 0.035344438583798765, 0.03789448983877175, 0.04141442792397099, 0.05127801755310213, 0.05714891830476898, 0.03812475845373775, 0.04474965283655108]}, "mutation_prompt": null}
{"id": "f5ec8e6f-662d-4b54-8d20-69bba19741dc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        self.elite_size = max(1, self.dim // 10)  # New: elite preservation size\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.7, 1.5)  # refined dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            elite_indices = np.argsort(self.fitness)[:self.elite_size]  # New: preserve elite\n            elite_population = self.population[elite_indices].copy()\n            elite_fitness = self.fitness[elite_indices].copy()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n            self.population[:self.elite_size] = elite_population  # New: reinstate elite\n            self.fitness[:self.elite_size] = elite_fitness  # New: reinstate elite fitness\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved selection strategy in HybridDEOptimizer by introducing elitism to preserve best solutions across generations.", "configspace": "", "generation": 39, "fitness": 0.1055735053621003, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "e8d81a22-0b9d-4d1b-9b60-9afca8440e45", "metadata": {"aucs": [0.17918970558824587, 0.14630071578569226, 0.15691536266507278, 0.19312465802174772, 0.16198613556990782, 0.15158265470386445, 0.17982823791878422, 0.16047592030885405, 0.16719272686802322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044960442925867206, 0.03232104375328948, 0.03071789139400316, 0.04280544229599814, 0.043077094368055624, 0.04401512699583998, 0.03590596449091121, 0.04650817367666893, 0.03039393699545767, 0.042533087670739045, 0.030410913403928874, 0.015248016075373405, 0.02972478624453634, 0.031827255105083885, 0.017397722626700474, 0.027429683577984587, 0.027550590644143447, 0.014053315052368287, 0.21207280008653429, 0.7645742717284403, 0.17091354477650222, 0.8320275902880233, 0.9364616731200177, 0.8719991998934709, 0.8883909667198568, 0.7614379335432857, 0.8359286263497036, 0.07725242441898539, 0.04969143604421644, 0.05980602253627476, 0.04926656160435028, 0.06019530489738334, 0.07009625547469933, 0.08035881746248508, 0.06264642267842568, 0.060124897177153414, 0.11659124051652958, 0.10733631782721553, 0.08567565081002226, 0.10494278403383173, 0.1219433662424877, 0.0983575239861586, 0.09851542477355701, 0.11609079381486775, 0.09776088605512356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031680483298952566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00047104357492611104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050891233311374684, 0.01715631947701035, 0.04777580843650098, 0.03615330416934981, 0.014105397508968776, 0.03184769123829301, 0.03644957533883331, 0.026853537738963817, 0.03980286754283313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.178531758914101, 0.16551353502763744, 0.18198369143972815, 0.17675791637106086, 0.18309627436237852, 0.19105308851565783, 0.16869138523940785, 0.16223970765442342, 0.20417614290295827, 0.030315512986603066, 0.03802371695518525, 0.033432845791561694, 0.03363349658401471, 0.030924938610401242, 0.09257365606597179, 0.03676268320206599, 0.02791144223883113, 0.038132201998719584, 0.17136330098453312, 0.16031461223191457, 0.13454160304608775, 0.13494295093395592, 0.15984998089192703, 0.13119140520577277, 0.17226047525961763, 0.13398614322406666, 0.13938495418234798, 0.1524662644459397, 0.1534396872162057, 0.1472031370067196, 0.15355861394562142, 0.15807906618209178, 0.1544620937498028, 0.15847688498902357, 0.17377774300845283, 0.15457798616530072, 0.1140983863983851, 0.08842771515631231, 0.09305347607300896, 0.11598165853369569, 0.08884223508212397, 0.09538315300721045, 0.09666360164175603, 0.09417987023355212, 0.09630565710329775, 0.15644865448574363, 0.14865090413726645, 0.14424482986239784, 0.14405747404126434, 0.14992357400981104, 0.14846397911258136, 0.1482887542118948, 0.1424859242894999, 0.1485155595243497, 0.13355789865802403, 0.10386620610111308, 0.1188201426493044, 0.13859397172649401, 0.12799147158394575, 0.1131565524249798, 0.11954389677506683, 0.137801009922207, 0.10873629637178894, 0.16063056962897504, 0.12779363535630894, 0.15677243654431916, 0.12899335895229214, 0.13937845696577822, 0.1239374860999034, 0.12575406957327617, 0.1401579631172839, 0.12329279072045829, 0.10461160408301007, 0.15097295850202808, 0.1514233508766465, 0.12382455354037192, 0.11685200942080787, 0.16142368081554248, 0.1522319898972173, 0.17945379055872113, 0.16094944351707896, 0.17955546423506585, 0.19980014349323905, 0.19565655119187209, 0.17519366033998596, 0.18102011995185274, 0.199478176714464, 0.1742179233878567, 0.17785730468075855, 0.17141216460809428, 0.03982081553879491, 0.05793206350610269, 0.035344438583798765, 0.03789448983877175, 0.04141442792397099, 0.05127801755310213, 0.05714891830476898, 0.03812475845373775, 0.04474965283655108]}, "mutation_prompt": null}
{"id": "413aace6-f175-4687-b0d5-6db0a463cf25", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.7, 1.5)  # refined dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.5 + (0.9 - 0.5) * (self.eval_count / self.budget)  # adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Improved Diversity Control and Adaptive Crossover Strategy.", "configspace": "", "generation": 40, "fitness": 0.09287719400448442, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "e8d81a22-0b9d-4d1b-9b60-9afca8440e45", "metadata": {"aucs": [0.17270372519856914, 0.19282413295744238, 0.18536202799681245, 0.16112462307470632, 0.1488372430741367, 0.1485306974284697, 0.19871623719431408, 0.16381016811498794, 0.1803103589754521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03599154374656466, 0.032134670973154256, 0.024153715653976948, 0.03355328713825201, 0.0313354733922635, 0.04131183960717155, 0.03995618880147578, 0.034697456840703356, 0.0387123830085937, 0.024764269961502716, 0.038830406492651126, 0.017543330581838545, 0.02237384616821092, 0.030937267999265328, 0.02013428730700273, 0.043126153579947424, 0.027004788163834892, 0.02569685545607936, 0.14164311645760497, 0.15804320144522577, 0.14655989407254932, 0.9731965671340589, 0.14750671372163082, 0.1437361547648216, 0.1488057170439051, 0.6032637173520807, 0.11858999046966057, 0.07176222365359086, 0.09003591251201015, 0.07963493592488047, 0.055747360695884485, 0.09015526095462867, 0.0797826420960992, 0.07084300170524571, 0.07467782050547045, 0.0607474363668864, 0.14148537245313075, 0.11990858868776832, 0.14696287751810944, 0.11047900742092898, 0.11376642481304444, 0.10784918936754861, 0.13573575447790243, 0.11292803535986318, 0.09862926822843965, 0.008347769273178485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006715719884319293, 0.00460825490084904, 0.0433168442872639, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006528194273373478, 0.00047104357492611104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046161305244271866, 0.015686211606774636, 0.03975953679445898, 0.0224494294107066, 0.017233242920739578, 0.04512338448075426, 0.05000280588333195, 0.04736601155542486, 0.05789783630884737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016644543025825853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017852234378512577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1849680304621002, 0.1856235684738382, 0.17707106386327154, 0.1885467672471386, 0.17686084577124916, 0.18679512982121405, 0.19785156060801412, 0.181419910597017, 0.174308925550538, 0.04647597300384643, 0.04259305616283815, 0.03349605360199226, 0.04795848071164077, 0.04179980799878247, 0.06093543091915565, 0.041117070576029646, 0.03857068608719694, 0.03314644854239779, 0.14825521066377, 0.17437361821039243, 0.14019837952546876, 0.13817353135193278, 0.14602462234908276, 0.14912668800602513, 0.16681624648161875, 0.1351361067333572, 0.14242077835495826, 0.15523125551914108, 0.1688740579746154, 0.1483749528499273, 0.1569627218551286, 0.14394287084918267, 0.15362822601733783, 0.1520121454593485, 0.17377774300845283, 0.15750577600099513, 0.08835141538613711, 0.11178795081306159, 0.09881806885653699, 0.09948509260513605, 0.10358822353191044, 0.1009721752337902, 0.13234918999235956, 0.10984112079304464, 0.10579077130783532, 0.16056041781516228, 0.1561865740956817, 0.17580043164103698, 0.15417479470440576, 0.17821655626466326, 0.14717659456919263, 0.1389974806145139, 0.160507799582012, 0.14114281369568615, 0.11314345026889694, 0.1375418207070307, 0.15315174371464269, 0.13633513536342357, 0.12860477916887025, 0.14185138484383075, 0.09347071562670117, 0.14190087982624844, 0.1290873398018615, 0.17091388441515887, 0.14696549988163166, 0.14739100996395682, 0.16252627965639388, 0.15719072325329198, 0.14367507831267523, 0.16574934322007284, 0.1454688971903395, 0.14574732715932093, 0.20527943177746066, 0.14700374001331928, 0.15482583826482899, 0.1252705409596776, 0.16115757511138384, 0.14046653472238535, 0.11255958030719015, 0.1428826922891291, 0.16585182155834666, 0.17797074907769528, 0.17743354576591597, 0.19243645810259968, 0.1867049591557367, 0.2040690737756491, 0.18834363735309312, 0.18684816709563978, 0.16918659679973824, 0.1925624717976595, 0.04903229343483417, 0.05253392351799335, 0.04662110137065556, 0.061549882650317134, 0.038755542500667595, 0.04946242504952569, 0.04464701077204791, 0.04300200505895668, 0.046180129637388934]}, "mutation_prompt": null}
{"id": "2fb789e0-e394-4fda-8655-affe9420ee9c", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.85, 1.7)  # enhance dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved Adaptive Differential Evolution with Enhanced Dynamic Scaling and Crossover Adaptation to Boost Convergence.", "configspace": "", "generation": 41, "fitness": 0.10857107088835148, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "e8d81a22-0b9d-4d1b-9b60-9afca8440e45", "metadata": {"aucs": [0.15627475113649758, 0.14095833054900064, 0.16741511738471215, 0.15832608487766264, 0.16194734337127648, 0.150817027705759, 0.15784071467415595, 0.16465517391956896, 0.17055437081004998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0348960935642475, 0.04845494860192667, 0.033731633036449105, 0.046723142293008446, 0.02952897758859996, 0.033848614122743315, 0.037937547448437026, 0.035915186797851995, 0.027366180805965423, 0.02118381839524841, 0.019670957675558154, 0.017193470398218724, 0.023640903100081045, 0.02159790087124569, 0.025638079530751368, 0.02724359804568577, 0.019060080245053568, 0.013397230966006646, 0.81501857999871, 0.8688648325174801, 0.5826228776443269, 0.8333314893694181, 0.991436701128339, 0.8901022249168572, 0.8984370000903157, 0.7590732229563234, 0.8370760747901923, 0.057546652461683, 0.09041651443761767, 0.05952161406643153, 0.05193821201599569, 0.0635321617557143, 0.06971289856175933, 0.05649737056413329, 0.06553375080373991, 0.03956581220585609, 0.10141333211406678, 0.09690220436038832, 0.08270925357985948, 0.10745737542981948, 0.08830370777464436, 0.13391230169197732, 0.10344730274460057, 0.11813182180252357, 0.08626848251529684, 0.002453266412937194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016539698905987832, 0.0011930209079360488, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004401765863876195, 9.999999999998899e-05, 0.0042674103970774535, 0.010138253077152881, 0.006734204628517149, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01033593865335658, 0.025218898910785215, 0.03459971356135427, 0.04430089088936384, 0.0257921907249975, 0.05931627924276095, 0.03531265873997613, 0.019468645859558764, 0.043889943423477185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16300445226161842, 0.156466773108352, 0.16150158799762815, 0.16155301440478564, 0.16699818187327276, 0.16925948370508537, 0.1670477833224, 0.18839471607130198, 0.21217576067050492, 0.03776612035775928, 0.03651231489365492, 0.03532998861735792, 0.030544207868830164, 0.0398096595893318, 0.04030837298552792, 0.03357575550549008, 0.02815482534950675, 0.03332683673729786, 0.11667724032817439, 0.12798004228278437, 0.140810913362027, 0.17308403963044972, 0.13544383814917205, 0.1592979667269645, 0.1566733099219857, 0.15650081042586395, 0.14116943884228572, 0.1545503145013547, 0.13946568233661671, 0.1520650897673922, 0.1536915520633273, 0.14601901482945556, 0.14071395540833165, 0.15031578686093583, 0.17377774300845283, 0.14146916989309577, 0.0919332844734343, 0.08546982602737319, 0.09490110716199252, 0.08899278152717904, 0.09052654360599133, 0.10663352465934206, 0.09505234263824747, 0.09386031173166853, 0.10029232109653008, 0.14956897454444806, 0.13889595038461555, 0.1417650804651175, 0.13386655323501018, 0.1417130961018236, 0.13225043681895243, 0.14556967808255106, 0.13762215509579223, 0.15514944393164676, 0.06449335467236483, 0.10752669100140944, 0.11562288602037918, 0.14475547069238381, 0.14479947864148202, 0.11447053440937527, 0.12486417153479323, 0.13831840669863793, 0.05874924642200097, 0.16259930477468731, 0.13636881898816777, 0.1593378926433907, 0.15984343942242774, 0.14523931101300547, 0.1424867042824609, 0.13084483330535623, 0.13946205848934334, 0.1452303331049012, 0.15955883482828337, 0.13512874871271674, 0.11545484707330711, 0.10876085344320341, 0.09186201369671021, 0.10778958270202443, 0.13778467672192418, 0.1647895990250703, 0.15604618408348614, 0.18317618505083832, 0.18281148458579133, 0.1852352427844869, 0.1799067911500346, 0.17442710115693338, 0.18853760155596866, 0.18438622038945052, 0.18861286852564407, 0.19695562931161747, 0.037968511821632855, 0.050177876112697084, 0.04331378213124104, 0.04211297617026155, 0.04436321930996401, 0.03975382147404449, 0.03990409683257601, 0.044834081246174495, 0.04393256021823]}, "mutation_prompt": null}
{"id": "05778dce-86f9-4b98-80f3-a1b1fb8e738d", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        self.no_improvement_streaks = np.zeros(self.population_size, dtype=int)\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.85, 1.7)  # enhance dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n            self.no_improvement_streaks[idx] = 0\n        else:\n            self.no_improvement_streaks[idx] += 1\n            if self.no_improvement_streaks[idx] > 5:  # Reinitialize if there's no improvement\n                self.population[idx] = np.random.uniform(self.lb, self.ub, self.dim)\n                self.fitness[idx] = func(self.population[idx])\n                self.eval_count += 1\n                self.no_improvement_streaks[idx] = 0\n            self.CR = 0.9 - 0.5 * (self.eval_count / self.budget)  # Dynamic CR adjustment\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Ensure new pop fit\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced Hybrid DE with dynamic adjustment of crossover probability and convergence speed-up by re-initializing stagnating vectors.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "2fb789e0-e394-4fda-8655-affe9420ee9c", "metadata": {}, "mutation_prompt": null}
{"id": "ee409734-238a-4f3c-83db-f36cf096a6ed", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.85, 1.7)  # enhance dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced HybridDEOptimizer with Adaptive Trial Vector Generation for Improved Convergence.", "configspace": "", "generation": 43, "fitness": 0.11142690946687844, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.14.", "error": "", "parent_id": "2fb789e0-e394-4fda-8655-affe9420ee9c", "metadata": {"aucs": [0.1881376664825296, 0.15013277291481686, 0.16683942313774003, 0.15970280410212712, 0.17266724257309074, 0.15073251512213937, 0.16412119091373678, 0.17866194873854802, 0.16178578743437533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05394934598465484, 0.05630790137452768, 0.04004530005513007, 0.06014308060412055, 0.03809432059894591, 0.0342264484172663, 0.046291856482209015, 0.035992750819349606, 0.03933585295523767, 0.028517826192121176, 0.031229837474262445, 0.033205458090143525, 0.039597075815899885, 0.03709400670712204, 0.03677814437248328, 0.024877300069615527, 0.04035328356104351, 0.0265748767288172, 0.38718514328041875, 0.8372495960796272, 0.20940252250067026, 0.5523847781985829, 0.9435320038546571, 0.8332179340671649, 0.8026071914992522, 0.41206378945683664, 0.9242197574384693, 0.0861341005659122, 0.08086059765989106, 0.08457479850089766, 0.0581865436758211, 0.09864560878906736, 0.045013110041904114, 0.07844733017650507, 0.06106029105337207, 0.05575804794161099, 0.1444269099939418, 0.10624363480807208, 0.09768710266306557, 0.11276261150978861, 0.13637133670598345, 0.13968190443004647, 0.13600060738472386, 0.12691989873866572, 0.11113773708813823, 0.0014755588558061916, 9.999999999998899e-05, 0.016475892839886153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005164758349346377, 0.021886440065078783, 0.00022617874062047516, 0.0009566749033954602, 0.004769195341324695, 9.999999999998899e-05, 0.007226219304626635, 0.006614436502203391, 9.999999999998899e-05, 0.015402147105740172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04519675228240361, 0.08279124508069202, 0.06284316175725124, 0.11926629905334707, 0.05827201231304713, 0.0425629452154872, 0.03784105859585163, 0.026049970634193786, 0.055823871717758045, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003400963825488157, 9.999999999998899e-05, 9.999999999998899e-05, 0.18393792863555614, 0.19960500322969388, 0.18840911636754942, 0.18569319655850458, 0.18082662227514668, 0.18550346622976865, 0.18525688452999445, 0.19656554095051126, 0.18489156802591755, 0.03257522608133856, 0.03772527107726842, 0.03873538308118096, 0.038591677861043006, 0.05104503805309468, 0.04016905007646143, 0.03213964150052584, 0.045327139735225175, 0.03639590379341784, 0.1500725592108727, 0.13804325719399824, 0.13797836145112763, 0.13440089146042844, 0.1309504571979513, 0.13702873709506525, 0.1501441663489128, 0.14357145744700717, 0.1337322536472364, 0.16385412658763143, 0.1682917087963478, 0.1516600147137317, 0.1701014111965371, 0.16333882606240224, 0.15890437913322364, 0.16266978882158745, 0.17377774300845283, 0.1732500976739162, 0.10149583812653873, 0.09719604321909137, 0.09727392075638197, 0.11215156516134861, 0.1001556674707812, 0.11274612927641559, 0.1152076727530068, 0.11224130382741804, 0.09723325355256163, 0.14832396092294764, 0.1741805825641326, 0.14868197568610153, 0.16711792458098684, 0.143467784702779, 0.14031308377994633, 0.16933731974310773, 0.15798541209646555, 0.14048209978488646, 0.1408314835072353, 0.14048560109426744, 0.12786138356086008, 0.14907871552207785, 0.15381816783112923, 0.14194791157985964, 0.1446778156149694, 0.15550194272028273, 0.13567847398146093, 0.18209494181590835, 0.13278341011167427, 0.1552666574638597, 0.24609057007972235, 0.2472112730120255, 0.17308478845548303, 0.1552749500735745, 0.14638364317260733, 0.1505352185208576, 0.15198995334519205, 0.16817407749584168, 0.15115889574233565, 0.22141686632347923, 0.16376371264358625, 0.12090813838954595, 0.14920831985438432, 0.16057381719064323, 0.17518047891554145, 0.17869553115053982, 0.20128568243224954, 0.19700303623178983, 0.1882317880280442, 0.1804858554421005, 0.18902000655943507, 0.17950989574676657, 0.1842025405895884, 0.1961531168344619, 0.04675687593069555, 0.04683830103252318, 0.06246208674859477, 0.04441675542986634, 0.050270526005390836, 0.05214056183612337, 0.04888648365544157, 0.04328328190470565, 0.04576507236122107]}, "mutation_prompt": null}
{"id": "afd8b394-3d18-434f-9b12-70ce71b669d6", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_F = self.F * np.random.uniform(0.85, 1.7)  # enhance dynamic mutation scaling\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        # Diversity in crossover probability based on fitness variance\n        fit_var = np.var(self.fitness) + 1e-9  # avoid zero division and improve variance\n        flexible_CR = np.clip(np.exp(-fit_var) * self.CR, 0.1, 1.0)\n        cross_points = np.random.rand(self.dim) < flexible_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Improved exploration by introducing diversity in crossover probability and mutation factor based on fitness variance.", "configspace": "", "generation": 44, "fitness": 0.09012059000816906, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "ee409734-238a-4f3c-83db-f36cf096a6ed", "metadata": {"aucs": [0.16421718397093532, 0.16168532135591163, 0.19753068212907, 0.17894841224670766, 0.178423127190255, 0.20154544888581172, 0.17858877491420866, 0.14600165355831962, 0.1656881665026385, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047776490150952866, 0.047224489323341, 0.03799591401214397, 0.04152425576774166, 0.04279863958415808, 0.04104840467730175, 0.04161334877516054, 0.039819207491089026, 0.048870319927535655, 0.02840885483669431, 0.033613702665666434, 0.03359566791736013, 0.0281309392546929, 0.04528837377997319, 0.037480116727568236, 0.03169302814948205, 0.030722730560469258, 0.04138913995458293, 0.09733960212409021, 0.10258835492978613, 0.08216431574734284, 0.12243818875940926, 0.08547556011156576, 0.08973792499922295, 0.1012761200914798, 0.09828361733240032, 0.11010033529970076, 0.07657845013051556, 0.06803362060523666, 0.07888129120768339, 0.06993411230838464, 0.07121519055139036, 0.07843811407969092, 0.0550739034202008, 0.0738912876722907, 0.054860655564967775, 0.11622921859275048, 0.09475433497235353, 0.11006474080765782, 0.10758791487930919, 0.14665124540960484, 0.12751441651644402, 0.13203854552641936, 0.11382202305743105, 0.09854865894990072, 9.999999999998899e-05, 9.999999999998899e-05, 0.00389851219852122, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007929451839318036, 0.01049286901452584, 9.999999999998899e-05, 0.00020692236781638673, 0.04489244555541849, 9.999999999998899e-05, 0.0028185164947553965, 0.031735504812137716, 9.999999999998899e-05, 0.01052016139052847, 0.03712308823295485, 9.999999999998899e-05, 0.016215265589812233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03195639459741417, 0.053092703031886956, 0.025175695363590767, 0.05847865865744939, 0.040584734318440896, 0.1080487140211599, 0.06392281618447981, 0.05225385655937698, 0.038511304166909066, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031528147266559614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1928394277061216, 0.1940794370047363, 0.20359631187836347, 0.18302567221346766, 0.1768038625545707, 0.20432240425372306, 0.19665457801521014, 0.20201649685762735, 0.20171932425646721, 0.04075071694014809, 0.051452499401799634, 0.042563360591672206, 0.04347743669213655, 0.057683700698340945, 0.034269273201461115, 0.052391124044643966, 0.03595338830456607, 0.05206308405390625, 0.13994824652220816, 0.14120827781337753, 0.130624612637252, 0.15653057258585779, 0.1459206723269133, 0.14595159860047513, 0.12758380711602768, 0.1630922711401307, 0.1418793057945844, 0.17857074544321916, 0.18522201680049077, 0.16046622529013532, 0.16012054045223434, 0.1524066394279745, 0.16983924558670227, 0.17104575183456094, 0.17377774300845283, 0.1863193248577827, 0.12450454321268267, 0.1240898031636658, 0.1017853021818439, 0.10759460495544959, 0.12942083089887035, 0.1059787869945511, 0.12072770492504592, 0.12487583742355268, 0.1092601707979649, 0.16244997219127888, 0.15930816641476264, 0.1378191289044094, 0.14964317790066928, 0.1589146147149395, 0.16561162756550818, 0.14999230558167997, 0.16945925614749635, 0.1531422403846806, 0.14005803639099557, 0.14443992198830746, 0.14451164278121564, 0.14378168119837742, 0.13845455786329897, 0.14496436619999586, 0.13227654586434567, 0.15036544633855975, 0.13758766336519257, 0.16225432986719712, 0.1597264537855303, 0.1600579337378807, 0.18249023173932988, 0.15890959167340557, 0.18643466897136352, 0.16799954626326474, 0.14714094062740402, 0.166199486033635, 0.19726551701181738, 0.16199071665407538, 0.1370562068265706, 0.17516698631085859, 0.22610668860258354, 0.14606544059948423, 0.19273048075723265, 0.20888626716849334, 0.11493873631095397, 0.20174028568391245, 0.18090661491048776, 0.18626654913816543, 0.20591028468906492, 0.18248229293452511, 0.2134700496721561, 0.22177700668864397, 0.1882581582294619, 0.19331569965469209, 0.05648584921979005, 0.04907461520986944, 0.04473227284212011, 0.047731455186414085, 0.05961624994243797, 0.04481471491418976, 0.044610205711057116, 0.04949569941246934, 0.04343352210252782]}, "mutation_prompt": null}
{"id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced selective mutation strategy to enhance exploration potential while maintaining convergence.", "configspace": "", "generation": 45, "fitness": 0.11554605156709746, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.15.", "error": "", "parent_id": "ee409734-238a-4f3c-83db-f36cf096a6ed", "metadata": {"aucs": [0.18067121136619335, 0.17138146979398172, 0.19088833483634704, 0.16970139577006083, 0.14376591725762844, 0.16853068649941283, 0.15970363568912438, 0.15757684708917152, 0.17415054826441934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053902143506161515, 0.05749411080088285, 0.04173328705430268, 0.03845598053579102, 0.04043597193235493, 0.050602634784522316, 0.040710813185634964, 0.03761237424776376, 0.033857681573965404, 0.041939404973332595, 0.04898288309195542, 0.02256538252920892, 0.027827252188589613, 0.03347997595386554, 0.025227754028803062, 0.02500475878227204, 0.024814818360944124, 0.03646587590896744, 0.7431130082076114, 0.9480025618118065, 0.8845040903493226, 0.19373793615921386, 0.4711872360043329, 0.8781412206897049, 0.9313028435304783, 0.8318869469932537, 0.7103881924272791, 0.05695316773956216, 0.08208372300627065, 0.07230206297476793, 0.06619244057977725, 0.07183950132897154, 0.0865623937218174, 0.06342452149004729, 0.05410628245192639, 0.07446739743341546, 0.10965571313556044, 0.11206938486051754, 0.1427892750859593, 0.1122911355539602, 0.09403543538105719, 0.0907903522925444, 0.11531128122635859, 0.10821718223364873, 0.1110023853085439, 0.03733523221346846, 0.010204757464102654, 0.003273187468961436, 0.008695547589168351, 9.999999999998899e-05, 0.0009878724044940501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006045140948204408, 0.005121667621280412, 9.999999999998899e-05, 0.04118655081989342, 9.999999999998899e-05, 9.999999999998899e-05, 0.009914268627165601, 0.008328788703270251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038395220755867876, 0.02877298315898047, 0.022712875306792335, 0.06977707255367571, 0.09252049850284871, 0.04539993151676558, 0.04460239048766712, 0.06565519222698035, 0.04658026738120713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01460684947037938, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.20223188825951433, 0.18969967954018807, 0.19280729089233917, 0.1990739320273034, 0.18295577132117224, 0.185728553281732, 0.19373676237758242, 0.1848281553475113, 0.21227996181553122, 0.04386621732322493, 0.040339566289088524, 0.04477347462026138, 0.04731275489627573, 0.03735028283868358, 0.053095592576924866, 0.03799040341852955, 0.0344360956860944, 0.04320190758626363, 0.1429849659676753, 0.14466419313234002, 0.15637611586669486, 0.17197304264948232, 0.13198052708009744, 0.1337571653141335, 0.14231356646354376, 0.15775235925535747, 0.1253242507125122, 0.15718415206432068, 0.1650341686609007, 0.1812092350046992, 0.16979214926620712, 0.16324943553487214, 0.1679713040218418, 0.1668178622845009, 0.1752580858302878, 0.16719301274211773, 0.09879317357534656, 0.09729239163647252, 0.10901773125705072, 0.1191637533672878, 0.1316656091220073, 0.11702202630108693, 0.11671830848219833, 0.11246209396457418, 0.11875345756327116, 0.1579750970570991, 0.1574660707729323, 0.17599454842407325, 0.17892632230068262, 0.1472656071583449, 0.16193077513791465, 0.16445703117791077, 0.16022088251782263, 0.16017502547270068, 0.14096576912705028, 0.1391512703543929, 0.15020593677743566, 0.14356235722276922, 0.14312235253622207, 0.1558490300564208, 0.15530979572540615, 0.14701594856945233, 0.1643488603135076, 0.15442689453467373, 0.18674661669589232, 0.1574614043080642, 0.16914142433026025, 0.185332306866539, 0.15049497306968185, 0.13265966321362355, 0.19379951538448736, 0.19263481795963644, 0.15696905699607666, 0.25669194313252286, 0.1522303527162283, 0.13101941212704937, 0.12203803751990072, 0.13799231195610662, 0.1407885207683628, 0.15546758576392605, 0.20102622250961932, 0.18028787111895817, 0.20686758952476825, 0.1902242767570631, 0.1785190110801157, 0.1909914597073301, 0.18090012927343713, 0.19058522225553076, 0.19072742260319087, 0.18845913613611898, 0.05206884084170904, 0.04824137534847328, 0.04906240642082771, 0.056282563334934865, 0.049760126767736446, 0.07371171751638084, 0.05745431283729541, 0.04971979055229625, 0.04987417366701097]}, "mutation_prompt": null}
{"id": "f46195bd-16a9-487d-b773-1916be357763", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        # Periodic mutation rate adjustment every 100 evaluations\n        if self.eval_count % 100 == 0:\n            self.F = 0.6 + 0.4 * np.sin(self.eval_count)\n        \n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced periodic mutation rate adjustment to balance exploration and exploitation dynamically.", "configspace": "", "generation": 46, "fitness": 0.10120818575423478, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.10.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17668274121659544, 0.1692886821505981, 0.18745829416481852, 0.17625594422841384, 0.15652262027926267, 0.15437221257754152, 0.17561709611337484, 0.16000844038039963, 0.16534342534490243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04161072447182146, 0.03647725599104812, 0.03374933081860798, 0.044819705988389025, 0.03976535092954403, 0.03971911747966572, 0.03524448611226105, 0.03859341952439266, 0.052718822565633094, 0.03621986397390187, 0.03479711326899593, 0.027353749100987645, 0.02904925392128388, 0.03178686827727428, 0.023934050905849102, 0.02794941172926957, 0.0329262384137462, 0.03269217049364592, 0.15560647643679526, 0.3677817233113613, 0.21694641713613594, 0.16201092647927162, 0.16218613490586176, 0.14301948763776184, 0.9313028435304783, 0.4001762718449793, 0.7012803830112486, 0.060817845908330725, 0.07149606931685304, 0.1030389202905202, 0.059204619324494834, 0.10744637589207795, 0.07229715289272187, 0.08034204012296775, 0.07681529998769454, 0.07228176925703644, 0.11980316912227995, 0.16453644633543718, 0.1298761642495765, 0.14364766178759547, 0.07559816319129153, 0.10398594624632829, 0.11531735828041634, 0.1394190925763683, 0.11615625946995767, 0.014339053676692526, 9.999999999998899e-05, 9.999999999998899e-05, 0.009454836927579313, 9.999999999998899e-05, 0.02349142591722686, 0.012824135904967227, 0.012793910190701752, 9.999999999998899e-05, 9.999999999998899e-05, 0.025407137494681264, 0.009776141102585512, 0.016229601219965972, 0.021218072536540622, 0.005761250525828987, 0.05677282636746317, 0.0021709040208330865, 0.00013598985732532487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06911069215488075, 0.04978338824131001, 0.0465692455946457, 0.023627496405023152, 0.05394951283722005, 0.044972876277133755, 0.03845746272963735, 0.053109928723418465, 0.040899969411602455, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011928493942442775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18930559902490596, 0.18624304308393513, 0.21150731823658708, 0.20415155185847367, 0.1991646329371919, 0.18986135226245282, 0.22227938948859838, 0.18756819679020886, 0.19074291913214614, 0.04138690656226751, 0.03249206539329319, 0.03977874362067124, 0.037208039266510284, 0.05515534009992484, 0.055513964769752566, 0.03308052054324251, 0.04683980099520302, 0.041023677168181116, 0.12248672956846496, 0.14614936705040404, 0.13776714307622828, 0.16496342067107495, 0.15258838323108626, 0.13111477991255793, 0.13434137316075245, 0.13902199566487616, 0.15996759896975632, 0.15750084249073548, 0.16079652017243828, 0.1812092350046992, 0.18218882036322626, 0.15771766090158923, 0.1772621645304251, 0.15913991948372785, 0.17377774300845283, 0.17953389938863418, 0.10486019154513848, 0.11436182777792492, 0.1173794190250459, 0.11428757483057739, 0.10901610163790154, 0.12600032071022838, 0.09940810232892416, 0.1142324023679957, 0.1188323453894391, 0.16272660487270096, 0.1582091164411138, 0.1743098366128346, 0.18108294618277554, 0.16241382500620916, 0.15920884369871457, 0.16246242048486859, 0.1585123674167973, 0.14616194135902627, 0.15392560015047296, 0.15038379583047734, 0.15800607131521416, 0.14102544936568506, 0.14689191568993032, 0.1436962141708047, 0.15389705533636278, 0.16235079656425588, 0.14515356783913191, 0.15380067549182586, 0.18674661669589232, 0.16076536980293876, 0.16298984579509812, 0.16245421927474601, 0.16977162109748622, 0.14291499323719925, 0.2029771028422429, 0.17345517471407335, 0.22568659939383173, 0.16426884089274318, 0.1558319227564149, 0.15982228551849043, 0.1552769034561543, 0.13292838006484342, 0.17366528606286646, 0.12717055358186047, 0.15566645019903758, 0.17212331391768676, 0.17759630207006993, 0.1798190498239326, 0.1995705322241904, 0.1928974093135868, 0.20029224988308614, 0.18606578729568835, 0.18480865934674362, 0.21526598304436007, 0.06173428221200661, 0.06504089495570387, 0.06021458801189694, 0.05706465362764668, 0.05444927494669716, 0.05326826083095548, 0.04835858866620768, 0.04922500495091975, 0.057221374054589824]}, "mutation_prompt": null}
{"id": "7d2ab92b-387e-4ce8-afd1-0e3ee698fc02", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Enhanced adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.6, 1.6)  # Changed range for adaptive factor\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced dynamic crossover strategy for improved exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.11390505943506604, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.16.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17126834345605568, 0.1689370764913487, 0.1789798010885757, 0.150153601612232, 0.13597077376477318, 0.16650650329861982, 0.16735168544104073, 0.16620456733225963, 0.18319645980277044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055300078896842075, 0.03432487911119986, 0.038514254354823474, 0.041105665264547175, 0.035030025594510183, 0.043189216235567485, 0.04375162993156101, 0.039464825344284304, 0.04022990395954262, 0.033209579148486434, 0.028831322082693234, 0.03173632304831697, 0.029486217201874165, 0.02200493622205235, 0.029412335064351813, 0.030966039838043025, 0.0327331599278039, 0.019273515169795807, 0.9251707300194171, 0.9502563371259299, 0.8940023002108837, 0.19605810596404494, 0.49570724027156754, 0.8822540265495075, 0.9320135667211109, 0.8378033889775015, 0.8945862311478097, 0.06262567249637596, 0.04853908101445126, 0.07618717020252042, 0.0623090158617019, 0.10033422771272604, 0.07334262741282405, 0.07270136673383931, 0.07679061758491768, 0.08874758456690124, 0.11175891948231198, 0.10979587501316579, 0.11144179976363844, 0.09180448797455032, 0.09849530209861423, 0.1030193117124314, 0.14425398624844166, 0.10741666081682666, 0.11610416939257517, 0.003628508893474325, 0.0013187593360562966, 9.999999999998899e-05, 0.006061669119940438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007272140071311162, 9.999999999998899e-05, 0.0017718378286175618, 9.999999999998899e-05, 0.007511956848328172, 0.023833968939008576, 0.003833494656796943, 9.999999999998899e-05, 0.008052304800331367, 0.0008592107919325187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04223925092226, 0.04366777973736358, 0.022815774120094834, 0.031318307028103676, 0.006354130633396182, 0.032938940802439864, 0.00797948060436282, 0.017721919176467926, 0.027274523366126235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009353699139712957, 0.010263991007437245, 9.999999999998899e-05, 9.999999999998899e-05, 0.17422203085579768, 0.19405907884034412, 0.16813700677715482, 0.17564847145295748, 0.18919031527229513, 0.1833513132768142, 0.20840591887391724, 0.18240304006018837, 0.1898906467521565, 0.04757422884881557, 0.04319368480025676, 0.037885922167925634, 0.036221316755122634, 0.032663087406154756, 0.04654552299120662, 0.038251411610130126, 0.02972519638282134, 0.034883947847563435, 0.14846905603476535, 0.14646167050415315, 0.16384994593748636, 0.12535873179347123, 0.15613967787077965, 0.15889858838228987, 0.1427964161621723, 0.13931755063105633, 0.11988542997825258, 0.1613852869836121, 0.15665982219765007, 0.16001761831964845, 0.1678628627532831, 0.15985508564384854, 0.1551794558423646, 0.1552222785608217, 0.17377774300845283, 0.1556832303917125, 0.1023553588090006, 0.10715553805019351, 0.09799918357301429, 0.10350007086246027, 0.09215252825148579, 0.10322794102283406, 0.10607448938741271, 0.09417050169695207, 0.11208021096278076, 0.14929837937841528, 0.14535729518886964, 0.16823099053937418, 0.154931506469432, 0.14715354945535986, 0.19188869882632775, 0.14853607623565146, 0.18122129149740118, 0.17818940285864227, 0.13676588085845964, 0.13769173159995518, 0.13102180583943535, 0.12663233569236287, 0.13430610899481765, 0.1334996537151586, 0.1490253492363368, 0.15822620514864572, 0.138522072241143, 0.12812140409380357, 0.15943611936644653, 0.14116477476812617, 0.15903072169084975, 0.19904568267877654, 0.15497846843171392, 0.18094647767329952, 0.16778463073248773, 0.16684137273673927, 0.14747684336004674, 0.2845697306951315, 0.20037584005479625, 0.15868961549411253, 0.1292447171301998, 0.1494824641770176, 0.16542441489803428, 0.17232312582653664, 0.1690398991949731, 0.1832250813026196, 0.17921117535721043, 0.1778246811338604, 0.180094033318989, 0.18188495525454218, 0.18314856602546503, 0.18295864584883648, 0.18596741859736476, 0.2152425031082429, 0.04900567593636529, 0.04705485108639973, 0.053819238559651206, 0.04852770618441138, 0.041077636880639146, 0.049018350212114425, 0.04316512567861286, 0.03657391082642769, 0.04250606171593696]}, "mutation_prompt": null}
{"id": "6f57d614-28d6-432a-b676-fc0a2a82efb7", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced selective mutation strategy to enhance exploration potential while maintaining convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.18067121136619335, 0.17138146979398172, 0.19088833483634704, 0.16970139577006083, 0.14376591725762844, 0.16853068649941283, 0.15970363568912438, 0.15757684708917152, 0.17415054826441934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053902143506161515, 0.05749411080088285, 0.04173328705430268, 0.03845598053579102, 0.04043597193235493, 0.050602634784522316, 0.040710813185634964, 0.03761237424776376, 0.033857681573965404, 0.041939404973332595, 0.04898288309195542, 0.02256538252920892, 0.027827252188589613, 0.03347997595386554, 0.025227754028803062, 0.02500475878227204, 0.024814818360944124, 0.03646587590896744, 0.7431130082076114, 0.9480025618118065, 0.8845040903493226, 0.19373793615921386, 0.4711872360043329, 0.8781412206897049, 0.9313028435304783, 0.8318869469932537, 0.7103881924272791, 0.05695316773956216, 0.08208372300627065, 0.07230206297476793, 0.06619244057977725, 0.07183950132897154, 0.0865623937218174, 0.06342452149004729, 0.05410628245192639, 0.07446739743341546, 0.10965571313556044, 0.11206938486051754, 0.1427892750859593, 0.1122911355539602, 0.09403543538105719, 0.0907903522925444, 0.11531128122635859, 0.10821718223364873, 0.1110023853085439, 0.03733523221346846, 0.010204757464102654, 0.003273187468961436, 0.008695547589168351, 9.999999999998899e-05, 0.0009878724044940501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006045140948204408, 0.005121667621280412, 9.999999999998899e-05, 0.04118655081989342, 9.999999999998899e-05, 9.999999999998899e-05, 0.009914268627165601, 0.008328788703270251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038395220755867876, 0.02877298315898047, 0.022712875306792335, 0.06977707255367571, 0.09252049850284871, 0.04539993151676558, 0.04460239048766712, 0.06565519222698035, 0.04658026738120713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01460684947037938, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.20223188825951433, 0.18969967954018807, 0.19280729089233917, 0.1990739320273034, 0.18295577132117224, 0.185728553281732, 0.19373676237758242, 0.1848281553475113, 0.21227996181553122, 0.04386621732322493, 0.040339566289088524, 0.04477347462026138, 0.04731275489627573, 0.03735028283868358, 0.053095592576924866, 0.03799040341852955, 0.0344360956860944, 0.04320190758626363, 0.1429849659676753, 0.14466419313234002, 0.15637611586669486, 0.17197304264948232, 0.13198052708009744, 0.1337571653141335, 0.14231356646354376, 0.15775235925535747, 0.1253242507125122, 0.15718415206432068, 0.1650341686609007, 0.1812092350046992, 0.16979214926620712, 0.16324943553487214, 0.1679713040218418, 0.1668178622845009, 0.1752580858302878, 0.16719301274211773, 0.09879317357534656, 0.09729239163647252, 0.10901773125705072, 0.1191637533672878, 0.1316656091220073, 0.11702202630108693, 0.11671830848219833, 0.11246209396457418, 0.11875345756327116, 0.1579750970570991, 0.1574660707729323, 0.17599454842407325, 0.17892632230068262, 0.1472656071583449, 0.16193077513791465, 0.16445703117791077, 0.16022088251782263, 0.16017502547270068, 0.14096576912705028, 0.1391512703543929, 0.15020593677743566, 0.14356235722276922, 0.14312235253622207, 0.1558490300564208, 0.15530979572540615, 0.14701594856945233, 0.1643488603135076, 0.15442689453467373, 0.18674661669589232, 0.1574614043080642, 0.16914142433026025, 0.185332306866539, 0.15049497306968185, 0.13265966321362355, 0.19379951538448736, 0.19263481795963644, 0.15696905699607666, 0.25669194313252286, 0.1522303527162283, 0.13101941212704937, 0.12203803751990072, 0.13799231195610662, 0.1407885207683628, 0.15546758576392605, 0.20102622250961932, 0.18028787111895817, 0.20686758952476825, 0.1902242767570631, 0.1785190110801157, 0.1909914597073301, 0.18090012927343713, 0.19058522225553076, 0.19072742260319087, 0.18845913613611898, 0.05206884084170904, 0.04824137534847328, 0.04906240642082771, 0.056282563334934865, 0.049760126767736446, 0.07371171751638084, 0.05745431283729541, 0.04971979055229625, 0.04987417366701097]}, "mutation_prompt": null}
{"id": "f09a5b92-2dbe-4a57-8f74-36391c26cb89", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        dynamic_F = self.F * np.random.uniform(0.7, 1.7)  # Adjusted mutation strength\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced adaptive mutation and crossover strategies to improve convergence speed while maintaining diversity.", "configspace": "", "generation": 49, "fitness": 0.11328128229614999, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.1897151310092845, 0.14727036072809185, 0.16882355612512578, 0.14730221440302071, 0.17534813511570269, 0.15087696149806729, 0.15979718642619778, 0.17458362029434282, 0.16415302191702807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05375544168566926, 0.045629998816045014, 0.038914020654111536, 0.04929526020117048, 0.03742775541196097, 0.03517473556838535, 0.03484977235372566, 0.049353992714249784, 0.03541420736943368, 0.030076381687967446, 0.025094469859651136, 0.024194546440928777, 0.03873455633506273, 0.03920243939207502, 0.03332617555694273, 0.024615630785600806, 0.028040923927524997, 0.02338800224402804, 0.9232256909648294, 0.8371162658468987, 0.17841012904140408, 0.5506244281484866, 0.9435349063069363, 0.8332289960519736, 0.9811195401030957, 0.2086776349046363, 0.9242076056456295, 0.07541227498709813, 0.08765781158578845, 0.09326417577482204, 0.09574271831594228, 0.0588557087077799, 0.07438197250871326, 0.07789711019908752, 0.06372917072891982, 0.06175520398636747, 0.15903157861363793, 0.11351825891643874, 0.09391593879698756, 0.09219106500552643, 0.1041435622324074, 0.14589559765778615, 0.14017295014091702, 0.12629777766695838, 0.13197142727049305, 9.999999999998899e-05, 9.999999999998899e-05, 0.012924426607529682, 0.008881029891762204, 9.999999999998899e-05, 0.0024832524972149272, 0.0012935584733800853, 0.00044361362500200396, 0.003392631139358837, 0.009171815939781447, 0.0009821613462310808, 9.999999999998899e-05, 0.003800610177605135, 0.0039034593984892396, 0.026962873488505124, 0.004947592585906158, 0.006487175750647611, 0.003475324287878334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08673622231209432, 0.045098729279416716, 0.036147076035986214, 0.008667072123035746, 0.052719288896105554, 0.04422867645395123, 0.03888455954205816, 0.057518078727383126, 0.03988294261327774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009331141788849528, 9.999999999998899e-05, 0.18293059099397369, 0.20185530392771822, 0.19237339282096477, 0.18206694210927865, 0.17994092003630413, 0.18379540751652468, 0.1835723034861252, 0.19833199300649207, 0.18668817171477514, 0.03966979823382133, 0.03092347330045686, 0.0835891933888866, 0.042741241507198935, 0.05226780339724191, 0.040538810336559816, 0.04580295514027943, 0.04202015247261681, 0.04715152555245472, 0.14817014290756492, 0.13898476263920534, 0.12207518388760186, 0.14911762062207856, 0.1585469246978608, 0.12888119155983058, 0.1205141018122231, 0.14537371615345962, 0.13531738347912137, 0.16077018102419316, 0.16068546267135952, 0.1461328307395876, 0.17657145670243313, 0.1573739326789917, 0.1526202791999638, 0.16887014947672718, 0.17416740586074209, 0.1721223295465315, 0.0918233123777552, 0.09651217754409824, 0.1011626550763991, 0.1156162571030318, 0.10328358820844041, 0.09899059613420902, 0.1136698493377849, 0.11164172354736535, 0.10673868909722029, 0.14955436380856024, 0.14232767389013057, 0.15499056872040184, 0.15354586127875702, 0.16834754739450597, 0.16863684325198247, 0.15744049086694667, 0.1445675112324316, 0.17319807958796174, 0.1433532712526301, 0.13478549702597342, 0.14859673771095228, 0.15477268996461058, 0.1507059527858986, 0.14147667210883597, 0.153982680924992, 0.1555234645259137, 0.137068454447138, 0.1817617256725631, 0.15520995151412043, 0.1587949142382895, 0.1736603750909137, 0.26667562688508584, 0.18701815801342248, 0.15517602685693432, 0.13583851231516642, 0.14879182598854734, 0.21588064238398497, 0.1668927663722749, 0.16313305459009897, 0.149894269765404, 0.17262534082269998, 0.12952791194782498, 0.16459175527983594, 0.1778975578342601, 0.1559944144190475, 0.17984313784539518, 0.2001361821171217, 0.17246453422431296, 0.18084872976723865, 0.1906581390485359, 0.19125482783063796, 0.18810665941552684, 0.18274195320482023, 0.1803555151773073, 0.04783422241885926, 0.046707196034927456, 0.044650251042564926, 0.04416009653087094, 0.04450531615657927, 0.04784223345016181, 0.04413691627854621, 0.055345273683967244, 0.0503314063320659]}, "mutation_prompt": null}
{"id": "a1fdcc8c-a71c-4c88-994e-6977f4c15d35", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Modified adaptive trial vector generation\n        diversity = np.var(self.population, axis=0).mean()  # Calculate diversity\n        adaptive_factor = np.random.uniform(0.5, 1.5 + diversity)  # Adjust based on diversity\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced dynamic crossover adaptation based on population diversity to enhance convergence and robustness.", "configspace": "", "generation": 50, "fitness": 0.10255138784408836, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17871515078540656, 0.16176203971683212, 0.1544192573201757, 0.15509553881450955, 0.1194412116502821, 0.14509506328677202, 0.12215341291166637, 0.1318208791871579, 0.13707912392042054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019273351545120887, 0.023981970698131905, 0.020329077106015725, 0.025084382173447772, 0.02797933750621706, 0.018857228139386617, 0.02328979630270056, 0.03151281040881382, 0.013308539400669672, 0.007329097940892093, 0.010538027635631941, 0.007806218789214836, 0.01959972157639278, 0.0546092358629483, 0.042293608071878985, 0.002592686792067811, 0.014757005425276137, 0.0006929020851699219, 0.9692849337540825, 0.9924491351404656, 0.9913228976895541, 0.9854507362540779, 0.9912406876796129, 0.9806873678054074, 0.9959385303304028, 0.9975203443592477, 0.9945157248675437, 0.035079137697115015, 0.043980439147262795, 0.02550427051136539, 0.04085388874368201, 0.05634619108847472, 0.051228447829781754, 0.02163481487482477, 0.035624209970376075, 0.025861792037238263, 0.10128263655712688, 0.0562636654490023, 0.07975007178419713, 0.06018716598486662, 0.04881788856370073, 0.052105916300135724, 0.06272943625738991, 0.06520402695383787, 0.05552244541957718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011030020908158855, 0.006834518822235625, 0.006139166634243742, 0.007847006668958434, 9.999999999998899e-05, 9.999999999998899e-05, 0.008928751458571083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01989292558444744, 0.02999728330859086, 0.003637733914305108, 0.03869821211805269, 0.04328577654210164, 0.009846733952696196, 0.012466438781435718, 0.0061421022062090325, 0.005307433997293276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13966238289289268, 0.14686559053562198, 0.15738637742456452, 0.15620217694280036, 0.14091963321330003, 0.1658897923330851, 0.16665487041602556, 0.13821016148444232, 0.14892466295950857, 0.022753915963188542, 0.024895069391881353, 0.021723628822227337, 0.03726535523350194, 0.015857559077766537, 0.02884067020957659, 0.020674235174697464, 0.015820845650107218, 0.0267656688986897, 0.1271161047633843, 0.12574253983979744, 0.12606026340148235, 0.14906494083444521, 0.1663116683317334, 0.13546081295116275, 0.1278479346124528, 0.13252910479544822, 0.13222294068569007, 0.13026869906034522, 0.13456473518291767, 0.1308625884832929, 0.14799477169858033, 0.13857374044652115, 0.1409117978566934, 0.13409249667676193, 0.17377774300845283, 0.1502475390957978, 0.07665284252109017, 0.07051018825252464, 0.0634386614066027, 0.0813257450664796, 0.07738241057916351, 0.08078128021736697, 0.07762549628342552, 0.09386031173166853, 0.07983881070045684, 0.1289348137879921, 0.11767764318747553, 0.13345086981233123, 0.12836992835457572, 0.11836159016836334, 0.1171594567641443, 0.12245976138762271, 0.11086864484359016, 0.1261963614278906, 0.11203378370620953, 0.065396979761152, 0.05999343529854961, 9.999999999998899e-05, 0.054013616959389776, 0.029539372728405566, 0.060013730275439214, 0.12980618735680471, 0.00526974139818559, 0.11010460831120583, 0.1177720102116031, 0.11435294928166717, 0.11402265962506952, 0.14691840793697286, 0.12039770690985319, 0.11572787723605615, 0.10648897628468879, 0.10873588939396817, 0.07794164943863013, 0.13127276847530123, 0.0749519468409644, 0.1372321765549941, 0.07057029826070671, 0.0977382509195378, 0.11915794881821096, 0.15607115536874117, 0.167314283369545, 0.1942078950593743, 0.17643960409520765, 0.17866898486386706, 0.17485323314566503, 0.19349697442043212, 0.18590854035765758, 0.17870896118924395, 0.18333124599303952, 0.19799192886630912, 0.025151328302991938, 0.03366312353078815, 0.03306562776261068, 0.03505261111249125, 0.02415944158945893, 0.05255072604641864, 0.03243233026810288, 0.03213553171302663, 0.03172785744209816]}, "mutation_prompt": null}
{"id": "989d497a-833e-44c9-9da4-7898c988ec77", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced mutation strategy\n        dynamic_F = self.F * np.random.uniform(0.5, 1.5 + (0.2 * (self.eval_count / self.budget)))\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Enhanced adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5 + (0.1 * (self.eval_count / self.budget)))\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced adaptive mutation and crossover strategies to boost exploitation efficiency without sacrificing exploration capability.", "configspace": "", "generation": 51, "fitness": 0.11476951720451732, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17364793096318443, 0.15717270851574305, 0.17379584037590246, 0.1364323544431718, 0.1848851342113237, 0.16140616134609775, 0.14989703097871077, 0.17265058084665397, 0.1658822681616552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.057010911519953744, 0.038266015122926156, 0.04237564854542708, 0.03565680095135415, 0.038443467204174575, 0.046975959235655895, 0.04135609063107237, 0.06175316920186813, 0.04524924466872671, 0.028537584173704444, 0.03018000153229239, 0.027377197452982394, 0.0674405986805412, 0.04225211272798757, 0.03254942370553948, 0.04198446931473865, 0.031551667402463845, 0.03938005880743989, 0.9230695025764185, 0.6457501097100604, 0.917202218307211, 0.5415295823795561, 0.5239321949145441, 0.6905789067590673, 0.9809858259549328, 0.16119816200065284, 0.9222966246884572, 0.07378200768486165, 0.10637511953847911, 0.08770073129022471, 0.08890550742774572, 0.062196518251003696, 0.08762358271699866, 0.077091045072322, 0.05583263907608593, 0.07862454803214036, 0.12534802968673397, 0.1324196302856655, 0.10587779477652981, 0.11717982837445284, 0.09675327134173384, 0.12990530479413487, 0.09941463667128914, 0.11844838759036591, 0.11081627926887927, 0.003366928707648764, 9.999999999998899e-05, 0.03814112632704603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006682778472759998, 0.006833480759154353, 9.999999999998899e-05, 0.02447535494875286, 0.008521757710785782, 0.02363733347304975, 0.09817677404561942, 9.999999999998899e-05, 0.018841094534370884, 0.04577038703374858, 0.00022740577116853178, 0.0045633038373367185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045918804618364395, 0.0600636651410319, 0.044411762427736035, 0.060247553120867825, 0.0306766466096684, 0.08813977173478382, 0.06894304125994222, 0.027034754067652433, 0.048831675465129454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1942612740648738, 0.17669082596247176, 0.18121531512189915, 0.18091838200606414, 0.18155788944828377, 0.1775006231850048, 0.18652993105828186, 0.20427594394732973, 0.19604588813803026, 0.036064077012310736, 0.04034600559100776, 0.04262223822594191, 0.054199548759727656, 0.037660579402242766, 0.036620498531371726, 0.03966026147747104, 0.040887013641345615, 0.04371123037641378, 0.14556334856509257, 0.18708380658752266, 0.13043525105875597, 0.1318813355350349, 0.12779315264998548, 0.14016718128417816, 0.14545111923133058, 0.13712624989453182, 0.13194509289344059, 0.15255492132465465, 0.16448782334820788, 0.15154363563793372, 0.16899366244652736, 0.15174702108305937, 0.16366871985365505, 0.15888052372088313, 0.1757066910950129, 0.18703218748389827, 0.10077669185077398, 0.10441878424206497, 0.09825511631058814, 0.11329940970143948, 0.10312472114851556, 0.11251901832869082, 0.1028860049166267, 0.10551790793958005, 0.1173505624568073, 0.17213957871314156, 0.16418783301568018, 0.1472312011339989, 0.16664084267167767, 0.15464634889912465, 0.14345660441287478, 0.1605744785526365, 0.16966799839066082, 0.16359971803446371, 0.1518138125092655, 0.14872929880301122, 0.15063313153323, 0.1471763178555704, 0.1493517376867699, 0.14635810804845262, 0.1454062950110696, 0.14944471579426666, 0.13329137521967083, 0.15199456461066274, 0.14184379625895904, 0.15898887335650813, 0.11668442157288539, 0.20701194206292262, 0.16451803466252735, 0.24107515976622074, 0.14143938629493602, 0.15404198713463135, 0.25984719385785326, 0.23241719796385973, 0.16683271624131502, 0.14942576291018506, 0.12644575463938923, 0.16850249084550528, 0.17408704577791545, 0.18291111402542393, 0.1693532846299799, 0.17759595032882602, 0.18845888322127125, 0.18364794163998077, 0.1835881058772605, 0.16660335355828138, 0.17381513141134652, 0.20020103454282312, 0.1944294097816739, 0.1906617903257516, 0.061592404062177364, 0.048418370424629376, 0.0455992118816132, 0.04816680889890135, 0.05338534018874741, 0.045671986172251655, 0.049663997543583305, 0.05300965187922446, 0.050304935042830734]}, "mutation_prompt": null}
{"id": "099c982a-8194-4ce7-ab89-849a9e3f3eaa", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced mutation strategy with probabilistic scaling\n        dynamic_F = self.F * np.random.uniform(0.6, 1.8)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Adaptive crossover adjustment\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy with probabilistic scaling to promote diversity and adaptive crossover adjustment.", "configspace": "", "generation": 52, "fitness": 0.11256041466865965, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.1881234539840444, 0.14847057194406021, 0.16962065868445575, 0.14570657816011845, 0.17683637745484726, 0.1503328107274018, 0.15049093301787142, 0.17823060667593604, 0.16309721254276333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05525216005400235, 0.047960985250158794, 0.03531257016635514, 0.04924210682413577, 0.03368851816604479, 0.04491780276033874, 0.05147631469645475, 0.05796875450903283, 0.04196605426371858, 0.039475080229565696, 0.03830831573346627, 0.038551384813938605, 0.057270718011524835, 0.03948618199569354, 0.03389885096146972, 0.021937001790962807, 0.03872960803458081, 0.027499776613699067, 0.9235921349135793, 0.6802136351087905, 0.1832323168861575, 0.5515707562895402, 0.943538985527497, 0.6909273912412012, 0.9811368434704401, 0.22371732564471147, 0.9242176207951306, 0.07498811951189344, 0.08799936393529229, 0.09215749950911634, 0.0914974685135741, 0.058123176984755665, 0.07224971599823216, 0.08046095535763675, 0.060801015823621074, 0.07055422767126018, 0.15083523138691268, 0.1045237742440015, 0.10678127212301991, 0.10137314881724746, 0.10523388220279317, 0.13172194009985283, 0.10377989060934889, 0.11076531922885935, 0.1544107684938555, 0.006329998524444491, 9.999999999998899e-05, 0.014607355806144362, 0.006825293753408568, 9.999999999998899e-05, 9.999999999998899e-05, 0.005943438396790568, 0.0004068735234752374, 0.0006265981024822231, 0.013108112329116572, 0.0007292816055767259, 0.0018196053044224891, 0.01070016589261813, 0.00620095271668919, 0.022827566822736345, 0.00705086577896874, 0.017138742622778924, 0.0069961604200883265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04001911487852272, 0.03952424634687757, 0.03958944786753671, 0.035271976854975406, 0.05607824458824595, 0.041744812046214275, 0.0491192091303112, 0.058954690514775976, 0.023726450530090593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006720135091843105, 9.999999999998899e-05, 0.18427473923014903, 0.19285232179886702, 0.19243352582433737, 0.17932647251539058, 0.180237509867325, 0.18447282670627008, 0.18791137557856397, 0.19860890532872622, 0.1866626184245037, 0.033523352598136213, 0.0449818886965313, 0.055105657096152894, 0.03791815462570869, 0.04149457671218204, 0.03874920682404448, 0.048637410499391964, 0.04226202191398665, 0.046548724833745836, 0.14162653633690547, 0.1702052159053481, 0.1386021463336119, 0.145373365370292, 0.14816013783016024, 0.13229205019673973, 0.12861150668349164, 0.14262755015405104, 0.11958055814231572, 0.1550251325540647, 0.1582906347503431, 0.15431582103617425, 0.16055031038105738, 0.16021578406953108, 0.15026662767592103, 0.16527182911735194, 0.1757275311821841, 0.16660275021001358, 0.11865650494243363, 0.10810588095498819, 0.11546017148129373, 0.11611481953876412, 0.10743953235408266, 0.10111377642353436, 0.11567881231695953, 0.11145275012123423, 0.10903294133393904, 0.16982649909165215, 0.1558046807021246, 0.14695544577328368, 0.1717425600654875, 0.15474783489888955, 0.15156270550436168, 0.1441897583635522, 0.15922466437018556, 0.14663430728071125, 0.14748217487445525, 0.13495854540508823, 0.1534972842019119, 0.15807319650252227, 0.16158135650260974, 0.14200049126723657, 0.14487119794358028, 0.14826505689744685, 0.1304965235820833, 0.18374809592762942, 0.1508824574571359, 0.16676967318624591, 0.15919122308586997, 0.23487120207255086, 0.16470707808519092, 0.15494775351245038, 0.13651112199573523, 0.148024567139457, 0.16585098005970889, 0.1874712262634699, 0.2220328574423175, 0.15053870827127425, 0.13030997649240217, 0.1615774919370082, 0.15520349049399373, 0.21365621481118846, 0.1846120085623304, 0.1826013374789941, 0.18126520883151243, 0.1824402780277763, 0.1701126995828357, 0.18419141230898817, 0.17780183369445846, 0.17468983313433806, 0.19523595497346213, 0.1933651661885467, 0.05158911548851042, 0.05066448965017556, 0.0565957760314042, 0.04084221442525582, 0.05370318291492748, 0.0532904448447018, 0.058323614470691454, 0.05957748677155272, 0.06142263521431701]}, "mutation_prompt": null}
{"id": "63c7e50d-1f12-4874-a5cd-6211071b562a", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced selective mutation strategy to enhance exploration potential while maintaining convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.18067121136619335, 0.17138146979398172, 0.19088833483634704, 0.16970139577006083, 0.14376591725762844, 0.16853068649941283, 0.15970363568912438, 0.15757684708917152, 0.17415054826441934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053902143506161515, 0.05749411080088285, 0.04173328705430268, 0.03845598053579102, 0.04043597193235493, 0.050602634784522316, 0.040710813185634964, 0.03761237424776376, 0.033857681573965404, 0.041939404973332595, 0.04898288309195542, 0.02256538252920892, 0.027827252188589613, 0.03347997595386554, 0.025227754028803062, 0.02500475878227204, 0.024814818360944124, 0.03646587590896744, 0.7431130082076114, 0.9480025618118065, 0.8845040903493226, 0.19373793615921386, 0.4711872360043329, 0.8781412206897049, 0.9313028435304783, 0.8318869469932537, 0.7103881924272791, 0.05695316773956216, 0.08208372300627065, 0.07230206297476793, 0.06619244057977725, 0.07183950132897154, 0.0865623937218174, 0.06342452149004729, 0.05410628245192639, 0.07446739743341546, 0.10965571313556044, 0.11206938486051754, 0.1427892750859593, 0.1122911355539602, 0.09403543538105719, 0.0907903522925444, 0.11531128122635859, 0.10821718223364873, 0.1110023853085439, 0.03733523221346846, 0.010204757464102654, 0.003273187468961436, 0.008695547589168351, 9.999999999998899e-05, 0.0009878724044940501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006045140948204408, 0.005121667621280412, 9.999999999998899e-05, 0.04118655081989342, 9.999999999998899e-05, 9.999999999998899e-05, 0.009914268627165601, 0.008328788703270251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038395220755867876, 0.02877298315898047, 0.022712875306792335, 0.06977707255367571, 0.09252049850284871, 0.04539993151676558, 0.04460239048766712, 0.06565519222698035, 0.04658026738120713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01460684947037938, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.20223188825951433, 0.18969967954018807, 0.19280729089233917, 0.1990739320273034, 0.18295577132117224, 0.185728553281732, 0.19373676237758242, 0.1848281553475113, 0.21227996181553122, 0.04386621732322493, 0.040339566289088524, 0.04477347462026138, 0.04731275489627573, 0.03735028283868358, 0.053095592576924866, 0.03799040341852955, 0.0344360956860944, 0.04320190758626363, 0.1429849659676753, 0.14466419313234002, 0.15637611586669486, 0.17197304264948232, 0.13198052708009744, 0.1337571653141335, 0.14231356646354376, 0.15775235925535747, 0.1253242507125122, 0.15718415206432068, 0.1650341686609007, 0.1812092350046992, 0.16979214926620712, 0.16324943553487214, 0.1679713040218418, 0.1668178622845009, 0.1752580858302878, 0.16719301274211773, 0.09879317357534656, 0.09729239163647252, 0.10901773125705072, 0.1191637533672878, 0.1316656091220073, 0.11702202630108693, 0.11671830848219833, 0.11246209396457418, 0.11875345756327116, 0.1579750970570991, 0.1574660707729323, 0.17599454842407325, 0.17892632230068262, 0.1472656071583449, 0.16193077513791465, 0.16445703117791077, 0.16022088251782263, 0.16017502547270068, 0.14096576912705028, 0.1391512703543929, 0.15020593677743566, 0.14356235722276922, 0.14312235253622207, 0.1558490300564208, 0.15530979572540615, 0.14701594856945233, 0.1643488603135076, 0.15442689453467373, 0.18674661669589232, 0.1574614043080642, 0.16914142433026025, 0.185332306866539, 0.15049497306968185, 0.13265966321362355, 0.19379951538448736, 0.19263481795963644, 0.15696905699607666, 0.25669194313252286, 0.1522303527162283, 0.13101941212704937, 0.12203803751990072, 0.13799231195610662, 0.1407885207683628, 0.15546758576392605, 0.20102622250961932, 0.18028787111895817, 0.20686758952476825, 0.1902242767570631, 0.1785190110801157, 0.1909914597073301, 0.18090012927343713, 0.19058522225553076, 0.19072742260319087, 0.18845913613611898, 0.05206884084170904, 0.04824137534847328, 0.04906240642082771, 0.056282563334934865, 0.049760126767736446, 0.07371171751638084, 0.05745431283729541, 0.04971979055229625, 0.04987417366701097]}, "mutation_prompt": null}
{"id": "619f6733-65c0-4967-9387-16b4b2afcd30", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced selective mutation strategy to enhance exploration potential while maintaining convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.18067121136619335, 0.17138146979398172, 0.19088833483634704, 0.16970139577006083, 0.14376591725762844, 0.16853068649941283, 0.15970363568912438, 0.15757684708917152, 0.17415054826441934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053902143506161515, 0.05749411080088285, 0.04173328705430268, 0.03845598053579102, 0.04043597193235493, 0.050602634784522316, 0.040710813185634964, 0.03761237424776376, 0.033857681573965404, 0.041939404973332595, 0.04898288309195542, 0.02256538252920892, 0.027827252188589613, 0.03347997595386554, 0.025227754028803062, 0.02500475878227204, 0.024814818360944124, 0.03646587590896744, 0.7431130082076114, 0.9480025618118065, 0.8845040903493226, 0.19373793615921386, 0.4711872360043329, 0.8781412206897049, 0.9313028435304783, 0.8318869469932537, 0.7103881924272791, 0.05695316773956216, 0.08208372300627065, 0.07230206297476793, 0.06619244057977725, 0.07183950132897154, 0.0865623937218174, 0.06342452149004729, 0.05410628245192639, 0.07446739743341546, 0.10965571313556044, 0.11206938486051754, 0.1427892750859593, 0.1122911355539602, 0.09403543538105719, 0.0907903522925444, 0.11531128122635859, 0.10821718223364873, 0.1110023853085439, 0.03733523221346846, 0.010204757464102654, 0.003273187468961436, 0.008695547589168351, 9.999999999998899e-05, 0.0009878724044940501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006045140948204408, 0.005121667621280412, 9.999999999998899e-05, 0.04118655081989342, 9.999999999998899e-05, 9.999999999998899e-05, 0.009914268627165601, 0.008328788703270251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038395220755867876, 0.02877298315898047, 0.022712875306792335, 0.06977707255367571, 0.09252049850284871, 0.04539993151676558, 0.04460239048766712, 0.06565519222698035, 0.04658026738120713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01460684947037938, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.20223188825951433, 0.18969967954018807, 0.19280729089233917, 0.1990739320273034, 0.18295577132117224, 0.185728553281732, 0.19373676237758242, 0.1848281553475113, 0.21227996181553122, 0.04386621732322493, 0.040339566289088524, 0.04477347462026138, 0.04731275489627573, 0.03735028283868358, 0.053095592576924866, 0.03799040341852955, 0.0344360956860944, 0.04320190758626363, 0.1429849659676753, 0.14466419313234002, 0.15637611586669486, 0.17197304264948232, 0.13198052708009744, 0.1337571653141335, 0.14231356646354376, 0.15775235925535747, 0.1253242507125122, 0.15718415206432068, 0.1650341686609007, 0.1812092350046992, 0.16979214926620712, 0.16324943553487214, 0.1679713040218418, 0.1668178622845009, 0.1752580858302878, 0.16719301274211773, 0.09879317357534656, 0.09729239163647252, 0.10901773125705072, 0.1191637533672878, 0.1316656091220073, 0.11702202630108693, 0.11671830848219833, 0.11246209396457418, 0.11875345756327116, 0.1579750970570991, 0.1574660707729323, 0.17599454842407325, 0.17892632230068262, 0.1472656071583449, 0.16193077513791465, 0.16445703117791077, 0.16022088251782263, 0.16017502547270068, 0.14096576912705028, 0.1391512703543929, 0.15020593677743566, 0.14356235722276922, 0.14312235253622207, 0.1558490300564208, 0.15530979572540615, 0.14701594856945233, 0.1643488603135076, 0.15442689453467373, 0.18674661669589232, 0.1574614043080642, 0.16914142433026025, 0.185332306866539, 0.15049497306968185, 0.13265966321362355, 0.19379951538448736, 0.19263481795963644, 0.15696905699607666, 0.25669194313252286, 0.1522303527162283, 0.13101941212704937, 0.12203803751990072, 0.13799231195610662, 0.1407885207683628, 0.15546758576392605, 0.20102622250961932, 0.18028787111895817, 0.20686758952476825, 0.1902242767570631, 0.1785190110801157, 0.1909914597073301, 0.18090012927343713, 0.19058522225553076, 0.19072742260319087, 0.18845913613611898, 0.05206884084170904, 0.04824137534847328, 0.04906240642082771, 0.056282563334934865, 0.049760126767736446, 0.07371171751638084, 0.05745431283729541, 0.04971979055229625, 0.04987417366701097]}, "mutation_prompt": null}
{"id": "cacc71bb-954f-46f5-aa6f-0c571888e34a", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        # Dynamic crossover probability based on evaluation progress\n        dynamic_CR = self.CR * (1 - self.eval_count / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced dynamic crossover probability based on evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.10280968495177419, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.1557196955065494, 0.18024525939155278, 0.17839185067925467, 0.17019322223221445, 0.1732285670195981, 0.17377755164055653, 0.15989163155510355, 0.16066183031457404, 0.18596425170738307, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0602885166979269, 0.04602755015489024, 0.0603607018142438, 0.04061545618635576, 0.05105985705771077, 0.0467043157524335, 0.03644407466175925, 0.048641086897133534, 0.050908120694577175, 0.021795950509665096, 0.04023222937698501, 0.05468499536955096, 0.03470515792950535, 0.03396412865337661, 0.03483784617686947, 0.029116073693425504, 0.02083096677160301, 0.03065651658989632, 0.11172488454034135, 0.9480025618118065, 0.16682201853097123, 0.171791170285175, 0.1329600860496417, 0.1377852094296581, 0.9313028435304783, 0.6614216905906196, 0.13002999150263406, 0.06658125081098698, 0.08762688786379169, 0.07862721096208536, 0.1152591276103958, 0.08043747298805048, 0.07656876603709784, 0.06615378766531521, 0.0831622685504233, 0.07196163336607464, 0.12936285532292824, 0.12432369683886824, 0.1427892750859593, 0.10998184982538495, 0.10461650276308865, 0.09787377128808716, 0.12409055941119418, 0.11425356129798525, 0.1294313507690491, 0.0106435045786335, 0.012961617183653629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013395106488107156, 0.03101174817390273, 9.999999999998899e-05, 9.999999999998899e-05, 0.03119696454836063, 0.016897630644710837, 9.999999999998899e-05, 0.007368043329666896, 0.007636341410790948, 0.06757459499787255, 9.999999999998899e-05, 0.029682278065544465, 0.015539144042086228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05315418613437306, 0.04062831888440255, 0.05554657135646468, 0.06768189372177713, 0.052688447696107144, 0.06620158129734266, 0.04338043891764032, 0.051129305244999146, 0.11592143273166855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.18569392189952638, 0.1842230429178594, 0.18657625933422828, 0.19337120698756638, 0.2030746491728782, 0.18724057785140702, 0.204778362310149, 0.19002274964086252, 0.2179927173317764, 0.04536600453658479, 0.04966045236910088, 0.03517720709388483, 0.04737118329287382, 0.04116163300055886, 0.04958185108468094, 0.049089603237858825, 0.037059206243021614, 0.05035250689762383, 0.14293186906390476, 0.12584134457586282, 0.15545105546126126, 0.13456538744199642, 0.12984900252029308, 0.1412476260464537, 0.15221890674802985, 0.15846938537383137, 0.16863273098915965, 0.15110030282025222, 0.1591249860157341, 0.1812092350046992, 0.16806136237795166, 0.17436628591120484, 0.16180748201229833, 0.16477930411877406, 0.17377774300845283, 0.16791942466416754, 0.10417611029345375, 0.09606616540083013, 0.11302126630239251, 0.11389487207830151, 0.12725719047284478, 0.10603774921267572, 0.10251800138226896, 0.1104931211519683, 0.1110847489139416, 0.15425945104745953, 0.1560124616884454, 0.175557822287429, 0.15462331631295256, 0.1497244925990251, 0.15105477930301114, 0.15129417539912704, 0.14493574990074776, 0.14994699555549573, 0.1367645440404931, 0.14021582927511722, 0.14350587085311306, 0.14018891920529153, 0.14480065394334563, 0.15376257653590042, 0.15778654960921956, 0.14436248086280612, 0.14454896552028662, 0.19545947628982163, 0.20184368758383686, 0.14351245458206852, 0.1995083817446549, 0.185332306866539, 0.16324977357003323, 0.1868007158967776, 0.14806222864283247, 0.1243261831449638, 0.19757224775588267, 0.25371664921464754, 0.1583479232756354, 0.1485047981529075, 0.1404715697993303, 0.17452895718497907, 0.18819611387492907, 0.15416595590554893, 0.15759906567830662, 0.18981887667571096, 0.18154056585114964, 0.1804542454227469, 0.1774644446104674, 0.17297818761197525, 0.20854605385907998, 0.18929870480216726, 0.17930507816060104, 0.18985488902027314, 0.06340853751341069, 0.04918810333617896, 0.04629963844906526, 0.05028587770450399, 0.05982195898824849, 0.051323877059537004, 0.07450395889911965, 0.043207557542828345, 0.05426620942541793]}, "mutation_prompt": null}
{"id": "fede1063-c637-46c8-b887-44a0e767a248", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        # Adjust crossover probability based on population diversity\n        diversity = np.std(self.population)\n        self.CR = 0.9 - 0.4 * (diversity / (self.ub - self.lb))\n        \n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced exploration by dynamically adjusting crossover probability based on current diversity in the population.", "configspace": "", "generation": 56, "fitness": 0.1024591698004856, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.15797817518759216, 0.16648991432835958, 0.17487783617563923, 0.17371556243798425, 0.1679985989614634, 0.17426384305093523, 0.15042700043795743, 0.15750301522890764, 0.18189943490572613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07302354489463359, 0.04672061094811397, 0.06319598301274743, 0.0524327534917135, 0.051061086258993416, 0.05003707793452927, 0.050272469909566464, 0.05655151893190047, 0.038823233365353205, 0.044506690594846465, 0.040214443370324315, 0.04914568077081294, 0.029089068018549602, 0.029655899773982308, 0.03392871343665882, 0.027756264148833698, 0.027929384800230994, 0.03250395782714821, 0.12725762942962227, 0.8760575414022136, 0.6000017510130915, 0.1774076063551171, 0.1392066180189544, 0.6395290003328055, 0.15620915545848224, 0.396401728970995, 0.4996919088776304, 0.05741980786595591, 0.08771459339540011, 0.0800285982615917, 0.0678729591268662, 0.09379523864379813, 0.08321662479908287, 0.053208703282285774, 0.07685416606898976, 0.06348193599531171, 0.1238272488814367, 0.12377207690170722, 0.14269302763658887, 0.12417352202110454, 0.10292469175555707, 0.10395774197110519, 0.11152287469613276, 0.10763720226805451, 0.1286439161455386, 0.03597564879663573, 9.999999999998899e-05, 9.999999999998899e-05, 0.00907943061340688, 0.007292599892642637, 0.0131733559470395, 0.03101174817390273, 9.999999999998899e-05, 0.004797386772405154, 0.009557774576902767, 0.0001104985966654537, 0.005121667621280412, 9.999999999998899e-05, 0.0061668702175448065, 9.999999999998899e-05, 9.999999999998899e-05, 0.010030777023331439, 0.0022707962049612895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0509153966365784, 0.06923078749614964, 0.01566294846893157, 0.06977707255367571, 0.04189226362772536, 0.02056031424835769, 0.037769826826280606, 0.059195862613964145, 0.05443350556321225, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018873292665206876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20893097482266942, 0.21963185791868944, 0.17794439612034896, 0.1921747173371181, 0.19772099271628663, 0.18856722742598764, 0.2264753457605807, 0.18838564178478578, 0.20132942017994637, 0.04871996153898184, 0.06541907407124747, 0.031340609665394314, 0.03799457621703606, 0.036115292096717155, 0.07153977338257622, 0.05012932085847077, 0.03998490408594557, 0.03808797055897217, 0.14288883372611638, 0.12255498183841862, 0.1624428541301457, 0.15597466588688824, 0.14294500828629753, 0.14425114044445853, 0.14199547931960022, 0.16224730983676272, 0.1415893353190153, 0.15170958282495772, 0.18976787292447783, 0.1523761701353895, 0.15994058476439588, 0.16844847292052167, 0.17020285611095642, 0.16844985794200218, 0.17377774300845283, 0.16854693102209461, 0.09955084717503615, 0.11533146021863727, 0.10795100448782236, 0.11206605489383148, 0.10962048599058838, 0.11177994464537078, 0.1107566082763769, 0.10219609839196508, 0.11769453516013761, 0.1507317833194809, 0.15940273155774154, 0.1716177571849059, 0.15332897668066958, 0.16054558966176624, 0.16145510500191051, 0.14327621799735057, 0.15204464568454146, 0.17737279013330132, 0.13867254038542065, 0.1373456992387786, 0.14723447693961667, 0.1377449428823726, 0.13594477838345775, 0.15289028699056761, 0.15519079393574453, 0.14458205368179877, 0.1517771925402982, 0.16253675794778277, 0.17074982216697987, 0.1542785385430281, 0.17326591578710726, 0.1551987473465002, 0.1460486175714535, 0.18576073481411326, 0.18707614965563957, 0.14345186352696815, 0.16628221560836332, 0.25627305771454845, 0.15837180209476442, 0.15541882563110176, 0.1154943901525941, 0.2312859062351349, 0.1559968848532195, 0.13522792342106482, 0.15390788497374086, 0.18685856789705624, 0.18277474894807944, 0.18654240162112468, 0.17941643674197183, 0.18198181181537743, 0.18507109838620395, 0.18615463884970396, 0.18981857866926644, 0.18791984386752147, 0.06419405394032729, 0.049780410648143536, 0.05059067956255181, 0.06409553494494502, 0.048648771072282715, 0.050886428660565586, 0.0611432682558507, 0.04651626939331688, 0.05693046364726195]}, "mutation_prompt": null}
{"id": "c2019aba-dbf3-4b76-a78d-40319129dde4", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                # Fitness-based selection probability\n                p = np.exp(-self.fitness / np.max(self.fitness))\n                p /= p.sum()\n                selected_idx = np.random.choice(self.population_size, p=p)\n                mutant = self._mutate(selected_idx)\n                trial_vector = self._crossover(self.population[selected_idx], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(selected_idx, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Implemented fitness-based selection probability to enhance exploitation and intensify search in promising regions.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {}, "mutation_prompt": null}
{"id": "48cb07b2-ffaa-449e-a53c-1f8b991ffccc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Enhanced adaptive trial vector generation\n        fitness_variance = np.var(self.fitness)\n        adaptive_factor = np.random.uniform(0.5, 1.5 + 0.01 * fitness_variance)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced crossover with a dynamic adaptivity mechanism based on fitness variance to improve global exploration.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('Range exceeds valid bounds').", "error": "OverflowError('Range exceeds valid bounds')", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {}, "mutation_prompt": null}
{"id": "20414303-5466-4446-9553-3a27b1a887ec", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Adaptive mutation factor\n        dynamic_F = self.F * np.random.uniform(0.7, 1.5)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 4:  # Adjusted scaling thresholds\n            self.population_size = int(self.population_size * 1.7)\n        elif 3 * self.budget // 4 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced adaptive mutation factor and enhanced population scaling to augment exploration and exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.10743146180565885, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.13.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17234040023207509, 0.15465131519171516, 0.1571418561825476, 0.177243285555179, 0.182112569186483, 0.1787221795959658, 0.16134454440153734, 0.14903886846126502, 0.14618326915622515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03571121313521708, 0.05410808560149616, 0.032271912503105904, 0.04553170370191162, 0.043265950492358596, 0.039120931404290404, 0.03605721608859025, 0.04349350786546513, 0.03895949721090841, 0.020936633120002823, 0.01846518920534823, 0.0285850054436374, 0.03289668736631923, 0.035046490656205576, 0.02489856538210311, 0.023642364373721803, 0.024391708006475166, 0.027783058426199547, 0.6583585742550873, 0.36584265889909495, 0.49351808170640843, 0.16294834379336298, 0.776207471268882, 0.5968486338736043, 0.5400485848315011, 0.7533001810454885, 0.8074938475839006, 0.06504211394224146, 0.06700023523944854, 0.07092955029166204, 0.06914044404738218, 0.06568801044394645, 0.07858545529478311, 0.09356912800153461, 0.06965535278895318, 0.11209376340844135, 0.10849781957299942, 0.09697420960074599, 0.13937961729504056, 0.09459314904045057, 0.11763714385092738, 0.11795840097470078, 0.11729750580202358, 0.16063295097925434, 0.12437938684038818, 0.0060264717305892335, 0.010690535768774989, 0.011857013852743736, 0.025969523722833232, 9.999999999998899e-05, 9.999999999998899e-05, 0.012418433968989895, 0.007382332467746, 0.020488202420314572, 0.011314712810305494, 9.999999999998899e-05, 9.999999999998899e-05, 0.024497862114470248, 9.999999999998899e-05, 0.031086317338293146, 0.03200424302160776, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04354730844150578, 0.0505061671533622, 0.015650755755965973, 0.033242733793372614, 0.04111151671482871, 0.040306503595214926, 0.028979852206070245, 0.046879747916478864, 0.03188965606869221, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025614508824964854, 0.18412984043987513, 0.19868819236856294, 0.17514035877718792, 0.189008399918021, 0.1640652669822109, 0.18275014212055807, 0.20129457196811174, 0.1749048361406469, 0.1953414287513361, 0.042022770483802874, 0.04830086611733475, 0.03343859910684044, 0.06007214698729635, 0.03975233170453518, 0.047372685756710387, 0.0418726223398771, 0.03363905291643243, 0.04969524324610253, 0.15307930357306976, 0.14510859241553242, 0.1524892336042103, 0.14949834466467726, 0.1672759962056316, 0.14277820540481423, 0.12966907090159618, 0.13764699625078958, 0.16809482478188387, 0.15000447021086183, 0.1524712210822936, 0.15604131767610563, 0.15241456799355146, 0.16955942783097921, 0.16694838233746956, 0.16222701837412934, 0.17377774300845283, 0.15498685511704136, 0.10026551661587602, 0.09384243978606244, 0.0969340999364886, 0.10060828105551245, 0.10863288023384088, 0.11223109421555422, 0.12003562157563286, 0.09667707325014596, 0.10602748276533835, 0.16320027814231275, 0.15431159836802233, 0.17154772114397132, 0.17590562817942879, 0.17248263765989214, 0.15446695540883226, 0.1513424613536214, 0.15301669753801395, 0.15614421174747295, 0.14800607621990092, 0.1182465044830946, 0.1438670503834395, 0.1445218153151938, 0.14954247733491233, 0.14685934483111474, 0.14919228813035357, 0.13656796591978293, 0.1442547114843482, 0.16016897238759809, 0.1597704402257013, 0.17204047372617293, 0.17371126201457987, 0.12667539181919074, 0.16218188244212683, 0.1720625487883075, 0.16669960512723225, 0.15879519137238662, 0.1642703087898303, 0.177369199935283, 0.2000593102374414, 0.11951756138204606, 0.17870271693066841, 0.1488270752461187, 0.22230926202255452, 0.1696347205133527, 0.1583045707909374, 0.19379103760622285, 0.21229969053115938, 0.17199732915992716, 0.19040879492766527, 0.17838249529675654, 0.1911461998926618, 0.20362179516684908, 0.18964904778658498, 0.1808716087787261, 0.04704682620407785, 0.050353814115192796, 0.055948352557808945, 0.05690402836218378, 0.042655924748923324, 0.050131204287114595, 0.04877371226954785, 0.04373474192969895, 0.05191084764972764]}, "mutation_prompt": null}
{"id": "a052fd53-6d7f-4e31-8b3f-9e47fa93c8a9", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy with feedback mechanism\n        diversity = np.std(self.population, axis=0).mean()\n        dynamic_F = self.F * np.random.uniform(0.5, 1.0 + diversity / 10)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced convergence rate by introducing a feedback mechanism to dynamically adjust mutation factor based on population diversity.", "configspace": "", "generation": 60, "fitness": 0.11183918344092848, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.17077338958147303, 0.16428088423271126, 0.17824296481789137, 0.14138225946015248, 0.18972268535375392, 0.1602880362921194, 0.15204206428830258, 0.15224971673993426, 0.17329658675380155, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06325945613848105, 0.035540652589884814, 0.0429016628478075, 0.04933065472882825, 0.028303613163729313, 0.034727847294984016, 0.03628257198957707, 0.046533285704125404, 0.04506978285775387, 0.028597625740808374, 0.028051231901971008, 0.036843086738826414, 0.03155767702100343, 0.03627246978897092, 0.039584542453058535, 0.038684960972263926, 0.02728885249566393, 0.033264487185950764, 0.9230793389300489, 0.4871524424408995, 0.9162693321283725, 0.14373043123288354, 0.5172672055940442, 0.8761818024188583, 0.9809250136827509, 0.15515912269398335, 0.9214315139592718, 0.06452594359511354, 0.08902120127416802, 0.08640253752210869, 0.0766128236738659, 0.06200529717723491, 0.05946958388563328, 0.07947991578096447, 0.060446099659583474, 0.04707924668798247, 0.1419171574166176, 0.12904441631756125, 0.13323337517684108, 0.14298774728093466, 0.09107167834674168, 0.12880800089489752, 0.11281699171006365, 0.1159259703381853, 0.1426097926449562, 9.999999999998899e-05, 9.999999999998899e-05, 0.041688582084556614, 9.999999999998899e-05, 0.024593969628179946, 9.999999999998899e-05, 9.999999999998899e-05, 0.033222413431504894, 9.999999999998899e-05, 0.008985163044906264, 0.03563442233886582, 0.01931518975616875, 0.021866058538858146, 9.999999999998899e-05, 0.010981751377089899, 0.009430193766663986, 0.00035258830768869487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06725468961797798, 0.03721210519485718, 0.034693684278929715, 0.07652902119918947, 0.06288025328729763, 0.06490093240881711, 0.1021206555761126, 0.04035874797971806, 0.06904849212941522, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002205466264772249, 9.999999999998899e-05, 9.999999999998899e-05, 0.20930993073998083, 0.17796420805085167, 0.1820303715046614, 0.18888220274712075, 0.1806525174865946, 0.17102668039429425, 0.1899161461857941, 0.19235758354423438, 0.20082437077469317, 0.03708284381349658, 0.03959978173063805, 0.04277667862010481, 0.047833059253742594, 0.03265531542189726, 0.05294156457142529, 0.035399548036267325, 0.04032532110250653, 0.046780480151118686, 0.121640908663739, 0.138584936821193, 0.1388225792672465, 0.12029495041865779, 0.13671057338152515, 0.1410356219465424, 0.1299199065967407, 0.14747299059530672, 0.13179822360673932, 0.14495585626326157, 0.16076888628886699, 0.1579742211240751, 0.16928109301273853, 0.16658473900577242, 0.16455674046165236, 0.15835924577082328, 0.1762220156901827, 0.16347770956224972, 0.09392039823436493, 0.10893770624967769, 0.10757428372008271, 0.11285057128672693, 0.1130711191917233, 0.10208412994317606, 0.10166593092772913, 0.11551068497704486, 0.11951220438691068, 0.1913006183941831, 0.14803887806075233, 0.1532619356613213, 0.1696255630041722, 0.15668880496611293, 0.1526682815578917, 0.15073460784494397, 0.14388553953410232, 0.15841433538433447, 0.14920202468764032, 0.1530566671773762, 0.15244863887439575, 0.14760733343669796, 0.15528520285875003, 0.14503314950811186, 0.14708277419605087, 0.12799256054117103, 0.13893027517335776, 0.15285486642593826, 0.1501840567319781, 0.154887326281829, 0.14311067789169463, 0.20575206959173897, 0.1511494313168691, 0.17824204273199762, 0.1316562636067954, 0.1599707942886065, 0.14272734870613224, 0.16704726148910798, 0.2186417036922368, 0.15635611362612511, 0.13533388711533934, 0.21396366698087899, 0.16256221445500274, 0.19272609526049178, 0.1532117426794133, 0.17485106153617858, 0.18294225361728966, 0.18200150025113104, 0.17497097247626447, 0.1881338880459258, 0.18733962656933367, 0.1824386097699131, 0.18285352908114183, 0.2168859757327577, 0.06372849470860242, 0.04631020194128466, 0.04695102546131624, 0.05425328972990029, 0.04700143788679911, 0.04471422524138924, 0.04435846103432073, 0.048992453367165734, 0.04835361972216201]}, "mutation_prompt": null}
{"id": "cd27f193-dbee-415a-b862-2a085d40acaa", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Selective mutation strategy\n        if np.random.rand() < 0.5:\n            dynamic_F = self.F * np.random.uniform(0.85, 1.7)\n        else:\n            dynamic_F = self.F * np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced selective mutation strategy to enhance exploration potential while maintaining convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.18067121136619335, 0.17138146979398172, 0.19088833483634704, 0.16970139577006083, 0.14376591725762844, 0.16853068649941283, 0.15970363568912438, 0.15757684708917152, 0.17415054826441934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053902143506161515, 0.05749411080088285, 0.04173328705430268, 0.03845598053579102, 0.04043597193235493, 0.050602634784522316, 0.040710813185634964, 0.03761237424776376, 0.033857681573965404, 0.041939404973332595, 0.04898288309195542, 0.02256538252920892, 0.027827252188589613, 0.03347997595386554, 0.025227754028803062, 0.02500475878227204, 0.024814818360944124, 0.03646587590896744, 0.7431130082076114, 0.9480025618118065, 0.8845040903493226, 0.19373793615921386, 0.4711872360043329, 0.8781412206897049, 0.9313028435304783, 0.8318869469932537, 0.7103881924272791, 0.05695316773956216, 0.08208372300627065, 0.07230206297476793, 0.06619244057977725, 0.07183950132897154, 0.0865623937218174, 0.06342452149004729, 0.05410628245192639, 0.07446739743341546, 0.10965571313556044, 0.11206938486051754, 0.1427892750859593, 0.1122911355539602, 0.09403543538105719, 0.0907903522925444, 0.11531128122635859, 0.10821718223364873, 0.1110023853085439, 0.03733523221346846, 0.010204757464102654, 0.003273187468961436, 0.008695547589168351, 9.999999999998899e-05, 0.0009878724044940501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006045140948204408, 0.005121667621280412, 9.999999999998899e-05, 0.04118655081989342, 9.999999999998899e-05, 9.999999999998899e-05, 0.009914268627165601, 0.008328788703270251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038395220755867876, 0.02877298315898047, 0.022712875306792335, 0.06977707255367571, 0.09252049850284871, 0.04539993151676558, 0.04460239048766712, 0.06565519222698035, 0.04658026738120713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01460684947037938, 0.007756427771439811, 9.999999999998899e-05, 9.999999999998899e-05, 0.20223188825951433, 0.18969967954018807, 0.19280729089233917, 0.1990739320273034, 0.18295577132117224, 0.185728553281732, 0.19373676237758242, 0.1848281553475113, 0.21227996181553122, 0.04386621732322493, 0.040339566289088524, 0.04477347462026138, 0.04731275489627573, 0.03735028283868358, 0.053095592576924866, 0.03799040341852955, 0.0344360956860944, 0.04320190758626363, 0.1429849659676753, 0.14466419313234002, 0.15637611586669486, 0.17197304264948232, 0.13198052708009744, 0.1337571653141335, 0.14231356646354376, 0.15775235925535747, 0.1253242507125122, 0.15718415206432068, 0.1650341686609007, 0.1812092350046992, 0.16979214926620712, 0.16324943553487214, 0.1679713040218418, 0.1668178622845009, 0.1752580858302878, 0.16719301274211773, 0.09879317357534656, 0.09729239163647252, 0.10901773125705072, 0.1191637533672878, 0.1316656091220073, 0.11702202630108693, 0.11671830848219833, 0.11246209396457418, 0.11875345756327116, 0.1579750970570991, 0.1574660707729323, 0.17599454842407325, 0.17892632230068262, 0.1472656071583449, 0.16193077513791465, 0.16445703117791077, 0.16022088251782263, 0.16017502547270068, 0.14096576912705028, 0.1391512703543929, 0.15020593677743566, 0.14356235722276922, 0.14312235253622207, 0.1558490300564208, 0.15530979572540615, 0.14701594856945233, 0.1643488603135076, 0.15442689453467373, 0.18674661669589232, 0.1574614043080642, 0.16914142433026025, 0.185332306866539, 0.15049497306968185, 0.13265966321362355, 0.19379951538448736, 0.19263481795963644, 0.15696905699607666, 0.25669194313252286, 0.1522303527162283, 0.13101941212704937, 0.12203803751990072, 0.13799231195610662, 0.1407885207683628, 0.15546758576392605, 0.20102622250961932, 0.18028787111895817, 0.20686758952476825, 0.1902242767570631, 0.1785190110801157, 0.1909914597073301, 0.18090012927343713, 0.19058522225553076, 0.19072742260319087, 0.18845913613611898, 0.05206884084170904, 0.04824137534847328, 0.04906240642082771, 0.056282563334934865, 0.049760126767736446, 0.07371171751638084, 0.05745431283729541, 0.04971979055229625, 0.04987417366701097]}, "mutation_prompt": null}
{"id": "96e4aa34-7dfc-4a2c-bbb2-14e1416a4304", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        adaptive_F = self.F * (1 + (self.budget - self.eval_count) / self.budget * np.random.uniform(0.5, 1.5))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced convergence through a dynamic selection pressure mechanism in selective mutation.", "configspace": "", "generation": 62, "fitness": 0.11811388669442652, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "7d65c32f-400b-43b4-bb34-d13355348d3c", "metadata": {"aucs": [0.16688064367258626, 0.14446095062306774, 0.1631933336276703, 0.2300255707841351, 0.15824832831925706, 0.16243198297155614, 0.15232018710155393, 0.15817760822562432, 0.1453245354209377, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06541314249264019, 0.04581921750378681, 0.046651460075435525, 0.03744137566245376, 0.03718875997356985, 0.033527143786092006, 0.029809586577289715, 0.03532800534246072, 0.034993249037418184, 0.01929551789827766, 0.02710074506632465, 0.02693066934768995, 0.02444936475226911, 0.030156150105265622, 0.03759333118712471, 0.023158293437881006, 0.026916370977656645, 0.018287583862026446, 0.8394897379987172, 0.8637480786861707, 0.9444801845529073, 0.7637379228106378, 0.9308868166552043, 0.965459641267437, 0.8145495181853861, 0.9411095748252236, 0.9894448381691963, 0.09732671579391372, 0.07899415013382427, 0.057607542582364446, 0.054695138328107684, 0.105295927637726, 0.05205898325748892, 0.06424299451965398, 0.05281609802285203, 0.06729696922413331, 0.11373993039003161, 0.10162895407278738, 0.10556426407206987, 0.09554794494776975, 0.1154821192625457, 0.11177766357905405, 0.17826829262950705, 0.12744694081007746, 0.11583277942792591, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016996210791774269, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032650122029223017, 0.0005005470838019832, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004421155227104512, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001629410454672131, 0.0009567719139272901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05132039983981196, 0.030628493178644578, 0.0308133236244017, 0.034137133756221516, 0.04057224126040071, 0.021417674121244845, 0.058263913010049295, 0.023540125738498174, 0.0748690233090229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17457726320686107, 0.2317520095967054, 0.18941222556031256, 0.1945224163518241, 0.18147988624750022, 0.1980828982156183, 0.18966994821711325, 0.17441064525675543, 0.22094722237785025, 0.041725442881561325, 0.03930487708588537, 0.04407127705863567, 0.0387948960224056, 0.03343499901668545, 0.04171243014028225, 0.05133793802516318, 0.04422793402820502, 0.033719910278789955, 0.18430490456997906, 0.14053741704658695, 0.15521017084676592, 0.1369304578076671, 0.14943108668669536, 0.11354242445808505, 0.1487687433124245, 0.13650988046348178, 0.1371946837203294, 0.16477519345432357, 0.15926142518209685, 0.14909874102748433, 0.17311492677482, 0.1741081609862959, 0.16168489088347526, 0.15207967740921957, 0.17428573078034282, 0.1603357302304812, 0.10863797205639003, 0.0947358527710428, 0.0947542637761184, 0.11107586814931036, 0.09859361416140944, 0.10122949841452789, 0.10121553999544941, 0.10564339903486164, 0.10512999233463849, 0.18228634065641558, 0.14405427846920615, 0.13561471475875264, 0.17886113373624812, 0.1372086798726012, 0.1828688550707116, 0.15624329921134106, 0.14965708684766554, 0.134942239546458, 0.14213563958303999, 0.14102308544730202, 0.13750965584450003, 0.1250164144053182, 0.13619297239774353, 0.1473373571523049, 0.13433298530813387, 0.13981186161107073, 0.12028132807741965, 0.15665650484503002, 0.12475618978335934, 0.2234850218988974, 0.15395150144922032, 0.16660982099300892, 0.2001384008961682, 0.1527167660452876, 0.1300545923831281, 0.1451990780074648, 0.15790118263183273, 0.12272501566473637, 0.1451444968648391, 0.14508884795286536, 0.12810968479009222, 0.13834735401081577, 0.15094563339144973, 0.1436336471748053, 0.1532995513397758, 0.19587089566816906, 0.18082777170724884, 0.19471248449165757, 0.17591613458724809, 0.18716628612612518, 0.17722112286176506, 0.18762832704095422, 0.182532887658454, 0.18322856731146675, 0.04696840044404271, 0.04249847510867655, 0.06067082399367241, 0.04354349740582186, 0.0664740626453828, 0.05127773066674579, 0.058213401550910926, 0.04655452643286373, 0.04473627991238849]}, "mutation_prompt": null}
{"id": "dfdd29e1-affb-4532-bb7e-847e5b08d4af", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        adaptive_F = self.F * (1 + (self.budget - self.eval_count) / self.budget * np.random.uniform(0.5, 1.5))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced convergence through a dynamic selection pressure mechanism in selective mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "96e4aa34-7dfc-4a2c-bbb2-14e1416a4304", "metadata": {"aucs": [0.16688064367258626, 0.14446095062306774, 0.1631933336276703, 0.2300255707841351, 0.15824832831925706, 0.16243198297155614, 0.15232018710155393, 0.15817760822562432, 0.1453245354209377, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06541314249264019, 0.04581921750378681, 0.046651460075435525, 0.03744137566245376, 0.03718875997356985, 0.033527143786092006, 0.029809586577289715, 0.03532800534246072, 0.034993249037418184, 0.01929551789827766, 0.02710074506632465, 0.02693066934768995, 0.02444936475226911, 0.030156150105265622, 0.03759333118712471, 0.023158293437881006, 0.026916370977656645, 0.018287583862026446, 0.8394897379987172, 0.8637480786861707, 0.9444801845529073, 0.7637379228106378, 0.9308868166552043, 0.965459641267437, 0.8145495181853861, 0.9411095748252236, 0.9894448381691963, 0.09732671579391372, 0.07899415013382427, 0.057607542582364446, 0.054695138328107684, 0.105295927637726, 0.05205898325748892, 0.06424299451965398, 0.05281609802285203, 0.06729696922413331, 0.11373993039003161, 0.10162895407278738, 0.10556426407206987, 0.09554794494776975, 0.1154821192625457, 0.11177766357905405, 0.17826829262950705, 0.12744694081007746, 0.11583277942792591, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016996210791774269, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032650122029223017, 0.0005005470838019832, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004421155227104512, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001629410454672131, 0.0009567719139272901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05132039983981196, 0.030628493178644578, 0.0308133236244017, 0.034137133756221516, 0.04057224126040071, 0.021417674121244845, 0.058263913010049295, 0.023540125738498174, 0.0748690233090229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17457726320686107, 0.2317520095967054, 0.18941222556031256, 0.1945224163518241, 0.18147988624750022, 0.1980828982156183, 0.18966994821711325, 0.17441064525675543, 0.22094722237785025, 0.041725442881561325, 0.03930487708588537, 0.04407127705863567, 0.0387948960224056, 0.03343499901668545, 0.04171243014028225, 0.05133793802516318, 0.04422793402820502, 0.033719910278789955, 0.18430490456997906, 0.14053741704658695, 0.15521017084676592, 0.1369304578076671, 0.14943108668669536, 0.11354242445808505, 0.1487687433124245, 0.13650988046348178, 0.1371946837203294, 0.16477519345432357, 0.15926142518209685, 0.14909874102748433, 0.17311492677482, 0.1741081609862959, 0.16168489088347526, 0.15207967740921957, 0.17428573078034282, 0.1603357302304812, 0.10863797205639003, 0.0947358527710428, 0.0947542637761184, 0.11107586814931036, 0.09859361416140944, 0.10122949841452789, 0.10121553999544941, 0.10564339903486164, 0.10512999233463849, 0.18228634065641558, 0.14405427846920615, 0.13561471475875264, 0.17886113373624812, 0.1372086798726012, 0.1828688550707116, 0.15624329921134106, 0.14965708684766554, 0.134942239546458, 0.14213563958303999, 0.14102308544730202, 0.13750965584450003, 0.1250164144053182, 0.13619297239774353, 0.1473373571523049, 0.13433298530813387, 0.13981186161107073, 0.12028132807741965, 0.15665650484503002, 0.12475618978335934, 0.2234850218988974, 0.15395150144922032, 0.16660982099300892, 0.2001384008961682, 0.1527167660452876, 0.1300545923831281, 0.1451990780074648, 0.15790118263183273, 0.12272501566473637, 0.1451444968648391, 0.14508884795286536, 0.12810968479009222, 0.13834735401081577, 0.15094563339144973, 0.1436336471748053, 0.1532995513397758, 0.19587089566816906, 0.18082777170724884, 0.19471248449165757, 0.17591613458724809, 0.18716628612612518, 0.17722112286176506, 0.18762832704095422, 0.182532887658454, 0.18322856731146675, 0.04696840044404271, 0.04249847510867655, 0.06067082399367241, 0.04354349740582186, 0.0664740626453828, 0.05127773066674579, 0.058213401550910926, 0.04655452643286373, 0.04473627991238849]}, "mutation_prompt": null}
{"id": "03d1116a-5f30-4eaf-ba13-10dfc2ebb4c2", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        adaptive_F = self.F * (1 + (self.budget - self.eval_count) / self.budget * np.random.uniform(0.5, 1.5))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced convergence through a dynamic selection pressure mechanism in selective mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "96e4aa34-7dfc-4a2c-bbb2-14e1416a4304", "metadata": {"aucs": [0.16688064367258626, 0.14446095062306774, 0.1631933336276703, 0.2300255707841351, 0.15824832831925706, 0.16243198297155614, 0.15232018710155393, 0.15817760822562432, 0.1453245354209377, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06541314249264019, 0.04581921750378681, 0.046651460075435525, 0.03744137566245376, 0.03718875997356985, 0.033527143786092006, 0.029809586577289715, 0.03532800534246072, 0.034993249037418184, 0.01929551789827766, 0.02710074506632465, 0.02693066934768995, 0.02444936475226911, 0.030156150105265622, 0.03759333118712471, 0.023158293437881006, 0.026916370977656645, 0.018287583862026446, 0.8394897379987172, 0.8637480786861707, 0.9444801845529073, 0.7637379228106378, 0.9308868166552043, 0.965459641267437, 0.8145495181853861, 0.9411095748252236, 0.9894448381691963, 0.09732671579391372, 0.07899415013382427, 0.057607542582364446, 0.054695138328107684, 0.105295927637726, 0.05205898325748892, 0.06424299451965398, 0.05281609802285203, 0.06729696922413331, 0.11373993039003161, 0.10162895407278738, 0.10556426407206987, 0.09554794494776975, 0.1154821192625457, 0.11177766357905405, 0.17826829262950705, 0.12744694081007746, 0.11583277942792591, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016996210791774269, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032650122029223017, 0.0005005470838019832, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004421155227104512, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001629410454672131, 0.0009567719139272901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05132039983981196, 0.030628493178644578, 0.0308133236244017, 0.034137133756221516, 0.04057224126040071, 0.021417674121244845, 0.058263913010049295, 0.023540125738498174, 0.0748690233090229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17457726320686107, 0.2317520095967054, 0.18941222556031256, 0.1945224163518241, 0.18147988624750022, 0.1980828982156183, 0.18966994821711325, 0.17441064525675543, 0.22094722237785025, 0.041725442881561325, 0.03930487708588537, 0.04407127705863567, 0.0387948960224056, 0.03343499901668545, 0.04171243014028225, 0.05133793802516318, 0.04422793402820502, 0.033719910278789955, 0.18430490456997906, 0.14053741704658695, 0.15521017084676592, 0.1369304578076671, 0.14943108668669536, 0.11354242445808505, 0.1487687433124245, 0.13650988046348178, 0.1371946837203294, 0.16477519345432357, 0.15926142518209685, 0.14909874102748433, 0.17311492677482, 0.1741081609862959, 0.16168489088347526, 0.15207967740921957, 0.17428573078034282, 0.1603357302304812, 0.10863797205639003, 0.0947358527710428, 0.0947542637761184, 0.11107586814931036, 0.09859361416140944, 0.10122949841452789, 0.10121553999544941, 0.10564339903486164, 0.10512999233463849, 0.18228634065641558, 0.14405427846920615, 0.13561471475875264, 0.17886113373624812, 0.1372086798726012, 0.1828688550707116, 0.15624329921134106, 0.14965708684766554, 0.134942239546458, 0.14213563958303999, 0.14102308544730202, 0.13750965584450003, 0.1250164144053182, 0.13619297239774353, 0.1473373571523049, 0.13433298530813387, 0.13981186161107073, 0.12028132807741965, 0.15665650484503002, 0.12475618978335934, 0.2234850218988974, 0.15395150144922032, 0.16660982099300892, 0.2001384008961682, 0.1527167660452876, 0.1300545923831281, 0.1451990780074648, 0.15790118263183273, 0.12272501566473637, 0.1451444968648391, 0.14508884795286536, 0.12810968479009222, 0.13834735401081577, 0.15094563339144973, 0.1436336471748053, 0.1532995513397758, 0.19587089566816906, 0.18082777170724884, 0.19471248449165757, 0.17591613458724809, 0.18716628612612518, 0.17722112286176506, 0.18762832704095422, 0.182532887658454, 0.18322856731146675, 0.04696840044404271, 0.04249847510867655, 0.06067082399367241, 0.04354349740582186, 0.0664740626453828, 0.05127773066674579, 0.058213401550910926, 0.04655452643286373, 0.04473627991238849]}, "mutation_prompt": null}
{"id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 65, "fitness": 0.12127686996580281, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "96e4aa34-7dfc-4a2c-bbb2-14e1416a4304", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "a66952c0-d4cc-403e-8ac1-0e2fcf551829", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "13fa6e60-f83b-47db-822d-d24d3dc1eacc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "bfe22a4f-4b93-4259-8ef4-3a2ceb1cd196", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "a174adb5-d801-4f40-9927-73fa7c7ab756", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "45124349-769b-4fff-b2bb-bd9038faa267", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "4620bec4-9258-4cdf-92b4-eabd09c4f8e8", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "b7e2db49-f473-48fe-bb89-f2e2ec3dd105", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "f676be3b-adb6-42d7-be1e-eb6802c4f819", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Adaptive trial vector generation with dynamic factor\n        adaptive_factor = np.random.uniform(0.4, 1.6)  # Slightly broadened range for greater exploration\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Balanced DE with adaptive crossover boosts exploration via dynamic trial vector scaling.", "configspace": "", "generation": 73, "fitness": 0.11958112395461178, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.1842962524318028, 0.16313502150445092, 0.17239075747369392, 0.195885326063876, 0.17012447902556993, 0.15173727679085314, 0.1941098022234985, 0.15547723740206987, 0.15873374897959458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03871673146574428, 0.03410582801517559, 0.03402965135054836, 0.04150706863767628, 0.03760982583993899, 0.04872599281168766, 0.038735730889946196, 0.03999890107596471, 0.03720797259806519, 0.023008323175425893, 0.02625034600234244, 0.032788588527873475, 0.04024395132655301, 0.01869894584879006, 0.029157530576260027, 0.048818922080102634, 0.038206927355851295, 0.03393262885561743, 0.7842093445113891, 0.8437162270348169, 0.9441237241338158, 0.930028260555152, 0.9320956840478727, 0.9863059090478365, 0.9806564252434702, 0.9411057765117743, 0.9470667299269788, 0.058535514728126126, 0.049872498985188196, 0.05623266499407986, 0.0686263999576735, 0.05914794624477415, 0.052366414839883135, 0.09536451619646091, 0.05056970531164662, 0.07496841644302243, 0.12758840547662986, 0.12392901419094338, 0.10781562890921537, 0.10986591572104698, 0.0959415827743445, 0.133478376201139, 0.13139431766342657, 0.11577998562209069, 0.10614896449169031, 0.0012128456664930454, 0.023541755642126683, 0.021043410361410442, 9.999999999998899e-05, 9.999999999998899e-05, 0.020679963646199617, 0.026919116930456788, 9.999999999998899e-05, 0.008396540026976429, 0.0009221353606005955, 0.002492974710218143, 0.007870003078987775, 0.006460792367724899, 9.999999999998899e-05, 0.003750982221757293, 0.008692653284579688, 0.0005962253227719261, 0.012824895820245708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040942960501558434, 0.020097536656736192, 0.03396306868833021, 0.024287977932145766, 0.06117739971424285, 0.023175200848971733, 0.03387197028264932, 0.02800211425806265, 0.037448829584682986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017966437914824773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16965840074216454, 0.2046763909276016, 0.2230498156175984, 0.20279655673639974, 0.1866677073941312, 0.20151569896895372, 0.17925273294028188, 0.18051552503984347, 0.19185670578687986, 0.042484263640272135, 0.04569798650923307, 0.03590158586049419, 0.04107553938101993, 0.03427373850532223, 0.03696057812791753, 0.04271683247922886, 0.044813578322202785, 0.05853743220913621, 0.16377416963320413, 0.13727673258908413, 0.15659980889183645, 0.15506975093987752, 0.13304458258213547, 0.12850995834454115, 0.14358800815861628, 0.13995757070402892, 0.1490920977554301, 0.148782145533222, 0.15255613664562007, 0.1499416334138235, 0.1568636622709899, 0.15841161134218795, 0.16492402072702994, 0.14562698487478942, 0.17377774300845283, 0.1462540383152151, 0.08641640722105581, 0.0937251388990108, 0.09310642629095078, 0.10197057668828202, 0.1208617401770995, 0.10104059512735852, 0.10456934256391048, 0.10214445215145407, 0.09430731875396448, 0.1429482263665084, 0.13623833988236078, 0.1487622451268078, 0.13638252407807394, 0.15365387093917615, 0.17837224356727643, 0.18651521869869936, 0.13689648753601047, 0.15439972876643537, 0.13326086434052287, 0.14999909504000897, 0.13000918970820474, 0.11711817155666482, 0.13360173276577902, 0.14379053199405312, 0.14100601400483115, 0.12759760984638158, 0.14069887319333285, 0.14668843315752533, 0.1281778648200248, 0.19250566582231443, 0.24263258587339298, 0.15353460327526336, 0.1511526307303519, 0.15297768308280446, 0.13522615117648562, 0.16478850209861629, 0.1547517828515449, 0.11523176759464282, 0.144543522681721, 0.13623052346277031, 0.14464251372444892, 0.16320560415240293, 0.16168701067212055, 0.13775296628733957, 0.19866826285373484, 0.1874695330552244, 0.19333235466878718, 0.2015121345962967, 0.19323573431708674, 0.19692028310964615, 0.18498639435773, 0.18310074875093318, 0.17832865533695663, 0.18065117953610987, 0.04181473534376523, 0.04448398652760366, 0.04454770722693557, 0.07190529152454705, 0.043915094983990044, 0.04698379932190655, 0.055559422854606244, 0.04327906865371711, 0.04856777071694118]}, "mutation_prompt": null}
{"id": "b4591215-dff6-4b7d-bd53-4bda2549fe34", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        # Adjust crossover probability based on fitness variance\n        fitness_variance = np.var(self.fitness)\n        adaptive_CR = 0.5 + (self.CR - 0.5) * np.exp(-fitness_variance)\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced dynamic crossover probability adjustment based on fitness variance to enhance diversity and convergence.", "configspace": "", "generation": 74, "fitness": 0.08821472462973914, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16066331767565645, 0.16267700491675463, 0.16712511207792236, 0.16945883356263602, 0.16085248304822686, 0.19898073993435061, 0.17721534519582405, 0.15465004412616368, 0.16287893667181053, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05088281418332208, 0.0534800043872361, 0.03769420363051046, 0.0445294170056415, 0.040007367644540714, 0.04205386929106569, 0.04449352194403178, 0.035781746705825346, 0.04736764193552556, 0.03088810694950772, 0.033737887241433784, 0.03128233028343097, 0.03187912435799989, 0.049157575431773126, 0.04620715834035527, 0.02845907761794242, 0.029423204160730854, 0.02984718656674501, 0.09774416457495338, 0.1025979821836085, 0.08234625179039334, 0.12243818875940926, 0.08547556011156576, 0.08974340926700575, 0.10491516839761317, 0.09828361733240032, 0.110135429233992, 0.075908350529718, 0.06415570249709268, 0.07888129120768339, 0.06731702821521446, 0.0732910729108287, 0.0779146620858423, 0.05735407623690769, 0.07490548531657948, 0.05046208294999488, 0.10346496108922909, 0.09887898124267325, 0.11345500353754556, 0.11234459709714884, 0.11994180114346453, 0.0928192981054543, 0.12931605056054918, 0.11409430606890403, 0.10229757179644727, 9.999999999998899e-05, 9.999999999998899e-05, 0.004798254728788698, 0.001226983913320101, 9.999999999998899e-05, 0.012482835611634213, 0.009247855526869686, 0.03927256377796273, 9.999999999998899e-05, 0.044724250840246116, 0.01804116531720834, 0.000845522818983202, 0.03140557051506765, 9.999999999998899e-05, 0.00039219824935499137, 0.03677773475306367, 9.999999999998899e-05, 0.02611423905441057, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03106121992821409, 0.061904295724394265, 0.023258315451522682, 0.034617043275034676, 0.03873046497241628, 0.033201340709763105, 0.04649807690838148, 0.0752856809739102, 0.02901969803550275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006913439246625241, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18987186290597025, 0.17606498632255663, 0.18230459416355072, 0.1797698105459209, 0.18779401669370577, 0.19434924613435856, 0.20693200304264714, 0.22931150393171107, 0.20182010966357533, 0.038474482374053376, 0.04493804230422538, 0.04171814529639162, 0.043686511399842365, 0.06245607905729189, 0.046829138240632506, 0.038463130163791215, 0.045583716243844385, 0.04394348601376785, 0.13090967091107886, 0.13694749670558726, 0.12675033751749232, 0.1426102814916852, 0.15319093475531043, 0.12558705483830945, 0.14805123870255288, 0.1660988810227222, 0.14091636498252869, 0.17124219702443366, 0.16423828218960157, 0.16124027283074827, 0.1646211311763216, 0.15584026883316526, 0.1613140132757781, 0.15975511295514766, 0.17377774300845283, 0.1841190717237099, 0.13032748394719385, 0.10340447813372378, 0.10050449842454345, 0.11960761805391396, 0.09883483469014753, 0.1063882076039867, 0.11863073148376879, 0.10586847452477599, 0.12149669000660868, 0.16446064130565574, 0.15857554394173845, 0.1550102558714912, 0.14286103329552058, 0.169215793186269, 0.15950627326317612, 0.15895924881720291, 0.14675092925893096, 0.15515523402769738, 0.13796227272054074, 0.14038411623468605, 0.14637041570463516, 0.14605104220632859, 0.13089413933560934, 0.13828948492879845, 0.131877237819638, 0.14696894879152567, 0.14351184469321632, 0.1563121840793339, 0.1545611897731788, 0.14640004124282147, 0.18672129644249058, 0.16068216162684035, 0.15382855110976668, 0.14889698618635017, 0.16633436083877862, 0.1537356393431757, 0.23194378906567104, 0.2096360707913565, 0.13285465329868051, 0.18258583179709809, 0.2287285817670921, 0.16222884954469607, 0.1555796607381995, 0.13942409561941804, 0.11286033013370633, 0.19805894698955706, 0.18732255360770567, 0.18780994775250603, 0.18440528621545138, 0.1835375699525399, 0.21493418052271207, 0.18920802489277766, 0.18174765847798702, 0.18548955082897312, 0.05359022156593418, 0.04246580513851972, 0.049549563521123274, 0.05734183939337256, 0.046214275453675846, 0.04241811987560651, 0.045298007286763475, 0.04549190521140445, 0.050941295084712124]}, "mutation_prompt": null}
{"id": "8f731af1-e20f-4354-b953-fb3523348d90", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "db340bc7-4102-4140-a0b7-4e2f42a13ea3", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "f37cbba1-5be4-43e4-825b-d3239b7fdd38", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "19806147-1609-49f0-847b-6e8716247f7b", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Enhanced selective mutation strategy\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        # Added adaptive trial vector generation\n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced selective mutation with dynamic exploration-exploitation balance through adaptive scale factor adjustment.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16766891372511528, 0.15771761305291365, 0.16681343617826783, 0.23137643884860204, 0.16015093983965778, 0.15191052024395635, 0.1714139888520949, 0.15432220833605992, 0.15793279365469093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0697632558430823, 0.04130754920472357, 0.04117907619387484, 0.026525090801066797, 0.05234730888169503, 0.039916153325799675, 0.03787215361097063, 0.030333791543864064, 0.038721985747587895, 0.04284499298118083, 0.022380876850632392, 0.03127811660314361, 0.023828109690112065, 0.022873644669747173, 0.015152871061591577, 0.022747037879158105, 0.04742110082617523, 0.017524920810372158, 0.9788516307541526, 0.843054855137948, 0.9440052269728104, 0.9300168083679564, 0.9315845702350705, 0.9083180365113066, 0.9806594480146645, 0.9411056600815801, 0.9894240648943368, 0.09295625095975102, 0.06909407176720872, 0.054499366439015984, 0.061608385523437725, 0.1024676076809461, 0.04756596119102685, 0.07589496787478422, 0.048110208840869584, 0.0615491302931479, 0.11264477735760725, 0.1079497484431593, 0.08623341128847639, 0.08714200734153477, 0.1021014494551149, 0.09752717649632181, 0.13200269809818144, 0.11337407454222648, 0.1060441743461017, 0.007353765097259046, 0.03915636993769711, 0.03149782863193107, 9.999999999998899e-05, 0.005051418758405091, 0.01044513904430222, 0.006997461037377084, 0.011518074383096377, 0.002803951572611707, 9.999999999998899e-05, 0.006966686696959878, 0.0007988940731807892, 0.013725836524971835, 9.999999999998899e-05, 9.999999999998899e-05, 0.03960349781169936, 0.0025607442783533996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987960234528909, 0.0441116498625137, 0.03637808024285494, 0.016642390220884762, 0.06164642266729803, 0.012785540381848426, 0.09651259200938478, 0.03800151986644429, 0.12454946919825893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1682760992666692, 0.24708691690256013, 0.18958200691696137, 0.20129898284052017, 0.17521207597589095, 0.20158742334697244, 0.1899759878156545, 0.16916321573578663, 0.18591171133315276, 0.0439295420600716, 0.04319250458485946, 0.031295785525273456, 0.03772590120356434, 0.038498853968875535, 0.03668523466200202, 0.04158710459184167, 0.0593909199383339, 0.04714298717420495, 0.22090714499190822, 0.17695793755197353, 0.18425339305233635, 0.13167533134118636, 0.14124011567834183, 0.16566284112774643, 0.1511746454419095, 0.14086100586368888, 0.1447146754274743, 0.15975351717169284, 0.15222711056985316, 0.14857947666773375, 0.16589733824012642, 0.1575995475253047, 0.1605057123475765, 0.15157188516750375, 0.17377774300845283, 0.1703469887473288, 0.08415516481864871, 0.08841832861134313, 0.09168952554486676, 0.1229891945244701, 0.09628281710601683, 0.0875471018974604, 0.09627865244850708, 0.10173322985477429, 0.12463904985162011, 0.16843251350123678, 0.13878552568436608, 0.14970948146718344, 0.1431526863174004, 0.13466358705017478, 0.16582149096089183, 0.15123551193354634, 0.13872295548420155, 0.13961529162811714, 0.13414025772034643, 0.16077827503090902, 0.13938681863670443, 0.12276772710752504, 0.13952471517762532, 0.14329283841771756, 0.1400659081945076, 0.1304503870357323, 0.12312205806634935, 0.1518257623648327, 0.14052485905025913, 0.2058371095910837, 0.20769901722966133, 0.1394649021704023, 0.14721668306815772, 0.15121741817812728, 0.13838293428308612, 0.1399439263830191, 0.14302745160916042, 0.1403178386456586, 0.13257832912500456, 0.12009522837304698, 0.17004296572692346, 0.19962659878131495, 0.15969802099469088, 0.1579556223353895, 0.15734254239704837, 0.20191262866449622, 0.18159989066782678, 0.1820520915333118, 0.1776648837983017, 0.17670938056854812, 0.17146755146459458, 0.19578538199252316, 0.19075133371492725, 0.19050522496763356, 0.04775070165711537, 0.06108897276976366, 0.05068196440990691, 0.04543162417131075, 0.04813183305068702, 0.04886464576742566, 0.04388877427847382, 0.07525139538620751, 0.038620072798412175]}, "mutation_prompt": null}
{"id": "cef0b4c6-9fc0-42d2-9e33-ad0fb71c1c2e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced dynamic crossover probability adjustment based on evaluation progress to enhance convergence.", "configspace": "", "generation": 79, "fitness": 0.12243305859061396, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "2c034d2f-6468-4a43-86a7-d621e1b5b8c2", "metadata": {"aucs": [0.16821913918708764, 0.17097414382896003, 0.15955011450818257, 0.18293919648303647, 0.17293760717395346, 0.1454868452464545, 0.1489927532555868, 0.16111907499756584, 0.1541297816680477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07658657527075174, 0.04353899190101651, 0.037150831906001436, 0.0387485851951338, 0.05483283615310608, 0.035589631570075886, 0.038263124207592036, 0.03345198248169867, 0.04333754378242771, 0.028859390117233263, 0.02240878306559002, 0.017210841786906572, 0.03916247181303045, 0.026190077571835002, 0.02113739807874604, 0.023050504325515586, 0.04411466404329245, 0.02388062401733715, 0.9788516307541526, 0.843054855137948, 0.9425126925314458, 0.9452695830041817, 0.9319225958539881, 0.9083023236894253, 0.9806594480146645, 0.9411056600815801, 0.9893906960077153, 0.06226428989749622, 0.06590279765143436, 0.07223218957125033, 0.09641019547883511, 0.05666692331117795, 0.04924034040398051, 0.0754917249297008, 0.0819684213388564, 0.07056264271788937, 0.12656299944831317, 0.11935230777612194, 0.11295933636341993, 0.1470217266809143, 0.1294952654565088, 0.103242174675921, 0.1169315914976582, 0.10431574501574048, 0.12238336666636529, 0.003481679895921852, 9.999999999998899e-05, 9.999999999998899e-05, 0.003079243065038595, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015900130736987705, 0.0684547510566128, 0.0058491913366895965, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020108213694833843, 0.012312903281692877, 9.999999999998899e-05, 0.02248950850419118, 0.03960349781169936, 0.00019956543879684485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051962968357045614, 0.07617134054755403, 0.04302471107244166, 0.07008923994958494, 0.03607121519258849, 0.15785534989199645, 0.0350103894882946, 0.052443602477654894, 0.033621443306247056, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.188607539267038, 0.19168387478689974, 0.18169379453527867, 0.17619804830816987, 0.18660205510193373, 0.2015865191748739, 0.17540638802885333, 0.1823445759983311, 0.1853036756704315, 0.04799787725795435, 0.04053150149689211, 0.0458421351160323, 0.0441619890935252, 0.035685513957580794, 0.041322959146746, 0.04106048966392373, 0.035688836445836425, 0.04280378171923471, 0.22090714499190822, 0.17584205852000667, 0.18251357520596434, 0.1551086888871569, 0.1273202609371512, 0.1332237832039731, 0.1511746454419095, 0.14367236515470116, 0.1274859089475494, 0.17094299275966585, 0.14495489106288462, 0.16173279631410764, 0.15594036244244092, 0.16101301252685984, 0.1717274454083636, 0.16155033317530465, 0.17377774300845283, 0.17126198559049277, 0.1057658829952215, 0.09109623498571362, 0.10853336672230995, 0.10910635579291761, 0.11098976829542118, 0.10341279130484604, 0.09934776819873026, 0.10828575682869179, 0.12463904985162011, 0.145578356778024, 0.13570736428376318, 0.1514950310585096, 0.14943677544589629, 0.16138485135078828, 0.15126303475863934, 0.17166797650403276, 0.14966064146334723, 0.1449172696524602, 0.14016796876428306, 0.15158591371878394, 0.1270673140487747, 0.14627186616283439, 0.11693395437310572, 0.1444429902537815, 0.1357923723609028, 0.13523198695015548, 0.12576410939781002, 0.13915596731677815, 0.14473357268981468, 0.2058371095910837, 0.17057401765530555, 0.13811248900610207, 0.159188720979754, 0.142932826348371, 0.13346651716793745, 0.16694365691680835, 0.14666293822105003, 0.12663265765220444, 0.1390246015507247, 0.12319391224594223, 0.19091660432582436, 0.1323086956618883, 0.18724779988054374, 0.21444098978793613, 0.16713850869267388, 0.18457596715132063, 0.18479530596719695, 0.18277522708747973, 0.184724890080189, 0.18445551274001448, 0.17364170516028676, 0.18327793440545515, 0.18548316955632504, 0.19100341833953105, 0.0523054187791151, 0.05814926426143485, 0.05052415541940114, 0.04375256469361899, 0.04329083591370686, 0.062186270426941026, 0.04845829563704551, 0.07525139538620751, 0.04250096551672666]}, "mutation_prompt": null}
{"id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 80, "fitness": 0.1267041143512788, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "cef0b4c6-9fc0-42d2-9e33-ad0fb71c1c2e", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "9e04a5f9-d3af-4b8b-a327-75050986e2c2", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / float(self.budget + 1))  # Optimized balance\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(0.9 * trial + 0.1 * target, self.lb, self.ub)  # Slightly different factor\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Optimized dynamic balance and crossover for adaptive convergence improvement in HybridDEOptimizer.", "configspace": "", "generation": 81, "fitness": 0.09122949707334123, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.20072342270117471, 0.17988580405565413, 0.1640020787813753, 0.20923459828412283, 0.18287082230785112, 0.18336144761812745, 0.20865218268967312, 0.18627023052995306, 0.17588574279668823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05378159414296457, 0.048627985133141705, 0.03728484040332314, 0.05608344605464588, 0.050056851176951245, 0.04895609821232394, 0.04762808704107824, 0.041544413685163484, 0.04927531598673174, 0.03560087089063202, 0.022773021270318217, 0.03236863562797321, 0.03459380781113486, 0.02797354959394671, 0.028101772204649156, 0.026486286445171592, 0.04191230865023221, 0.02652035963257604, 0.10038693244728891, 0.12142726328385522, 0.1095489497741231, 0.10527836362874421, 0.10391892877523656, 0.1148738548391206, 0.12563384728803995, 0.11262276466093246, 0.1408214674680177, 0.07314779678969374, 0.08033248455820197, 0.12816123186285788, 0.08520524366807403, 0.07123804043865078, 0.07965789304869808, 0.09542455003876604, 0.08697527789834747, 0.10055172183459182, 0.1332904943403027, 0.10365996487096785, 0.11292204096759872, 0.12693271207393542, 0.13738848572022289, 0.11908650070759141, 0.14509139326249731, 0.14042302998855083, 0.14061149929318795, 0.004190976727614704, 9.999999999998899e-05, 0.03103622901875347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026576682042351862, 9.999999999998899e-05, 0.01984910978979404, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004263087341110916, 0.00011308849966740198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00034403949396510924, 0.002473762608604324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049788102951441426, 0.06592238090440583, 0.052854209536625785, 0.03189076899247634, 0.04101902241482425, 0.07595437591857024, 0.05000804179535756, 0.052013772728004226, 0.04735389400134993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008891274353373113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18602799593096875, 0.2054223544272682, 0.18348541660093975, 0.19193149390871478, 0.17928407179339179, 0.2028130479457385, 0.22323201180507302, 0.1978281077811238, 0.1952436730220829, 0.0558376289708018, 0.05068084623137381, 0.04560127797983182, 0.04504005721640225, 0.04588673979819469, 0.04182165668129123, 0.04890464724464183, 0.047018206495384796, 0.03837998404087706, 0.128828964082212, 0.12529447732874832, 0.12329560410360141, 0.12446624493568592, 0.1328243719703598, 0.1512410085285555, 0.15127446783813503, 0.13194393884832167, 0.1775694220761196, 0.1659458496829429, 0.20453629399066586, 0.1638173306497993, 0.1553826947385385, 0.17867703795652234, 0.17013784973675483, 0.17141570255342087, 0.17436513237752604, 0.15613799738785095, 0.09463524242549737, 0.12947888418455256, 0.10481405939687649, 0.11179400582628163, 0.11348603089660902, 0.11154594158758557, 0.11527890634117799, 0.12366659165371352, 0.11266998361965908, 0.16176559715523586, 0.14028796665046717, 0.18019911904179475, 0.15136840724655343, 0.14868261220801016, 0.14853254364248714, 0.14835508145708698, 0.16233171680931135, 0.15611506120652519, 0.14275184360455428, 0.14987813436256547, 0.13180159748207876, 0.1435414636474246, 0.13436183862881668, 0.1536892028646244, 0.14322588591529262, 0.15572397416436634, 0.12843144012432017, 0.1586503647503711, 0.20591730673222186, 0.19601092004524223, 0.1441634999775372, 0.15129208635631053, 0.18319645604336987, 0.16414650072592307, 0.16844342231045972, 0.16566882245112224, 0.16953751796535121, 0.16607441179184157, 0.14833942885907403, 0.1504885788338508, 0.1467169916735498, 0.12530409107403173, 0.17793002598861074, 0.18281225926242328, 0.16486394778587887, 0.19514955703042847, 0.21151042504219864, 0.17155781080413346, 0.17017115995142063, 0.18487478449239558, 0.1848323765621248, 0.18420785420336527, 0.19532166540377638, 0.17706727796848687, 0.060620629004481286, 0.04702661097381511, 0.050936407798139016, 0.04377640849944309, 0.047944686411565685, 0.06119891333553773, 0.04866358283647987, 0.05009554177898479, 0.052699117303617315]}, "mutation_prompt": null}
{"id": "847a1223-776e-461a-a430-9d9bca77996e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        distance_factor = np.linalg.norm(self.population[best_idx] - self.population[idx]) / (self.ub - self.lb)\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx] * distance_factor  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduced a variable step size based on the distance to the best solution to fine-tune exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.12483221122045453, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.17814780870239433, 0.16703638977596236, 0.16640629317955558, 0.19341968451056646, 0.18991651342358917, 0.16600751573083394, 0.17049907089967042, 0.16289308531014957, 0.22362441062978156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047310035376843196, 0.05618919303358527, 0.03969721088690226, 0.04410436391092154, 0.057706672899693556, 0.043245153178525064, 0.04131598550149229, 0.04727595226001502, 0.047502706250664994, 0.03383187881862082, 0.040502127873474625, 0.023416052095628914, 0.05875805497036157, 0.024676101934948735, 0.02457624370308842, 0.024646877277878065, 0.04221616254454097, 0.028997340492484036, 0.9276496169356457, 0.856416491059135, 0.9432213043344138, 0.8286855209859689, 0.933224070303894, 0.9523271159254191, 0.9813468336984438, 0.956881539838915, 0.9861364386963333, 0.06036114467876197, 0.060247254936080186, 0.06575251667717819, 0.10378925461194854, 0.07274295565220146, 0.05842578865099002, 0.11645846450699482, 0.08013275439423251, 0.09972630961833606, 0.11442566283657274, 0.12228926775323345, 0.11306212904543844, 0.10033669314791316, 0.1213251795256407, 0.10486819443998407, 0.10140205886135323, 0.11255538701076184, 0.14253366799743694, 0.0002829366349693663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001511775266966886, 0.009110107516962285, 0.0684547510566128, 0.02304861873205377, 0.017865498076897524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012257013096605984, 0.008074406899297726, 0.00026982009255915873, 0.00543637918019646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06876709415471416, 0.049086678017406626, 0.028373005342429702, 0.08769153170550237, 0.03368082247951787, 0.034426571804634154, 0.03766293182158098, 0.04554767273429494, 0.12189096513514852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002388010546767738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18794564987295137, 0.1900244256912259, 0.21041405250993683, 0.1837829919713465, 0.20102657082542708, 0.19174361717393473, 0.18288266184894175, 0.22151543981030697, 0.20837127204905326, 0.045283809054606494, 0.03563261213708502, 0.04712202003122423, 0.050468385079412426, 0.04181628388956593, 0.038867222885235586, 0.053983973484281855, 0.05058156209175846, 0.04285658779207391, 0.13964974082407478, 0.15837777484339655, 0.1281900949034438, 0.15790882757524882, 0.1342776000207665, 0.1287609445887541, 0.1312596127094623, 0.1587591732941066, 0.13715146509937326, 0.15155883990599073, 0.15099769953377906, 0.16193223172169058, 0.15258589166154668, 0.15723304224704093, 0.169167845348433, 0.1652048179230351, 0.17540407232787425, 0.17515255457389034, 0.11421901566685377, 0.09828927468840754, 0.09840282590249894, 0.10930876251510835, 0.11498060174682123, 0.11425227136093052, 0.10001173902242777, 0.0999825084649405, 0.10345343298212573, 0.15183488370597187, 0.1652866569381749, 0.1826098377241384, 0.17838958603079158, 0.1498138563761533, 0.14827845026346498, 0.15426750705518555, 0.15657866601691417, 0.16458769800298434, 0.14686154319241318, 0.15235250546988122, 0.13744140546339112, 0.15868363268779906, 0.12950164386818763, 0.14061020301463578, 0.15179012923594726, 0.1453206182669834, 0.12862901888849976, 0.1796318518477823, 0.1621951090383167, 0.22594521781130805, 0.14910839580249957, 0.16255314463721238, 0.15240589114813485, 0.16865763575714265, 0.19917990645666228, 0.18343485847248253, 0.2017944196713265, 0.20992004543527165, 0.15112381845519907, 0.12820154201698297, 0.1747732111909257, 0.13467104598105617, 0.17325754491865375, 0.15656261874418054, 0.22477458739051448, 0.1859747577146853, 0.19067293178797473, 0.18440673341684155, 0.18294443129704963, 0.18182773447180867, 0.18529066096759228, 0.17605783755517512, 0.17252630556497484, 0.18173655428443025, 0.04972199045450365, 0.051373760458326756, 0.04910123052307058, 0.06862088489849993, 0.05061159812348037, 0.04411153121635436, 0.06057459323534453, 0.046173466248662365, 0.0433360838872352]}, "mutation_prompt": null}
{"id": "8f1aff15-a2fc-4900-8ef8-883d39592174", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 2.0)  # Updated range for exploration\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy with a focus on diversity by employing an adaptive scaling factor for increased exploration.", "configspace": "", "generation": 83, "fitness": 0.1250230001215393, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1691476969628788, 0.16945591207880284, 0.15912264621549344, 0.18743137871807958, 0.17072792089289324, 0.15035323879097828, 0.18706384238216944, 0.19278583402953553, 0.15419732539697417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06919925571720908, 0.06849951486292338, 0.03265218508391721, 0.04285747754594338, 0.048460128445728556, 0.044298077762366495, 0.040833592388549, 0.038085518427285026, 0.04875682538330961, 0.045014600387632164, 0.023650389447300246, 0.0732407207119784, 0.059413968617987645, 0.03613895170850523, 0.041191508253533904, 0.02213235048743878, 0.02950265713119038, 0.021109913371695432, 0.9276750330276201, 0.970099467731911, 0.9762856412858952, 0.9457340019251237, 0.9328735169883451, 0.9891485578707808, 0.9812918834369645, 0.9874174607026135, 0.9275219003293168, 0.058895412565355354, 0.08678422159456767, 0.0660206563176634, 0.08047546170707898, 0.06036850407134009, 0.05462561472049077, 0.12602535116081526, 0.0774077054458201, 0.08664940324014914, 0.1378171971106793, 0.11449186249614962, 0.11035116330991313, 0.14976582092477386, 0.11906998588084594, 0.14614665936641924, 0.14127573606988975, 0.09880455395767929, 0.10559077320416144, 0.009822361198316698, 9.999999999998899e-05, 9.999999999998899e-05, 0.032066517133296335, 0.002341346840008196, 9.999999999998899e-05, 0.0016481192874676642, 0.07045936449073564, 0.015451989947030564, 9.999999999998899e-05, 9.999999999998899e-05, 0.008752052467003724, 9.999999999998899e-05, 9.999999999998899e-05, 0.001884110408993056, 9.999999999998899e-05, 0.00017470631960148086, 0.024574956811384663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04479557556096592, 0.06690036073407868, 0.028917240155415636, 0.04842395803612198, 0.019084840321374807, 0.03820693436777456, 0.02638800972924038, 0.04346161685400507, 0.0666454781129876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009137294699766985, 9.999999999998899e-05, 0.002356232024599003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1926908670029971, 0.18555543677035813, 0.20345913636269053, 0.17784998280037578, 0.19942174695248838, 0.1788382539378366, 0.17865022163184818, 0.23918715638436083, 0.18719374076692807, 0.03026187945374126, 0.03989668863490625, 0.03833059540308381, 0.05207198601894503, 0.03601888011084686, 0.03266771586686135, 0.04859816354332869, 0.0682354369738265, 0.0674759995106089, 0.12555669103118272, 0.13295936074307824, 0.1710930018237854, 0.1257765742798822, 0.13510806884148607, 0.13703153367485887, 0.13504901238721145, 0.13826837082278198, 0.18054043796030295, 0.16684054553419192, 0.15509276642242908, 0.16288686344253078, 0.16367685912426388, 0.1656324822501518, 0.1684176639261541, 0.1621632942547705, 0.17377774300845283, 0.1588500587139977, 0.10448690960913809, 0.09532698458492528, 0.12294668696772804, 0.1067709571912876, 0.10346762277488264, 0.12700521654079, 0.10006006301132075, 0.12257894874179898, 0.12124589561238774, 0.1779838981394618, 0.16128608546254364, 0.153444084794092, 0.18965205701271104, 0.14541108518622536, 0.1549091110188361, 0.14748776140901176, 0.14285378750876465, 0.1546872483971794, 0.1442185780774038, 0.15594625176041987, 0.16143849885494743, 0.13972942567437818, 0.12067323178948042, 0.140173882326461, 0.16822304308226665, 0.14410976953880872, 0.12612115993594164, 0.1321961093871883, 0.1292882559404478, 0.17831113575517554, 0.18897206736294547, 0.1921705409820469, 0.15007039131269773, 0.22027529922830213, 0.14072851086900595, 0.16288421954358911, 0.14785736157392437, 0.11979113572658695, 0.1510308443081343, 0.14333086436067355, 0.15606419521228054, 0.13901831903930706, 0.15739184353236402, 0.15274419981390874, 0.205289373061875, 0.1963059227603654, 0.18953170064361913, 0.19362932448853054, 0.1832585579264625, 0.19429076134736922, 0.18431383514951816, 0.176090857966687, 0.17979602616935664, 0.18582527171675656, 0.04579024183533187, 0.06310630991850263, 0.04874231130361617, 0.046705480295417545, 0.047813635368687435, 0.04767253268750482, 0.06338610514416998, 0.04726157598692149, 0.055262969247445115]}, "mutation_prompt": null}
{"id": "23cc24e6-91d8-4a5c-aa51-537316e9d87e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "43343c7a-ef0a-43c9-95f7-d87833dbb522", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "a310f297-be96-415b-9b82-0a03b3d01775", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        # Adjust mutation scaling based on convergence progress\n        progress = (self.eval_count / self.budget) ** 0.5\n        adaptive_F *= (1 - 0.5 * progress)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduce adaptive mutation scaling to dynamically balance exploration and exploitation based on current convergence.", "configspace": "", "generation": 86, "fitness": 0.1246947628939859, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.18426322182408472, 0.18131356811297739, 0.17093683248752456, 0.18422204138848286, 0.2165072750777195, 0.16347692812776915, 0.19869867185470091, 0.18402310712991776, 0.19015527308244562, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05376841170287039, 0.044021076483020116, 0.038578482352973675, 0.050879694917038476, 0.05268481116556345, 0.0386132068364855, 0.04553346198396846, 0.05826746375186831, 0.044937563080662546, 0.032632855132193384, 0.04292596219122791, 0.0369365276343131, 0.041680505536314194, 0.03689147199834786, 0.034371143877565236, 0.028230730423462802, 0.045351323689296064, 0.023701515726778366, 0.9276525009284889, 0.8464927079289993, 0.92051988148824, 0.9452857310790875, 0.9315744136744059, 0.18574298877043605, 0.9813747808535025, 0.9874225047374195, 0.9861147846006615, 0.080111139386005, 0.08354397425823612, 0.06746296914826744, 0.09145215866860856, 0.0637562361998042, 0.08035445248314521, 0.07202067289650349, 0.08069742148990733, 0.08317869781870357, 0.12769916858885266, 0.10624892560157095, 0.11520721928370492, 0.11303959812951958, 0.13591270180644643, 0.10951967511309213, 0.1601543154033479, 0.12934377141082787, 0.1323743972052558, 9.999999999998899e-05, 0.020343281194351803, 0.026140400916395135, 0.020583277764479102, 0.0004988285282492289, 0.006894854352564428, 0.026016999605069424, 0.06927739325129534, 0.0424152661253383, 0.005890979595132517, 0.010630614618648337, 0.015547100458151886, 0.005281052211470905, 9.999999999998899e-05, 0.03708210454688199, 0.007023581625384523, 9.999999999998899e-05, 0.05074777921811513, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06510503918161814, 0.03926991239055244, 0.07128443437530407, 0.052213843491770606, 0.02120389735247663, 0.052137510247660224, 0.03163632782469361, 0.07530812184550362, 0.0439519453938938, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002295048170126046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1919409562410037, 0.20069940166384603, 0.21603565850937023, 0.19897284139440585, 0.18777515931137467, 0.20658032503129908, 0.18515634953782578, 0.21890645026587618, 0.20609743539271363, 0.04145878759690658, 0.0368021089228594, 0.0457807087854879, 0.04802312738630099, 0.058170558851317056, 0.03733290080722529, 0.05821319628168298, 0.0472753668070196, 0.05314987252751402, 0.155701548546768, 0.16268502150694453, 0.14398667513459584, 0.1527815360331628, 0.1353928294975396, 0.13242351315089307, 0.1447424622728204, 0.1667290264750695, 0.1372436342863106, 0.17202665504524106, 0.16382734311719482, 0.16578490056663175, 0.18219018216291039, 0.16954261243974555, 0.16518778305338055, 0.16300381912417194, 0.17377774300845283, 0.1661387580938104, 0.11055336225468348, 0.10232156127156922, 0.10680339920489734, 0.11466127359924672, 0.11621351019351878, 0.1167351184918829, 0.11248985946798362, 0.11384681255584439, 0.1327471168405744, 0.1724893970667981, 0.15700837589847982, 0.15604396445150437, 0.17061808656064859, 0.179563820303427, 0.14985449644471227, 0.16477064581507217, 0.13977608031822708, 0.17016976206630263, 0.1483348346327097, 0.1572451914446259, 0.1442952946687467, 0.15130753417351894, 0.1409704723671884, 0.14335939141358978, 0.14635812675884718, 0.15766144414977445, 0.15495160773300454, 0.14348447623120497, 0.1551185857779276, 0.16794857853228984, 0.16086014541654348, 0.16601319422659455, 0.26358540060774627, 0.24895686684552665, 0.16366850534196276, 0.15678325576449026, 0.15905144014899342, 0.1794657849270661, 0.1536495426252319, 0.16462013280838783, 0.17134006445699268, 0.12238591236970753, 0.225243634563981, 0.16062675265993642, 0.161124585757207, 0.17295619519001937, 0.19714159450720004, 0.17456656444175456, 0.1805121650200947, 0.18664393927328038, 0.18493085351414162, 0.17990115749080482, 0.18054283270760385, 0.18160270218954833, 0.043974230308280626, 0.056304693632747704, 0.04938796530688727, 0.05466214477230713, 0.04687302144103345, 0.04994103327679, 0.07375573341587038, 0.056637298253566004, 0.046679501512446375]}, "mutation_prompt": null}
{"id": "52bf6eef-0eb6-4230-b4fe-fe262939056e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.65 * mutant + 0.35 * self.population[best_idx]  # Adjusted weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n        else:  # New minor adjustment for additional exploration\n            self.population[idx] = 0.5 * (self.population[idx] + trial_vector)\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Minor adjustment to mutation and selection strategy to enhance convergence reliability.", "configspace": "", "generation": 87, "fitness": 0.12592271507870545, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.17849259879650892, 0.18632480287353215, 0.17712672398646823, 0.186403329574776, 0.19500890217944444, 0.1656535790385506, 0.20295812597930707, 0.17037386765840679, 0.1721253218998634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462844380780405, 0.06604436736283403, 0.05691064558382464, 0.04826790015821858, 0.048485527047552934, 0.045497283640256736, 0.03917103226346863, 0.03831347409609975, 0.044030523565417035, 0.03062132723001565, 0.029077972341324365, 0.040062418844057146, 0.06443281367726417, 0.034434672987800674, 0.041453633725979655, 0.04067639592823036, 0.03586979085896824, 0.025530112433016616, 0.9276721410060251, 0.9959785458068922, 0.9214365915263221, 0.841410588088881, 0.9314591147450733, 0.8804930980533421, 0.9813948604612058, 0.9874770476542578, 0.9860588464554741, 0.06264896147014187, 0.08659418479582659, 0.06676538684785338, 0.11473434358633183, 0.07215337890250262, 0.06934397465472208, 0.09425543938006808, 0.08853306770463931, 0.08198778564582876, 0.1302171116158961, 0.11374385778987084, 0.1092468976723261, 0.11836679394503025, 0.13499523769562005, 0.11183892272065388, 0.1343923902086006, 0.13207168684981496, 0.15114496577387582, 0.0007746949638509637, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031170606326568207, 9.999999999998899e-05, 9.999999999998899e-05, 0.016693568210013665, 0.0684547510566128, 0.03042473839600457, 0.029628290567347393, 9.999999999998899e-05, 0.000393062926552723, 9.999999999998899e-05, 9.999999999998899e-05, 0.013520507264463966, 0.003770373951828554, 0.00027763549205106486, 0.024293752966197957, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04414358580873956, 0.026758256638866662, 0.044253777295517494, 0.047347111294969935, 0.025112610394601997, 0.01043442452431731, 0.04866592427680638, 0.0593314247443959, 0.039729889935302576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016848275770420251, 0.005688972457092101, 9.999999999998899e-05, 0.0024326813760184862, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1886342687798619, 0.1985375453491528, 0.21870325817057779, 0.1886440408518858, 0.2161976376821565, 0.20033343524928948, 0.2087397920522075, 0.2206023934801815, 0.20227366331570362, 0.03596452296678321, 0.03705505356223415, 0.0362754207300513, 0.04664427153909945, 0.0477546754118745, 0.04528737937945171, 0.04570391165381171, 0.05313085532236472, 0.05079749024625457, 0.1348353236973575, 0.13406771757516622, 0.13933677070301398, 0.14078783904714565, 0.14472780022040566, 0.12927334314885452, 0.17273309374796642, 0.1522781966208988, 0.1440610508512653, 0.16514143658117353, 0.15515186703943695, 0.1577516179126044, 0.1664105951237097, 0.1810570869580166, 0.18277068473743452, 0.1614031370288067, 0.1746132962278909, 0.1637807284486893, 0.10334180331869736, 0.09745937563303941, 0.11235031651554017, 0.10500753717898426, 0.11310810816430417, 0.10389151780035011, 0.12878838168027373, 0.13177041837521952, 0.1231542494692276, 0.1582147555789818, 0.14607204545591557, 0.16122573638139548, 0.18575415909374793, 0.15489838521520016, 0.15897259991245205, 0.15802612539313143, 0.1480758464891354, 0.15009747709304244, 0.15108002179414348, 0.14703105972042407, 0.14508067328969498, 0.1603556106417312, 0.14523275214762377, 0.14779064001429143, 0.14192467490193794, 0.1514513559973133, 0.13183893954098402, 0.17607680434878126, 0.1932286796197975, 0.1526658298611886, 0.15783829627877144, 0.1386817146191115, 0.18277094493053037, 0.15080967514338917, 0.15862871513171906, 0.16254608009646165, 0.15671122894345557, 0.14903601547492307, 0.15611808880675893, 0.15910071187195607, 0.1681409060571013, 0.23548441765272987, 0.22242590693467268, 0.16060368232941857, 0.16902655147927004, 0.180636182846327, 0.17214947335131514, 0.17672508290644617, 0.17323809621570485, 0.1780169405080605, 0.18045113537185498, 0.1867722839204241, 0.17354014798086537, 0.18350580880532674, 0.052447380305579494, 0.048809510566009684, 0.04741987101466416, 0.05070484081025084, 0.05446936998393137, 0.042549409273564875, 0.0509817579643268, 0.05862432788729688, 0.04793609388127773]}, "mutation_prompt": null}
{"id": "251fe3fc-4032-42f8-92a7-6d8cc839e130", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.9, 1.1)  # Adjusted self-adaptation\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget) * np.random.uniform(0.9, 1.1)  # Adjusted self-adaptation\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduce self-adaptation in mutation and crossover rates to improve convergence and robustness.", "configspace": "", "generation": 88, "fitness": 0.11513869905515184, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.15.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.17254529023967302, 0.17098158278998565, 0.14893904622455245, 0.16007910294346472, 0.15597398247230376, 0.17373497573205965, 0.1665942444462113, 0.16615581794747014, 0.21906723968159458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04230094354581837, 0.05682466132594932, 0.06658625084899994, 0.04821778571911073, 0.044067030750826186, 0.03824265949605199, 0.04315140569718645, 0.06932066243850366, 0.04128982566057471, 0.04285844091983382, 0.017820433739713426, 0.05084997931628821, 0.024088054259716718, 0.025859934761654046, 0.0357351346971323, 0.02083754059268017, 0.02234052221379157, 0.03209791113920435, 0.15776642042343136, 0.9249138762049582, 0.9348746195869899, 0.9309232901396041, 0.7206923337706195, 0.22315696281128405, 0.21259682367641475, 0.9798852655019129, 0.9745958220920247, 0.08067177610356102, 0.08232107320316062, 0.06804302027788034, 0.07877796266576786, 0.0891597087068009, 0.0769977279950883, 0.07130889208012448, 0.08890856362277066, 0.07935719888646231, 0.1439262216000209, 0.10892797072883098, 0.13805022526522825, 0.09797270112526546, 0.11356517167913827, 0.14260441890838538, 0.1401929653863765, 0.159656899649112, 0.121426017973713, 0.00659540052394636, 9.999999999998899e-05, 0.0028464826172966973, 0.00013635277633838871, 0.017990602711884685, 0.009649727829509902, 0.005187058460368266, 0.0015921345809388754, 9.999999999998899e-05, 9.999999999998899e-05, 0.03334566345520018, 0.002568364832475134, 0.016655847410793845, 0.007851011380702433, 0.010983495724323444, 0.0009848558986778055, 0.006661675280649759, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04362453164212188, 0.050035525750700804, 0.07422344721328622, 0.07336977388146004, 0.04367063794236714, 0.011488039451209464, 0.037428741795621834, 0.03413758028494662, 0.07868373592213629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009238280020421596, 9.999999999998899e-05, 9.999999999998899e-05, 0.18134590236014692, 0.19375496582687646, 0.191929849241122, 0.19185876807333313, 0.19285498798035172, 0.19534688202331807, 0.1931371376168144, 0.20941574028821053, 0.20388557150286513, 0.04518464028720459, 0.028204862149049603, 0.05185529514904519, 0.035688105506913925, 0.03750593868991403, 0.07118833948829983, 0.03245854801589432, 0.03773484654401349, 0.03940178331179556, 0.14065615155749545, 0.15116350600203388, 0.15049301485506383, 0.14852454597206632, 0.14861782443552873, 0.18035112736389836, 0.14163534900223917, 0.12718046798881566, 0.19840374645252323, 0.17895755608311115, 0.16636835197962208, 0.15694314072930537, 0.16436275033946457, 0.1700187993337824, 0.16475420511671401, 0.14724625738565444, 0.17377774300845283, 0.17355379313004848, 0.13449778993010109, 0.11648588560523898, 0.11302188651602685, 0.12018580216792396, 0.11627711464668378, 0.10473326666303306, 0.10819809259112567, 0.10265859730350946, 0.11108178071141106, 0.183389206435001, 0.16921552251556482, 0.15626885878991503, 0.16587717456406226, 0.1414919768471511, 0.15796361455496788, 0.14635980945409077, 0.1630167937189443, 0.149337425050184, 0.13808088519088924, 0.14110736018735748, 0.12056659626771271, 0.1343036804327894, 0.1389800675575823, 0.14318257389086908, 0.14897451192642963, 0.14396021655794045, 0.15028247009308393, 0.16096144655742806, 0.19695106682507635, 0.14768139574560935, 0.15488361686016794, 0.16306241761031537, 0.15577886767800642, 0.14654524499496113, 0.16023235754273557, 0.16203451596308516, 0.201580687621697, 0.16819730414434975, 0.2231910832467987, 0.14224291231732278, 0.1744276411921295, 0.2408118039249728, 0.1633790946163466, 0.20002484115477692, 0.20250983917410093, 0.1984929279587171, 0.1840483437445496, 0.17252198697148036, 0.18911497800457233, 0.170332304250863, 0.18038751130174047, 0.1920839868009644, 0.18694174684724107, 0.2161394327144479, 0.05256448150757298, 0.054429007941583785, 0.05090684001439516, 0.06192725894943074, 0.05043328553399007, 0.05499791988711744, 0.04765278809030293, 0.05783577536651463, 0.06870947084419854]}, "mutation_prompt": null}
{"id": "281a4f08-e814-40ff-874c-ff5ea54f34dc", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "01a52f55-bc73-4d55-91c7-905897a47c4b", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.65 * mutant + 0.35 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy with adaptive scaling factor and population diversity management for improved convergence.", "configspace": "", "generation": 90, "fitness": 0.12592271507870545, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.17849259879650892, 0.18632480287353215, 0.17712672398646823, 0.186403329574776, 0.19500890217944444, 0.1656535790385506, 0.20295812597930707, 0.17037386765840679, 0.1721253218998634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462844380780405, 0.06604436736283403, 0.05691064558382464, 0.04826790015821858, 0.048485527047552934, 0.045497283640256736, 0.03917103226346863, 0.03831347409609975, 0.044030523565417035, 0.03062132723001565, 0.029077972341324365, 0.040062418844057146, 0.06443281367726417, 0.034434672987800674, 0.041453633725979655, 0.04067639592823036, 0.03586979085896824, 0.025530112433016616, 0.9276721410060251, 0.9959785458068922, 0.9214365915263221, 0.841410588088881, 0.9314591147450733, 0.8804930980533421, 0.9813948604612058, 0.9874770476542578, 0.9860588464554741, 0.06264896147014187, 0.08659418479582659, 0.06676538684785338, 0.11473434358633183, 0.07215337890250262, 0.06934397465472208, 0.09425543938006808, 0.08853306770463931, 0.08198778564582876, 0.1302171116158961, 0.11374385778987084, 0.1092468976723261, 0.11836679394503025, 0.13499523769562005, 0.11183892272065388, 0.1343923902086006, 0.13207168684981496, 0.15114496577387582, 0.0007746949638509637, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031170606326568207, 9.999999999998899e-05, 9.999999999998899e-05, 0.016693568210013665, 0.0684547510566128, 0.03042473839600457, 0.029628290567347393, 9.999999999998899e-05, 0.000393062926552723, 9.999999999998899e-05, 9.999999999998899e-05, 0.013520507264463966, 0.003770373951828554, 0.00027763549205106486, 0.024293752966197957, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04414358580873956, 0.026758256638866662, 0.044253777295517494, 0.047347111294969935, 0.025112610394601997, 0.01043442452431731, 0.04866592427680638, 0.0593314247443959, 0.039729889935302576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016848275770420251, 0.005688972457092101, 9.999999999998899e-05, 0.0024326813760184862, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1886342687798619, 0.1985375453491528, 0.21870325817057779, 0.1886440408518858, 0.2161976376821565, 0.20033343524928948, 0.2087397920522075, 0.2206023934801815, 0.20227366331570362, 0.03596452296678321, 0.03705505356223415, 0.0362754207300513, 0.04664427153909945, 0.0477546754118745, 0.04528737937945171, 0.04570391165381171, 0.05313085532236472, 0.05079749024625457, 0.1348353236973575, 0.13406771757516622, 0.13933677070301398, 0.14078783904714565, 0.14472780022040566, 0.12927334314885452, 0.17273309374796642, 0.1522781966208988, 0.1440610508512653, 0.16514143658117353, 0.15515186703943695, 0.1577516179126044, 0.1664105951237097, 0.1810570869580166, 0.18277068473743452, 0.1614031370288067, 0.1746132962278909, 0.1637807284486893, 0.10334180331869736, 0.09745937563303941, 0.11235031651554017, 0.10500753717898426, 0.11310810816430417, 0.10389151780035011, 0.12878838168027373, 0.13177041837521952, 0.1231542494692276, 0.1582147555789818, 0.14607204545591557, 0.16122573638139548, 0.18575415909374793, 0.15489838521520016, 0.15897259991245205, 0.15802612539313143, 0.1480758464891354, 0.15009747709304244, 0.15108002179414348, 0.14703105972042407, 0.14508067328969498, 0.1603556106417312, 0.14523275214762377, 0.14779064001429143, 0.14192467490193794, 0.1514513559973133, 0.13183893954098402, 0.17607680434878126, 0.1932286796197975, 0.1526658298611886, 0.15783829627877144, 0.1386817146191115, 0.18277094493053037, 0.15080967514338917, 0.15862871513171906, 0.16254608009646165, 0.15671122894345557, 0.14903601547492307, 0.15611808880675893, 0.15910071187195607, 0.1681409060571013, 0.23548441765272987, 0.22242590693467268, 0.16060368232941857, 0.16902655147927004, 0.180636182846327, 0.17214947335131514, 0.17672508290644617, 0.17323809621570485, 0.1780169405080605, 0.18045113537185498, 0.1867722839204241, 0.17354014798086537, 0.18350580880532674, 0.052447380305579494, 0.048809510566009684, 0.04741987101466416, 0.05070484081025084, 0.05446936998393137, 0.042549409273564875, 0.0509817579643268, 0.05862432788729688, 0.04793609388127773]}, "mutation_prompt": null}
{"id": "c2980c3f-d36c-4acd-b75d-d5fd9ddc9982", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "aed66db9-8737-484f-b572-23141dc70e3a", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        diversity = np.mean(np.std(self.population, axis=0))  # Calculate population diversity\n        adaptive_F = self.F * (1 + np.log10(1 + diversity))  # Adjust F based on diversity\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduce adaptive mutation scaling based on population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.10563682413015837, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1536747940010782, 0.2144688925008601, 0.17927676772738776, 0.20635301890151692, 0.17854503917237996, 0.16914718405124352, 0.16582722079468715, 0.1565135401380383, 0.1825964512070669, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05444424837384343, 0.04486021329819212, 0.05995127032829184, 0.043244832116327236, 0.04868371490738432, 0.054769150621447826, 0.03942503055589264, 0.05786491056044174, 0.0383887675135951, 0.028780368088049735, 0.026008868221064185, 0.03429025831411037, 0.028107119574677042, 0.028532591592456136, 0.03193885560917464, 0.030282692956124957, 0.03535462328755834, 0.033016039007970566, 0.818630386171566, 0.8749740210314354, 0.22488679833643932, 0.2058217839739035, 0.3199074965294443, 0.16909139159553233, 0.1831422753438534, 0.157703027101585, 0.8259649706870275, 0.10648232775357158, 0.08394959334352314, 0.09922284771075096, 0.07739378659997931, 0.07057116415387721, 0.0703837778946036, 0.08199339030603547, 0.08849079726392628, 0.11046075920818965, 0.14130149607822584, 0.1377723017888135, 0.13187693355477026, 0.10531941743002915, 0.140705851593656, 0.09818053033304808, 0.14352134848315012, 0.14270004056464092, 0.16477150576428212, 9.999999999998899e-05, 0.018938431828127267, 9.999999999998899e-05, 9.999999999998899e-05, 0.014921830187265561, 9.999999999998899e-05, 0.02737001688335372, 0.007290730998724793, 0.0022358972694724866, 0.007727042072315449, 9.999999999998899e-05, 0.0011919794949830642, 0.0016193145389709063, 0.021260476437708342, 0.060709830745289906, 0.004274686436953945, 0.013173106377946664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07485930835788024, 0.0661671507944771, 0.04132504400159176, 0.04744433150585814, 0.04752484104661525, 0.044847897759326405, 0.04174819516534012, 0.09107897720348468, 0.05925896885320492, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006334788369035449, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004530713329710112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2353329389807195, 0.18951124428352395, 0.19461440864742574, 0.1975460106477468, 0.1875679344391924, 0.1947561969861593, 0.18515537744733745, 0.18470896010593674, 0.18132980509763996, 0.05172131991651929, 0.038285359414747866, 0.03505186150514095, 0.04628764404067842, 0.04243172161823727, 0.05851832853613104, 0.06637179606395671, 0.06339830885798015, 0.04479437623121796, 0.1252013781145388, 0.14632666838343333, 0.1288513690323565, 0.21937521156766404, 0.12481006177822895, 0.1516074338280159, 0.13686896807914384, 0.12383479417473786, 0.13986496739636345, 0.15127135348967913, 0.17613575058968856, 0.15241223589592245, 0.16012357457312842, 0.16851114798707845, 0.16941260484626242, 0.16272962473145347, 0.18961682503625832, 0.1545571366871955, 0.09314630700681081, 0.10813445184354664, 0.11119392291257468, 0.10726148598545282, 0.10720661865475722, 0.11874984402131017, 0.12701942871744065, 0.10525862552083076, 0.10255203572379235, 0.16605567910918306, 0.17022747910175673, 0.1732562357757239, 0.15582289099685298, 0.16744867711085787, 0.14797899810129833, 0.17968815280926587, 0.1543523046915709, 0.15325536238519055, 0.1427609833857083, 0.15511178378042534, 0.1384184203397213, 0.16205061208504035, 0.16174995205893394, 0.13935875428756606, 0.1643552243889479, 0.14275928036488983, 0.1329771550361296, 0.17159494027024524, 0.193036143590952, 0.13575025361107051, 0.22334092104452652, 0.13380824309943096, 0.18450882425888748, 0.18999150873144255, 0.15901684211183786, 0.15276632032650128, 0.1556710972358527, 0.18009063397943337, 0.13109544462490452, 0.2145937262727996, 0.23452862907388794, 0.20181419298149317, 0.14502001470842074, 0.12954863771156766, 0.16135483792443006, 0.18152300145241929, 0.19377679665610426, 0.18289632797344435, 0.18458606948340384, 0.18140054886344348, 0.18623727865057138, 0.18131205555143892, 0.18353716820639465, 0.18024845065221728, 0.05867007122556278, 0.06044702809676361, 0.05359264645136319, 0.05434560419711254, 0.052161386657448405, 0.06636874126932257, 0.05182269365802039, 0.04582810778623847, 0.048901056840614965]}, "mutation_prompt": null}
{"id": "9a886f22-4f65-409f-af1f-2f20774541dd", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.6, 1.4)  # slight change\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.6, 1.4)  # slight change\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "A refined DE algorithm with enhanced crossover strategy and adaptive mutation factor to improve convergence.", "configspace": "", "generation": 93, "fitness": 0.12043373245227117, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.17.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.16439997438770193, 0.14758455231525058, 0.15869736813304858, 0.18520817222165253, 0.19591652026892292, 0.1708167802392918, 0.17273620710007764, 0.16596598821631126, 0.16871324762067275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05572246980053519, 0.04448480263195964, 0.038440252579612255, 0.04297011657966521, 0.04054969288646004, 0.055816582788446034, 0.04572210364484075, 0.04495213418542843, 0.05441356351718207, 0.03463859390807489, 0.022780340555340284, 0.03939795865979612, 0.05321437998946099, 0.027022305079150488, 0.02205798350163335, 0.026547370450677565, 0.03722784932024137, 0.025679311782749625, 0.9276436080399753, 0.848176539133913, 0.9118266938090143, 0.25153162068451007, 0.930857863672084, 0.8782134238049795, 0.9813716346206895, 0.9874180194113376, 0.9863022932394405, 0.05504508235599859, 0.08669234765445144, 0.06624563815347029, 0.08315465406715505, 0.07611416943409277, 0.07784406397914112, 0.1042852140100975, 0.07733533733872522, 0.09371261057795177, 0.12945424824284402, 0.11392162774963177, 0.11306189759775376, 0.10901668418842614, 0.15556973388004824, 0.11391046532959626, 0.12387120197616786, 0.11360921116016964, 0.11748999816206773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008259213381572206, 0.021497178133614403, 9.999999999998899e-05, 0.002082571103544595, 0.05338936489117674, 0.030507906055627587, 0.018344111802626295, 9.999999999998899e-05, 0.04821426170715348, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005937676430640915, 9.999999999998899e-05, 0.017939544887804137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09142784912068469, 0.040645327053185576, 0.07512540997939465, 0.02456450839308677, 0.06249743081903181, 0.03998794842126896, 0.055489635637548274, 0.04081238681457233, 0.06156428742765763, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018013273937135255, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006237849962879016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1894769928854565, 0.2090452682375743, 0.19137236194815022, 0.19458892839103414, 0.20049961886882073, 0.1899485357344628, 0.19714017533736428, 0.20626691644099604, 0.1889038405490887, 0.03272130204895529, 0.04353277081145501, 0.039217071042460194, 0.04069783668396609, 0.048496037520444624, 0.03969210414700408, 0.045521106230061004, 0.03526899216183488, 0.048632762388653106, 0.12719566661667303, 0.15181788814744845, 0.13795067335011935, 0.1470090084338006, 0.1378342779188826, 0.12722839405344044, 0.12700957696058357, 0.18392142513422483, 0.12951287292593716, 0.1592077991823031, 0.163128376539861, 0.174237661637485, 0.15582923724689646, 0.1534770830535317, 0.17080523594028785, 0.1711555941808507, 0.17377774300845283, 0.15645738869818704, 0.10937833203021141, 0.09501548068383436, 0.10685362085343053, 0.0980736286160252, 0.10527295988661467, 0.10657870029557948, 0.10802732181921382, 0.11039826870069869, 0.10615261097694129, 0.18570448232175019, 0.1480230226138075, 0.1477573246702013, 0.1741773524400957, 0.15184057722963773, 0.15908790512567794, 0.13786670601415973, 0.16230066887854078, 0.17976360357988108, 0.14502286398639286, 0.12006085223432983, 0.13921774106083118, 0.15367352934521095, 0.13496993524431822, 0.1358549238056307, 0.14145155870289217, 0.14478452659021146, 0.12164431361194017, 0.1580006651773812, 0.17107391133887595, 0.14692980015340162, 0.1408919405671908, 0.14972283341139103, 0.16357038571044613, 0.14752435045200296, 0.1530379025868106, 0.17248651864177844, 0.15962381628739242, 0.17158643858554057, 0.1609488091267176, 0.15185144497430447, 0.17374251217651349, 0.124595012787732, 0.2189199624114393, 0.13925037622425573, 0.16303542323479236, 0.1922445730744473, 0.1856060771787258, 0.18227899876749365, 0.18824687965079534, 0.1997771215097307, 0.17807240749443265, 0.18673940856134907, 0.20116671495733118, 0.180025255152804, 0.058876008004199676, 0.05863807996662895, 0.05148784223834868, 0.04702369038664511, 0.04305209294365209, 0.06170185657760252, 0.06610301328622403, 0.04465534844910268, 0.043303172780178145]}, "mutation_prompt": null}
{"id": "98263e52-1583-47df-93c9-f38e366e8d2f", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "90190028-b411-4d02-871d-18493e95750b", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "dd77aa45-d8af-4a14-aa0c-912393d304b5", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
{"id": "e56b628d-7739-4ee3-b197-ced3cf157517", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.log1p((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Introduce an adaptive mutation factor that increases non-linearly to enhance exploration during early evaluations.", "configspace": "", "generation": 97, "fitness": 0.12097048767321039, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.17.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.18308190536145785, 0.21200651744706378, 0.16021535839245116, 0.18554818854050836, 0.2004738367937442, 0.16370114227669874, 0.20280855919676644, 0.1873962185754916, 0.19196267654927102, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07086027668543371, 0.06345786444688983, 0.04169352464535747, 0.04793595903291992, 0.045934701313987136, 0.042723128209045, 0.04232205135602052, 0.05147262328111213, 0.046474077693920646, 0.0337181158360641, 0.02909228351079196, 0.027462007003109634, 0.053860375753331025, 0.0300542959986857, 0.02854694512068745, 0.02755937383946494, 0.03821551501240794, 0.031814819436567277, 0.9252551038838238, 0.8456671891459411, 0.9199933809575375, 0.9452186095037821, 0.9315752875382222, 0.20510367626231407, 0.9813340479640668, 0.18723348476606216, 0.9860716736601637, 0.06329163657751924, 0.08172935189659691, 0.07299384592721525, 0.0976531211726086, 0.06198725685802875, 0.07916175753430921, 0.11226866507060818, 0.06853588954103274, 0.08337718529084526, 0.1384356867089367, 0.11164167935431613, 0.1162519932254561, 0.1649458672314975, 0.1489816282181533, 0.11597485919714012, 0.17398304379091134, 0.139378701693873, 0.11948642450616898, 0.00015079002483198156, 0.01585219693918316, 0.024973646573247077, 0.0037445057071101573, 0.0024637105111080526, 0.015163137999730458, 0.019769081066331462, 0.06921561248626584, 0.03184273377709157, 0.0058830787601720225, 9.999999999998899e-05, 0.026409450372654852, 9.999999999998899e-05, 9.999999999998899e-05, 0.030734537581684207, 0.013053890157843306, 0.000402776331322241, 0.043987574442375665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04203302723296842, 0.06468242295576687, 0.06376504846331499, 0.055457675386487826, 0.05594345154019853, 0.047033521740352136, 0.04023368977476116, 0.07358886489278482, 0.04093222750056735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020305253197148154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18905674558269525, 0.19684728717098365, 0.21485179994429782, 0.20247717368024742, 0.19087026115667316, 0.19998204959608623, 0.1896138193228163, 0.21378176896612644, 0.20516397748568382, 0.048585769450176675, 0.046026164068542874, 0.03773127895469619, 0.048309686421936227, 0.03776849982440822, 0.03883668108430738, 0.05172020638411612, 0.04461703215087798, 0.0428343883540685, 0.13816346784278977, 0.16318932091932914, 0.1395623238305871, 0.18561677959329614, 0.14175254886748645, 0.14397774137655417, 0.14507641793921267, 0.15798617427785788, 0.13627018065673424, 0.17359553642940795, 0.17780980298995452, 0.16253796850673385, 0.15958967285355774, 0.17003281644978685, 0.16449457920400723, 0.17498616524676913, 0.17377774300845283, 0.15648631987093609, 0.11613496827883996, 0.09401013536581426, 0.10501769346585754, 0.10998934560561124, 0.10150617113172378, 0.12727000016866152, 0.10788379481234589, 0.115226705392099, 0.13404105743269445, 0.149013021335058, 0.17574999547415915, 0.16733456447807182, 0.14900349852482708, 0.14838784597148535, 0.15059282782134165, 0.16569128357675633, 0.14259464617329853, 0.1763723208386615, 0.14380692819811325, 0.149136789154393, 0.14339922456311538, 0.16810427736494693, 0.14830240453773236, 0.14924016889192293, 0.15434931565756793, 0.14589370727530382, 0.1322344466062163, 0.16290749579471775, 0.12925203813131125, 0.16240683630551644, 0.16659912367652763, 0.1639034033886665, 0.2077431681271803, 0.22253852424650633, 0.16184569731062515, 0.15703329343668215, 0.16448710793575516, 0.16746661274031505, 0.155221393372997, 0.15830272477168805, 0.1741146368074622, 0.12978713329239366, 0.17686988277929738, 0.17548719450707762, 0.16233851774640629, 0.18859793843126504, 0.17414658807470473, 0.18011933976136407, 0.18971220946638734, 0.18074445667143357, 0.1973786742810777, 0.2115333880260878, 0.18020222431788713, 0.18281156863943404, 0.05092450532167092, 0.05893362496424415, 0.05817340755640832, 0.04647406580580804, 0.05393906320587827, 0.047851204109098044, 0.06048222767279399, 0.06558765492784902, 0.05837055792586254]}, "mutation_prompt": null}
{"id": "fe931168-bc67-457e-b779-0ea12eff184e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.75 * mutant + 0.25 * self.population[best_idx]  # Adjusted weight\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (0.9 - self.eval_count / self.budget)  # slightly adjusted CR\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced DE algorithm with improved mutation and adaptive crossover for faster convergence.", "configspace": "", "generation": 98, "fitness": 0.1094303929594569, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.14.", "error": "", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.17569282898792538, 0.20217313199955278, 0.16368850792434386, 0.18266877299875428, 0.17917154507927002, 0.1677102919649326, 0.17002318962782503, 0.17148668309115545, 0.16699211594590901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04555224729491725, 0.036156009054962635, 0.04941737622902964, 0.05776949995425362, 0.042206546531477374, 0.04493087187288658, 0.047229002116701335, 0.03552690480043452, 0.04917964416142573, 0.03921897173910216, 0.02800774230089864, 0.03759688189130106, 0.04053609310066908, 0.03960805369535825, 0.02940576538719797, 0.025703648356853237, 0.027808366256374617, 0.03048921693147144, 0.14377718973545728, 0.8399414009207611, 0.8387428690408358, 0.22340778146775142, 0.9312417874077552, 0.9664965400387542, 0.9803333960626465, 0.2054500767468852, 0.17252142744621746, 0.0649005394054557, 0.06185080323901471, 0.11183314551569368, 0.1029153362863281, 0.07667557801865355, 0.06888954863106833, 0.09572583972604376, 0.0955401515322607, 0.07598997097177529, 0.12067230672585816, 0.10163694712072979, 0.11334898525561188, 0.14224263897661116, 0.11590609008488806, 0.11091273437895666, 0.11616001272918819, 0.10271572443962473, 0.13816616959217665, 0.009045624796182317, 9.999999999998899e-05, 0.0011156518774602109, 0.00383550831416124, 9.999999999998899e-05, 0.015571869588060117, 9.999999999998899e-05, 9.999999999998899e-05, 0.03345731523687867, 9.999999999998899e-05, 0.007332869752626592, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016796238913558192, 9.999999999998899e-05, 0.00021557287230966615, 0.0034204822444174887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04213932143445287, 0.032265854133547545, 0.053318339719545804, 0.04864829526968928, 0.02571269491776207, 0.06053804819540742, 0.06411464553843615, 0.060323952094200606, 0.050667223725316735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040404262544500025, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20214359123065195, 0.19987128905869, 0.19287640952450213, 0.20293311707591022, 0.1805573299011214, 0.17709445608623375, 0.21205179302551447, 0.20268790037591633, 0.2016866453433641, 0.037511420132086304, 0.03789546850534775, 0.06863811511685503, 0.04702594403714122, 0.05613581778264065, 0.03705724282942302, 0.041630870857699676, 0.04245738455966819, 0.04487182495314068, 0.14916878935491074, 0.17193177931156856, 0.17248536219507238, 0.15219819935049506, 0.1360481950195841, 0.17199354584066207, 0.1407129762753162, 0.12836278234989262, 0.13227194546920673, 0.16499131775183629, 0.15984562465417018, 0.1503692336796808, 0.1696106810835154, 0.18389219503525533, 0.16729368873248363, 0.15865623668118656, 0.17461433448381836, 0.16412266290020983, 0.09649600779783374, 0.1167751328217308, 0.10267672446121245, 0.10348420436170769, 0.10436968722073414, 0.1048047280497667, 0.09853793881343131, 0.11428518589712822, 0.10382898471899338, 0.13455307299633346, 0.1630959739769563, 0.1616944414183228, 0.15655053007416542, 0.1768826235024601, 0.1630700853310083, 0.14354510884611393, 0.14812814356805593, 0.146510743858294, 0.1489592755877922, 0.14546473467544596, 0.14372018298142097, 0.12732678809850784, 0.13558855624115862, 0.1259726932444719, 0.14214310025290744, 0.1418218293570046, 0.13757845590953988, 0.17111968142683764, 0.17666670025594844, 0.16866171714917377, 0.1587097977013434, 0.14491840195327255, 0.1647962164525918, 0.15413930992275893, 0.22064487368240537, 0.17057389799980738, 0.14911571495275544, 0.20005098751331696, 0.16009054062395423, 0.11993456588275386, 0.1595171257512018, 0.12581456181300021, 0.1681227351599236, 0.16796545353055992, 0.15826057329320498, 0.19178716897413484, 0.17138593757332798, 0.17601585956199073, 0.1887302822641096, 0.1891990831809287, 0.18416902352955622, 0.18226348027155204, 0.17520633189280266, 0.19069901768362507, 0.0571374936407929, 0.04349060001409111, 0.052861937982116025, 0.04638741230549581, 0.050539451754014975, 0.05206879163778744, 0.08378374604788663, 0.05191248279761307, 0.047757982768333984]}, "mutation_prompt": null}
{"id": "8b5d418c-c447-4301-918e-c1b84960ef6e", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        \n        self.population_size = max(5, 4 * self.dim)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.F = 0.8  # mutation factor\n        self.CR_initial = 0.9  # initial crossover probability\n        self.eval_count = 0\n        \n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        \n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        dynamic_balance = 1 + np.sqrt((self.budget - self.eval_count) / self.budget)\n        adaptive_F = self.F * dynamic_balance * np.random.uniform(0.5, 1.5)\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = 0.7 * mutant + 0.3 * self.population[best_idx]  # Weighted average with best\n        return np.clip(mutant, self.lb, self.ub)\n\n    def _crossover(self, target, mutant):\n        CR = self.CR_initial * (1.0 - self.eval_count / self.budget)  # dynamic CR adjustment\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        \n        adaptive_factor = np.random.uniform(0.5, 1.5)\n        trial = np.clip(adaptive_factor * trial + (1 - adaptive_factor) * target, self.lb, self.ub)\n\n        return trial\n\n    def _select(self, idx, trial_vector, trial_fitness):\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial_vector\n            self.fitness[idx] = trial_fitness\n\n    def _adaptive_population(self):\n        if self.eval_count < self.budget // 3:\n            self.population_size = int(self.population_size * 1.5)\n        elif 2 * self.budget // 3 < self.eval_count:\n            self.population_size = max(5, self.population_size // 2)\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def __call__(self, func):\n        self._evaluate_population(func)\n        while self.eval_count < self.budget:\n            self._adaptive_population()\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self._mutate(i)\n                trial_vector = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                self._select(i, trial_vector, trial_fitness)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDEOptimizer", "description": "Enhanced mutation strategy using a weighted average of the best individual to improve convergence rate.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "01475d93-e36c-4c97-9d52-c064955b8dcd", "metadata": {"aucs": [0.1766094495990379, 0.17324132957208915, 0.1737951048288887, 0.1836951321229452, 0.19133433991029292, 0.16089863372831492, 0.19318646884895585, 0.16571591102729377, 0.19519899536056906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05687110878436419, 0.07491150582116224, 0.03652584538437209, 0.041739460363480974, 0.060045374905734805, 0.05013511454811237, 0.0479756709353345, 0.043652581346224406, 0.048888274606824544, 0.032580405474890495, 0.025183382150742006, 0.022418663373053316, 0.05443551696100113, 0.02890150479498721, 0.02861122764304369, 0.03469391289058987, 0.03594207853650733, 0.027511023491953557, 0.927654695449462, 0.8468289123774091, 0.9218013080791241, 0.9452931388853247, 0.9315853791167847, 0.8837390996428197, 0.9813662725617537, 0.9874242428097961, 0.9861544381530201, 0.05482785876105356, 0.05546112987050089, 0.11437051347821403, 0.10854095756706028, 0.07521267290164502, 0.0520008360008587, 0.09443921515125853, 0.09168397890623214, 0.08217219181592772, 0.1268063317497874, 0.12299535327323541, 0.11646575991906649, 0.1032646989810373, 0.11572979434553543, 0.11837676260238017, 0.13204961170217688, 0.11477171700005251, 0.11960702299945825, 0.00012464213916096867, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011887986298739772, 0.014566422885550878, 9.999999999998899e-05, 0.012006207870386087, 0.0684547510566128, 0.06294048931284157, 0.07133104500759979, 9.999999999998899e-05, 0.006634382299495312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001006257178535197, 0.004406923585033473, 0.0002675854486984264, 0.005795262258751932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07140935431502182, 0.06726434706471296, 0.03919407417481502, 0.0741809054370226, 0.07927646255306864, 0.04405934955704638, 0.08493949088692587, 0.046622327363512905, 0.08619387191876104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004140815533497322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019603114495636564, 0.18443905352299916, 0.18776990889356526, 0.2059744416592434, 0.1925859108960093, 0.2099796342825413, 0.1997759548743857, 0.19728815812319112, 0.2178918776337151, 0.19891243604322606, 0.03505453924457447, 0.03888044279156189, 0.03715883811650289, 0.05324031142471508, 0.034554218517888535, 0.046904938195257984, 0.05574539365766107, 0.05680308057047312, 0.04465919020082454, 0.1509542607787533, 0.13039696394770472, 0.12898719867293673, 0.1374756668465903, 0.13204141100127287, 0.1362105480908793, 0.13714941895607757, 0.15537061751632208, 0.1411782845079721, 0.16434911938919705, 0.16343689798792582, 0.15565009860838996, 0.1606644558007969, 0.1658235430356494, 0.16451285632109391, 0.16441497399460236, 0.17377774300845283, 0.16832928935129676, 0.09688474576771844, 0.09339110384003324, 0.10892094695323917, 0.1055324827838775, 0.11015982014932124, 0.10672692572405429, 0.10754149031375182, 0.13714671181331217, 0.11021855925659785, 0.1504870748003304, 0.16564447033860485, 0.160335921050206, 0.15840841264148853, 0.15764051277398938, 0.16916983975580713, 0.1755358352406694, 0.1542893329075843, 0.15460645394218686, 0.1450428133943793, 0.15573709447323125, 0.14264685689040213, 0.1470932829451862, 0.14181585240293137, 0.13773024559317748, 0.15059349596863125, 0.14766691314091296, 0.13188931656388125, 0.1802958049527128, 0.17104933167916936, 0.20308611895389472, 0.1495168563314162, 0.14136454093362139, 0.16327413323707607, 0.17109362027209096, 0.18073275677193046, 0.16001624288026683, 0.16212211159232903, 0.1717726228373061, 0.15810616821596235, 0.196285690000213, 0.15639210196882358, 0.14405920645497938, 0.22505812127260838, 0.13718942912230814, 0.2266897384800728, 0.1799172243434748, 0.23800381588451092, 0.1860042348980765, 0.19710909229663998, 0.19238077953175992, 0.18333250617224006, 0.17348697458469342, 0.18969432146518128, 0.18261258208205278, 0.05611378141761869, 0.05240485359195668, 0.05066565710239179, 0.04617175217559111, 0.055090506403888684, 0.05330411036165972, 0.05451319680526334, 0.052974095519805475, 0.0503903541199372]}, "mutation_prompt": null}
