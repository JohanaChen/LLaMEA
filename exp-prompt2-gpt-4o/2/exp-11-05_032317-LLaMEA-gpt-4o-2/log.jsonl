{"id": "2f650511-9871-40e7-9dbc-4806707dd882", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 0, "fitness": 0.38961586939502635, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "461d5086-46c0-47a5-af74-50da2db139ba", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "a3628229-dd99-4fc5-aefe-9dff8e7336bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "778ca092-e921-47c8-84b7-953dce012ede", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "7bc38157-ee69-4aed-8147-09736f22deca", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "8aa1d0b7-ae87-4273-a8f1-1b49797edf0e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "8ed538c7-3d35-4cbf-90b4-cc5c48edfe86", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "3ccbb7a8-03a6-4c24-b9f1-a7d2faaee710", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "9f7d2afc-28f2-4e9f-af7e-7c8158554cfe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Dynamically adjust Crossover Probability\n                trial_ratio = self.fitness[i] / self.best_value if self.best_value > 0 else 1.0\n                current_CR = self.CR * (1 - 0.5 * trial_ratio)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < current_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover probability adjustment.", "configspace": "", "generation": 8, "fitness": 0.25493768057222266, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.7809689452986767, 0.7656301512045233, 0.775956065889456, 0.7944453772045156, 0.7825426987875782, 0.7658067310464642, 0.7910314577117897, 0.7916748813438219, 0.780019868339723, 0.585275661646603, 0.5754569929611572, 0.5711498303108337, 0.5537700998673821, 0.5873411050252741, 0.5764655034536873, 0.5663312564673593, 0.589036084124847, 0.6082333085587037, 0.3907838242529531, 0.4094791058001285, 0.3778247073483627, 0.4005053318926487, 0.35939855073022, 0.4054085305623292, 0.4205589222080325, 0.4119425865026817, 0.3584764161287436, 0.28837604676164275, 0.30182408817511786, 0.30050292233423903, 0.3764197440945253, 0.31420492573469605, 0.3458234389371252, 0.27538846420311724, 0.28474553194536467, 0.26450049911815954, 0.9110968771094192, 0.9210707577590066, 0.9243870750386356, 0.9239051019966247, 0.9539711407499208, 0.9400477821677932, 0.9258727513863343, 0.9217161532197277, 0.9404172530746443, 0.16622418029477926, 0.15331748748718887, 0.1464136055109755, 0.1359942038591786, 0.13639821694947207, 0.17546706612081397, 0.27623741001572855, 0.27778929239433436, 0.2447109402524168, 0.1893136880770412, 0.19568372486954755, 0.20807604437384986, 0.2545432109752127, 0.2516736082363593, 0.2510497349991083, 0.18096070827979915, 0.1789270334502393, 0.19811330024950113, 0.13797896379946284, 0.14598427666384728, 0.13637594034743883, 0.16633917431319423, 0.14617120857476895, 0.11085670844075013, 0.16278538944761745, 0.19457427530649862, 0.1765862482178412, 0.10950014835782151, 0.10134992613288019, 0.09566727908274464, 0.147452762563009, 0.11262557246073412, 0.12940845151325087, 0.1115030618495153, 0.09238942061130218, 0.10965028749403138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07603600245482389, 0.044562092948637444, 0.08153111030717641, 0.07112984914261944, 0.07029650112169517, 0.05296371220517504, 0.10833812497216877, 0.055648828014793095, 0.07617193521590726, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05901342282988187, 0.07097938075416099, 0.05518052439270782, 0.11124768725565515, 0.10853666372826787, 0.10713014251978625, 0.10888762488493064, 0.11187688026836362, 0.09734553206618857, 0.4651541532668103, 0.464183087206381, 0.4663428005652349, 0.46990963190700463, 0.4803471185172278, 0.4657779740468584, 0.5010014903468607, 0.4516674711373905, 0.4867910199767591, 0.08692328055650911, 0.10738880757433888, 0.09687708648409477, 0.07983375637300649, 0.0981939764780092, 0.09158191455875675, 0.08871240764731647, 0.10496558764504882, 0.09238866554264091, 0.1435392314554208, 0.13502375118074128, 0.13329409617910093, 0.15235739491679745, 0.16155320773822346, 0.13979928061902558, 0.14675523170434768, 0.1353307730674671, 0.13549160284693385, 0.258428992221838, 0.27353650361849435, 0.2835957977638224, 0.25309111662744754, 0.2436785300065194, 0.25991911935894196, 0.3369095719093327, 0.3211094610022256, 0.3345913639095186, 0.19251853181191914, 0.17645700341123371, 0.20283083770457855, 0.17150339486411503, 0.13139184338442877, 0.16803235809205563, 0.2075800843211405, 0.2135336644889414, 0.21865133791176328, 0.19454611868993232, 0.18636285165903255, 0.1796111526802615, 0.19894396665065983, 0.20447792833864809, 0.19849521009895377, 0.21933530493063658, 0.21396647021859627, 0.19883759376116406, 0.22331461931251773, 0.21640739450310964, 0.2509161913010475, 0.2079273583163872, 0.21129622097264045, 0.20937220603781548, 0.24147247105971636, 0.2048666125915185, 0.19865260201146961, 0.22115084654547879, 0.20803767439522924, 0.21148144631575272, 0.28060355016987404, 0.2545285579013221, 0.24071287926307816, 0.2267895812616746, 0.16948517951734177, 0.27555175553170097, 0.2349934597478166, 0.19964071074508827, 0.22348542921675285, 0.21506255989074485, 0.18445169924737215, 0.19578038458343716, 0.23068733776366845, 0.23717934030026044, 0.19951041066664998, 0.17656569656751675, 0.1752721856427868, 0.18914169836979078, 0.16958875605308188, 0.17979194025770706, 0.1975416264988935, 0.19399137116231446, 0.17932302694960622, 0.1906024066776668, 0.06927299437514611, 0.06990001274581814, 0.06984619207600318, 0.08247262710634573, 0.07181192055158192, 0.08237671496520194, 0.07207448352711798, 0.0684142387527572, 0.06551860804700538]}, "mutation_prompt": null}
{"id": "5bc76c5a-d88f-4e61-b0a7-8272e7124a70", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "325fc4d8-b286-4e82-a4ac-470d36f5b1f4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "1f07ec6b-ac07-4457-a9e5-b4d62051434b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Global and Local Search for Efficient Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "629e669d-f518-41d2-85ae-a2b5d4c1cde8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Dynamic scaling of F\n                self.F = 0.4 + 0.1 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating dynamic scaling of differential weight (F) for better convergence.", "configspace": "", "generation": 12, "fitness": 0.39077615963365936, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "2f650511-9871-40e7-9dbc-4806707dd882", "metadata": {"aucs": [0.8297182841857896, 0.8282464320004341, 0.8367520540077624, 0.8446696263136985, 0.8278631434464191, 0.8424977417601272, 0.8288146977944895, 0.845411887405288, 0.8302201225125871, 0.6895157078949935, 0.6990344274859308, 0.7102815416621178, 0.6891678047577936, 0.7296307979684201, 0.7071656987725825, 0.6724793073236556, 0.7343204135235022, 0.6888258718343354, 0.11589244522348441, 0.12300563997492353, 0.1296254726278394, 0.12661971714031295, 0.11302063938020313, 0.12038844374268609, 0.11865766141717471, 0.12112510918841002, 0.1141154402759732, 0.12413600414499237, 0.10898526728872782, 0.1179772296214795, 0.11091872902656164, 0.12823626745813432, 0.11082415471766294, 0.11363801958793052, 0.11999780178584374, 0.11081121833210927, 0.908136471073802, 0.8519783045514191, 0.8984992611895012, 0.8675354553567507, 0.8816536192862857, 0.8648907479508278, 0.8134104935206561, 0.8555292162912275, 0.7920347578392879, 0.37014283961731353, 0.5395022900710471, 0.388706433161792, 0.47364673013739433, 0.47193111044682223, 0.4766241884262391, 0.5457866211780849, 0.5091508866345607, 0.4872088058293358, 0.8309667361690838, 0.7976938833706654, 0.7988074600127195, 0.8368788411673194, 0.8324008633193495, 0.7969104580578795, 0.8165841413147171, 0.7821268325539148, 0.8202574794453527, 0.139486794115955, 0.1662832726633453, 0.27797098400106135, 0.19561226114473773, 0.20055348768774006, 0.17035107285518547, 0.18653416009191193, 0.19651622053260576, 0.19359303383090087, 0.24081008049272445, 0.13985408409551636, 0.1780125451737291, 0.15346625207959474, 0.1498106228208682, 0.20126481052699985, 0.17947990414284176, 0.19244981040787024, 0.18297991472354824, 0.06232325563889585, 0.4683489920633571, 0.4850956625170101, 0.5417816713972738, 0.5272196992988829, 0.5314272565979132, 0.5410427687273415, 0.5246751003210441, 0.5201022128800142, 0.5755728250491697, 0.6198604612508753, 0.6302041966489492, 0.5052640311760895, 0.5533798295016513, 0.6203237688142106, 0.5993624168885698, 0.6726929786202396, 0.6455107489155559, 0.06188596632620158, 0.08291177452352605, 0.14994720324079824, 0.24011401520024378, 0.17414475418723085, 0.1292607797284543, 0.19820958828744528, 0.13874395940865836, 0.21894177913729052, 0.3302560469468151, 0.3704580939997443, 0.3934821380559118, 0.3938919348082579, 0.4061889408777579, 0.38710902370364497, 0.16076129636324443, 0.36725161464233524, 0.3970302398523894, 0.7474321133446227, 0.7430585991416889, 0.7472999826304789, 0.7568863899128297, 0.7403877795910385, 0.7480043914207704, 0.7643078126480249, 0.726802120387358, 0.7574627811760377, 0.10467664396144649, 0.09677483583321211, 0.10918226713078316, 0.11003921095940628, 0.0992102927432843, 0.11524504527431367, 0.1036110410669715, 0.10655907208292625, 0.10394299435906107, 0.15340596252769834, 0.14135923354080837, 0.1417361689757527, 0.12353443413547904, 0.14057519230890647, 0.185414431126386, 0.19051355861951602, 0.14272705026012844, 0.14266296779849685, 0.45092781070722066, 0.4845469728508389, 0.47228638600926454, 0.45757852457186154, 0.44283628045654366, 0.4431652718560237, 0.5176886441427049, 0.49830889675331747, 0.48977107698647904, 0.3634637288781266, 0.36010693961044615, 0.35650016022350517, 0.378969653154937, 0.3577068165970687, 0.3468252751399732, 0.4156948316077207, 0.421319427328951, 0.36702380016295955, 0.20540311477381956, 0.20141615365324084, 0.2069722434986755, 0.2042036607797847, 0.21672511785467863, 0.20611280015661038, 0.20528643025409798, 0.19845896586871847, 0.19602164354547535, 0.19409200220960277, 0.3446967630478892, 0.20249328854125692, 0.19927101629591848, 0.226194816177132, 0.25842803577812956, 0.18410453940141924, 0.1894646600339841, 0.2234407396916933, 0.18186631148703636, 0.18370926535947252, 0.1926005450789875, 0.8123875813075709, 0.7717047086707457, 0.8204878722760207, 0.5510091547397676, 0.7072265409692433, 0.7357991440180591, 0.7824305428635848, 0.7479577859491839, 0.20288474200170847, 0.7175285121899979, 0.20201399403587372, 0.43872899040498337, 0.16015250792768454, 0.20852710343260372, 0.2111329507549522, 0.169313626019169, 0.1947743706626397, 0.17623385596942265, 0.1789070786345366, 0.1856492442081381, 0.18803267954149583, 0.1734562306182852, 0.18031106718739232, 0.20983106934162377, 0.0851652789126982, 0.08672566305872464, 0.08396323297985742, 0.08778835108311034, 0.08663681855282668, 0.08818471975409192, 0.07515630427818432, 0.07579285650875245, 0.08186883199264228]}, "mutation_prompt": null}
{"id": "710d0586-8823-4a9e-814c-6a5183d70847", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Dynamic scaling of F\n                self.F = 0.4 + 0.1 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating dynamic scaling of differential weight (F) for better convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "629e669d-f518-41d2-85ae-a2b5d4c1cde8", "metadata": {"aucs": [0.8297182841857896, 0.8282464320004341, 0.8367520540077624, 0.8446696263136985, 0.8278631434464191, 0.8424977417601272, 0.8288146977944895, 0.845411887405288, 0.8302201225125871, 0.6895157078949935, 0.6990344274859308, 0.7102815416621178, 0.6891678047577936, 0.7296307979684201, 0.7071656987725825, 0.6724793073236556, 0.7343204135235022, 0.6888258718343354, 0.11589244522348441, 0.12300563997492353, 0.1296254726278394, 0.12661971714031295, 0.11302063938020313, 0.12038844374268609, 0.11865766141717471, 0.12112510918841002, 0.1141154402759732, 0.12413600414499237, 0.10898526728872782, 0.1179772296214795, 0.11091872902656164, 0.12823626745813432, 0.11082415471766294, 0.11363801958793052, 0.11999780178584374, 0.11081121833210927, 0.908136471073802, 0.8519783045514191, 0.8984992611895012, 0.8675354553567507, 0.8816536192862857, 0.8648907479508278, 0.8134104935206561, 0.8555292162912275, 0.7920347578392879, 0.37014283961731353, 0.5395022900710471, 0.388706433161792, 0.47364673013739433, 0.47193111044682223, 0.4766241884262391, 0.5457866211780849, 0.5091508866345607, 0.4872088058293358, 0.8309667361690838, 0.7976938833706654, 0.7988074600127195, 0.8368788411673194, 0.8324008633193495, 0.7969104580578795, 0.8165841413147171, 0.7821268325539148, 0.8202574794453527, 0.139486794115955, 0.1662832726633453, 0.27797098400106135, 0.19561226114473773, 0.20055348768774006, 0.17035107285518547, 0.18653416009191193, 0.19651622053260576, 0.19359303383090087, 0.24081008049272445, 0.13985408409551636, 0.1780125451737291, 0.15346625207959474, 0.1498106228208682, 0.20126481052699985, 0.17947990414284176, 0.19244981040787024, 0.18297991472354824, 0.06232325563889585, 0.4683489920633571, 0.4850956625170101, 0.5417816713972738, 0.5272196992988829, 0.5314272565979132, 0.5410427687273415, 0.5246751003210441, 0.5201022128800142, 0.5755728250491697, 0.6198604612508753, 0.6302041966489492, 0.5052640311760895, 0.5533798295016513, 0.6203237688142106, 0.5993624168885698, 0.6726929786202396, 0.6455107489155559, 0.06188596632620158, 0.08291177452352605, 0.14994720324079824, 0.24011401520024378, 0.17414475418723085, 0.1292607797284543, 0.19820958828744528, 0.13874395940865836, 0.21894177913729052, 0.3302560469468151, 0.3704580939997443, 0.3934821380559118, 0.3938919348082579, 0.4061889408777579, 0.38710902370364497, 0.16076129636324443, 0.36725161464233524, 0.3970302398523894, 0.7474321133446227, 0.7430585991416889, 0.7472999826304789, 0.7568863899128297, 0.7403877795910385, 0.7480043914207704, 0.7643078126480249, 0.726802120387358, 0.7574627811760377, 0.10467664396144649, 0.09677483583321211, 0.10918226713078316, 0.11003921095940628, 0.0992102927432843, 0.11524504527431367, 0.1036110410669715, 0.10655907208292625, 0.10394299435906107, 0.15340596252769834, 0.14135923354080837, 0.1417361689757527, 0.12353443413547904, 0.14057519230890647, 0.185414431126386, 0.19051355861951602, 0.14272705026012844, 0.14266296779849685, 0.45092781070722066, 0.4845469728508389, 0.47228638600926454, 0.45757852457186154, 0.44283628045654366, 0.4431652718560237, 0.5176886441427049, 0.49830889675331747, 0.48977107698647904, 0.3634637288781266, 0.36010693961044615, 0.35650016022350517, 0.378969653154937, 0.3577068165970687, 0.3468252751399732, 0.4156948316077207, 0.421319427328951, 0.36702380016295955, 0.20540311477381956, 0.20141615365324084, 0.2069722434986755, 0.2042036607797847, 0.21672511785467863, 0.20611280015661038, 0.20528643025409798, 0.19845896586871847, 0.19602164354547535, 0.19409200220960277, 0.3446967630478892, 0.20249328854125692, 0.19927101629591848, 0.226194816177132, 0.25842803577812956, 0.18410453940141924, 0.1894646600339841, 0.2234407396916933, 0.18186631148703636, 0.18370926535947252, 0.1926005450789875, 0.8123875813075709, 0.7717047086707457, 0.8204878722760207, 0.5510091547397676, 0.7072265409692433, 0.7357991440180591, 0.7824305428635848, 0.7479577859491839, 0.20288474200170847, 0.7175285121899979, 0.20201399403587372, 0.43872899040498337, 0.16015250792768454, 0.20852710343260372, 0.2111329507549522, 0.169313626019169, 0.1947743706626397, 0.17623385596942265, 0.1789070786345366, 0.1856492442081381, 0.18803267954149583, 0.1734562306182852, 0.18031106718739232, 0.20983106934162377, 0.0851652789126982, 0.08672566305872464, 0.08396323297985742, 0.08778835108311034, 0.08663681855282668, 0.08818471975409192, 0.07515630427818432, 0.07579285650875245, 0.08186883199264228]}, "mutation_prompt": null}
{"id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 14, "fitness": 0.4029451381221956, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "629e669d-f518-41d2-85ae-a2b5d4c1cde8", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "2d4c9ad6-9516-4b22-9eda-0965c3320ddc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "8184ff0e-332b-4dea-9903-1836be50431a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "22c84961-02e2-4e1a-a196-bf99e26fe665", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n                \n                # Greedy Expansion Step\n                expansion = np.clip(mutant + 0.1 * (mutant - self.population[i]), self.bounds[0], self.bounds[1])\n                if func(expansion) < func(mutant):\n                    mutant = expansion\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a greedy expansion step after mutation to enhance exploration before crossover.", "configspace": "", "generation": 17, "fitness": 0.22646960250479772, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.5260487043286161, 0.5415848126019486, 0.511529542263027, 0.5408619435106239, 0.5167799012226398, 0.5424793401941171, 0.5054875537751748, 0.5229271964708186, 0.5032650449784941, 0.2432722176488562, 0.2651971051350731, 0.2654200007323956, 0.21591648135232056, 0.21708678628838962, 0.22295137062820525, 0.25067114322168815, 0.26979966022801993, 0.21373549269841308, 0.09887469944412552, 0.07683828809332949, 0.10340596237805966, 0.09695707195250924, 0.10464628551281407, 0.092223750325925, 0.10738404538974677, 0.09797587897828797, 0.08413107672981845, 0.08144094517588274, 0.07615540962840495, 0.08326683732658091, 0.088350014235965, 0.0798423403264733, 0.07849654893200608, 0.08208565278571345, 0.07893344757853615, 0.09241737309086306, 0.8478414635196894, 0.7141230735709119, 0.7915235670340862, 0.7051562028745662, 0.8352393023760643, 0.8922202160493964, 0.612122026927316, 0.7816522728150265, 0.686102668535952, 0.20746579567390933, 0.21909039018133447, 0.1831657940231327, 0.20719938602467713, 0.19577152303158107, 0.24748448071520535, 0.18675506605311853, 0.205400681366406, 0.22563388302873078, 0.4178989678354603, 0.33550101932711796, 0.4463393954709658, 0.5951274875144137, 0.5082063329798325, 0.3238050962210749, 0.4348583030260482, 0.469912242287025, 0.44126908661814146, 0.18635378584702755, 0.14056198721738233, 0.13841861521891186, 0.13892013335956066, 0.14314218463046235, 0.13558500533471596, 0.13688884650720412, 0.14209792002447308, 0.1260107137502844, 0.13845131996833115, 0.10120203465539812, 0.12052248123019749, 0.17050109658377588, 0.1303433860916281, 0.21021649466458392, 0.12207504399590707, 0.12585190452099482, 0.1268518041290173, 0.10149238035498453, 0.11988878391660707, 0.08756932121867689, 0.09909493429311445, 0.10182541708784543, 0.0648812443000375, 0.10087000061974682, 0.10666322315090748, 0.09869885743172868, 0.2316044927032237, 0.2284594753782201, 0.23612248864112761, 0.22448040654926704, 0.21399404788743193, 0.21649847511817533, 0.20941295343691735, 0.2569684290490052, 0.24117508765220808, 0.020100460952098054, 0.030180801388654643, 0.025553734703765985, 0.032801895669161474, 0.03411973346842767, 0.01895355147852429, 0.06715709137260584, 0.04487715485247534, 0.04527841533173993, 0.13225052264616244, 0.12236976837673696, 0.12829075663268175, 0.14068811295717987, 0.1344899123608111, 0.13906113214872984, 0.12998454117881464, 0.14686239562735515, 0.1537694312818787, 0.433060977007965, 0.41440830636898196, 0.4318269396608959, 0.4562104851953299, 0.42944122060331624, 0.4285415274002832, 0.43055743820574355, 0.4170434349293072, 0.4226933554764766, 0.12744590695412628, 0.08630596669456281, 0.0860587957803205, 0.07819260879417378, 0.09290606042588678, 0.09930655165293234, 0.09313726044340942, 0.07668808094129143, 0.08474227123732436, 0.13127359446517495, 0.13656668957415619, 0.14858111125277407, 0.12280895886844778, 0.15945440117489929, 0.12913923811360584, 0.17308865411295848, 0.13292405596117973, 0.1455818995099879, 0.2544142974690521, 0.26937035477077365, 0.2817128896995552, 0.283504615787159, 0.25312764387077913, 0.2723158912062281, 0.27556153015023976, 0.2839823254936724, 0.28227245108147947, 0.19078247400735793, 0.19901418871339416, 0.20032600769596287, 0.19399139500156948, 0.19538527972079478, 0.20442237238693617, 0.2133955248683277, 0.2163769768619882, 0.23657172245774094, 0.20561655727877204, 0.1726701034410626, 0.1725927558582202, 0.17681610708945938, 0.1788979958588769, 0.1872754911035729, 0.18653410028533401, 0.17187112767227697, 0.17024778777914107, 0.17199322641055836, 0.2039521572165217, 0.1849292100366824, 0.1781583210169656, 0.18919141558779762, 0.17871616007268554, 0.18295091159514543, 0.1834166972722837, 0.17231621352480286, 0.2113422667670496, 0.35724256627382756, 0.3662720532986443, 0.27912211930435116, 0.2785164087772434, 0.46063308210617737, 0.19732733606284591, 0.13711340338915612, 0.2974143469545196, 0.17653823096322108, 0.18701662857429047, 0.4865274036538514, 0.2870239438058464, 0.18517246501111928, 0.16257756365621368, 0.1944901402032626, 0.18901677242003034, 0.41811396914591137, 0.1828173876781728, 0.19573253985608707, 0.18823616116439967, 0.1657501541032178, 0.17283719887934657, 0.1872195676418138, 0.18266776584061117, 0.17919533918018538, 0.1756654171501234, 0.07613087916751138, 0.07460980804771311, 0.07130627766152231, 0.07458123891996893, 0.0698399645404324, 0.06832311546827063, 0.08117671189006781, 0.0698022876827239, 0.07163171545597247]}, "mutation_prompt": null}
{"id": "68c3fc00-dde8-4069-b47d-8720501788d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "c92be3e7-4704-422e-aac4-66fd0b0bb0f3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "defe8316-303f-4cab-bd84-68c0e4aa36cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "f606fc89-68fe-4a58-a045-c7dc10148904", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "49ec0c34-4224-4e75-a911-73d7d169f0ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Self-adaptive scheme for F and CR\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                # Generate mutant vector\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Update the best solution found\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a self-adaptive scheme for F and CR to improve convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8307213628886547, 0.8399853636427447, 0.8163583310744299, 0.8433682313861227, 0.8309386122547638, 0.8441105890133875, 0.8336728598062256, 0.8211666579265394, 0.8227041104752126, 0.6878296420311089, 0.6998852056650899, 0.7290028852856482, 0.7009193213509205, 0.6922032902997006, 0.7185888447983351, 0.7065447100083893, 0.685929350491508, 0.7001929001195957, 0.1257956035907991, 0.12731181283251403, 0.1321721502099079, 0.1100823594960606, 0.10456898172316964, 0.11444477969086697, 0.133113362710929, 0.13051113025638228, 0.12139855226509877, 0.11371967790929505, 0.11502450482510618, 0.12065612455094799, 0.10128437640140964, 0.1262301917259463, 0.1167320530510948, 0.10501506422428974, 0.11684777767158616, 0.10255622838379097, 0.9421224488700655, 0.903949295265557, 0.7648814915577211, 0.8272613472018702, 0.8984989423961949, 0.8692384211033382, 0.8030241828597398, 0.8978126704539748, 0.947871390803894, 0.3698129155378431, 0.550907040532852, 0.5740207074308509, 0.5751567221549669, 0.5017439103740671, 0.5438158801860482, 0.4896081844146044, 0.2688625758056572, 0.5304033999678659, 0.7939504747434871, 0.8385703850648749, 0.7882592925680033, 0.8086528658138079, 0.8424288019127751, 0.7836954014529596, 0.8051958351428435, 0.8073528742546046, 0.837646474989946, 0.5276337689026297, 0.21888463756042698, 0.21023087445759225, 0.24740313530878943, 0.24418494922802192, 0.2352739873570161, 0.21772148654706192, 0.25089659237705186, 0.2054435408474784, 0.2105967276039339, 0.20711619992274832, 0.1830156407606066, 0.18939970560735797, 0.24123195026921718, 0.1839924524817239, 0.25986054775697454, 0.19479183511660159, 0.25083422094742036, 0.5183166591663768, 0.456783917234971, 0.4994660580357614, 0.5415031956182748, 0.5015259407528188, 0.5182205453359406, 0.5101578219551887, 0.5331892514496026, 0.5117127826429271, 0.5886721479893083, 0.6425376555972737, 0.639815005102832, 0.5701351397322889, 0.5897930068378547, 0.5277996447523466, 0.6261642737913461, 0.6182412082709445, 0.6616575674316523, 0.15874669181589784, 0.08304361538557548, 0.260810914924659, 0.4220339589879446, 0.14655289259954773, 0.2495105147134714, 0.11900745805951951, 0.14227762382632358, 0.2200940874185049, 0.3858283879385116, 0.41759136930943164, 0.3811014920699888, 0.3898991585248244, 0.4218401171286563, 0.4087514036843741, 0.3855701513349309, 0.3980463201146456, 0.39492529028012346, 0.7509410037912893, 0.797019696852103, 0.7675486134929322, 0.7792667960922447, 0.7580558316370636, 0.7671139141821552, 0.7549395263011023, 0.734461876868095, 0.7712859264930261, 0.10100516041980412, 0.11269682854726637, 0.09655531416185603, 0.10776566304728386, 0.09200623698340915, 0.10849230652143538, 0.10403701622145878, 0.16072451352841055, 0.10428763519099649, 0.1488741615843363, 0.15598375017942212, 0.14889833515692097, 0.14370009508328552, 0.12502419209113158, 0.1634499676216239, 0.15683929467346513, 0.1583872216969746, 0.15094011639334948, 0.4528229783505634, 0.4854820811457413, 0.49196876731580974, 0.4578171825842169, 0.4349367215910275, 0.46179044151286586, 0.5366224062805067, 0.5404185031251929, 0.5217403062899384, 0.35792465532054973, 0.3668874557295202, 0.395275066898371, 0.36347623803744533, 0.36336274010305747, 0.37330884905628237, 0.3734531017218745, 0.3976156090538452, 0.3882344230539333, 0.20467474484305126, 0.2085639874420323, 0.18854456911870832, 0.20811623722819972, 0.20832410435502668, 0.21075781985018072, 0.19330377499384876, 0.19209588217861207, 0.19770144348880936, 0.29042953281403605, 0.49020665662168583, 0.207187694326895, 0.39581275203948785, 0.23644038171085835, 0.2968227432187025, 0.20557673125173248, 0.20708865007797972, 0.189837067432562, 0.16997072293081805, 0.20328150590394511, 0.20781979859573152, 0.8036015442923586, 0.811388918030959, 0.7708902687514334, 0.7178610267878694, 0.5161758878634, 0.7926592809085564, 0.1944605918480533, 0.20163231069747412, 0.8042842460053141, 0.7957356623062868, 0.37778155173169037, 0.19564752078804326, 0.15306526534246911, 0.2023628130912969, 0.1515053950588623, 0.17679599101272947, 0.1818340828655055, 0.18203528183647488, 0.18349131852872846, 0.17452830993588653, 0.18949327934956361, 0.20962260993801252, 0.17646901155164962, 0.18427444498505796, 0.11765284421123834, 0.084725859213171, 0.08177483513571893, 0.09074369383896286, 0.07622711942490845, 0.08122706714725425, 0.08091018989867804, 0.08926704364982474, 0.08386279019544196]}, "mutation_prompt": null}
{"id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 23, "fitness": 0.46201277870554064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "ce536b93-90c3-43d2-9aac-bf0aa45ecf14", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "ff51b2cd-cbcf-4b40-af43-9a11e7a7d17f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_size = max(1, int(0.1 * self.pop_size * (1 + self.evals / self.budget)))  # Dynamic elite size\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Utilize dynamic scaling of elite size for improved convergence in adaptive differential evolution.", "configspace": "", "generation": 24, "fitness": 0.4566789034954708, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.867710746526496, 0.8706660525326253, 0.8652901351660502, 0.8748941892713012, 0.8746913628261092, 0.8706583514755586, 0.8613671257177145, 0.8843479165077868, 0.8739137084986881, 0.772503101362423, 0.7716529118295056, 0.771400575070884, 0.7666111110140144, 0.7494470563213471, 0.7612904996699313, 0.7800530405158563, 0.755779100788893, 0.7803117185816114, 0.22261817767496173, 0.16837392356533565, 0.4727125922889439, 0.14832402424210722, 0.14739319218164548, 0.45959119191984477, 0.14767494407653414, 0.1485799675942242, 0.1524106989130638, 0.15711805668569145, 0.1321972231273808, 0.14704157875034085, 0.14565165827606563, 0.15842668116092662, 0.5257321612601749, 0.1376808453180438, 0.13145670660250686, 0.14387131552021348, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6662836406203925, 0.6741552259200128, 0.5416856098291243, 0.6039243049229412, 0.6466643179484053, 0.682550937176214, 0.6911824951483592, 0.6657650820189002, 0.6782534095640979, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.2399748406581811, 0.18380671748557564, 0.20520059468225116, 0.3145871911894441, 0.6205363784285434, 0.26266252386797473, 0.21122343750493944, 0.23632827142807045, 0.2534120887092981, 0.16980282217642084, 0.4418277643613421, 0.19768176832019313, 0.21040063492891636, 0.3564809542510442, 0.564067504348539, 0.2091464326143606, 0.17508173470120292, 0.3224524486000765, 0.5031740206727204, 0.16803810418934118, 0.5279527485775863, 0.5961112960631594, 0.42859557172947693, 0.051944718617575436, 0.5714846415473724, 0.5269780679084513, 0.6077697438447947, 0.6993203682913973, 0.4081108776696273, 0.7267797896872581, 0.22525198495932175, 0.7073402905507752, 0.7336584974041872, 0.7509870768206748, 0.7313208653855887, 0.755101076727954, 0.32020202184335267, 0.3241007900932551, 0.10550104990554121, 0.4289383912848105, 0.19463033434030153, 0.3949256032187789, 0.21608261092625491, 0.3461251415573324, 0.08313969243887787, 0.5677350121862353, 0.465888447449177, 0.5682803752656289, 0.4298979414319528, 0.5105428836638899, 0.4145545059071777, 0.3702478472331229, 0.41195911942181584, 0.24148851483404266, 0.8282578943008994, 0.8331357897500091, 0.7358304010548697, 0.8207427327795601, 0.8150824094159437, 0.8095797478850992, 0.8202531978103693, 0.8195867587206669, 0.6896370412965287, 0.16504464144158226, 0.13805534872527092, 0.1279385181599757, 0.12211501832836891, 0.11822827669755787, 0.14779064012894338, 0.09249875891047266, 0.14913423333607845, 0.1536395486487936, 0.1686882875780088, 0.17156400862385635, 0.25419389784518176, 0.46937080527018227, 0.17882615575292415, 0.2547625742573787, 0.17947918904796456, 0.12026691350336549, 0.19184875909340426, 0.596755272043103, 0.6508109041250016, 0.6172738366923856, 0.48708404843834774, 0.5119883882921316, 0.6288473376803859, 0.6153716222815548, 0.6644623237780243, 0.6529279682780549, 0.4773063904182684, 0.516899325859048, 0.3464885238078156, 0.5325983489717542, 0.26759307539824473, 0.4202504205125984, 0.5060091075271549, 0.5454645326390527, 0.5574702027520839, 0.2036902766674421, 0.23300302149225804, 0.19763134718903463, 0.19127734645268324, 0.19537077350297982, 0.19189288623715406, 0.20740293145154254, 0.2196855443508161, 0.21012773343055646, 0.23656450641032356, 0.6893845144201832, 0.21018958220731587, 0.6653166808385118, 0.2383753003798641, 0.2142623997038826, 0.230496669679235, 0.2010499928871593, 0.2042934470117258, 0.17021071338545168, 0.19181790575275826, 0.20936955726923745, 0.8753735420429216, 0.7549714305652241, 0.8218828953178898, 0.16569571543209372, 0.8843061514696682, 0.874924566708438, 0.6446073142535855, 0.21042420794397287, 0.8748997018594643, 0.8687756265162967, 0.7843446410337703, 0.16708564871661802, 0.15454740998100902, 0.7193268202902126, 0.20918377206025163, 0.16922282089394536, 0.17991442836985183, 0.17254934509198372, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18636332960029378, 0.1787035477132899, 0.08335494361615203, 0.08984338992443286, 0.08950074323776902, 0.0825145552264599, 0.08419594003022446, 0.08476395715037266, 0.08081136364790187, 0.08775715659060712, 0.07772330986930354]}, "mutation_prompt": null}
{"id": "46023220-d8c6-4d58-b2bd-dd258c2d9100", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.CR[i] = min(1.0, self.CR[i] + 0.05)  # Increase CR if no improvement\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance survival criteria with a dynamic adjustment mechanism that increases the crossover probability CR when trial solutions are not improving.", "configspace": "", "generation": 25, "fitness": 0.46201277870554064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "85cce459-4faa-477d-a278-f752e1ebe2c8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "aac28116-0e9f-4ba5-9d33-5eddf0a50f04", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "6e78cac1-b40b-4b8e-87d4-b4c1bb473fb5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "1fb53af2-15d4-402f-a677-a3be66072ae1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        prev_best_value = self.best_value\n\n        while self.evals < self.budget:\n            if self.evals % (self.pop_size // 2) == 0:  # Adjust pop size dynamically\n                if self.best_value < prev_best_value:\n                    self.pop_size = int(max(5 * self.dim, self.pop_size * 0.9))\n                else:\n                    self.pop_size = int(min(10 * self.dim, self.pop_size * 1.1))\n                self.F = np.full(self.pop_size, 0.5)\n                self.CR = np.full(self.pop_size, 0.9)\n                prev_best_value = self.best_value\n\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adjustment of the population size based on convergence speed to improve exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.43633224599481957, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8960820237213902, 0.8844715126082793, 0.9002484979298874, 0.8929257598212704, 0.8953399776246784, 0.8864249745696497, 0.8921023771961948, 0.8888453891549558, 0.8909358719318503, 0.8204317070409305, 0.7992185038252142, 0.820620683146187, 0.7738706518211882, 0.7901791485597414, 0.8149956172770276, 0.7817238812345412, 0.8245267681354589, 0.791212849662852, 0.12058344721028569, 0.6185483882848439, 0.1787296244002069, 0.17277339817163317, 0.15896827497670107, 0.24023422274689588, 0.17225498998318622, 0.5618260500955303, 0.5603735299009722, 0.1276523398827627, 0.1389767762429972, 0.12844452058559874, 0.12705868251824537, 0.1342363460108038, 0.12666659715384554, 0.14779132775067627, 0.6520301436858218, 0.1357850697694457, 0.906958056420323, 0.9759760605076276, 0.9625299297868216, 0.9476847089209541, 0.9662890957451868, 0.9378772720241471, 0.93079197696024, 0.9526888904606327, 0.9528519397036387, 0.7108676466552944, 0.3358246435947321, 0.7150760084380399, 0.7503096697195506, 0.44750282335656233, 0.5779071894441792, 0.7524400773242728, 0.6076227254686524, 0.5742920935033919, 0.8753377438837129, 0.39123248095828045, 0.8633820127163554, 0.8872775256765356, 0.903203393709109, 0.9071390576444811, 0.8917756953883393, 0.8889305739127525, 0.8887554202047602, 0.17328163259444573, 0.16270883523583757, 0.19447009088658218, 0.48869582936339817, 0.17655495333531834, 0.1924981677750397, 0.1648943575443711, 0.15960546587026425, 0.2738836538613546, 0.18173293342287078, 0.14773837248631028, 0.211445883648815, 0.19038462767641628, 0.13166737153749652, 0.23203170943814533, 0.1847404962150988, 0.16341687931532456, 0.17574531190924314, 0.643031243274151, 0.6447119341564709, 0.22034581004633458, 0.6965627697480705, 0.3348357943643081, 0.35895832494345137, 0.17483907377100227, 0.6133334612964891, 0.3952942955537031, 0.45355408092819316, 0.3771387812805156, 0.3477101238224165, 0.10041094441556997, 0.14030290144411484, 0.09943813883973085, 0.7916959986945222, 0.7540468095976848, 0.8059650407764615, 0.27965060390567564, 0.2533136585272212, 0.1246322961942038, 0.0895228665867438, 0.1732864548202928, 0.16209221098691617, 0.38851105509574946, 0.1405549361833056, 0.3677684559179122, 0.3789543756096677, 0.3835980132050745, 0.3665746603321639, 0.42998943223534214, 0.3435327276128167, 0.5426181418896125, 0.21772013545746272, 0.35558076642911596, 0.193367381501086, 0.855531541411036, 0.6690792594501211, 0.6740383027461953, 0.6279672406466734, 0.7116726009422886, 0.6887306748918112, 0.516328943631774, 0.7493796487581653, 0.8458890882165695, 0.12131741975802501, 0.1393604680550039, 0.12857469092152118, 0.1338885244217115, 0.14676146806651558, 0.13172913277994835, 0.1414343277323169, 0.09621609864420155, 0.12135914806533366, 0.3605609044534658, 0.18642755722709303, 0.569153907054979, 0.14924807583747313, 0.3066375108757694, 0.13666311234658346, 0.17897760649643346, 0.21969066939992854, 0.15145863996632802, 0.7189260075200539, 0.6839584670641861, 0.5118467163174244, 0.4168679531716267, 0.5829303733337696, 0.6978265588946616, 0.6922112295401573, 0.5254202200035716, 0.5258633630683547, 0.46190327209211957, 0.4359831067350154, 0.5584149086013679, 0.556087785778467, 0.21199490234444862, 0.44757385723617304, 0.4773545185099053, 0.589910999233706, 0.48625413669695783, 0.19925117452391128, 0.20296657871320256, 0.2411027546307991, 0.2446300442809225, 0.18451331355591405, 0.23507526433235937, 0.1966512360267053, 0.23172641305369657, 0.21228281537959004, 0.23846190750624352, 0.2446827487125829, 0.21496768352064943, 0.7566034794711972, 0.2478945704843254, 0.24712600534678486, 0.20409860250482947, 0.7446059154983273, 0.21234177440481006, 0.17172908322365443, 0.7858891425807584, 0.20689368018078091, 0.8899620910730632, 0.19369994468154061, 0.1977718550596016, 0.859910581652334, 0.8240205156160885, 0.8911078363329735, 0.8450017787787577, 0.21110257279787825, 0.8582946664196416, 0.90607427016673, 0.8638742847894096, 0.166896188624848, 0.1545844105555343, 0.1668314619449469, 0.2070748303826555, 0.19989000832343273, 0.21422593153367275, 0.1812976655165942, 0.18344068607927777, 0.18146540955863444, 0.172896139138364, 0.17747445379553206, 0.19540261577990736, 0.19330005613011148, 0.07590207832406737, 0.07433763669738525, 0.09515895262403318, 0.08057719382977135, 0.08575538148771589, 0.062146655085282276, 0.0933771623207269, 0.09354269503178525, 0.08991308955723287]}, "mutation_prompt": null}
{"id": "c8297c91-f2af-420a-9439-f3a5f84ead11", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "374687b4-74a4-45ed-a8ea-41b013ed93c7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "d7d7480a-6afb-417e-a671-fc22c4afb419", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "5b0c4b2d-8092-47ca-a166-a2fee7f37b13", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            diversity = np.std(self.population, axis=0).mean()  # Calculate diversity\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                # Adjust CR based on diversity\n                self.CR[i] = 0.8 + 0.2 * np.random.rand() * (1 - diversity / 5.0)\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting crossover probability based on population diversity.", "configspace": "", "generation": 33, "fitness": 0.46139872524484027, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.867676009425418, 0.86254569119002, 0.8668702271627348, 0.8668940828218098, 0.8599806013933201, 0.8682154616427181, 0.870173100779868, 0.8769097294152217, 0.8800847890267723, 0.7659468796226967, 0.7583259533053912, 0.7782542987344405, 0.7553161524145799, 0.7677319987499928, 0.7798145065805838, 0.7712151877645597, 0.7656471103824518, 0.7729670540288477, 0.35866180504583334, 0.1649045044612747, 0.4865219113451805, 0.47576674131972674, 0.1638185037809028, 0.14226658562467742, 0.24770129947781327, 0.16710234952215308, 0.5490623070450125, 0.13529636552583746, 0.24634185879401382, 0.24334673825274133, 0.13925854828997875, 0.1545146954097314, 0.13796260292435725, 0.1142943614248092, 0.1602475261235018, 0.14545997664914234, 0.9444852308400866, 0.9458836832863037, 0.9574452500227454, 0.9417579133868045, 0.9663341087735079, 0.9639685936710827, 0.9436983144691874, 0.961484940583494, 0.9491595527805002, 0.6599142418009316, 0.6049880390445816, 0.6512799731288363, 0.6934346911284535, 0.6268045781100078, 0.6463242037074086, 0.6265651100406007, 0.40817375059288175, 0.6663217967195864, 0.845427567942312, 0.8647979107480804, 0.838888813103228, 0.8774783340440832, 0.3637635775195447, 0.8786452026946933, 0.8446902367265546, 0.84478699114031, 0.8426393142503377, 0.226958416753969, 0.5441484639817815, 0.17293524243133174, 0.1767283850557656, 0.2844892422365267, 0.12871437451666057, 0.6667615173484365, 0.24648193359137938, 0.18408995077760937, 0.22394578538836485, 0.2157000711055438, 0.21190410189952535, 0.2245220974156369, 0.7210198132909749, 0.22352600148735646, 0.29353880861549, 0.22515534155949635, 0.12887573921871698, 0.4703574065427397, 0.6288482700299551, 0.6321104536170519, 0.6063776575112347, 0.6111750477120168, 0.5666463139378672, 0.5725210254704498, 0.5519850091079795, 0.20589536700967703, 0.3074016908124443, 0.6427377031226711, 0.7145636942378968, 0.6929236462423126, 0.6646626447299075, 0.6988496258749367, 0.6940565365122171, 0.6974108258514495, 0.717358589499127, 0.06823514323367197, 0.09400292314913261, 0.13771329697146084, 0.2576581836329199, 0.12732811760922946, 0.3035010376407219, 0.3453171376806652, 0.19689397724081192, 0.14993819657824148, 0.5042560601447937, 0.49853428674171363, 0.5393209236317495, 0.5227991611226106, 0.40639041460695124, 0.5369469879843227, 0.21234062710762158, 0.5034924506916437, 0.3534108464872687, 0.8121440088689843, 0.8178441161255641, 0.8133877706481377, 0.8040909709592288, 0.7742256469912279, 0.817355994439319, 0.8211905948978404, 0.7992015003595383, 0.8372127994712835, 0.14223587473835453, 0.13622946232624655, 0.12786589630911405, 0.14499010297394377, 0.1232661242795513, 0.1548485074864293, 0.5252527871413106, 0.14773039819491418, 0.14257807731601402, 0.16237531212499745, 0.23615189072761877, 0.19124885959484939, 0.1432495185894821, 0.1783361154334241, 0.2280427435447696, 0.37577606635119665, 0.14274006744739165, 0.20335248076252832, 0.5498909693494924, 0.5685036700721309, 0.612993024664233, 0.5693298475321829, 0.5893161971011969, 0.5528800631604553, 0.6230567466468522, 0.644768523117125, 0.5467155278557189, 0.46471997238538654, 0.3815435859221027, 0.4690610334371794, 0.3942400039816447, 0.42641113864014346, 0.4261936932948186, 0.46182201072568774, 0.5508327922626952, 0.531791019168974, 0.2110283444304175, 0.2049192423367847, 0.18719176020709616, 0.18990832231445864, 0.20626767551515057, 0.21107810619921397, 0.19736952840427036, 0.2001806039186178, 0.23248886714975248, 0.6400711680380724, 0.23740975237345252, 0.3925594612931125, 0.6560394610805376, 0.6582750975063463, 0.5774295958597304, 0.21301963385645506, 0.19078376730654922, 0.19856997913101715, 0.20354640342875696, 0.2072174242085314, 0.18626369304335844, 0.868320919147355, 0.831632806467344, 0.7995238213684454, 0.8495546233547282, 0.16955001053226693, 0.8234937021518297, 0.8221467954238131, 0.20747407374489257, 0.844066529870714, 0.8767655492115738, 0.6548225638444038, 0.681026801814326, 0.20477438341392595, 0.2061449643526374, 0.15497839700129556, 0.19299666467419652, 0.1809279118093997, 0.18401042566613668, 0.18303180600095825, 0.18068686120424404, 0.18532802124735182, 0.19555935370967303, 0.18215587176615522, 0.19365356956477053, 0.07936895370219355, 0.08149957243981243, 0.09564836415530553, 0.07906017631485907, 0.09183783414826352, 0.075406594558172, 0.08137662102816756, 0.08198714538505991, 0.09500556632196822]}, "mutation_prompt": null}
{"id": "f3c65cb8-4dc1-429b-891a-57aaa992918b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "94127f88-d8e0-435f-bfeb-87e9b1fdb01b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success_rates = np.zeros(self.pop_size)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success_rates[i] += 1  # Increment success rate\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n            # Adjust F and CR based on success rates\n            if np.any(self.success_rates > 0):\n                successful = self.success_rates > 0\n                self.F[successful] *= 1.1\n                self.CR[successful] *= 0.9\n                self.success_rates.fill(0)  # Reset after adjustment\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive parameter tuning by incorporating feedback from historical performance.", "configspace": "", "generation": 35, "fitness": 0.46201277870554064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "01ab62f7-e6e1-4d1a-a0a0-15155c96448a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand() * (1.5 - self.fitness[i] / self.best_value)  # Dynamic scaling\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance diversity through dynamic mutation scaling for robust exploration.", "configspace": "", "generation": 36, "fitness": 0.38648120123415086, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8718683538284092, 0.8595120572740695, 0.8814896127255589, 0.8740343212390101, 0.8725947931932267, 0.8856692462650977, 0.8749817398960709, 0.8835064609393664, 0.8922119981446638, 0.5017906719056275, 0.5970796517536832, 0.5251284263986808, 0.5315432291169929, 0.3557166218601022, 0.24105411438379798, 0.4854594372975336, 0.588230743513035, 0.5414454267190802, 0.16372199713348923, 0.16029482659151273, 0.44580120585508, 0.1599134365423377, 0.4550732738623755, 0.41422085130164865, 0.11539406974454725, 0.5485535558560429, 0.13274776346759465, 0.15309964192996794, 0.1855072563038035, 0.13194581319136667, 0.12613490948988548, 0.14825904925901834, 0.1540510782623551, 0.16917174388859202, 0.1453717765254331, 0.35695668450094264, 0.9716806353738743, 0.9363817214888561, 0.9292776910784507, 0.9584039938484552, 0.9505125555803747, 0.9700711617509774, 0.9564206674346046, 0.9546139006760604, 0.8481448410836512, 0.6358097217033782, 0.5221878004144207, 0.6105815378098914, 0.5054602512967364, 0.6390191856171988, 0.47188066620682967, 0.4471105780065423, 0.570711986322178, 0.6518989117397558, 0.8627918534454204, 0.8536071820135838, 0.2257541496024047, 0.8782512406470435, 0.8920501195752316, 0.8576760598218216, 0.2413111797696047, 0.23184521081142384, 0.23386372112315856, 0.5672514331504697, 0.17112660339935504, 0.15727493266503567, 0.5995677287436918, 0.11318568154342701, 0.20594982513988713, 0.16637474199314817, 0.37522918582961207, 0.19070465276900728, 0.6310029214713415, 0.1725938209756589, 0.7471877631459541, 0.14301422193113722, 0.13239094916102734, 0.2208551811020375, 0.17526303331796278, 0.12825007365169316, 0.21792174436109057, 9.999999999998899e-05, 0.07545897979825145, 0.05335717961228459, 0.08176591445699832, 0.1276732038210483, 0.09599092265719578, 0.06751531801665511, 0.359850205770867, 0.4439361713504908, 0.5026928688777517, 0.20858587018698516, 0.3209874264911343, 0.05117313680249502, 0.04236577346469217, 0.037173406287175026, 0.20772638070928384, 0.02967574612659829, 0.2702853181600078, 0.030755735537600026, 0.08100677873664919, 0.07026845301944118, 0.05493470041588766, 0.09063116730317344, 0.2852784363335995, 0.15979092738535527, 0.1496661348100341, 0.21879752319071655, 0.5962192933109495, 0.5262790512790279, 0.38507370617766723, 0.5384324222930352, 0.6078435814587084, 0.6002637650342337, 0.3695137624739572, 0.429196483215576, 0.4030155165661933, 0.7271155620832179, 0.8332096383753624, 0.7699041394633501, 0.8311812023359318, 0.79535138478129, 0.797532464734906, 0.8359542687499065, 0.8378216711768123, 0.7974216521718034, 0.12817445830906493, 0.11000597239051402, 0.12395499231986029, 0.13292743333704915, 0.1687254284275923, 0.16934209129050481, 0.1433923506167486, 0.12246473165537974, 0.11910643311216684, 0.28255537850812107, 0.2100611794672821, 0.24012047932489045, 0.14306673890357846, 0.2223556473847481, 0.17654483322552694, 0.22804980096523197, 0.20530049653020488, 0.19031394435063909, 0.5809938487573789, 0.5983711919457055, 0.5546923354998188, 0.5374470578713706, 0.6025241119577314, 0.656372810050518, 0.6769019204501724, 0.6475713875116729, 0.6386061506885061, 0.5305651856286508, 0.44701520788203775, 0.34119946225115505, 0.46947996995311314, 0.21896145961234892, 0.49357129602523553, 0.28934452162437396, 0.567600530878671, 0.4776564727516749, 0.2142778299431325, 0.22364838070495918, 0.2126599791113547, 0.19738472974317078, 0.18817357726354267, 0.19553628871802498, 0.19312181151546404, 0.2195665564617003, 0.19497676729404778, 0.4655495749199394, 0.23307990782202448, 0.20131591611207345, 0.22892441189822832, 0.21872298686801783, 0.5559235031139673, 0.22796047615255255, 0.21132346263957036, 0.22857079726097018, 0.17106008754887025, 0.8344722193808236, 0.18577178701943098, 0.8077150250029772, 0.19724822817810894, 0.16270616766625645, 0.8634345667281668, 0.2001219546043027, 0.8606003630669878, 0.8593984681300194, 0.2070673308048333, 0.8742774399899648, 0.8690796244367447, 0.20341146799545473, 0.16608355270762054, 0.15512708323047242, 0.20797825133019776, 0.20763440567287827, 0.181564504673004, 0.16638443733488006, 0.17474533948076099, 0.17729792700967373, 0.21510909592724947, 0.18193579485329814, 0.17983307233663404, 0.1983456387816157, 0.17841922845384273, 0.07811853003823432, 0.08119971629001799, 0.08492943026504018, 0.08920695675246604, 0.07990191727467777, 0.08420824994740073, 0.10982897991677987, 0.09067589368220519, 0.08822035730494371]}, "mutation_prompt": null}
{"id": "fde16011-97eb-4f36-ac81-628910e9158b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "b9b6b846-0015-4ac6-a96b-a83e798225e6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "6e5d51d1-ee78-43ff-8e2e-ecceca4d6c40", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.95)  # Adjusted Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.85 + 0.15 * np.random.rand()  # Adjusted adaptive initialization\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the crossover strategy by adjusting the adaptive crossover probability initialization for enhanced diversity.", "configspace": "", "generation": 39, "fitness": 0.45617318122450984, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8576877349354765, 0.8596927760075176, 0.8768114116869301, 0.8740007759725095, 0.8718691421599676, 0.8582755247118591, 0.8697095055405392, 0.8634291198323328, 0.8643476937562649, 0.7582975797948397, 0.7619816969752315, 0.7696056796892586, 0.7448081181321363, 0.7565965588957204, 0.753908449042161, 0.7704167668698345, 0.7729622575854458, 0.7726909595445763, 0.1572043256278003, 0.14999131315997105, 0.15644074098056648, 0.4147419608824765, 0.15328141562804543, 0.16570783390148658, 0.15810385122928383, 0.15053938243051102, 0.27030435214604154, 0.12369267871102108, 0.12589129923818676, 0.14327098319121012, 0.13282126215091505, 0.15686737512434779, 0.12798184697531034, 0.42855821491161983, 0.12092062768906087, 0.14321816635904128, 0.9369240064167986, 0.9329860714673576, 0.9343247927457772, 0.9367316169589318, 0.9123366796160344, 0.9577536399922152, 0.9133536129115951, 0.9624497138213739, 0.9287971665009269, 0.5264030624049736, 0.6234210663003146, 0.6660609791783747, 0.6845415352248485, 0.6161171520768236, 0.6715199779902729, 0.6804330409084033, 0.6304241256748271, 0.680711465567114, 0.8234220525060498, 0.8691773815181496, 0.3130134924389071, 0.8585334370599188, 0.8942451501624827, 0.26858262617004425, 0.8749157556149385, 0.863918788525988, 0.8944946240336811, 0.1657581054250017, 0.1981147118216039, 0.16398746803610376, 0.17939165897183318, 0.16939043130218012, 0.48543744470708694, 0.19846955666226607, 0.7266352762862889, 0.17315769666997471, 0.19364305189818842, 0.16167180507316858, 0.15445440431595303, 0.20450287423880753, 0.20591728068187953, 0.15926013670154937, 0.17651890278577753, 0.19935508066037633, 0.17580835686415341, 0.508944694797139, 0.5566352914464168, 0.6561935148115055, 0.621977557786255, 0.6956894040940762, 0.625522479129493, 0.6577260271466192, 0.6797761351055903, 0.6899359184747933, 0.6603726249509041, 0.7842849867186106, 0.7553453323744393, 0.21356350412951564, 0.7682007069435753, 0.7563410849362453, 0.41838452136263704, 0.7679269471997691, 0.7154155559732338, 0.16179421371203662, 0.25372249330828933, 0.21050559822607828, 0.31167332727981356, 0.18025197527273118, 0.10121086632917609, 0.36746703626349364, 0.123169429400114, 0.1711605885134868, 0.4197268668998976, 0.5528068252382194, 0.5453679196938528, 0.5888872283854293, 0.5004121796087415, 0.5656885523764064, 0.5745431788058752, 0.5062275226722655, 0.6037553084768084, 0.8197613552522209, 0.8358334664158505, 0.8398870953214093, 0.8362118595544801, 0.7864037779311296, 0.7104965424644198, 0.8585115005950775, 0.8176262161371296, 0.8194820803104439, 0.0950921796356915, 0.1374904875962848, 0.17375529467256712, 0.12100781689793494, 0.129684672670781, 0.10991703726254165, 0.1521121885315181, 0.12918519840502485, 0.13361062645247335, 0.18190424198640354, 0.14296004131212425, 0.163644133742331, 0.17044869604066115, 0.6204418692401963, 0.21065140609108146, 0.2153107305068288, 0.1439692937019219, 0.16247318057962679, 0.6204862727667957, 0.6432065580267736, 0.5646959280468893, 0.5461800270840099, 0.5971218193365169, 0.4618892505691722, 0.5710309344508808, 0.6535858188783925, 0.6188637377146211, 0.4079409025706896, 0.450514273821211, 0.502897268959071, 0.5168968974287074, 0.4616444862249335, 0.5201071160477325, 0.581271097837182, 0.5842401995772445, 0.5267709694975762, 0.19178481107358347, 0.18414764342399725, 0.19041495733992453, 0.2393674992749234, 0.2064000005595883, 0.2124989121188392, 0.21717731916492666, 0.1884063831265974, 0.21246822114842268, 0.22802895956144476, 0.2322992110482326, 0.570971672219005, 0.6613816447852696, 0.6379380103484587, 0.20124449016149148, 0.22702390133139738, 0.20760705359437093, 0.22929437065901148, 0.15222472287222266, 0.8790557646876898, 0.8749220209884245, 0.8363667957923262, 0.8387986112283057, 0.16789554110124627, 0.16620984267319805, 0.16923517234891428, 0.8628638321440907, 0.7716796889485806, 0.20952919925289193, 0.9000566965588114, 0.8652922826358509, 0.8005867521627188, 0.16384368785083192, 0.20677238971577738, 0.5274479095920773, 0.1542722608167294, 0.18741703469502324, 0.18234347438869158, 0.18066696953205286, 0.17635360103048936, 0.19601258494564755, 0.19331833376677643, 0.1885990838665802, 0.1833404602881623, 0.1843185838181065, 0.09078382458325973, 0.09286180055865023, 0.08410179508912863, 0.08626669699972866, 0.08712996936751782, 0.07796952081275288, 0.08732239352818671, 0.0873219029812572, 0.08025029758303859]}, "mutation_prompt": null}
{"id": "2ff32afa-3db3-4d84-9364-ed7abca89eac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "2fc38740-cc68-44a2-ae53-424fad1b37f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        initial_pop_size = self.pop_size\n        while self.evals < self.budget:\n            current_stage = self.evals / self.budget\n            self.pop_size = max(4, int(initial_pop_size * (1 - 0.5 * current_stage)))  # Dynamic resizing\n            \n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population resizing to enhance exploration during early stages and exploitation in later stages.", "configspace": "", "generation": 41, "fitness": 0.4422200383816342, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8590173063791045, 0.8879658500789728, 0.8645135314919887, 0.8816434340599854, 0.8737447749501912, 0.8691452096574788, 0.8767558643525508, 0.8634971064546042, 0.8758170901150923, 0.7837073801964383, 0.7811195429958897, 0.7725439921869526, 0.7861202392658206, 0.7564689845864359, 0.8142651601123674, 0.777989454260716, 0.7769857111344923, 0.7802829023037561, 0.15702376127773898, 0.28943746939393955, 0.3782676232349389, 0.5815671160395196, 0.15668039262355482, 0.15207542525367257, 0.15783482562433582, 0.16130443131865946, 0.16028930435977384, 0.12268926388694457, 0.11703162873390682, 0.1521045654841675, 0.09584007161182873, 0.11623431602245105, 0.16902846215623124, 0.16087171698434244, 0.11007888675201971, 0.1279719540917682, 0.9034311338390645, 0.9655331434169098, 0.9531512471014231, 0.9736595802280974, 0.9372424673062665, 0.9727756302361568, 0.9461934830473842, 0.9125958819849133, 0.9764169249125714, 0.5059168830617773, 0.6860660844540444, 0.5890942472274456, 0.6963752674769541, 0.5942970198207711, 0.7008649606308028, 0.7104089825574156, 0.7425540787511796, 0.6015170468236088, 0.8985142250562594, 0.8772203429062825, 0.8802820052510554, 0.8771226177003772, 0.8651010787962012, 0.8660119785373459, 0.8929244831400548, 0.8717979517889315, 0.8608443912099398, 0.17266242106552165, 0.1945845732856003, 0.21262657013104547, 0.18218905867209167, 0.6005754862697186, 0.17676394425505781, 0.249461271695268, 0.23486931264889788, 0.15694954914835668, 0.13925537830663248, 0.12818003249651377, 0.1864669566131698, 0.23591964100490592, 0.14431799898857056, 0.7233850467562388, 0.17974252167634963, 0.17108225159543677, 0.17924097924436988, 0.6500366643930515, 0.7029698984274944, 0.6876414565234774, 0.4219346414445858, 0.3049093350586829, 0.5044599614457727, 0.4062638311997343, 0.020406679392147242, 0.5558523250177958, 0.5453595408559213, 0.496640749461737, 0.7116159028791098, 0.07239384024074791, 0.674317662696081, 0.5529562571730435, 0.23459679186425997, 0.7217509247652194, 0.7641471907877384, 0.3572804148258625, 0.21182776889168053, 0.19137347572188612, 0.24656837229236084, 0.46113059195104555, 0.17032135590322772, 0.20749246580411362, 0.22460141272556278, 0.17168580556322754, 0.41388627120862787, 0.3217379669958331, 0.3140488418193266, 0.49244417410545815, 0.4376746862195291, 0.32807897277526377, 0.4598829907076267, 0.3430535757640897, 0.2948622744672622, 0.836033352139884, 0.8335790155318216, 0.6933173717893069, 0.6731087903108777, 0.6397419517641332, 0.7273085184101729, 0.8173763944332124, 0.6973776831953146, 0.6759321694783402, 0.1276047284297892, 0.16493104089929478, 0.16557297915868696, 0.45310627623442357, 0.12028123083965314, 0.3876007927927875, 0.1561201334671709, 0.11045437180229256, 0.1349815176750091, 0.17848807873341266, 0.6895759008283876, 0.18777851449277327, 0.14174510134411744, 0.235019734293605, 0.3198959782873829, 0.17813169132414464, 0.21825977927897744, 0.1773254355388888, 0.6733689041400883, 0.6655872174831828, 0.643725936003648, 0.6861975624567125, 0.6433870652847358, 0.5583208431795422, 0.516345461810647, 0.7098610264501746, 0.5694147996657675, 0.36582346791394027, 0.46417474672397396, 0.2934029950484145, 0.5852760115759441, 0.38386154094920943, 0.4319431066340902, 0.539951358591966, 0.4299625577399574, 0.4239998069178671, 0.2026968840071891, 0.185173717572223, 0.25731416103252047, 0.2099425502757144, 0.20633296993568828, 0.24317470759518223, 0.21342501578414685, 0.22647960225466868, 0.19224190881648962, 0.2320863521983516, 0.730943397149185, 0.20480937529178556, 0.23896351017332262, 0.6445817147203344, 0.23503976633335977, 0.20770678418699418, 0.7376160273162573, 0.20684337999481017, 0.18789026366905504, 0.16468983290004213, 0.8187969193030387, 0.8689438526540876, 0.19145480807369708, 0.8462725806936632, 0.8713799680415545, 0.1956113839780652, 0.1653119751872093, 0.8914863567654016, 0.8121991822770318, 0.8543673124947138, 0.20862406445306725, 0.19717067633662033, 0.1654934296948397, 0.15482198854868456, 0.16213096502533664, 0.21193594563009932, 0.1754144040590554, 0.1771372875431937, 0.1772171454258098, 0.1913497679397267, 0.1677825818006864, 0.18404728143386873, 0.18385392277737822, 0.167534219985629, 0.17227587500163133, 0.09189000331734709, 0.08098551363597617, 0.07566660988572183, 0.10600099796034013, 0.1024026170246467, 0.08193160120123688, 0.10242141774016655, 0.0840799207175631, 0.07802489965667136]}, "mutation_prompt": null}
{"id": "6f492a00-bbe1-4063-a5fd-e8baa17fdbb2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "b43912c9-2f4d-4388-863a-7883d82bbdfa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "70858f0e-5a4b-47ba-95ac-02becca63cc8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "5c86bddc-1cc6-4978-8596-9ba3c515b820", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "f9afc17b-9cac-4459-975e-b412e919fbf0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            diversity = np.std(self.population, axis=0).mean()\n            adjusted_CR = 0.5 + 0.4 * (1 - diversity / (self.bounds[1] - self.bounds[0]))\n\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = adjusted_CR\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjusted crossover rate dynamically based on population diversity to enhance exploration and convergence.", "configspace": "", "generation": 46, "fitness": 0.44971482625238685, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8680947901248169, 0.8566994711969628, 0.8657757864173623, 0.8639644519586077, 0.8713418637513226, 0.8783850757012422, 0.87122169275213, 0.8700370503216344, 0.8615680130590236, 0.746513356397468, 0.7793181064482086, 0.7625442761210124, 0.7559183565437585, 0.7749988587038235, 0.7756281234500488, 0.7512293684089517, 0.7609209452750961, 0.7751080141250976, 0.35830712393125563, 0.5231799686138794, 0.4580397073409834, 0.3648765418581724, 0.3122203933493951, 0.1658101133815424, 0.25077298918333024, 0.2811052495531493, 0.41510661168434604, 0.15780702244645506, 0.5853668336086695, 0.12336492090070483, 0.15914056063471593, 0.13392117335411546, 0.3025480891715788, 0.14565435885108213, 0.15436599750177082, 0.13816828195509934, 0.9430376684544538, 0.9571483894060494, 0.9544745309196305, 0.9430282350961852, 0.939910008317548, 0.9039632942355227, 0.962548098090706, 0.938484678900799, 0.9045385346452129, 0.6218354066876621, 0.6681243227867812, 0.6625130818056015, 0.6514487971532814, 0.6584668354935207, 0.6871842979300515, 0.6243515639773018, 0.3694881272623056, 0.6278302688442292, 0.8177814430360592, 0.864487087678285, 0.8330768725913119, 0.8331174055668971, 0.8810116014454324, 0.8309272731092076, 0.8173776307823593, 0.8588983918256681, 0.8318429076815159, 0.32085922749272644, 0.18218048288541266, 0.2348922347531468, 0.1906166381778599, 0.2541901009480778, 0.34822837363435444, 0.4455230216153836, 0.19131479858541622, 0.22994681322718358, 0.23116517916384505, 0.15102561185404062, 0.18243627436805965, 0.22870830041426415, 0.176438558964209, 0.35589561176027995, 0.12978346337068236, 0.5342646561167868, 0.3079831700128286, 0.5473887869422738, 0.5267647792781143, 0.6293204844428855, 0.5850318192436349, 0.5499556013062167, 0.48286411287646547, 0.5538715295640844, 0.10743158053138979, 0.5774802565032802, 0.5942094380139042, 0.64977006553326, 0.6346745020870911, 0.6027571995340049, 0.6216183386184806, 0.6403821136484513, 0.6682559201719616, 0.6613799222902081, 0.710956584505351, 0.23199048590327798, 0.2361343376525168, 0.22530074521917753, 0.21630514485555752, 0.5925506042891822, 0.24519664253647167, 0.2273821229365467, 0.29258086235349545, 0.1607207135883798, 0.47704362187282645, 0.376538982216037, 0.4952128694549329, 0.47954118520941025, 0.4191173790979711, 0.530225126805787, 0.507439105542748, 0.5389069854879114, 0.3431459693767531, 0.806507040854782, 0.8343366777946082, 0.8112676258754528, 0.79185486626371, 0.8161010658381669, 0.7153729265066355, 0.8258581936735554, 0.7799260086088498, 0.7361125825212371, 0.14923318851159983, 0.1255652076573719, 0.11351124385950784, 0.13565242539791977, 0.12233598680275826, 0.26501132689735907, 0.12344306072253908, 0.10602952916012387, 0.10289634359151734, 0.2175693871751888, 0.2088032984824294, 0.20250608196930386, 0.1577553866943474, 0.14232935178135886, 0.16518356379122, 0.1353226905248699, 0.3017212204964116, 0.214574868876385, 0.5634937862201397, 0.6006228397188069, 0.5956237473883628, 0.5735708617983613, 0.6029253704920592, 0.565864609458733, 0.6016985425131083, 0.666889026387943, 0.6427386500515204, 0.474330090574279, 0.4610047080978562, 0.4387511365635298, 0.4889081619280329, 0.3135336710205635, 0.4369363260112097, 0.47316855663100743, 0.4801065814422003, 0.46048986862675423, 0.199119403787421, 0.2102184988042134, 0.2031926941747071, 0.22177660808411226, 0.20254728004853673, 0.21628513103802105, 0.1948017156816021, 0.1914044125285096, 0.19281027209912505, 0.2264367120441344, 0.5674530780959699, 0.1927985098823548, 0.5314471555821414, 0.20185052216274313, 0.48361212630973704, 0.23294001658739438, 0.5710754536822109, 0.19792482564255331, 0.18250152490761806, 0.8815104184668932, 0.1932926776280659, 0.19016878893813782, 0.18129648322181258, 0.18241731233688574, 0.8695561921134007, 0.16265403302212722, 0.8524025002740616, 0.8171839870037656, 0.20799505655728168, 0.804061780065594, 0.7580479859845631, 0.1980394058296705, 0.1628415693972065, 0.14905464323305218, 0.15276937373286548, 0.20895301683873668, 0.1801252969664483, 0.18063243670850682, 0.1882689473285667, 0.19965290429996307, 0.17255118478661224, 0.20227955832473, 0.17722232519277992, 0.19001134185154356, 0.18472520060474173, 0.08668936037199637, 0.08159891578326883, 0.09009178635280768, 0.08094544254302927, 0.09483563870115164, 0.09169673444186355, 0.08699962663324878, 0.08495430330485854, 0.08442388664353817]}, "mutation_prompt": null}
{"id": "2c42f992-383d-4be6-9492-6d73aae277b2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "3113d711-80e3-47de-b7e3-b3f580782c47", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "dcb509bf-3f34-4893-92b3-dae5a3ff53ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            # Adjust elite size dynamically based on evaluations used\n            elite_size = max(1, int((0.05 + 0.05 * (self.evals/self.budget)) * self.pop_size))\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration-exploitation balance by dynamically varying elite preservation and mutation strategies.", "configspace": "", "generation": 49, "fitness": 0.45512033429539805, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8452499219040224, 0.8511717536916578, 0.8579648379733853, 0.8619770089697555, 0.8452335135781901, 0.8509584800051296, 0.851603455089635, 0.8619633192257885, 0.8446024463262188, 0.7242721426105246, 0.7141717056809377, 0.7419811842820458, 0.7384486382033504, 0.7321862177672648, 0.7317299771660533, 0.745942437697517, 0.7540675004112701, 0.7480880737903293, 0.15861433961321314, 0.38663855424508975, 0.22411317154950738, 0.3873367637628463, 0.18332809036468012, 0.2290583101920728, 0.14236283581010611, 0.1151972172398602, 0.14160126704375597, 0.10799501850925486, 0.13202543467706185, 0.13406949837141524, 0.13904918530090238, 0.11488222891329625, 0.1426056131985528, 0.14117872600575443, 0.14562839138346484, 0.1405932983453626, 0.9242548564357199, 0.9523736328227147, 0.932239031919185, 0.9111755788973253, 0.8977201935419293, 0.9573542329609352, 0.875976870352856, 0.9520073173014255, 0.8828731686111213, 0.6326122450329872, 0.6114136087658477, 0.6369073640390308, 0.6760835175623471, 0.6024531720340094, 0.6503702731834109, 0.6179623109943208, 0.5631809887122856, 0.6522413588838635, 0.817373969674043, 0.8394961374898635, 0.8476520622823502, 0.8105546499963237, 0.8656944730409308, 0.8486544361288569, 0.8334339036246765, 0.8180427364713897, 0.8404978400838099, 0.2011711767366, 0.16517215566673404, 0.22740760476925348, 0.2879875031790238, 0.4061626687035599, 0.6264594756783621, 0.17347377116775753, 0.4945093297605859, 0.15490390791552855, 0.2605547163181571, 0.20712927922217306, 0.16567000753319028, 0.13014693325676796, 0.6553867393455559, 0.19685992970052368, 0.1846410664623801, 0.4139949447250446, 0.19742532033221305, 0.5964850265686172, 0.6055238659429001, 0.5837120499374127, 0.26233971412479073, 0.25652053055627344, 0.5739842853402968, 0.5739480261645942, 0.582297628953737, 0.614518253941683, 0.6766246257599358, 0.6899424580452351, 0.6995955688373663, 0.6847600656048924, 0.7085967005293574, 0.686076321538369, 0.6895701526811269, 0.7140867524205138, 0.7034056389110295, 0.1567417689473981, 0.3023365155490747, 0.18917551874617955, 0.5136016801699921, 0.22161114710205077, 0.49923890150684425, 0.17500030806909495, 0.23934341244408353, 0.11130968799077257, 0.47641401106270387, 0.4219565228661759, 0.5023880213667514, 0.46455880406761385, 0.4811553003753737, 0.474700303998594, 0.4371925526418756, 0.44876868612308196, 0.48598116516462897, 0.7820106506434032, 0.809339212289969, 0.7839989974098694, 0.7819196237103107, 0.7873223806904479, 0.8150890605446832, 0.7893024196315922, 0.7914082986827367, 0.7849161656666584, 0.12168363070422672, 0.10432312687370782, 0.21098623792111126, 0.13956464240061472, 0.11315645262936358, 0.10582990645525481, 0.1572410466744586, 0.11747179775191685, 0.10256232361684037, 0.2140577412721466, 0.1588415392109841, 0.19448824736773684, 0.17855521046237433, 0.18328714728596385, 0.3889698512574964, 0.1522773158107339, 0.2068448529020026, 0.34232971550870694, 0.5031613838209494, 0.5130126261458925, 0.5656677577351248, 0.5389976973972064, 0.4666628092789501, 0.5740649762903609, 0.5900325426435731, 0.4991278953669235, 0.5783238153947692, 0.43042571698353105, 0.3927648717918323, 0.4404309554113537, 0.4391546330758346, 0.4194577488378993, 0.41407135716128196, 0.47133750345287595, 0.43543088378229355, 0.4765672781609114, 0.21453537622280816, 0.1924357101722729, 0.21165338674826317, 0.22450009410454963, 0.2111132683022643, 0.19440146502012134, 0.20179090237558006, 0.20903716751309298, 0.19283154456285223, 0.5698374684600477, 0.5177501611992501, 0.34686395247950363, 0.48993382526756024, 0.4340579372611072, 0.20568086955149123, 0.21563200090635415, 0.46440654614351506, 0.6175734581874082, 0.1700828593654261, 0.19364347030004692, 0.18275061147789007, 0.7984335000213804, 0.7773717235669231, 0.19888355855323048, 0.7416526679347378, 0.1930144452063035, 0.7561520916039506, 0.716190448687474, 0.20557444747122977, 0.861370064460784, 0.8233457295771704, 0.2059775406612787, 0.7925218324807135, 0.2065267205221767, 0.7970921354234135, 0.8264246089274593, 0.17602293822951542, 0.18305502730451062, 0.18968141491423707, 0.19328436172463814, 0.1876991850477704, 0.19864105182541192, 0.18815906029875618, 0.1868986945117479, 0.23246061596226208, 0.07168991651530687, 0.08573947108495827, 0.08796338961494055, 0.08959847152180156, 0.0875998323743199, 0.09115347265369289, 0.08226899066913829, 0.08871601478148694, 0.08683766567831774]}, "mutation_prompt": null}
{"id": "dba40ba2-2402-4d74-acf9-50ef8c50327b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "aaceb792-a971-474b-bb70-eedd87453cda", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "8d9505d2-cda5-4cb2-8c24-9cf1522272e4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                        self.CR[i] = min(self.CR[i] + 0.01, 1.0)  # Adjust crossover rate\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refined strategy involves dynamically adjusting mutation and crossover rates based on feedback from successful trials to enhance convergence.", "configspace": "", "generation": 52, "fitness": 0.46201277870554064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "8f16b598-d1b8-4a48-8b88-c149186e644e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "cfc11f07-fb7f-400d-a987-f38a24d62f4e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        while self.evals < self.budget:\n            improvement = self.best_value\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            improvement -= self.best_value\n            elite_size = max(1, int(0.1 * self.pop_size * (1 + improvement)))  # Adjust elite size dynamically\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptation by dynamically adjusting the elite size using current convergence rate for improved exploration-exploitation balance.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('kth(=69) out of bounds (50)').", "error": "ValueError('kth(=69) out of bounds (50)')", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {}, "mutation_prompt": null}
{"id": "685563b5-1f36-4448-b79a-ded61393f35f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "75dcf457-5d50-4423-93c2-0d9afb41b29b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "aadf88e1-687b-4f4d-a0d6-b87699713b2e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            diversity = np.std(self.population)\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand() + 0.05 * diversity\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy by incorporating a dynamic adjustment of differential weights based on the population diversity.", "configspace": "", "generation": 57, "fitness": 0.452241827811024, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8509960603787343, 0.8356302226546517, 0.845049525974212, 0.8241145913437364, 0.8332508804153433, 0.8247371567990763, 0.8470191314079492, 0.8489230606540078, 0.8365189580908023, 0.7287399920171499, 0.7246682885434486, 0.715216960806212, 0.7185706756804507, 0.7273422468094561, 0.7265282892044564, 0.6899148058173445, 0.7037828045005416, 0.7163327499176722, 0.3085031849893718, 0.15044058225930568, 0.15550607633625146, 0.13563971955867749, 0.1683952997123601, 0.2580246485402634, 0.14611014966032976, 0.3218219543404255, 0.11052539389798133, 0.13102866234239152, 0.12737461217174273, 0.11537733821678542, 0.13793992643375008, 0.1544321140961783, 0.1298555033562785, 0.11949464071495697, 0.12934665402059986, 0.11067542457765245, 0.9717224751911537, 0.979243992479829, 0.9508599049722218, 0.9229168434718434, 0.9706001890402508, 0.960321047201814, 0.9667449388222943, 0.9564189990801196, 0.9532150208571071, 0.568110640745835, 0.5727387039506239, 0.5950230706169615, 0.5689549277152869, 0.5787357000245936, 0.6101044742456319, 0.5954317570520897, 0.5785919315015026, 0.5966019379408617, 0.8404623109113118, 0.8049461712909104, 0.847701984436791, 0.8704467224593584, 0.8218666236518802, 0.8289735893195441, 0.8150320630448481, 0.7804142842873698, 0.8030469279721074, 0.504476069535158, 0.305337922721054, 0.44000775584691354, 0.44863367573692314, 0.4285154292023422, 0.5608994739239843, 0.4885055338072576, 0.4691496837048007, 0.4535621587151206, 0.1763706949275582, 0.4891496540866256, 0.600995800908762, 0.490997104752541, 0.38613930285418474, 0.12600866769873587, 0.498708724814828, 0.19490661151758903, 0.22604245095427156, 0.5104779008075256, 0.49961400275619616, 0.47382624522594663, 0.521291891953539, 0.5336731587248237, 0.5014951876848146, 0.56627909214343, 0.5887949973725711, 0.5821465395851448, 0.6674853340653129, 0.6677850438760533, 0.6329468874888479, 0.6176713916786213, 0.6081026741800027, 0.6289213032272606, 0.6628531973854503, 0.6420591798092438, 0.6954811302175186, 0.22295289412356945, 0.2553845346170228, 0.15669322892941706, 0.33985254227732264, 0.4038442950643867, 0.17236493362700533, 0.3348496716572992, 0.27050987061435494, 0.11406001065398574, 0.403230145997985, 0.41248522076189886, 0.39759304749491076, 0.4032786301181621, 0.4091382811885911, 0.38808763016867265, 0.398421554328644, 0.4064173550876641, 0.39876015020717015, 0.7620014960034792, 0.8034605498906896, 0.780317662915232, 0.7491239203294034, 0.7464773505009232, 0.7531519539886062, 0.7851625026513996, 0.7768627076494621, 0.7942502725619739, 0.11631313882003413, 0.10125418819066312, 0.1345676633342402, 0.13192309505418165, 0.12433990597140421, 0.13199777138331104, 0.1307285076312894, 0.11560912343174745, 0.11261445884524124, 0.1706470186199195, 0.26706009453601354, 0.16999874792970038, 0.1235796199069289, 0.22210136310224704, 0.12889719358515717, 0.16562673378330217, 0.16447016267981984, 0.12240636115685521, 0.4644845612617824, 0.5096175162070327, 0.5315701282953822, 0.5159260488368445, 0.4851100242460412, 0.5365867754510079, 0.5204905155605697, 0.5082844503221506, 0.47426075656606403, 0.3930707176538054, 0.42419201312116006, 0.4149163736825613, 0.2819729991353561, 0.41922741803334485, 0.40522750578277844, 0.37393370113385704, 0.37304367382669257, 0.4219851984021046, 0.20011454955121133, 0.18960867448738827, 0.211400758348938, 0.19865086430543866, 0.20651336843694135, 0.20162012207452717, 0.21395548196880465, 0.20337636446449892, 0.20427681348538929, 0.238151601717014, 0.562745966380148, 0.20830895392893756, 0.6934643342306926, 0.4167332259159975, 0.22555892012869938, 0.536279359349531, 0.3062498971463501, 0.20616482910869216, 0.17147757963010768, 0.7476986480154911, 0.8155221050808352, 0.7993446624042674, 0.758487806291858, 0.195078657061183, 0.8144633054398405, 0.7683993483510319, 0.7152246049364543, 0.8063602536947609, 0.17877113102177722, 0.8269540588276616, 0.16008581776607367, 0.681997562788333, 0.6873254928156978, 0.20710110595197784, 0.2093605864384801, 0.7814623191079328, 0.17656471748917535, 0.1696485113511762, 0.20352286254550678, 0.20551530899693315, 0.20113380449085594, 0.19503365112455284, 0.19373825162763314, 0.2006988003386626, 0.19453072333825672, 0.07930401571387047, 0.08513001949818044, 0.09835844240856206, 0.087843532784729, 0.09830680659629598, 0.0777622958834503, 0.06478970584525201, 0.07793266959623779, 0.09299622559341347]}, "mutation_prompt": null}
{"id": "bd46d45b-1079-4f33-b566-3fb17ae53815", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "08a46b41-d0f3-4dba-bcf3-d75bea20ba09", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "9523ee83-c429-4635-80ae-a9a68e22823e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "dae40829-b795-4951-891e-d6f7164287dd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "57bdeede-4fc5-45f8-bf7f-3e39f4aee3d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "c59b4779-f33d-48c8-b1f7-0546cf33892a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.successes = 0  # Track successful mutations\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                # Adjust F based on success rate\n                self.F[i] = 0.1 + 0.8 * (self.successes / max(1, self.evals))\n\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.successes += 1  # Count successful mutation\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation factor adjustment based on success rate to balance exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.398053921318398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8799013653139852, 0.8770222934670837, 0.8725213740502525, 0.8712049159860286, 0.8748362103976142, 0.8774916787630346, 0.8629385138272415, 0.8666319060181494, 0.863420725056812, 0.7553018575280466, 0.7780929841746062, 0.7769853148868099, 0.7495319103768308, 0.7594138223551353, 0.7714872569898665, 0.7470847182928004, 0.7657640586453842, 0.771821176088693, 0.16259517736766593, 0.14849165454635982, 0.17200583661905167, 0.18095502920589412, 0.17788472961765367, 0.3467545211008004, 0.1501570592328979, 0.15511486389093732, 0.17240102812431235, 0.1345267422497065, 0.1429702826888155, 0.15528979435345214, 0.13743066744311838, 0.15664173775032342, 0.19102152267631567, 0.1082835726260617, 0.1275967868909187, 0.14806421069023168, 0.902445184086017, 0.92931878771167, 0.9515185477753123, 0.9288668516961662, 0.9501917145719485, 0.952678830420222, 0.9342388267113025, 0.9500875304250062, 0.9367206552866416, 0.7149588636637637, 0.6239599102344839, 0.6446004024363661, 0.6009071092709264, 0.6999827975883774, 0.6882443665781538, 0.512084007858732, 0.4944773605466831, 0.694508093090743, 0.8744825361836567, 0.9063508089868595, 0.8675874021712278, 0.8559299266753391, 0.9173159510769351, 0.8661074235253244, 0.8364577566819764, 0.8641180021705495, 0.8644034337785511, 0.7079949132580505, 0.32450693579902823, 0.1580208193148539, 0.2484223768564079, 0.15294782213047964, 0.16464009040024108, 0.17736301843885416, 0.21662340400329116, 0.29258642233713794, 0.1939829733428432, 0.12068575229777379, 0.1308781071006364, 0.20626741502746682, 0.29499128164900346, 0.7359260585333572, 0.2005439530158214, 0.14204398638564963, 0.3443526937198229, 0.207437035098317, 0.20259829155579645, 0.11928922444107115, 0.44165846427330757, 0.08987293498173021, 0.06564420276145688, 0.01081925501890224, 0.1682964577985835, 0.053666251988929825, 0.2141737470634829, 0.2678420831093494, 0.3382218178251173, 0.15771543091563744, 0.17490605638710222, 0.08569344632029863, 0.31789824025918345, 0.5130472829537374, 0.3970797680438751, 0.1281391070565483, 0.319625829284663, 0.07572617017448702, 0.3354630243941419, 0.31237065283493903, 0.2512463574714646, 0.32619900303563276, 0.14982641287020082, 0.18073758626287095, 0.31373890163624696, 0.43760679426038396, 0.3006045962667222, 0.3903852778463236, 0.4581420027358768, 0.53265350401353, 0.3081062737936967, 0.5183592014369766, 0.15223645204305924, 0.6840107546040246, 0.755767579662054, 0.5996548485846604, 0.5892827673503076, 0.8427623656444513, 0.7208732124866328, 0.7656022830084512, 0.6483757339809919, 0.6406679595757601, 0.15309087781259823, 0.12436836157241138, 0.1106170029965593, 0.12673795283055422, 0.11879829807569364, 0.11413234485627655, 0.13194819728960339, 0.11766605564633914, 0.11343306581033685, 0.2297933410130042, 0.2625674996413382, 0.22051577588155602, 0.18013278341273253, 0.1758128002297128, 0.21220455803364968, 0.29191763167554696, 0.18982413325382397, 0.29521393212135394, 0.48979104887218816, 0.4608734199118947, 0.5957100922130599, 0.5968000904800312, 0.5653957861504726, 0.5693472617520814, 0.7045838377544092, 0.7261654412809578, 0.4789479268850557, 0.25518986111164443, 0.37417237375876466, 0.4081080835139226, 0.45460080562199257, 0.2909531593707123, 0.26173259001408544, 0.5837167280862283, 0.38126654028476725, 0.4130417445595721, 0.2550337913064693, 0.20642898851683633, 0.1856985727153999, 0.19539475772674786, 0.19467661583754725, 0.2156153995268294, 0.27636382611788135, 0.2442732249892462, 0.20552447574343102, 0.21615474736623597, 0.23354730108052857, 0.38509802274692717, 0.31546393999873423, 0.19327186064284596, 0.7889214509467752, 0.21854054419611457, 0.2151435094505466, 0.20424759248596014, 0.184768792205252, 0.8875972020741866, 0.15268029877367117, 0.19985410849149254, 0.20093205753118137, 0.9212557233511148, 0.16598856872609213, 0.1696832556789255, 0.8839021184172486, 0.8732577510292422, 0.21120448615107945, 0.8824556110335575, 0.16644176491743978, 0.16790739726741644, 0.16554145730543257, 0.16494139888289006, 0.1563095232820526, 0.28596999749855667, 0.1755945169346136, 0.17365992780602768, 0.1814409374780992, 0.20289888596348293, 0.19064706188964475, 0.1812413580108463, 0.19223679301458707, 0.20467933683284856, 0.20836325516577614, 0.08999985149481438, 0.09841529254924919, 0.09391201727495158, 0.10428075414507498, 0.10392468691385603, 0.0888745471296204, 0.09209882925501855, 0.10182007748948041, 0.09731429042163398]}, "mutation_prompt": null}
{"id": "027fc17d-c39e-4df2-9a8d-38e525233e3a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            diversity = np.std(self.population)  # Population diversity\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand() * (1 + diversity)  # Adjust F based on diversity\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic scaling factor adjustment based on population diversity to improve exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.4430150676819164, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8623842382868503, 0.8336687534751046, 0.8494453573332705, 0.8331698306793838, 0.8354057348402527, 0.8540959574204672, 0.8314733156183842, 0.8516371786462544, 0.8344512860683759, 0.7141998794857957, 0.720574183639378, 0.7210548481108094, 0.7090034022178937, 0.7332751030391208, 0.737505226781531, 0.6935153085327943, 0.6870182378346075, 0.7039051990463532, 0.15622935194680232, 0.1365841796938193, 0.4274464620847501, 0.5481219421347825, 0.12428820925829509, 0.3686539408401802, 0.13983074752174873, 0.26109911257856455, 0.3644934634862296, 0.14952357871770872, 0.13559657794935842, 0.14615075869962113, 0.13607363882684254, 0.1409044360704842, 0.1245795619893505, 0.15311646126199396, 0.13729728079945924, 0.1464879277721497, 0.9686857742359578, 0.963016458453657, 0.916727917757999, 0.9656714191053442, 0.9388054930993392, 0.9508990343525614, 0.9406086327627398, 0.9571526068869013, 0.9550016177073152, 0.6066219043204176, 0.5890609402173735, 0.5723483140995422, 0.5932640114390679, 0.6156823960157491, 0.5789131292794444, 0.5845262917225473, 0.5839473015331884, 0.617531516485068, 0.8257837229120292, 0.8514873856992942, 0.815331048779578, 0.8216105560070406, 0.861801641263593, 0.8188388475343542, 0.799821508478751, 0.8567890939894771, 0.8519818168069708, 0.32655700489155237, 0.5245413040052074, 0.6682717735070534, 0.4619996956053325, 0.6049466487591801, 0.5802391508902672, 0.3710630607107276, 0.3714109422590097, 0.503108990264933, 0.19950915841089112, 0.12429092413434628, 0.2254930065493621, 0.1866263407212505, 0.383379593325726, 0.12680817584139348, 0.18540455511189513, 0.1282661994804115, 0.2268541812444359, 0.49090783954318395, 0.5346345993429081, 0.5271662841805405, 0.5401336020462106, 0.5523454067370268, 0.4000836874983881, 0.5832004232401782, 0.6079003111865291, 0.49198714508103225, 0.6695760403834237, 0.6888306064561844, 0.6859312712010179, 0.6748714606223689, 0.6173678163687143, 0.6531267408068795, 0.6942550137734865, 0.6926388641329878, 0.6233408981071906, 0.12105942237358358, 0.12622927150386754, 0.28577993720287, 0.3620897146000238, 0.291292112572211, 0.36615305222675276, 0.2064822716251653, 0.12129947362089111, 0.21665234195040306, 0.39406936815096083, 0.3919805195388072, 0.39563947249333165, 0.4004929058738046, 0.3888718264731962, 0.37713041321697005, 0.40343414797229893, 0.4013910130649754, 0.3995442925680256, 0.7685040376455808, 0.780778752722785, 0.743211925572794, 0.7611699889153787, 0.768113864756627, 0.7448883912673632, 0.7835087595836747, 0.7652134015693149, 0.777149705201966, 0.12722592321434545, 0.10655976923794952, 0.11032822540038667, 0.31666348415956314, 0.11270618031666635, 0.09830212071598166, 0.10852567209112352, 0.14534787673852567, 0.11729176599456381, 0.15972194661999095, 0.3764276541529754, 0.13332779629365088, 0.17914948125977337, 0.22406788802876032, 0.1277038276112169, 0.1686309970121791, 0.19584752518312654, 0.15984711832528375, 0.4780750919099245, 0.5385901032949236, 0.5029000713434012, 0.5437760134544771, 0.5234165552613355, 0.5345056494923393, 0.48972754595044965, 0.5112864858314438, 0.4925570368600929, 0.44256711484283473, 0.39245492742618704, 0.40752297609632504, 0.4493374219790067, 0.4159999416836607, 0.4179981758823539, 0.3672997938271425, 0.38097205141883395, 0.3954220760327376, 0.19112477910806747, 0.17869206040350905, 0.2008467314953024, 0.19844865509494336, 0.18183721232860606, 0.19279599585637985, 0.20898998026282767, 0.187251086189837, 0.20699444864543504, 0.5825728155079553, 0.555218603640216, 0.22427846056393586, 0.23440954918442147, 0.21444914866830989, 0.21304289234585716, 0.1987478281037145, 0.5210665682688886, 0.22895231870473554, 0.1827621882306838, 0.2295592974117049, 0.19450214865314452, 0.8417983685995853, 0.1924165517311509, 0.8045330917862782, 0.8166230354770209, 0.165723663773923, 0.18260932340610647, 0.7846641556294782, 0.20692490027774135, 0.8176342014307899, 0.6496128751384619, 0.6955398914487303, 0.7226106735511992, 0.15385073884344402, 0.7992408518905224, 0.20744605469491173, 0.18147123953424305, 0.18346090031341, 0.1865109040222933, 0.17904243955357446, 0.17717284276013545, 0.18212225297001927, 0.17872831218839236, 0.1753928175560453, 0.1868550649956353, 0.08910108922687354, 0.07990380076914372, 0.07893877271872585, 0.09136873291248282, 0.08879938145190369, 0.08372629436576173, 0.08807256238460137, 0.0854114689626454, 0.08195015699778518]}, "mutation_prompt": null}
{"id": "65a3eb73-625d-4774-81db-059acc5a0e6e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                        self.F[i] *= 1.1  # Adaptive scaling\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of mutation factor F based on fitness improvements to enhance convergence.", "configspace": "", "generation": 65, "fitness": 0.46201277870554064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "cbcbfff6-4f94-480e-8263-035ad8b716fc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a greedy selection strategy for improved convergence by using elite preservation for the best individuals.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8658376732859595, 0.8687796795589471, 0.8694394573707126, 0.8724625512660305, 0.8736275162882141, 0.8699592153587621, 0.8596648960258548, 0.8845333276715042, 0.872381240596055, 0.7810335379260351, 0.7700501937620972, 0.7616032282008689, 0.7632363310261701, 0.7386612655901349, 0.755396360756936, 0.7760065128391571, 0.7615335487524075, 0.7714166722396433, 0.38033227987537754, 0.4344368402560813, 0.4597180219179664, 0.5115017035456093, 0.13450854343135377, 0.15931894117975243, 0.4434772829244643, 0.1442145875405877, 0.30307214947782046, 0.14128600931572455, 0.1547581702718519, 0.13531833106776792, 0.14517314425502625, 0.13826230003593665, 0.47867341928925033, 0.130686609652918, 0.14750955647428632, 0.12509219108991543, 0.9454865058548677, 0.9416660078238542, 0.9588316401336916, 0.969625735824792, 0.9370213467071344, 0.9567861176222033, 0.9224383168589929, 0.9405199923007158, 0.9353586834547691, 0.6628482065462105, 0.6595719491281733, 0.28166550255537415, 0.6404516847921291, 0.6616734957819832, 0.6885086684746384, 0.6639979318335975, 0.6518562521015521, 0.618766541751786, 0.8740137989131425, 0.8583709112133049, 0.8638636811416043, 0.8697267300640236, 0.8720397448521255, 0.8530477701101613, 0.8725108599462003, 0.8589335605875688, 0.8666989955907165, 0.28633259290657675, 0.22387389779696865, 0.3473475959200628, 0.31358849972403846, 0.5516704835270686, 0.1825180577492902, 0.40974686689104056, 0.46774933400369667, 0.2651237417519431, 0.1756532485757114, 0.3710708958088531, 0.2112347353713867, 0.20052221539266402, 0.5488213957865218, 0.35400283638884245, 0.2643096652076564, 0.18457346661280105, 0.3822345898235472, 0.35039622733341114, 0.28354469699487006, 0.3124736214096736, 0.6288929625911059, 0.6023305561199619, 0.019857791940058767, 0.6555408989349307, 0.6224668111438125, 0.6436929989666238, 0.7182523127888204, 0.7218500816861493, 0.7033411277509838, 0.12287364779976395, 0.7308623433221765, 0.7424621189760549, 0.7515057353981465, 0.7076854701985522, 0.7492943872943432, 0.2434728825554947, 0.25277790766870956, 0.10139871744507944, 0.4188879089000964, 0.2082720218609183, 0.48606556128957545, 0.18464386088209706, 0.3570399193337126, 0.07861858545974088, 0.5654183712603793, 0.4900015028810646, 0.5140990928933196, 0.5289354321319584, 0.5525144650028415, 0.507780590423933, 0.4016824726834155, 0.5314467895437196, 0.4533058323064977, 0.8089147315984079, 0.8108525507944018, 0.7976141186016752, 0.8140124681709278, 0.7889816936933531, 0.8102855189518362, 0.8057728293944676, 0.8235157645300881, 0.7495232502904878, 0.13327068521725816, 0.13716809867380597, 0.13100806976508061, 0.12144509879804388, 0.12907481909865715, 0.1326401482881152, 0.12582405758800086, 0.10857021347943596, 0.15133948350005444, 0.18089918672143457, 0.22523008442471093, 0.21584583276805158, 0.2263765596332381, 0.15484634529537378, 0.18284132206512527, 0.19139947637603316, 0.13397388589494663, 0.222763862893247, 0.5861837544999327, 0.6430929019008322, 0.611570389056463, 0.5844913735950354, 0.6263973473059017, 0.5730856959661744, 0.595976147492294, 0.6387592849257908, 0.5545037876987207, 0.335008924975411, 0.5364591727862746, 0.3477606981761162, 0.5039902589632134, 0.426115374480562, 0.5142474011115512, 0.37827023830393247, 0.4678809856637779, 0.5058425424750002, 0.1994119994074035, 0.2272086722087875, 0.21984886332673137, 0.2051534042578823, 0.2038937126777236, 0.1956730361863086, 0.19439995581455272, 0.2113211905029757, 0.21012773343055646, 0.23772973179698687, 0.6938299701156404, 0.2046965674292731, 0.6338752175423765, 0.23762674763459424, 0.2138422153138685, 0.212698717360584, 0.22141309153902788, 0.19370005171105587, 0.17021069829962254, 0.19181789896045198, 0.20936952389483066, 0.8747280410443403, 0.7220415963707405, 0.8195961889198824, 0.16569572190361836, 0.8832825254046373, 0.8748534846544109, 0.5319972587425112, 0.21042420863718847, 0.8757618449972945, 0.867463885651138, 0.7744198205034849, 0.16708565029737454, 0.15454740952555113, 0.592515258049886, 0.2091837709034985, 0.18674969462494395, 0.18094028234418824, 0.17576229134601107, 0.19936520548690728, 0.18924466602052215, 0.18727213959898226, 0.19094336329458295, 0.18403670724269072, 0.17624421538135682, 0.08368804787083484, 0.09160348067417201, 0.08745120522884775, 0.08134430155131267, 0.08431008019648145, 0.08476405184815317, 0.08847576962593862, 0.08554366894864596, 0.08864518171901747]}, "mutation_prompt": null}
{"id": "4eb3a0c4-38c3-42e6-97aa-9e3ed09f99da", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c) + 0.01 * np.random.randn(self.dim), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance diversity by introducing a Gaussian mutation step combined with adaptive differential weighting.", "configspace": "", "generation": 67, "fitness": 0.32956743344355505, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.6719961469844475, 0.6447426053079806, 0.6413887623314147, 0.6462018101497751, 0.6369363441670225, 0.6315312055393882, 0.6289180752710115, 0.6176751947669006, 0.6509164302794157, 0.2427379725316533, 0.23970194582853377, 0.25417335640522254, 0.2430394929646299, 0.26348955967553334, 0.22992946043864126, 0.2503291243471114, 0.26271050773639015, 0.25757573694586855, 0.2091040970529392, 0.1915605736277587, 0.1424431884109345, 0.25154565010889074, 0.25997928236068024, 0.16293733333701144, 0.16611172563828935, 0.16139395733034523, 0.17046546762034398, 0.1294959991171145, 0.1498291616183811, 0.24171411812460675, 0.1135358495731551, 0.11104745810088024, 0.1505377969656061, 0.15080919688788108, 0.14173608389827275, 0.1573201495020048, 0.9093138021623536, 0.9160869441704496, 0.9440035658748751, 0.9237987639896171, 0.9142249296690192, 0.9419330125284041, 0.888835356603126, 0.9210723866331271, 0.9572805672028027, 0.4135733763832754, 0.42121603935284035, 0.4339383564708438, 0.4150602363155459, 0.4245307107907814, 0.42086859016930567, 0.40614022145883477, 0.45274067715959476, 0.42208628760629785, 0.8861757874278497, 0.8891205848118886, 0.8654832415791793, 0.9040676537165054, 0.868923911779486, 0.8582919354214572, 0.8611017897906722, 0.8103285048073734, 0.8597204931488325, 0.310371504975237, 0.28996063179153597, 0.24398129448562156, 0.256582049589931, 0.27165587166769534, 0.2592809642373123, 0.28269264919793324, 0.3641883153678688, 0.26735138152091054, 0.24928275656475907, 0.2745704183915195, 0.25498446981700396, 0.31948763179872564, 0.12900798748208342, 0.30414304471468956, 0.2197484008523355, 0.2678739108751116, 0.28982430958158545, 0.1935159856717703, 0.1448755383302185, 0.1922695272466688, 0.09012520837861171, 0.16797988571604905, 0.06878264024741543, 0.2103532517755723, 0.15127919636783538, 0.16653529013151236, 0.22503378819730402, 0.24286444663889817, 0.2241571879531451, 0.2572915832355528, 0.10727908052116597, 0.24352083919791256, 0.2441251294585456, 0.25204670252791994, 0.28882080572992685, 0.08878559866101854, 0.09436714388973633, 0.0689608934627477, 0.0826863119202812, 0.07378357821731096, 0.07554633244858555, 0.09880336357508823, 0.0610477487934431, 0.0786281382720474, 0.18849493656586314, 0.19666220118030975, 0.19953593118623414, 0.1981441033034349, 0.2123236322128802, 0.17125503180557022, 0.2063124120628128, 0.20402200073587096, 0.20629939935456543, 0.5214101777359986, 0.5212607378071011, 0.5127026748466585, 0.5255260930357872, 0.5126386952950791, 0.530213800509441, 0.5439272060801835, 0.5268264288186016, 0.525845537639468, 0.11983164039057304, 0.1365126410651888, 0.12587872045874282, 0.15011056493634656, 0.13805472966626642, 0.2618599162570263, 0.11853279320234356, 0.13387048777010568, 0.16612195228448112, 0.3404376054139534, 0.2905598419577825, 0.19973338189506196, 0.22495471998770467, 0.31372026124330543, 0.22925706188723827, 0.2453289658368608, 0.3113610441016501, 0.40131221415804386, 0.3724942186590028, 0.36940047961517863, 0.3806733203115379, 0.37503215465400996, 0.3690686619986423, 0.38494602009205325, 0.3917189993652993, 0.3736005948621651, 0.3864753062579137, 0.30335888106024933, 0.3113563706284075, 0.3059253526435326, 0.31511434773848046, 0.3088016407938622, 0.30610660387381194, 0.31457500426007945, 0.314493713984759, 0.3555474092172404, 0.20033211682665264, 0.22450479169624482, 0.21442954415768922, 0.21749898705530624, 0.19800605580582342, 0.21694229323339387, 0.2085831037456667, 0.21014180848804553, 0.20119517847536583, 0.22201105847269365, 0.3912331181639024, 0.2189855952908063, 0.23878506333037086, 0.31685340507635584, 0.23524888614128026, 0.20736877212494143, 0.22479769775048708, 0.19615701461090074, 0.15315778338925468, 0.20752010743108062, 0.16512662213072815, 0.8473511307719, 0.1769196891082927, 0.8360798743749545, 0.18465822446162905, 0.16751694408151507, 0.1816346162358552, 0.8840968381576659, 0.21022857646369497, 0.6555006886915467, 0.8067022859647791, 0.2072904674134497, 0.20906269884198325, 0.2109153804515329, 0.8196178986236339, 0.8439819901456829, 0.18880160868317875, 0.19337639873536727, 0.18837202057834934, 0.18921187748642976, 0.19767416130839421, 0.19158863092729284, 0.1774335285004659, 0.20640344947625977, 0.2017189840671788, 0.08956866243206496, 0.08222112981918983, 0.09593672760772043, 0.10208396070441961, 0.0871614993264056, 0.09310585286044748, 0.09302197838944759, 0.08957513401809902, 0.10541375154879185]}, "mutation_prompt": null}
{"id": "8a9db4ed-a4df-44ad-b294-eb485d8aec07", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                self.F[i] = 0.4 + 0.1 * np.random.rand()\n                self.CR[i] = 0.8 + 0.1 * (self.evals / self.budget)  # Adjust crossover probability\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting crossover probability based on convergence progress.", "configspace": "", "generation": 68, "fitness": 0.43011835830298417, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8696391193844958, 0.8684176618137216, 0.8516704177312322, 0.8554799706550364, 0.8518827312863202, 0.868655796242997, 0.8499994899670495, 0.8670849490488157, 0.8667603308972708, 0.7511293687701975, 0.7717196845132677, 0.7411626678457661, 0.7646580252682709, 0.7684535846720029, 0.7626534586827586, 0.6511609596072856, 0.7664302617449237, 0.7754274124191103, 0.15422082246529567, 0.17411763282599024, 0.15438303564166944, 0.5153737377301397, 0.1944194273708606, 0.3039099605315633, 0.14639374084243661, 0.4706935344916473, 0.40798266733754096, 0.3535291507979086, 0.14941553565959842, 0.15146365704782527, 0.13956234427459513, 0.14850743146948264, 0.14554099785379893, 0.19078802715928445, 0.1434148002470853, 0.11264351862914501, 0.9550903916774353, 0.940604534643915, 0.9619552291404827, 0.9298266901318415, 0.9465208007596146, 0.9077981747464234, 0.9522525013210461, 0.9457662712330821, 0.9627922102388584, 0.6392804717009468, 0.6197792692047519, 0.6306165261241525, 0.6097315870785918, 0.6262448237019067, 0.645713579650681, 0.6422225695924643, 0.6236340041808588, 0.616325843221683, 0.7987907392555789, 0.8045166561949445, 0.7763024373955804, 0.837393401382733, 0.8204968775775517, 0.7965917744425814, 0.8318071972006419, 0.790014655919626, 0.8391785247665593, 0.25245424800515426, 0.18846484413687936, 0.538040756917131, 0.24901785960361267, 0.20902881703158016, 0.38462825286259117, 0.19355979929883216, 0.44866313999200325, 0.22787515285449156, 0.1872129949478235, 0.2602516008164393, 0.19637760694016537, 0.47031078889665523, 0.22698729311494514, 0.19697142930766143, 0.19354145649286458, 0.19640121782750064, 0.19010694268403638, 0.4555535011280797, 0.502679408846304, 0.47982280453851267, 0.46371296745405044, 0.24456443016076368, 0.30275461957649563, 0.48178978654668714, 0.5200758210463406, 0.34404390205371627, 0.49346628553933525, 0.5297924965612343, 0.6203539707582308, 0.5084757817449682, 0.5557024551100953, 0.5790001563248103, 0.21911647663650957, 0.638185357041045, 0.6199171536159507, 0.14533023131286138, 0.2647944321926068, 0.16179027743482788, 0.3128195850927098, 0.3540622832950233, 0.17845297609439603, 0.1956211768666548, 0.23878234467748438, 0.17561355460762518, 0.3988708510200737, 0.38981807168491, 0.41690203543987014, 0.3282191681473535, 0.45055160954900486, 0.43924443728147466, 0.38853048437952575, 0.41864974218045403, 0.35991824032049624, 0.7628695966969222, 0.7939623788467304, 0.7788537086204311, 0.7847616826439431, 0.7686006453386517, 0.734203904576128, 0.7716233359138545, 0.7210273873989473, 0.752056051702239, 0.10004899372606602, 0.13666497617421425, 0.11157687769159108, 0.1108244066280476, 0.1152420121403247, 0.11331308818077634, 0.12003464648195405, 0.11125188174700884, 0.1124188780369948, 0.18257098154992435, 0.18522700648881107, 0.14555382121628446, 0.14292572636828282, 0.20319586937827971, 0.15020421543946794, 0.19723164153951245, 0.14473139033197457, 0.3339585497227374, 0.5645581220288269, 0.5344806613654642, 0.5136606139901103, 0.5862582101532059, 0.5539143573053238, 0.4929146462281029, 0.5765455838112266, 0.5558246313900588, 0.5521025965553625, 0.37899550859505593, 0.38460446193635145, 0.3992066862295215, 0.40860910394787175, 0.4161667148598073, 0.3878546639456508, 0.40000350815612695, 0.4079542169060334, 0.37960717257846666, 0.2038517605423874, 0.21896776905864912, 0.20305863951132364, 0.19456346370503108, 0.18994656620974315, 0.19843914458160394, 0.2317109097485457, 0.2271551612951811, 0.23489256121865032, 0.23194632387811154, 0.5257036146848963, 0.2135508760151097, 0.39827185239351426, 0.21104053656742772, 0.5786906921632933, 0.2305775717932398, 0.6475719626207141, 0.32093093836752673, 0.17650807131949708, 0.18510063146849243, 0.19467096201725687, 0.7565189466858078, 0.7923807618247579, 0.7622366282174752, 0.779651687087018, 0.20937512531258484, 0.796850195072965, 0.7809258860335027, 0.20812831803515108, 0.7750634725479615, 0.16227158871239622, 0.20002565370721692, 0.16584100950077407, 0.793562211446512, 0.20404840134402524, 0.19346374412793854, 0.1723579392842075, 0.17725816056947863, 0.17941846631538594, 0.1624369580875069, 0.1764392904383143, 0.2180412842320436, 0.1734010758644443, 0.19394879197691361, 0.18043698602992242, 0.08683663760108362, 0.08406547115910035, 0.08253806919883178, 0.08922630951556387, 0.0959181840765585, 0.08670779058879086, 0.09007201794815678, 0.09587761676138429, 0.08802885701615837]}, "mutation_prompt": null}
{"id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 69, "fitness": 0.46975649739980335, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "72b4a30a-5244-4ec5-9367-ca70090f1cd6", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "415d510c-d672-421a-b529-f9d8e4d5086e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n\n                # Modified line for dynamic CR adjustment\n                self.CR[i] = 0.5 + 0.4 * (1 - success_rate)  # Adjust CR based on success rate\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting crossover probability based on fitness improvement trends.", "configspace": "", "generation": 70, "fitness": 0.41644058902529285, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.846462511105273, 0.8340740496038986, 0.841587987957223, 0.8444023263659634, 0.8357909544084334, 0.8430499420346658, 0.8584259857247569, 0.8445250718537911, 0.8351662758472931, 0.7271439612892714, 0.7109233966557427, 0.7107686311083433, 0.7247107159789986, 0.7285781841674495, 0.6971120597559809, 0.7142425344539055, 0.7246372702179924, 0.7110422406891603, 0.39485491002501727, 0.37767851805269836, 0.15378628935791927, 0.2608713611895731, 0.13878798101553969, 0.6079197840917603, 0.4115731720796517, 0.17478731789058533, 0.168187230874429, 0.1491434220909974, 0.13706937497198157, 0.21383934106463265, 0.15161295927406937, 0.14261823458771816, 0.14713958433735042, 0.126284587370048, 0.14173342920024767, 0.3126301505297914, 0.9500682535638739, 0.9848813057077874, 0.9534504047058107, 0.9675896592437979, 0.9663767439792654, 0.9273166292949102, 0.9531522058651409, 0.9420506605487481, 0.9691062016457836, 0.6104404541350668, 0.5886684936708217, 0.602778235480026, 0.5890710988724215, 0.5918230375319665, 0.623668279824247, 0.5769792453608746, 0.5355064721917107, 0.5676530412588857, 0.829960480935752, 0.8353669720040944, 0.8385169622836839, 0.7858496027849213, 0.8073221528826551, 0.782147915613282, 0.8334805122643391, 0.7914600593693008, 0.797769712629701, 0.31927399217017627, 0.3450292034992217, 0.5698198607165383, 0.26134885677958286, 0.18725760086101528, 0.29464851001091175, 0.2701848771638311, 0.5031790267861989, 0.20719161506519435, 0.2618735895619442, 0.22249247849211373, 0.23232014596757977, 0.31285339624284314, 0.2798134212110124, 0.18010277714810652, 0.32420270060451317, 0.23976087420275294, 0.21559857915551695, 0.4795657817647029, 0.4449135092716905, 0.3839998092390009, 0.39139740181795935, 0.44390925921684776, 0.4659020369160447, 0.3372315635615707, 0.4639907265225264, 0.30398316717442986, 0.5447905275310116, 0.5552337992317935, 0.18460863408512662, 0.4937107540141916, 0.5280383382469495, 0.36959375328425403, 0.600911196002802, 0.6087178921332042, 0.6057171730693818, 0.23437864239702444, 0.23104209413265242, 0.058219018362001274, 0.10801933062068059, 0.19059951725895907, 0.1617653830231851, 0.1697507078680094, 0.1979264117893932, 0.12220161769712412, 0.30267415212910687, 0.3164700633565952, 0.31986136933918374, 0.3028668763336404, 0.3216871369356259, 0.3656985235913428, 0.29505741585106093, 0.30568300107792545, 0.36540869109259977, 0.6579309950043244, 0.7152829298602559, 0.7157900702570683, 0.7256441145314481, 0.6899120678944745, 0.7195487136870093, 0.7232638968520506, 0.6774830653360037, 0.7358326755421836, 0.11530049219994654, 0.13637280735012225, 0.09973740500946437, 0.11664344366721524, 0.11980721127782457, 0.13060300884670728, 0.1269026080921749, 0.12456616348327698, 0.11028826239198186, 0.18272260512952299, 0.19140185909794294, 0.2085978218118706, 0.20960764532402365, 0.20410232283562413, 0.4510895885596359, 0.20030611274570187, 0.3593508149705883, 0.33930473570247455, 0.4837391839011703, 0.45059015470868613, 0.4973991051818992, 0.51719263676464, 0.49130543110479474, 0.5264906137586964, 0.5249530047232278, 0.4988768983783959, 0.5639570473409403, 0.4021734088864991, 0.3683655493600665, 0.4281148402983648, 0.37467896351339613, 0.3500837150261197, 0.3954290031848007, 0.40445139786551876, 0.40035715206424194, 0.41954071521919944, 0.19488664268136258, 0.19225524248893666, 0.18693970562888929, 0.17329834343128536, 0.19813599399683868, 0.24729900041570085, 0.23201222243321729, 0.18009069250945342, 0.21789231575450563, 0.21063876093885114, 0.6476655285031926, 0.4236745606433614, 0.5229074737368453, 0.2063526862517553, 0.2323737102182335, 0.22667679466153923, 0.5460390812479922, 0.5034838400472744, 0.18394645685834266, 0.7632898859152771, 0.8685190040675392, 0.8290978457530968, 0.19596235369891923, 0.19445127184906608, 0.16406399582283715, 0.795051558600167, 0.18277630874933115, 0.20536206034055626, 0.20783688394556565, 0.6680581690224244, 0.2007489483135011, 0.20314646359699018, 0.7714558163362648, 0.20744722896956458, 0.2085816174485341, 0.20908277978584733, 0.17424601648296134, 0.1829503332225224, 0.173967347838201, 0.1714683390428987, 0.17442266827384834, 0.19121380287548195, 0.19095579968411636, 0.18488129722546798, 0.17924199703726096, 0.08401473698519568, 0.09337392925007115, 0.09156596225298286, 0.09691147564493752, 0.07951580406995984, 0.08573802857410906, 0.09012234432375776, 0.07635993220694348, 0.09553058861823305]}, "mutation_prompt": null}
{"id": "5c2020b1-03f7-47c9-bb93-dfd8c03c79f1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "4e38d660-8aba-4b3d-b76f-bd9fccfb2a2b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand() * (1 - self.evals / self.budget)\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover probability by incorporating a time-dependent decay to improve exploration.", "configspace": "", "generation": 72, "fitness": 0.4591270527019545, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.86593230565438, 0.8660016007919471, 0.8640386400914701, 0.8645034688294153, 0.8649576503845311, 0.8492652091130573, 0.8544167845710713, 0.8698066180439641, 0.854881481125396, 0.7441231871983967, 0.7382862300586102, 0.7432817592062866, 0.7282573400757766, 0.7339734231694129, 0.7487490785794454, 0.7124096315821546, 0.7410460544309065, 0.7296371486535379, 0.4161014817930573, 0.14912173516341776, 0.3955152448026823, 0.38048737412535316, 0.3638502532387369, 0.3709784553563461, 0.15828333998370703, 0.292473559331874, 0.15142680506651263, 0.1585730620035236, 0.2940059151786827, 0.1565349514331601, 0.14416586160853162, 0.28423140430893223, 0.36090322121147944, 0.13023617611222038, 0.14011272402929387, 0.282755273025197, 0.9473374497559671, 0.9238235711263321, 0.9484388059264157, 0.94196687856031, 0.92847591640886, 0.9675660693587553, 0.9676802054768835, 0.9295986313409371, 0.9681813356330702, 0.6356305197521038, 0.6440694200124754, 0.669876348938472, 0.6116277840022661, 0.6375391890563851, 0.6489761642057623, 0.6571229856938499, 0.6400251565840812, 0.5239383175715651, 0.8718068708304166, 0.8542826209285905, 0.8289234990216792, 0.8744693623424318, 0.8504945753749411, 0.8226519850048883, 0.8448213485613426, 0.8618079138593795, 0.8622405846997869, 0.20034767263390418, 0.25361250794415413, 0.2386873885026506, 0.4725328408384326, 0.5648816617124008, 0.3265073531450804, 0.18919608369571528, 0.13174559891801274, 0.4809212652602428, 0.16049309563398761, 0.11584906838903608, 0.3185823118040976, 0.2802023598765274, 0.24051498399028137, 0.29510073741205567, 0.3577066343268137, 0.1294156629604173, 0.17452729876442752, 0.5910604512225998, 0.14472912533583604, 0.5431050027980131, 0.541279918228551, 0.5697221477408518, 0.4580597539034036, 0.6150829871284005, 0.5900492996594688, 0.5158152994242573, 0.5751159933149124, 0.6482886915973614, 0.5681129594642442, 0.6583896227663419, 0.6572543597066909, 0.6847018484415199, 0.7014159559716564, 0.6803737022147816, 0.6091678472801608, 0.10387746838378642, 0.19861570019740027, 0.290119113280786, 0.4412074256471472, 0.3785775542932145, 0.15719525138085078, 0.1993929808326943, 0.19454326797793497, 0.20958443415005046, 0.45371845361232144, 0.38794256909606517, 0.40677599459660163, 0.41709424994128974, 0.47332636913107407, 0.4420733026604936, 0.37346251494093863, 0.4321077739252812, 0.39110514719206535, 0.7589620873960378, 0.7562232522917383, 0.7955142586995811, 0.8005269328245045, 0.8093666235808932, 0.7769358016196831, 0.7913179247908447, 0.8044085173118328, 0.776199876186599, 0.10647672813955156, 0.12524300033421187, 0.12209222473755055, 0.15187296700208974, 0.13101061707150108, 0.09927195134309952, 0.13672326733776574, 0.11926310925643069, 0.1302050996884131, 0.2381343945392007, 0.2328256693843388, 0.2005401254374234, 0.1798733509617224, 0.49232758262062193, 0.1966590182249054, 0.17774998010012388, 0.28976247459897175, 0.1571108733247516, 0.4613980451907852, 0.5499568573818056, 0.5939659188082824, 0.5442014890728313, 0.5645649854473196, 0.46649054264294176, 0.5560506624063424, 0.5821292871012544, 0.5757864745445154, 0.3664369726255161, 0.25791992515586604, 0.3876254753711408, 0.212839250749442, 0.40190879361341103, 0.3817626018910071, 0.4918112369508685, 0.539787285924429, 0.44841026663572214, 0.19313022975250305, 0.19575878143144032, 0.1930532576554036, 0.19818722368064867, 0.1930333129116194, 0.21484387739738242, 0.23982286770666783, 0.21744503706088747, 0.22371626037241854, 0.42378620956419666, 0.21922418571896674, 0.2075007515123225, 0.43379126662209766, 0.2190780172825898, 0.2344300221000548, 0.2292814959545192, 0.6510142520439193, 0.2076063687372638, 0.7998474096988073, 0.20995329098959847, 0.8110907981920489, 0.8312298462608899, 0.8205400700921641, 0.8284748638623509, 0.16479651051487088, 0.7282522540133345, 0.8590434985609681, 0.8270731056487335, 0.208184942096311, 0.8276423487265339, 0.7933030104249664, 0.20860955244952817, 0.42097667683670514, 0.16583615181586153, 0.8343185995105615, 0.7645572545127927, 0.18646042784490102, 0.18182221562754242, 0.19600668242778163, 0.1921310593637866, 0.1925736112575449, 0.2000222069554205, 0.1922710042564969, 0.20939474052337903, 0.1783404785729925, 0.07959422333709154, 0.08797467360920674, 0.08642427578226275, 0.08806151718859512, 0.09243182648946435, 0.09437382553958029, 0.08802810900292257, 0.08086665948329641, 0.10662144172239385]}, "mutation_prompt": null}
{"id": "e4bcc241-e1e5-46c1-b107-ad9eba762a6a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "f85df8e0-6c9d-4a2f-8673-a795c92bebfa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "5339dae4-35f5-4fd9-9dde-7c11699e7da3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            if self.evals % (self.pop_size * 5) == 0:  # Refresh elites every 5 generations\n                elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n                for i in range(elite_size):  # Preserve elites\n                    self.population[i] = self.population[elite_indices[i]]\n                    self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic strategy to preserve elite members by periodically refreshing them based on the latest fitness evaluations.", "configspace": "", "generation": 75, "fitness": 0.4460105935411345, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8419636470239993, 0.8487574666637011, 0.8405833381096863, 0.8307565109059497, 0.8323586717319089, 0.8418944684877392, 0.8333831509389231, 0.8449085490380488, 0.8356473595833265, 0.7071047098948927, 0.7225522119499463, 0.7107586317657807, 0.7228083436712838, 0.70908575306993, 0.7205724182758271, 0.7158038857942791, 0.7266681989037913, 0.6946728763619071, 0.31770912050544253, 0.1584503691366801, 0.1404008831448993, 0.3632439245791924, 0.14318602111319234, 0.44655083018282316, 0.4075448784784338, 0.38392803596171066, 0.1402607445209817, 0.13362303675589737, 0.12309698514524825, 0.11886205411013884, 0.13946411003770687, 0.13136577438654928, 0.13522277670067018, 0.12962248575265878, 0.137342168323921, 0.13927971258186012, 0.912944764910954, 0.8551879252192488, 0.9028646578304962, 0.8878871288057845, 0.9317726649702298, 0.9367365510979351, 0.9296869066683582, 0.9303527007183587, 0.8948478497274468, 0.5843099773292897, 0.5473729918254323, 0.555244552606841, 0.5571596036282285, 0.6165134373407122, 0.553347048487575, 0.5456289778126822, 0.578349732679547, 0.5585520806005504, 0.8391300910533817, 0.8488569755426763, 0.7936178950622084, 0.8596393995949687, 0.8506157425908121, 0.8252697816868404, 0.8510678287821448, 0.8101129164301011, 0.8455370365689453, 0.13928398260356822, 0.22978741620971432, 0.1621890295767907, 0.26120960531225257, 0.19331120466016216, 0.1878362606575713, 0.1952462383671676, 0.6103120688070971, 0.5396031341682634, 0.1509969711833533, 0.2845172283453311, 0.2257634645136749, 0.22987343929834536, 0.17245774958545335, 0.1781833117478835, 0.2306938797521183, 0.24885114727361157, 0.2386871903572344, 0.5615206724689732, 0.5087753165582359, 0.523099817325615, 0.5142508897244417, 0.2010570269945431, 0.46913868097035505, 0.6248310347550183, 0.6044567724886809, 0.48584488963157524, 0.6728503976296252, 0.6799924707362357, 0.6849635426334126, 0.6785258836608478, 0.6025464863180348, 0.6796692966284938, 0.6903955656555822, 0.6640963808675451, 0.7005649805983261, 0.08720329549198047, 0.2496491122002863, 0.142698429998117, 0.46938010724574775, 0.17652904406641934, 0.22722830423029539, 0.1806387645049362, 0.28454852519215723, 0.2479679489524187, 0.46812750205710896, 0.43726077591332935, 0.4689946530720108, 0.478275681487186, 0.5025881261992666, 0.5077035574896676, 0.42893833808626036, 0.43630977905068735, 0.4603779214324981, 0.7989023482393416, 0.7849521403314632, 0.7765087870737691, 0.7655106899125144, 0.6052237213460081, 0.788205245264318, 0.7972969928722144, 0.7863055320040218, 0.7613392508796913, 0.16562934184015177, 0.13227043093711277, 0.11801934432932615, 0.11951267821228506, 0.14527648641094804, 0.13523208579965107, 0.11826789436076401, 0.44932789658456596, 0.1693416615893868, 0.159549292558257, 0.1737607216802618, 0.19389760508119613, 0.349897981717197, 0.5825068828069337, 0.2639048882080215, 0.21703812249617493, 0.2080603450571823, 0.25158179873048025, 0.4823215522497951, 0.5228379701601928, 0.522185231581626, 0.5331907258317077, 0.5348761955355621, 0.516141588206382, 0.5556143955551306, 0.5672340674168526, 0.566887007902051, 0.40259627524415376, 0.38111568504878557, 0.4280662590962927, 0.5026445466071106, 0.43202698281874985, 0.39974185279929764, 0.46966376495466156, 0.4539638249809762, 0.47301790295039514, 0.19835888839488802, 0.20410454687734036, 0.23844371618708982, 0.20681932534229008, 0.220786588563204, 0.2544671450702106, 0.2161849493269653, 0.21188942272220024, 0.20232991036388925, 0.43196675514525484, 0.22856968382717546, 0.30326387983578484, 0.4612060594811628, 0.42291798350831245, 0.23191438839740108, 0.24126928033562267, 0.4790193359857693, 0.5781759911739934, 0.7628821794750706, 0.20557307898800248, 0.8062968691031526, 0.1766350927992265, 0.8249092095212174, 0.16316958745071242, 0.7741435582847663, 0.840279348666664, 0.8338220109241044, 0.7915827830201408, 0.16414835358268975, 0.8208424481050616, 0.20043302825232945, 0.2066510660456471, 0.7578622078770872, 0.20447176610057827, 0.4843673273400235, 0.21010271203686648, 0.19746130233917936, 0.18689392128562243, 0.18330504333701547, 0.1902067701469936, 0.1692430205695562, 0.17445544387030365, 0.2095757272113664, 0.19432959487454626, 0.19022345498020488, 0.07120875917617164, 0.08328115845246031, 0.10980800471423258, 0.08460147411350205, 0.08070700384734952, 0.08585259978534254, 0.092038781344569, 0.07940427412872741, 0.08254077943684957]}, "mutation_prompt": null}
{"id": "974528f4-c570-49e5-96ed-9142ccb3e3ec", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "91ce725a-2da3-41e9-989a-d25fd33bca9b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate + 0.1 * np.sin(self.evals / self.budget * np.pi)  # Oscillate F\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a dynamic adjustment of the differential weight F using stochastic oscillation to enhance exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.4612573804039246, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8454388830978815, 0.8588600031879383, 0.8430409170865896, 0.8556067180045277, 0.8599770620278725, 0.8360007637330076, 0.8435804368351622, 0.854931484692041, 0.8313165620295405, 0.708196445781575, 0.7216216473007571, 0.6869627323936107, 0.7381504387130997, 0.7191440543366369, 0.7314187803952119, 0.663648910520269, 0.7222635785978762, 0.7128005261791881, 0.15108017965056275, 0.15540553961356385, 0.14157623306498424, 0.3836729956975601, 0.16599303602832582, 0.3081772077339626, 0.16401743520135936, 0.14691103664878125, 0.12591120140886092, 0.15001030690078054, 0.14257584490653286, 0.13237331845192346, 0.13110371660411402, 0.1280921387023367, 0.12724651314815294, 0.40296745727178374, 0.14410992352914742, 0.1351263876824227, 0.9279086124339213, 0.9491864668873666, 0.9421471300193711, 0.9322316028698188, 0.9263338746312135, 0.9676063228447571, 0.9640946862427856, 0.9327837225762112, 0.8967011075696703, 0.5802926783206683, 0.6398725558675095, 0.5969322626659438, 0.6073480573514942, 0.6459360280632445, 0.6188918631166164, 0.6358248862142775, 0.6282517380522585, 0.5925263929132131, 0.8287226993282683, 0.8508226373484999, 0.8327514485228642, 0.8503003615715874, 0.8524788766104611, 0.8394464029207195, 0.8195129686709467, 0.8181907092308194, 0.8638804397758351, 0.6111825856439921, 0.5748300897167136, 0.36235793513299475, 0.45263469777289733, 0.5196811111067451, 0.602237290316376, 0.4894389010412016, 0.6255838506065045, 0.3725167453964655, 0.2093815568267876, 0.4778015173681093, 0.4673009201450504, 0.3931478611837569, 0.6670182979312789, 0.5282466710973349, 0.4798768801219102, 0.47595754010928193, 0.5258074436480678, 0.6090342029100363, 0.5161043156580761, 0.5625390610851342, 0.5647792141681014, 0.5830388780160425, 0.4873714031204184, 0.6035019614818757, 0.5956798898652429, 0.5318992197216259, 0.6739656508559404, 0.6989649872732661, 0.689521053441647, 0.675927356217237, 0.6693392384954535, 0.5989669177144197, 0.6645146454527168, 0.6561971971578691, 0.6527266188078131, 0.11758257549752105, 0.15522647708081627, 0.1248411545166418, 0.44281215277981323, 0.4944330375889183, 0.22377501916688192, 0.16496340000176712, 0.27056896934458186, 0.19463057751148105, 0.4640903287929956, 0.4562608631430817, 0.4430253373167897, 0.4577585521508648, 0.463084127400878, 0.4642593886664925, 0.4147396429708087, 0.44483793346341416, 0.4307887710500753, 0.7707730466002302, 0.7951290173211523, 0.775714717109908, 0.783470466800157, 0.7838806588333138, 0.7696163574544932, 0.7698791346283188, 0.7855679623794479, 0.7588966688974269, 0.10841981908141374, 0.14341562935104935, 0.3696152437079442, 0.14279946886421313, 0.13961144264832215, 0.1309883335546399, 0.1120369240441016, 0.11290869072412801, 0.1164127776382633, 0.2246245875431312, 0.19137856584356372, 0.16913406879818138, 0.20722286717603677, 0.13267942742270222, 0.16407282065622852, 0.34561355299171703, 0.16024078878607229, 0.14620238029553678, 0.5146552060528159, 0.5505711384682666, 0.5428087007447588, 0.5392280760825368, 0.5292429446345015, 0.4799426816117016, 0.5555050112529638, 0.5564575646385377, 0.5097364362101346, 0.40175737803033473, 0.4168225980909346, 0.43824908764671544, 0.4110000487941686, 0.43707948586202006, 0.41681861659749697, 0.42374305523745925, 0.41453688295903657, 0.4360893414848218, 0.21212478349501873, 0.20983111803797605, 0.18023184635628298, 0.19190872873229659, 0.21017185469559796, 0.19654152851887197, 0.22264211449004256, 0.20019938336505094, 0.21221290131954273, 0.4557747373045513, 0.5375681126697256, 0.21955921947009105, 0.2293072833492894, 0.18887249150005092, 0.5088884485577967, 0.21985040709588521, 0.20869308811550902, 0.19760782830893298, 0.8424644602601976, 0.20867322919143483, 0.15086744115517536, 0.8075049251623132, 0.8632864001229119, 0.737629991859637, 0.16017567795798682, 0.1670915708135099, 0.860452966321443, 0.8437141986302613, 0.20920330032214762, 0.8449576378908967, 0.1661398414058245, 0.20853696901557428, 0.16597177822394749, 0.16481789871475616, 0.8168114897289211, 0.7448064629259136, 0.19648815786183393, 0.1828573831967194, 0.18573476533746625, 0.1844611063551571, 0.1753315834956144, 0.17145473886982032, 0.1889867335304395, 0.179254286944193, 0.19019989071378784, 0.08532310178793157, 0.08678484203489156, 0.1025066485843914, 0.10248846733828687, 0.08963233390833447, 0.0835708309341815, 0.09663739423011453, 0.08972596578252812, 0.08347518287525346]}, "mutation_prompt": null}
{"id": "9da89c08-1a56-4513-9d38-51cf9da4b992", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "1659746b-3266-4631-b390-425d7d6d4794", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "c4a9a03d-556b-426a-88fe-53d6162d8c99", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "0ae1f75f-760d-4eeb-b30a-ced27eaf405b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "b07b8506-4426-428b-ac89-517261f24e2b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "016aa93e-a3db-4bd3-ac3d-ec6214327e48", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            elite_contrib = np.mean(self.fitness[elite_indices])  # Calculate elite contribution\n\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate + 0.1 * (self.fitness[i] < elite_contrib)  # Adjust F\n\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by incorporating elite-based weight adjustment for improved convergence.", "configspace": "", "generation": 83, "fitness": 0.4540000407619064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8503486966435204, 0.8421018733375265, 0.8398712397845876, 0.8511973822058373, 0.8621825844284309, 0.8424334677848299, 0.8475349627209252, 0.8394089021877205, 0.8252506335286658, 0.7504112719638816, 0.6999778260422742, 0.7197791436309228, 0.7256336842463567, 0.7060772751558348, 0.7370268745977523, 0.7230154785578027, 0.7320779106070138, 0.7482340330670272, 0.2933397696255463, 0.1591435822855296, 0.15801716902849638, 0.16854216417849344, 0.15089415469764988, 0.3945185227718896, 0.3347925837736969, 0.16320629545278242, 0.35396662560188064, 0.13989462542615916, 0.14200683724606622, 0.12801798040297674, 0.1260694719329447, 0.11409415886007535, 0.12329586172468265, 0.13962971834779403, 0.13013772635821064, 0.15780629452107275, 0.9471724637348299, 0.9586958917454843, 0.9625983340694992, 0.9572987540376603, 0.9460297106040116, 0.8782498779268737, 0.9485610665255065, 0.926476761464624, 0.9311742479092584, 0.6406603595927177, 0.6185795935195839, 0.6148702164564995, 0.5755235844312333, 0.6166603003966054, 0.6115676383177506, 0.6372809601663891, 0.6070927481522115, 0.5901879252025244, 0.8504051305235691, 0.8452978766127677, 0.8408086461856136, 0.8539505115088882, 0.8637628312584853, 0.8415693672171924, 0.8698747330146419, 0.8656586879537786, 0.8508265684392594, 0.18934796143786115, 0.2285008272955873, 0.1578217873494594, 0.1525519621909367, 0.33583333691882256, 0.3680051309264013, 0.15945938595095632, 0.20479751636335175, 0.17998729022979154, 0.1395045894075969, 0.12593032704933083, 0.21520405037489776, 0.2641457473345399, 0.14600076064571754, 0.24522858383451085, 0.1766659108771299, 0.19205069784845996, 0.2535992243695069, 0.5642277998505623, 0.3630558378921557, 0.5011112717958195, 0.5119181610109651, 0.6622072645509935, 0.6223484087671762, 0.2758810085604143, 0.6543771200942847, 0.6302048548450794, 0.5699020698194859, 0.6902827771630575, 0.7133503204433114, 0.6815015633110983, 0.6981283517876995, 0.6807139435632727, 0.7311878157816496, 0.7263923832690694, 0.646051518743253, 0.07899304281489095, 0.12548751336346997, 0.33201622442545475, 0.4831330536702114, 0.44980199756184125, 0.16321275009652436, 0.16174249464505197, 0.3304395048862764, 0.12334138695672647, 0.5154832795201465, 0.5283124017735172, 0.4769794407455119, 0.5206576625074304, 0.4491391981898021, 0.4758407860356866, 0.46270224764481327, 0.4253062050821895, 0.5161632005804597, 0.8160352384430837, 0.8098674750085897, 0.7803201646823853, 0.7933509697445735, 0.7365545387483274, 0.7923060930484723, 0.7982213390747364, 0.793735613361984, 0.7890732631614759, 0.31323522989924657, 0.1420620888870724, 0.1446448783019918, 0.11850593743371973, 0.10076949552547831, 0.15244658728234795, 0.1220435223519627, 0.11609724199666249, 0.14594978435719874, 0.18974804889043084, 0.14959008006170893, 0.2345751951325099, 0.15820787997823227, 0.2794121154109527, 0.19039795236810764, 0.4606056119722203, 0.29589177034182446, 0.49825258864312383, 0.568235401605462, 0.4722036581246474, 0.5448121311100722, 0.5651583642780197, 0.5757709785812679, 0.541384145565039, 0.5585633949854893, 0.5907986284591038, 0.5863314988876868, 0.37698738309864144, 0.40019102249855265, 0.460033354615193, 0.4712316274755186, 0.4422907273615476, 0.4579969424934488, 0.432653068924735, 0.5345220533421722, 0.47983116775328094, 0.22407955600901996, 0.2157434955364751, 0.18540149947119777, 0.21957746671778156, 0.18420641176495145, 0.1941592981727729, 0.2392301487402949, 0.20495498534090828, 0.18077127859725006, 0.6015078202993095, 0.23477532955913705, 0.2351770679689712, 0.514881706015814, 0.23744973121848, 0.2277763131281847, 0.628297232856696, 0.6592131744477666, 0.22132844139435026, 0.8393610476773292, 0.20924783959532978, 0.17859081869554827, 0.8065742770568137, 0.7902879174203465, 0.813546071393607, 0.8547763808204791, 0.843066567567174, 0.8393474340357502, 0.8439303396489889, 0.4236592192754697, 0.7967407859031688, 0.19688261714988253, 0.2078389776241505, 0.16559661141819093, 0.160368386407162, 0.5663269030403522, 0.21133866150842018, 0.18173217012676945, 0.17376567549831234, 0.1960277321314079, 0.18609687934098862, 0.18655739923876358, 0.19434027481188587, 0.1799058192728764, 0.21358078451460005, 0.19188477905697388, 0.08893754920294372, 0.08379295236351614, 0.08415676266566186, 0.09341096259653625, 0.0884189071195346, 0.08328173822596785, 0.07808912477518493, 0.09466501670622784, 0.08145468832928504]}, "mutation_prompt": null}
{"id": "f489b846-5c5e-48d6-81b5-e31f4c751774", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "43ae3459-ee67-4345-b70f-4311e201db67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "59ff85ca-c00e-42c7-b0b7-86a8924ed50e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "95a97b65-f788-4ab0-abae-cd4ce2998fb3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "fa8afc67-f710-44a8-a4b8-a9ec0b183d4d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "6ee77046-24a4-4091-9949-89bf586035a6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n        self.elite_archive = []  # Elitist archive\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n                if self.population[i].tolist() not in self.elite_archive:\n                    self.elite_archive.append(self.population[i].copy())\n\n            # Occasionally replace worst individuals with random elites\n            if self.evals % (self.pop_size * 10) == 0 and self.elite_archive:\n                worst_idxs = np.argpartition(self.fitness, -elite_size)[-elite_size:]\n                for i in worst_idxs:\n                    elite_candidate = np.random.choice(self.elite_archive)\n                    self.population[i] = elite_candidate\n                    self.fitness[i] = func(elite_candidate)\n                    self.evals += 1\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an elitist archive to maintain diversity by storing the best unique solutions and occasionally replacing the worst individuals with them.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {}, "mutation_prompt": null}
{"id": "da30d29b-f9a7-4a2c-b54b-47869f3e9ea8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "4c954977-3ee9-4d1b-a862-46f168dc79d2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "d3a8682b-6eda-4d2e-9381-47080c88284e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "32919bbe-9214-42c1-8151-f0a855bc509f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "e567f47f-c85a-4c6b-a452-819d9e921e32", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.1 * success_rate + 0.1 * np.random.rand()  # Adapt CR based on success rate\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability scaling based on historical success rates to enhance exploration.", "configspace": "", "generation": 94, "fitness": 0.4579094726954028, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8520394761771267, 0.8471437404807662, 0.8513756530518947, 0.860545696320845, 0.8561227347116034, 0.8419146876576639, 0.8516105487176419, 0.8771678505493697, 0.8463713360141405, 0.731089687112805, 0.7225049340779732, 0.7516586557808664, 0.7357222590864232, 0.7342419709446115, 0.7424428409547141, 0.7110488190320818, 0.7488364205862368, 0.7368955564135704, 0.5085800454810949, 0.14328354876685412, 0.2514975944590022, 0.40364837706971357, 0.32127707048516785, 0.4267232682848192, 0.13722080582083496, 0.29636708649255405, 0.2974655408184359, 0.14059128723609315, 0.17470966232400875, 0.13636814558641341, 0.14138717391238442, 0.40662318621491966, 0.12887863444214276, 0.14567018830116718, 0.10874759994938954, 0.14080420976608676, 0.9425597693736893, 0.9662334151465098, 0.9457836173860028, 0.9305312396999917, 0.9311673350828852, 0.9343647352956628, 0.9314874684154436, 0.9754368084369235, 0.9253280217105745, 0.6357619474274881, 0.6510308306311772, 0.6536807126325974, 0.6274850036749742, 0.6937284678507614, 0.6329330897023149, 0.6581954084453083, 0.6426879791042877, 0.6499130412660803, 0.8735547030607383, 0.8398480350417695, 0.8460175224387061, 0.8703774863056587, 0.8898308126915474, 0.8590761455387202, 0.8440135583537358, 0.8093741174274172, 0.8498411106849981, 0.18194503132411555, 0.32660387154816894, 0.6306745725045391, 0.535873725157274, 0.34874079164290983, 0.5517289286611851, 0.2108638381744512, 0.5925850166319953, 0.4448833442554595, 0.19886166768161484, 0.19431980852628372, 0.2798960680812834, 0.23134421303229857, 0.4252978569946848, 0.2004689770524175, 0.16770957735512926, 0.48147280914467483, 0.20198567300326153, 0.5561674498330941, 0.574022198950338, 0.5601889712445216, 0.3651306539856667, 0.6288437427606759, 0.5051727141456618, 0.5931918277302061, 0.39743038596491187, 0.5978495834990243, 0.64814250339822, 0.6822010502601386, 0.6993573056430622, 0.4292469440553457, 0.6415280114192408, 0.6583538903385113, 0.6887249182902955, 0.6870610095280123, 0.6781604937985017, 0.1593652999905083, 0.21189722680579137, 0.34073762640331995, 0.2979909979814972, 0.22108052980577253, 0.5127143887287426, 0.3477827220665286, 0.1279608084047752, 0.17801747619807085, 0.46803998015926607, 0.4469452554797664, 0.4448094150007116, 0.47409434633856085, 0.4736036448984371, 0.44330878914877525, 0.4768459953483887, 0.5272877602668766, 0.3694801797463402, 0.7720660835725541, 0.8168917613868513, 0.8009431600997251, 0.7116516425865698, 0.801058653956411, 0.787539844591413, 0.8140063996209229, 0.7876473710434002, 0.7454277746706648, 0.14310456326738497, 0.10573861240385218, 0.11886170980117128, 0.11840521637316337, 0.4221648044632458, 0.1401178755486544, 0.13829192957128966, 0.12775277778685434, 0.14146971186119062, 0.15343187895893629, 0.24558200827777477, 0.19901225018428514, 0.23047216131889903, 0.17953226811683076, 0.1615914583694399, 0.2154162182256446, 0.3730799996391153, 0.1691689099335939, 0.5881073046516483, 0.5834108162153115, 0.5900491925779479, 0.4986276058716891, 0.5165853758821961, 0.5880188013372434, 0.5882401005307638, 0.6071050082950076, 0.5965847752528957, 0.4569292556242581, 0.45107941666902984, 0.49900585825963406, 0.39913664828068074, 0.47264863215968334, 0.4312592581160768, 0.48505645888063087, 0.4823903291622863, 0.4646530348890644, 0.20552608353810498, 0.2028877790909881, 0.1948903399283145, 0.19886604331511348, 0.2162017286860639, 0.21003740208179766, 0.19026492456304844, 0.20612953551133872, 0.20979990494886525, 0.4493030100883656, 0.21722612575479028, 0.1894345891882403, 0.4830207635360927, 0.5403381620237238, 0.573286955672722, 0.21623851948333228, 0.19619035007387897, 0.21119729269077903, 0.8487742936018737, 0.16408460781481948, 0.16255096792280677, 0.17626767697284818, 0.7186540793486529, 0.1909616487568958, 0.8807918211697839, 0.814052011682743, 0.8673540290612264, 0.8367240611384454, 0.16723540650754298, 0.8225792172277406, 0.2025965491847369, 0.2054696078956042, 0.16698182780706283, 0.2080191821687135, 0.20767713678344402, 0.21182064910938447, 0.19133981570651026, 0.17614337482874032, 0.19316515021336444, 0.1810487095046357, 0.18584384473533289, 0.18644013737104848, 0.18568032718591898, 0.19194446856560154, 0.18114106093767368, 0.09289643990353558, 0.09411924082773371, 0.09160654143924751, 0.08791088437258898, 0.09886351467747767, 0.08721732406130356, 0.08742551190982195, 0.09429750977827245, 0.08180249927572025]}, "mutation_prompt": null}
{"id": "328b8b92-0854-4393-a119-3fcab498ac1a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "bd7edd98-9d3b-4e88-a368-dc7698d26412", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "c3c8ddb7-7ba1-498e-8f8e-5de51702ddd0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "f1550a43-4845-4730-a611-6cfb8be48348", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
{"id": "ee397185-2678-40a7-b6ce-9747b956ea16", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = np.full(self.pop_size, 0.5)  # Differential weight\n        self.CR = np.full(self.pop_size, 0.9)  # Crossover probability\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_idx = None\n        self.best_value = np.inf\n        self.evals = 0\n        self.success = np.zeros(self.pop_size, dtype=int)\n        self.fail = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n        self.evals += self.pop_size\n        self.best_idx = np.argmin(self.fitness)\n        self.best_value = self.fitness[self.best_idx]\n\n        elite_size = max(1, int(0.1 * self.pop_size))  # 10% of the population as elite\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = self.population[idxs]\n\n                success_rate = self.success[i] / max(1, self.success[i] + self.fail[i])\n                self.F[i] = 0.4 + 0.2 * success_rate  # Adapt F based on success rate\n                self.CR[i] = 0.8 + 0.2 * np.random.rand()\n\n                mutant = np.clip(a + self.F[i] * (b - c), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.success[i] += 1\n\n                    if trial_fitness < self.best_value:\n                        self.best_idx = i\n                        self.best_value = trial_fitness\n                else:\n                    self.fail[i] += 1\n\n            elite_indices = np.argpartition(self.fitness, elite_size)[:elite_size]\n            for i in range(elite_size):  # Preserve elites\n                self.population[i] = self.population[elite_indices[i]]\n                self.fitness[i] = self.fitness[elite_indices[i]]\n\n        return self.population[self.best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing adaptive differential weight scaling based on historical success rates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "24aa55ed-02ff-4bd9-b7ed-b39f3d4045e8", "metadata": {"aucs": [0.8698848475407805, 0.8643640245918526, 0.845194135296383, 0.862779091711477, 0.8644246468519118, 0.8456477668008944, 0.8566459714785288, 0.8618646385693018, 0.8568728506995866, 0.7336140295038327, 0.7496923299171445, 0.74233729527254, 0.7186695741370863, 0.7582678832944216, 0.7508212046448923, 0.6506740641352733, 0.7312719652717062, 0.7602188284521441, 0.14303245745104742, 0.16346068391247393, 0.15381756466787277, 0.16467742220756976, 0.1469761721606101, 0.14340468699581665, 0.4836257033580408, 0.15416276476315816, 0.13316927558185454, 0.15437365951474935, 0.11968404289689083, 0.1221913198427006, 0.1428211244122911, 0.1736100309882751, 0.1396391663479286, 0.13990854363418226, 0.27193954014783195, 0.13428643184224565, 0.9480848969804626, 0.9447009163037204, 0.9146760590810121, 0.9111439332100232, 0.9361372977014706, 0.9675660693587553, 0.9676802054768835, 0.9424171878748229, 0.9681813356330702, 0.6697981434697686, 0.6421388872533129, 0.6609931569234033, 0.6709558863753102, 0.6853534991847591, 0.6642349927286771, 0.6963885780802859, 0.6896340305247552, 0.6394151650689289, 0.8723400478746146, 0.8592280026881822, 0.8587252467745117, 0.8708580106167664, 0.8681504254424371, 0.8191393763729669, 0.8096942315178285, 0.7901209420332931, 0.8673182747039585, 0.3882483933890223, 0.28874972461635284, 0.18496837204959626, 0.20296345372046565, 0.31175778247107744, 0.26835438409069634, 0.3677622218652504, 0.1318941241930528, 0.5126778037415265, 0.2529350460204377, 0.48862424960486783, 0.4216763158950674, 0.40945770159279615, 0.516155040926081, 0.2742549764964738, 0.19137149156551658, 0.1284205203380372, 0.6659472696657212, 0.6144903409547824, 0.42329831136045537, 0.6144518409237323, 0.6425037545078236, 0.615245239735852, 0.6117241713673258, 0.6784204925986118, 0.10460592310679895, 0.5873142001914144, 0.6716582081233744, 0.7171128413873045, 0.7311038371535796, 0.6807325923867606, 0.6938593149331569, 0.6624268659606141, 0.7597228566673512, 0.7286351610085552, 0.7200084738785254, 0.12541471863281928, 0.14495750071670677, 0.1534720590588584, 0.5101350771760527, 0.27428296617257875, 0.2949018783645787, 0.13732336468314754, 0.17733038156411474, 0.2196253259717238, 0.49245441937328027, 0.3018066463111505, 0.4952649387524444, 0.462192479649682, 0.5291847333221529, 0.5426024023985866, 0.23204206560031737, 0.5226227015034446, 0.5032120563124043, 0.7531126773200503, 0.8054352950511529, 0.7425634849726837, 0.8080935293439355, 0.801328142578188, 0.7860892640439823, 0.7886303131670598, 0.7600005499994525, 0.7825789881163069, 0.10825954003430249, 0.12611050170079452, 0.1492890573792114, 0.10960253567093392, 0.17196920307181174, 0.40580289756049026, 0.14886535717994398, 0.11404554308517345, 0.10038919860269013, 0.15627338194912976, 0.15314397200304775, 0.17881416723936439, 0.19219099016656127, 0.22413342344886644, 0.4415735227043124, 0.20654684820573876, 0.23105190437323808, 0.24423598995057694, 0.5069081204003043, 0.5528004836595947, 0.6183027312049831, 0.5871285211978222, 0.6357014454754597, 0.591329731158784, 0.632336775588627, 0.6523817195113242, 0.6080218755664287, 0.43855942886762755, 0.4918700043128975, 0.48312801096663904, 0.416914943395136, 0.4701768137579616, 0.3851408075045807, 0.5221604108441907, 0.5393601077500976, 0.4983492674816571, 0.27141076367109795, 0.21401030387292408, 0.24227652997260452, 0.2134831598363055, 0.2069318747292591, 0.21915941616172363, 0.2436564542197549, 0.21744503706088747, 0.20998692549434494, 0.24094271743612206, 0.6806122637885479, 0.234485959781621, 0.22309402115051413, 0.2334284743191989, 0.23695367000633005, 0.20915557605900448, 0.46509933077109666, 0.2093375286064092, 0.825269740573251, 0.21024977729166472, 0.7148386789587685, 0.8376383742505931, 0.8559376703727715, 0.7878953688055574, 0.16484415861947632, 0.6567064808037757, 0.837985184905252, 0.8333375459933298, 0.20776319469230264, 0.8437918592168848, 0.6815147051282687, 0.20868080918241316, 0.7015046646743608, 0.16586289980062574, 0.8629868527055945, 0.7554263605161355, 0.20479637816065333, 0.1859494866483704, 0.17121795992624733, 0.1948250483663735, 0.18151572071517552, 0.18354664793017406, 0.18737324629265728, 0.18571906970632424, 0.18055453577348435, 0.07860542001419146, 0.08581146991375155, 0.09280052581483178, 0.08292701715301432, 0.08887707121039934, 0.09344455452785838, 0.08742935087302794, 0.10417628066424567, 0.10796829147347109]}, "mutation_prompt": null}
