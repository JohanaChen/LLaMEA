{"id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 2.0  # PSO cognitive parameter\n        self.c2 = 2.0  # PSO social parameter\n        self.w = 0.5  # Inertia weight for PSO\n        self.F = 0.5  # DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "A hybrid metaheuristic combining Differential Evolution and Particle Swarm Optimization for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.143853459681817, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2788970705848268, 0.26507172703069504, 0.2806843667667437, 0.31023584810951366, 0.18765800825398926, 0.18735740193603556, 0.3092836180882452, 0.31469631617735094, 0.27873168656465963, 0.05103999335745435, 0.07816031682015545, 0.027096886901914474, 0.05595949665904043, 0.02589221966512978, 0.0332594160982399, 0.08464079668167013, 0.06199160258728831, 0.041085973264871845, 0.05718014301261409, 0.0770806014159563, 0.052121330086582596, 0.07515537800750172, 0.05428967306153065, 0.053598358651017586, 0.03738225880081991, 0.05867519580941938, 0.061991406966037, 0.05334085141342426, 0.04839112309688809, 0.031671560876398885, 0.03959528351434893, 0.04387675344290942, 0.05513745350282662, 0.03395129480364045, 0.03897871398877506, 0.0584249490343236, 0.9964892501149025, 0.9971770189596351, 0.9968783863901883, 0.9937677198437236, 0.9938978618064982, 0.994172065041017, 0.997421021303589, 0.9931625142373827, 0.9971924860211732, 0.09552442380525916, 0.14828010701589667, 0.08640680564002468, 0.09990393589776325, 0.1073880911948003, 0.11543124794682935, 0.05036181974135101, 0.09098464517099436, 0.04839831306807296, 0.2051244271614251, 0.13218794250814803, 0.1500146176135988, 0.1898464862532463, 0.16460954303609376, 0.1489828083518534, 0.23635598752543208, 0.15099402901830727, 0.19847567480386463, 0.01092656868448516, 0.01741305098718382, 0.014983001645477612, 0.043540507543046614, 0.054295875289344986, 0.05224853943328034, 0.023590026411006493, 0.045506640332678816, 0.019709659950942315, 0.030291288240765768, 0.010123088146343107, 0.050112443694420805, 0.05093186290268281, 0.015062494037997975, 0.03811705071168381, 0.03458964441731727, 0.022107351000070996, 0.03292276868676469, 0.0012218516074639085, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011932014992517281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052545158149105875, 0.020356255533876544, 0.061948776979715015, 0.06990241370361094, 0.0449910940133168, 0.048352403909388664, 0.06892478691143511, 0.09272986212302547, 0.0635566369045617, 0.00010956828655506179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01964435388771202, 0.02753371458277909, 0.040138653042291805, 0.04828633171990493, 0.02676936196491153, 0.02438297911560927, 0.051383680604659476, 0.04582329762894477, 0.026527552735718607, 0.25038596494475907, 0.2709884026500704, 0.25076873591434723, 0.2929532032689389, 0.2578301601119043, 0.26447166302026126, 0.24352082447537837, 0.25451359775674764, 0.2691157013748231, 0.05771097623637256, 0.053428380177060864, 0.04397991717940308, 0.0606433872172516, 0.048972009843981645, 0.05697091858255976, 0.057279376579338015, 0.054562605257332475, 0.04974102925394108, 0.16739494671723698, 0.14335777199426614, 0.1494253828582951, 0.14744437478119066, 0.12663377559682265, 0.11125144059951486, 0.14733890248838177, 0.11457246091635787, 0.1294724346350713, 0.16435190059873805, 0.1963514255363581, 0.15419547904649566, 0.16601286846949803, 0.17814093516386786, 0.17197565469345533, 0.17816642250096704, 0.19276356428152364, 0.1902332724014446, 0.13625859623430736, 0.1285750098141183, 0.10749735314909026, 0.12121618790996513, 0.11982747363647872, 0.10919174031117496, 0.12245336033290499, 0.12769279259375654, 0.11702947197952673, 0.1345285956462816, 0.14270881105751254, 0.15616280121623516, 0.14869032475086008, 0.16887122263768284, 0.18259944076653423, 0.15201389155351286, 0.18044810748666118, 0.14834965401265798, 0.1556038658046649, 0.15192038341003322, 0.15079332381132804, 0.16341774232382122, 0.1507014803223743, 0.14030198896938295, 0.15939379625703842, 0.16259966363096068, 0.1354127851554222, 0.1658085683863847, 0.1505544149716539, 0.11277320337276597, 0.26559834191723153, 0.14412491019768114, 0.11616868173868844, 0.11388942415364678, 0.1380993101951361, 0.16226122636101192, 0.1609843326464907, 0.15443968889549375, 0.1494448977837718, 0.1890940760334633, 0.12881744072861745, 0.1389207869530661, 0.2099486436744643, 0.1961313868138682, 0.20626441273816865, 0.16602778489086467, 0.17321582772688948, 0.18594254286333112, 0.1692748064519456, 0.19527121044821383, 0.17365317975134553, 0.17070944160119017, 0.18135495405651314, 0.180768924343905, 0.06150671222547621, 0.04446956569870564, 0.04651614015011951, 0.05441042216738112, 0.048649705280635835, 0.043142307183206996, 0.040578607872642, 0.050213397101520285, 0.05583018047549726]}, "mutation_prompt": null}
{"id": "859cd5b3-9332-4fe2-baf1-f1fbfcaf4017", "solution": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.w_min, self.w_max = 0.4, 0.9  # Dynamic inertia weight range for PSO\n        self.F_min, self.F_max = 0.3, 0.8  # Dynamic DE mutation factor range\n        self.CR = 0.9\n        self.c1 = 1.5  # Adjusted cognitive parameter\n        self.c2 = 1.5  # Adjusted social parameter\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic parameter adjustment\n            w = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget))\n            F = self.F_min + ((self.F_max - self.F_min) * (evaluations / self.budget))\n\n            # Apply DE/PSO hybridization with portfolio-based operators\n            for i in range(self.pop_size):\n                # Differential Evolution with adaptive F\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization with adaptive w\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveHybridDEPSO", "description": "Adaptive HybridDEPSO with dynamic parameter tuning and portfolio-based operators to enhance performance across diverse landscapes.", "configspace": "", "generation": 1, "fitness": 0.12265222479839176, "feedback": "The algorithm AdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "metadata": {"aucs": [0.15880343422086352, 0.16875739155148983, 0.19067331777461427, 0.2584390724000186, 0.1824875657605669, 0.16981352069747313, 0.2155088706133138, 0.20758448437863286, 0.20894122103008717, 0.02717431201345044, 0.014539407444891905, 0.0287015922256747, 0.013545285433873122, 0.006950832646364646, 0.018226117928027974, 0.014242650229329246, 0.014048157722925114, 0.01612126175786721, 0.03771644674897667, 0.04269502784189594, 0.04208659221364486, 0.0485185486754901, 0.04879679533129799, 0.0461783305799488, 0.041722258561400105, 0.04757893812438996, 0.04356538900552709, 0.025548308982771828, 0.01597176125523203, 0.02256732959251362, 0.023667739670993226, 0.01921944667422615, 0.02244011690557013, 0.0254657117671373, 0.02395317803874719, 0.015976276962767377, 0.9891188608656936, 0.9935546776146755, 0.9963854580970088, 0.9936528200769266, 0.9937052320223719, 0.9902689522529888, 0.997169203071397, 0.9931300006741433, 0.9940639681778034, 0.050697765898165326, 0.04884933421037496, 0.04300692878168899, 0.08588338006445262, 0.09064818042096068, 0.0596725956958466, 0.06428064240459574, 0.06580900817624091, 0.06666990481637891, 0.13740219376883922, 0.10300216951058738, 0.09386075622377033, 0.13407629762274353, 0.13499123960640735, 0.12746858056368038, 0.1339254301423094, 0.13771265474673822, 0.11268237801505454, 0.00955159719886034, 0.024562221760010328, 0.02822865978251321, 0.015163396233338955, 0.01440387174571478, 0.013259482518438892, 0.013133602349310602, 0.013361854786844152, 0.015827139816798952, 0.06179886980486138, 0.0394136233935809, 0.019950586609070342, 0.001274719293182347, 0.014181911192975183, 0.0010609878030489739, 0.021263773496964178, 0.011753190926381274, 0.017285829603740033, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0062176346242427405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030599757150183038, 0.019659016448224764, 0.05681929774783678, 0.052443413857304, 0.023422217676627555, 0.0227318446829482, 0.026571600796513883, 0.05855348030782592, 0.0029699041630059098, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011282074185624658, 0.011087296543172642, 0.029214899500815572, 0.011568336322644424, 9.999999999998899e-05, 0.0006730890356597685, 0.02812480072537349, 0.029912968027837272, 0.016012458404483176, 0.20169976423186664, 0.22090516905054858, 0.2123681297335832, 0.22249093127627295, 0.22360383556565344, 0.2075200331123942, 0.19818996902939934, 0.19511937359676934, 0.2051781120157289, 0.058074177023713314, 0.04825061949606657, 0.045277946082497134, 0.05399442866481463, 0.046452914273164225, 0.04552259240225465, 0.04965478549050262, 0.05062456147733896, 0.03948945911061641, 0.12196005907525664, 0.14080951683646414, 0.1450590257298081, 0.11205049933290978, 0.1522984070765877, 0.15596902982191918, 0.14269233153391636, 0.12754561375742035, 0.12283560171650765, 0.15673449019566377, 0.1578858290108348, 0.15964051869054552, 0.15026629640701272, 0.1555063741152437, 0.13236234821977688, 0.15731006022167549, 0.19287586854901895, 0.17068053397162097, 0.10206117269039683, 0.09965967152161248, 0.09673699483373766, 0.12388536394519833, 0.09089367447947039, 0.08374550277719284, 0.10643258467405026, 0.10888101457964527, 0.08582862404404801, 0.1354712861763674, 0.13222493769042465, 0.15281242743230583, 0.1439601438963729, 0.1453966655957769, 0.15920380005418955, 0.13738786391493962, 0.1375454919328285, 0.150174740755188, 0.07975255657278502, 0.1146585806649848, 0.10349399235939072, 0.14012668711201437, 0.08971972073455492, 0.0884498687761206, 0.09518388150021984, 0.14847175770311916, 0.09962088659868007, 0.22300556481129674, 0.11132711218373448, 0.1473060473580159, 0.10402466516470488, 0.16441221260898398, 0.11287322301340441, 0.12388209140665385, 0.12721126357621126, 0.13546815137074042, 0.0857795069500622, 0.14075352289949294, 0.14789122524020437, 0.1138016156694115, 0.0863297843446067, 0.10867540876312654, 0.18977639645464084, 0.1817896730255596, 0.1721937458938091, 0.1624585054725547, 0.1808234624994186, 0.17348377038546947, 0.18745996195518877, 0.17332834584195467, 0.19350487514754122, 0.17502180632910136, 0.16605475710626616, 0.16919582055785254, 0.04679447341022802, 0.05948867028312821, 0.034263258095704074, 0.03749939576510697, 0.05010113934287619, 0.04478391350814004, 0.03766559222969246, 0.042459213873932145, 0.036258570203024476]}, "mutation_prompt": null}
{"id": "98d83585-5915-4a32-b82d-80f89cba6574", "solution": "import numpy as np\n\nclass HybridGAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 2.0  # PSO cognitive parameter\n        self.c2 = 2.0  # PSO social parameter\n        self.w = 0.6  # Adjusted inertia weight for PSO\n        self.F = 0.8  # Adjusted DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n        self.mutation_rate = 0.1  # New GA mutation rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Hybridization of GA, DE, and PSO\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Genetic Algorithm - Mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.randn(self.dim)\n                    trial += mutation_vector\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridGAPSO", "description": "Hybrid Genetic Algorithm with DE and PSO elements for improved adaptability and convergence in black box optimization.", "configspace": "", "generation": 2, "fitness": 0.1198660540028237, "feedback": "The algorithm HybridGAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "metadata": {"aucs": [0.21609533175485207, 0.1701628820073645, 0.1754733046887288, 0.27192775885505593, 0.22659808110537982, 0.25075075713165196, 0.19328113964402727, 0.22533221125055347, 0.20714953711729467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04746059313428863, 0.03407291019960923, 0.03137397178569623, 0.039264576777242155, 0.053802957534002105, 0.04644462960696494, 0.04526974664656369, 0.03973431243557246, 0.038685176907112706, 0.005270529544329161, 0.022132761347501084, 0.01528090229314516, 0.03500331389200362, 0.017236356274969555, 0.014702538626076733, 0.013104770667714316, 0.028733432173226325, 0.023109182071636702, 0.9905684772321534, 0.9959212990525363, 0.9950374720836941, 0.9917841027759653, 0.9914283637014295, 0.9247984694924014, 0.9949410657299558, 0.9962353624025357, 0.9963282340196743, 0.08128072859023705, 0.053328574306783394, 0.08388535535990471, 0.039704624331773464, 0.12560808346581653, 0.03607366085350072, 0.07874898103614181, 0.08319853045761083, 0.08877626114387871, 0.12395024346267325, 0.1254510951865201, 0.08944989048486296, 0.10256449105229914, 0.14201149224753173, 0.12808538325562913, 0.13530094601097242, 0.1172061724568757, 0.12012313250611029, 9.999999999998899e-05, 9.999999999998899e-05, 0.016903674156314108, 0.010112756654541366, 0.009606737235874574, 9.999999999998899e-05, 0.009792562856927867, 9.999999999998899e-05, 9.999999999998899e-05, 0.01405857378372688, 0.009913092847965377, 0.027081569964611973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007540014925491167, 0.005651436596047499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04081960490848724, 0.02404314046285927, 0.047748893023709216, 0.05009807057102045, 0.037450096087800144, 0.04204346369817791, 0.0352406283534723, 0.04302787011833731, 0.014884248995673421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036811396255407303, 0.000647824676650588, 0.0006184392649088988, 0.00027652910102660133, 0.009547517063865918, 0.0016867495996053528, 0.013657579607624037, 0.022979021077486506, 0.00938154299866123, 0.17611334031020565, 0.19155938273786532, 0.16682154241964275, 0.2088043303089434, 0.21052460275765894, 0.20276901919029555, 0.1938825096469775, 0.18628410397405992, 0.19205018604522484, 0.0444319027987502, 0.07042000993270559, 0.03853613423689006, 0.05885758052713941, 0.0391265777669334, 0.041153270103338246, 0.04102745315526357, 0.03152636281640153, 0.05190741139341226, 0.12725437877440637, 0.12220252553742217, 0.1324953941937722, 0.1292861627258428, 0.12758226563005992, 0.10711908896222189, 0.13414506008595328, 0.12093439353681024, 0.1483506545705623, 0.15845993935471592, 0.14769286461500974, 0.1442485050710951, 0.14296832953937466, 0.14550643988852485, 0.1477915580849074, 0.15105014202394196, 0.17377774300845283, 0.1741831421859531, 0.08720656643554903, 0.09959539606689671, 0.09744042716109924, 0.0910431311659311, 0.1161578630494492, 0.10716504043381303, 0.10048717835910881, 0.12109787818887507, 0.10292015001532506, 0.12759239056459082, 0.15247510744814385, 0.1508839839962135, 0.13542321199398843, 0.15246745161643815, 0.1350858387699676, 0.1441428620710543, 0.13186344031948793, 0.12978233221384072, 0.0576627357095193, 0.10779923594668384, 0.0941477789950168, 0.14314307786112057, 0.034923502249360694, 0.06571865124530907, 0.12129789925147438, 0.11926926302239116, 0.11981739822902981, 0.15081016939715441, 0.1452803125040626, 0.13830670881944973, 0.112235259123311, 0.14494997605569604, 0.14844614508426823, 0.11454345210956385, 0.11870676179257023, 0.20890179012773902, 0.11040265245322212, 0.15453820931383888, 0.08949746876581066, 0.14845140728735895, 0.11628111972017652, 0.11423772235233287, 0.20041284064603715, 0.16590669980067219, 0.20089764545883504, 0.1746297456460918, 0.17714264368455424, 0.18514380388183904, 0.1788385168171266, 0.17151939462359023, 0.19112746060289487, 0.17041490285995264, 0.19514150745820424, 0.18368517223167669, 0.03321238183280528, 0.024553108353055686, 0.0364246456648043, 0.029764836486776636, 0.03826689656792692, 0.046873147550077765, 0.031191398193733733, 0.05504797420921237, 0.03327876384759021]}, "mutation_prompt": null}
{"id": "eda14c9b-a9db-4e05-bd9e-9b17937cce7d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 2.0  # PSO cognitive parameter\n        self.c2 = 2.0  # PSO social parameter\n        self.w = 0.5  # Inertia weight for PSO\n        self.F = 0.5  # DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "A hybrid metaheuristic combining Differential Evolution and Particle Swarm Optimization for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "metadata": {"aucs": [0.2788970705848268, 0.26507172703069504, 0.2806843667667437, 0.31023584810951366, 0.18765800825398926, 0.18735740193603556, 0.3092836180882452, 0.31469631617735094, 0.27873168656465963, 0.05103999335745435, 0.07816031682015545, 0.027096886901914474, 0.05595949665904043, 0.02589221966512978, 0.0332594160982399, 0.08464079668167013, 0.06199160258728831, 0.041085973264871845, 0.05718014301261409, 0.0770806014159563, 0.052121330086582596, 0.07515537800750172, 0.05428967306153065, 0.053598358651017586, 0.03738225880081991, 0.05867519580941938, 0.061991406966037, 0.05334085141342426, 0.04839112309688809, 0.031671560876398885, 0.03959528351434893, 0.04387675344290942, 0.05513745350282662, 0.03395129480364045, 0.03897871398877506, 0.0584249490343236, 0.9964892501149025, 0.9971770189596351, 0.9968783863901883, 0.9937677198437236, 0.9938978618064982, 0.994172065041017, 0.997421021303589, 0.9931625142373827, 0.9971924860211732, 0.09552442380525916, 0.14828010701589667, 0.08640680564002468, 0.09990393589776325, 0.1073880911948003, 0.11543124794682935, 0.05036181974135101, 0.09098464517099436, 0.04839831306807296, 0.2051244271614251, 0.13218794250814803, 0.1500146176135988, 0.1898464862532463, 0.16460954303609376, 0.1489828083518534, 0.23635598752543208, 0.15099402901830727, 0.19847567480386463, 0.01092656868448516, 0.01741305098718382, 0.014983001645477612, 0.043540507543046614, 0.054295875289344986, 0.05224853943328034, 0.023590026411006493, 0.045506640332678816, 0.019709659950942315, 0.030291288240765768, 0.010123088146343107, 0.050112443694420805, 0.05093186290268281, 0.015062494037997975, 0.03811705071168381, 0.03458964441731727, 0.022107351000070996, 0.03292276868676469, 0.0012218516074639085, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011932014992517281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052545158149105875, 0.020356255533876544, 0.061948776979715015, 0.06990241370361094, 0.0449910940133168, 0.048352403909388664, 0.06892478691143511, 0.09272986212302547, 0.0635566369045617, 0.00010956828655506179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01964435388771202, 0.02753371458277909, 0.040138653042291805, 0.04828633171990493, 0.02676936196491153, 0.02438297911560927, 0.051383680604659476, 0.04582329762894477, 0.026527552735718607, 0.25038596494475907, 0.2709884026500704, 0.25076873591434723, 0.2929532032689389, 0.2578301601119043, 0.26447166302026126, 0.24352082447537837, 0.25451359775674764, 0.2691157013748231, 0.05771097623637256, 0.053428380177060864, 0.04397991717940308, 0.0606433872172516, 0.048972009843981645, 0.05697091858255976, 0.057279376579338015, 0.054562605257332475, 0.04974102925394108, 0.16739494671723698, 0.14335777199426614, 0.1494253828582951, 0.14744437478119066, 0.12663377559682265, 0.11125144059951486, 0.14733890248838177, 0.11457246091635787, 0.1294724346350713, 0.16435190059873805, 0.1963514255363581, 0.15419547904649566, 0.16601286846949803, 0.17814093516386786, 0.17197565469345533, 0.17816642250096704, 0.19276356428152364, 0.1902332724014446, 0.13625859623430736, 0.1285750098141183, 0.10749735314909026, 0.12121618790996513, 0.11982747363647872, 0.10919174031117496, 0.12245336033290499, 0.12769279259375654, 0.11702947197952673, 0.1345285956462816, 0.14270881105751254, 0.15616280121623516, 0.14869032475086008, 0.16887122263768284, 0.18259944076653423, 0.15201389155351286, 0.18044810748666118, 0.14834965401265798, 0.1556038658046649, 0.15192038341003322, 0.15079332381132804, 0.16341774232382122, 0.1507014803223743, 0.14030198896938295, 0.15939379625703842, 0.16259966363096068, 0.1354127851554222, 0.1658085683863847, 0.1505544149716539, 0.11277320337276597, 0.26559834191723153, 0.14412491019768114, 0.11616868173868844, 0.11388942415364678, 0.1380993101951361, 0.16226122636101192, 0.1609843326464907, 0.15443968889549375, 0.1494448977837718, 0.1890940760334633, 0.12881744072861745, 0.1389207869530661, 0.2099486436744643, 0.1961313868138682, 0.20626441273816865, 0.16602778489086467, 0.17321582772688948, 0.18594254286333112, 0.1692748064519456, 0.19527121044821383, 0.17365317975134553, 0.17070944160119017, 0.18135495405651314, 0.180768924343905, 0.06150671222547621, 0.04446956569870564, 0.04651614015011951, 0.05441042216738112, 0.048649705280635835, 0.043142307183206996, 0.040578607872642, 0.050213397101520285, 0.05583018047549726]}, "mutation_prompt": null}
{"id": "4e869636-a88e-444b-aaa7-46d5542fd868", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 2.0  # PSO cognitive parameter\n        self.c2 = 2.0  # PSO social parameter\n        self.w = 0.5  # Inertia weight for PSO\n        self.F = 0.5  # DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "A hybrid metaheuristic combining Differential Evolution and Particle Swarm Optimization for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "metadata": {"aucs": [0.2788970705848268, 0.26507172703069504, 0.2806843667667437, 0.31023584810951366, 0.18765800825398926, 0.18735740193603556, 0.3092836180882452, 0.31469631617735094, 0.27873168656465963, 0.05103999335745435, 0.07816031682015545, 0.027096886901914474, 0.05595949665904043, 0.02589221966512978, 0.0332594160982399, 0.08464079668167013, 0.06199160258728831, 0.041085973264871845, 0.05718014301261409, 0.0770806014159563, 0.052121330086582596, 0.07515537800750172, 0.05428967306153065, 0.053598358651017586, 0.03738225880081991, 0.05867519580941938, 0.061991406966037, 0.05334085141342426, 0.04839112309688809, 0.031671560876398885, 0.03959528351434893, 0.04387675344290942, 0.05513745350282662, 0.03395129480364045, 0.03897871398877506, 0.0584249490343236, 0.9964892501149025, 0.9971770189596351, 0.9968783863901883, 0.9937677198437236, 0.9938978618064982, 0.994172065041017, 0.997421021303589, 0.9931625142373827, 0.9971924860211732, 0.09552442380525916, 0.14828010701589667, 0.08640680564002468, 0.09990393589776325, 0.1073880911948003, 0.11543124794682935, 0.05036181974135101, 0.09098464517099436, 0.04839831306807296, 0.2051244271614251, 0.13218794250814803, 0.1500146176135988, 0.1898464862532463, 0.16460954303609376, 0.1489828083518534, 0.23635598752543208, 0.15099402901830727, 0.19847567480386463, 0.01092656868448516, 0.01741305098718382, 0.014983001645477612, 0.043540507543046614, 0.054295875289344986, 0.05224853943328034, 0.023590026411006493, 0.045506640332678816, 0.019709659950942315, 0.030291288240765768, 0.010123088146343107, 0.050112443694420805, 0.05093186290268281, 0.015062494037997975, 0.03811705071168381, 0.03458964441731727, 0.022107351000070996, 0.03292276868676469, 0.0012218516074639085, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011932014992517281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052545158149105875, 0.020356255533876544, 0.061948776979715015, 0.06990241370361094, 0.0449910940133168, 0.048352403909388664, 0.06892478691143511, 0.09272986212302547, 0.0635566369045617, 0.00010956828655506179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01964435388771202, 0.02753371458277909, 0.040138653042291805, 0.04828633171990493, 0.02676936196491153, 0.02438297911560927, 0.051383680604659476, 0.04582329762894477, 0.026527552735718607, 0.25038596494475907, 0.2709884026500704, 0.25076873591434723, 0.2929532032689389, 0.2578301601119043, 0.26447166302026126, 0.24352082447537837, 0.25451359775674764, 0.2691157013748231, 0.05771097623637256, 0.053428380177060864, 0.04397991717940308, 0.0606433872172516, 0.048972009843981645, 0.05697091858255976, 0.057279376579338015, 0.054562605257332475, 0.04974102925394108, 0.16739494671723698, 0.14335777199426614, 0.1494253828582951, 0.14744437478119066, 0.12663377559682265, 0.11125144059951486, 0.14733890248838177, 0.11457246091635787, 0.1294724346350713, 0.16435190059873805, 0.1963514255363581, 0.15419547904649566, 0.16601286846949803, 0.17814093516386786, 0.17197565469345533, 0.17816642250096704, 0.19276356428152364, 0.1902332724014446, 0.13625859623430736, 0.1285750098141183, 0.10749735314909026, 0.12121618790996513, 0.11982747363647872, 0.10919174031117496, 0.12245336033290499, 0.12769279259375654, 0.11702947197952673, 0.1345285956462816, 0.14270881105751254, 0.15616280121623516, 0.14869032475086008, 0.16887122263768284, 0.18259944076653423, 0.15201389155351286, 0.18044810748666118, 0.14834965401265798, 0.1556038658046649, 0.15192038341003322, 0.15079332381132804, 0.16341774232382122, 0.1507014803223743, 0.14030198896938295, 0.15939379625703842, 0.16259966363096068, 0.1354127851554222, 0.1658085683863847, 0.1505544149716539, 0.11277320337276597, 0.26559834191723153, 0.14412491019768114, 0.11616868173868844, 0.11388942415364678, 0.1380993101951361, 0.16226122636101192, 0.1609843326464907, 0.15443968889549375, 0.1494448977837718, 0.1890940760334633, 0.12881744072861745, 0.1389207869530661, 0.2099486436744643, 0.1961313868138682, 0.20626441273816865, 0.16602778489086467, 0.17321582772688948, 0.18594254286333112, 0.1692748064519456, 0.19527121044821383, 0.17365317975134553, 0.17070944160119017, 0.18135495405651314, 0.180768924343905, 0.06150671222547621, 0.04446956569870564, 0.04651614015011951, 0.05441042216738112, 0.048649705280635835, 0.043142307183206996, 0.040578607872642, 0.050213397101520285, 0.05583018047549726]}, "mutation_prompt": null}
{"id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 5, "fitness": 0.2456039080374717, "feedback": "The algorithm ImprovedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "ae42747c-e586-42b6-a4d5-7ef0ef92ced8", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "91531597-6608-4fc3-bdf6-a31de2a8d2cb", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "26efc5db-f340-4910-99e9-68712bd99750", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "b5fd93e3-e841-478e-b599-6d635859a5bf", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "aa042712-30b6-413b-a655-710c3a2e3f9d", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "381b9945-3d0d-4ae0-8077-31b0d4a5eebd", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "1cc5860d-2f5f-4520-ace1-e7cdd22dcaf9", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "adb86e60-86a5-4ef3-b2f0-34eb8f199ab2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Adjusted PSO cognitive parameter\n        self.c2 = 2.0  # Adjusted PSO social parameter\n        self.w = 0.5  # Adjusted inertia weight\n        self.F = 0.7  # Reduced DE mutation factor\n        self.CR = 0.9  # Increased DE crossover probability\n        self.resampling_threshold = 0.2  # Resampling threshold\n\n    def adapt_parameters(self, evaluations):\n        self.F = 0.4 + 0.3 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n\n    def resample_population(self, population, global_best):\n        for i in range(self.pop_size):\n            if np.random.rand() < self.resampling_threshold:\n                population[i] = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            self.resample_population(population, global_best_position)\n\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Enhanced DE-PSO Hybrid with Adaptive Population Resampling for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 12, "fitness": 0.11232404517749485, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.14034370324972312, 0.15166206382495162, 0.17337071085251032, 0.21744638625540424, 0.1630417125039927, 0.14379137023901034, 0.1415564370550364, 0.14803087099024093, 0.14720979287681457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03697737627046915, 0.03435216912923211, 0.02159186459210627, 0.04097933818316035, 0.03794098179888383, 0.03793187545595533, 0.026776748593830058, 0.0409746555270627, 0.028021205374820002, 0.024909913381389148, 0.05239267951867421, 0.011385648100451395, 0.01979974396079054, 0.011181457371883918, 0.024426275002481068, 0.017549684321252812, 0.012874050894856714, 0.009926212975596371, 0.9938654446066446, 0.997797184101392, 0.9940301923683685, 0.989230075606167, 0.9892484108983873, 0.9928767017883717, 0.9937308327997857, 0.9897107168974866, 0.996707169872394, 0.05879889884673262, 0.04119468193777398, 0.06144249389556078, 0.0706686198830575, 0.04727386904600295, 0.11256124477076623, 0.06232169832508683, 0.053046100850472566, 0.053514113383431816, 0.13359176913211068, 0.054554187462529824, 0.07630769968478801, 0.1105411065964429, 0.07528424389802935, 0.09658863188034517, 0.08090243692842103, 0.14030442354881834, 0.1132701389361862, 0.01530447668250412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04105447698504372, 0.0099466433296157, 0.009738498626883252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028869079540687625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025975394386901662, 0.05738380362174589, 0.029814577358736494, 0.037349702573980514, 0.011150700022148907, 0.00223730380674092, 0.014266437411587174, 0.029235238364223592, 0.005226521051366895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033762475173670925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22226254247907107, 0.14893439556637955, 0.22872350635135164, 0.17185085591168914, 0.16904138514768785, 0.1846338578052822, 0.14859691163673872, 0.15799781669153456, 0.16484190657175402, 0.03438484657896057, 0.03013628264027335, 0.031557578594404334, 0.027654402912523413, 0.022316213966104947, 0.037257771564572995, 0.041683306214899685, 0.03008440886890007, 0.0267656688986897, 0.13118406033614993, 0.14799683559502863, 0.1267781488619566, 0.14228314584077473, 0.13222968472768593, 0.12744961087753548, 0.14811520263129296, 0.11465269768213371, 0.1212785498271034, 0.15559780978732163, 0.15194963866018862, 0.1416564890179558, 0.13676941995762248, 0.15454324454020296, 0.15123599544200084, 0.1540099030514963, 0.17374871778202072, 0.13190741344881585, 0.09805204361488262, 0.07649531696509348, 0.0995614964257564, 0.09187971734964395, 0.09554969618962383, 0.09060904919006685, 0.08095729807127516, 0.09462678108054712, 0.09918080961117903, 0.14123799724113906, 0.14092335212072649, 0.14269226071184526, 0.13925871345275087, 0.12448617485975244, 0.14333491094503092, 0.15833387779394237, 0.14154647545101784, 0.13383120126734616, 0.11080373343467786, 0.10422757871779109, 0.04712422217889256, 0.11508635577240833, 0.06714716871439452, 0.10305301868695149, 0.09890572395638941, 0.0680984730538794, 0.13650797545939908, 0.15322653797376384, 0.11899413189497332, 0.11550345617703373, 0.12579548770783167, 0.13711510029400464, 0.11997483179334467, 0.1588653900855197, 0.13758663437997787, 0.13035517618397807, 0.16579400068643557, 0.09855313603516092, 0.11704157524481651, 0.1311949568440508, 0.14493693491845894, 0.08900530612650126, 0.15625628532349123, 0.10768455569327184, 0.13420825151978666, 0.16771871784897396, 0.17459919003826763, 0.18469962104153292, 0.18187908219563564, 0.18672873547955926, 0.17775750284457792, 0.17424161572928953, 0.17771953891400172, 0.17735216341895543, 0.038485531824656416, 0.03304464486522063, 0.03537139094308006, 0.03752876750469791, 0.04209363725213022, 0.03736862131626162, 0.04787089032850489, 0.037408768033669326, 0.04685699515391972]}, "mutation_prompt": null}
{"id": "53dc9144-6fe1-458a-bfe9-b1ef9d166efb", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "9796e072-fb65-4953-97e4-54e0ac1e8cd1", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "165cf513-c891-4f6f-9e32-f9d368a781c3", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "0ba2525d-13c8-40c0-883e-7a0e3f4b9f09", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "6fef380c-6883-46dc-b1c5-46da150b7d08", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "3a797be0-95cd-43b9-8840-f1adf77c66ab", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "69e482a6-d4dd-4cab-9ea1-18df9724659c", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "5072350a-ef4c-4148-afe4-d54abfb82f2a", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "987df532-645c-412a-8cd4-6dbd1348316a", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "c8a03dc5-1fe4-4f4b-8090-4b552c509f93", "solution": "import numpy as np\n\nclass EnhancedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Updated PSO cognitive parameter\n        self.c2 = 1.7  # Updated PSO social parameter\n        self.w = 0.5  # Updated inertia weight for PSO\n        self.F = 0.9  # More aggressive DE mutation factor\n        self.CR = 0.9  # Higher DE crossover probability\n\n    def adapt_parameters(self, evaluations, max_evals):\n        # Adaptive strategy for parameters based on progress\n        self.F = 0.5 + 0.4 * (1 - evaluations / max_evals) * np.random.rand()\n        self.CR = 0.5 + 0.5 * (evaluations / max_evals) * np.random.rand()\n\n    def local_random_search(self, candidate):\n        # Introduce a small local random search step\n        return candidate + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations, self.budget)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial = self.local_random_search(trial)  # Apply local search\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedDEPSO", "description": "Enhanced DE-PSO Hybrid with Adaptive Parameter Control and Randomized Local Search for Improved Global Optimization Performance.", "configspace": "", "generation": 22, "fitness": 0.19306776704073836, "feedback": "The algorithm EnhancedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.4171110736428004, 0.4771519098721153, 0.4240283144259934, 0.4571799724626143, 0.44478848385561387, 0.429822087591614, 0.43764934935361866, 0.4478679385008616, 0.42850910753295113, 0.023971498984097117, 0.030273884738595047, 0.04912185005705272, 0.04117740394533975, 0.023552293737172825, 0.04366411819838556, 0.04451063517512088, 0.04472183233888649, 0.02029176903038188, 0.09308041246928511, 0.09251691986231214, 0.08207151021719983, 0.09935874146891088, 0.10241967770021732, 0.10332509940731538, 0.10869848142774663, 0.08825197012547359, 0.08602390889240052, 0.06844807386112028, 0.08400834251699585, 0.08142971235806162, 0.07774577488165724, 0.0841802888152734, 0.08833404742662476, 0.06673939055934808, 0.08275521905850636, 0.07857422418545279, 0.9661651418115006, 0.9891636779536918, 0.993069764503378, 0.9374434542911798, 0.9886867728302439, 0.9889411541572088, 0.9927330496818484, 0.9787219626441003, 0.9926797319569832, 0.16341613682247402, 0.1746587682076719, 0.18267870320566715, 0.1949205770846708, 0.16903075184897642, 0.20303102187968503, 0.1967319873944039, 0.22615441774660316, 0.17596509836761232, 0.29159506472537844, 0.2016703604921566, 0.26988300066286675, 0.2006321748278347, 0.30851426132959037, 0.21127124140755082, 0.3481198836592765, 0.5506525879381959, 0.25428431042866706, 0.14758630574159193, 0.17509811509180384, 0.1611742175306654, 0.14797842183246046, 0.12816667215778665, 0.11692076343075619, 0.16755131959560243, 0.15507195348295955, 0.1591557178857942, 0.13573639902859758, 0.12131539035579952, 0.13907706315045798, 0.16027979639837453, 0.13185625035751514, 0.1534630649033899, 0.16179160909705115, 0.09667679477540236, 0.12292060959894258, 9.999999999998899e-05, 0.01091977769641872, 0.012232685006676958, 0.032015390060173066, 9.999999999998899e-05, 0.020216251388991413, 9.999999999998899e-05, 0.021422838471491734, 9.999999999998899e-05, 0.05431151951037805, 0.043828634150498647, 0.09038533246386482, 0.02440411140041454, 0.025435014753260488, 0.04476161139863777, 0.1261196484744287, 0.03982530693751485, 0.048535072166252746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07253350355996413, 0.07344471550513354, 0.0737966486318643, 0.09764486597014188, 0.09567438598628009, 0.09830863487845998, 0.07747604132944674, 0.08089265287746839, 0.09663418369817178, 0.39216503221438725, 0.36617677177879737, 0.38705883891376014, 0.42864482455229014, 0.4205991511327085, 0.3795831437073133, 0.37361827015194804, 0.37772095773373415, 0.4030153602104922, 0.07807280897354651, 0.07650983461649175, 0.07808240239310449, 0.06441276871271351, 0.073101553146938, 0.07239591174165816, 0.07265673920925275, 0.09310100562192725, 0.06871499784429891, 0.17873989601850004, 0.12745377268702218, 0.149582690999982, 0.19730516392012865, 0.20866151997734805, 0.23044713056268618, 0.15287745953902454, 0.28726016337263216, 0.1530863687741557, 0.1968846050622104, 0.19148696080339012, 0.2611096782298825, 0.22125473072645807, 0.1944757892425638, 0.23080048655466667, 0.26515374599551855, 0.2776368626135376, 0.19428576992467628, 0.15948846455147125, 0.16537062887077503, 0.1505053034342101, 0.1767390639580677, 0.1700047807297408, 0.16661464364006184, 0.13442646572488537, 0.2125095961769785, 0.1742683143041608, 0.15771489342489253, 0.18078468440506934, 0.15619453180109444, 0.13372129583916303, 0.17461109797531427, 0.16522785363718873, 0.15234110431375392, 0.1786223433751598, 0.1620324494476001, 0.19971822813747253, 0.17864556026208067, 0.17410589328497228, 0.18222256683454885, 0.18159645083599352, 0.19470066778289608, 0.18685450646306645, 0.17587241423233313, 0.20155929993477373, 0.16550924014876167, 0.12364356444483016, 0.1522127699956105, 0.5432294365222947, 0.1942932135865414, 0.18996980845504963, 0.12256640923840545, 0.16744548377248536, 0.15029844701569162, 0.08275623567662149, 0.15396918826047146, 0.19453253870400566, 0.3750015008972949, 0.37845693443950157, 0.42648741937558543, 0.16338523663462778, 0.21226646518126469, 0.2123066491526726, 0.170443994756163, 0.17572371710292445, 0.1656720554280684, 0.19250576953248055, 0.175872242665154, 0.1956274220216606, 0.16322671936779698, 0.1746135908827131, 0.18051009002629037, 0.06152139233198706, 0.0644161691311187, 0.05178526677631523, 0.06935227998831783, 0.08048666631697865, 0.061192287613273, 0.07691622148586374, 0.057180108088951576, 0.05856520747682481]}, "mutation_prompt": null}
{"id": "0eb39aac-3707-4054-a538-8a0be92dbc41", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor (adaptive)\n        self.CR = 0.8  # DE Crossover probability (adaptive)\n\n    def adapt_parameters(self, evaluations):\n        # Adaptive strategy for parameters\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial += velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Greedy selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedHybridDEPSO", "description": "A novel hybrid algorithm integrating Adaptive DE with PSO using local search intensification to enhance convergence speed and accuracy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.7483095453175803, 0.7775159893973487, 0.7733584856192364, 0.776570925617721, 0.7827731586576189, 0.7620091235878188, 0.18244789405582873, 0.782824855713659, 0.7749581815282008, 0.6366509250929947, 0.620114856818746, 0.579507188892483, 0.5827966929924414, 0.04580179933444728, 0.5483656778711491, 0.05113610221774867, 0.5913093469143436, 0.605358924007461, 0.10940725514898353, 0.1330637532421819, 0.10028687913618872, 0.1151698030916588, 0.116494571845976, 0.11753983747855268, 0.09994597347885958, 0.11576750041178507, 0.1036213281535483, 0.11101521115241353, 0.10117609041839548, 0.09121938574609179, 0.09901733141158697, 0.11105221916084906, 0.0998551594743241, 0.1064691583386882, 0.09679620106720865, 0.08905588620043059, 0.9972397616171825, 0.9974914066531857, 0.996466163006017, 0.9928854641732004, 0.993113540301351, 0.9907499653873187, 0.9971647314672383, 0.9927427639328571, 0.9932345633758872, 0.2602522321799208, 0.24094163363512866, 0.2617265817974952, 0.270525293055889, 0.2627293281265928, 0.28017773819649583, 0.08659047481346316, 0.08724800592250359, 0.2572099732469795, 0.20963937686181167, 0.4430586504395162, 0.31629378487501303, 0.20015602016429102, 0.18790814962977287, 0.2947536039447418, 0.5528190750359343, 0.3378842908170272, 0.24755447439950207, 0.21805993270565627, 0.2317515420662991, 0.19527489526141606, 0.1764313405251643, 0.1655192545448766, 9.999999999998899e-05, 0.1691212976750046, 0.1948116842403922, 0.14257657085420883, 0.1996018996733041, 0.20771918554980273, 0.11464835131489182, 0.28272855051830326, 0.16835269640190764, 0.18592213595187046, 0.09815360662476347, 9.999999999998899e-05, 0.19369560669231634, 0.01992194884142695, 0.012533778247017513, 0.04340204811112558, 9.999999999998899e-05, 0.03910844567753824, 0.0018722339402919008, 0.027251709336293617, 0.0432739911485871, 0.042575295825552306, 0.10121351528284828, 0.08110380258306082, 0.18265257609414554, 0.09014165869597524, 0.01347688782583023, 0.09085170048964408, 0.02044104860111473, 0.15816459959292062, 0.1526455444796193, 0.04448166833393696, 9.999999999998899e-05, 0.030362608901084442, 0.06093568120794701, 0.057122041126694056, 0.08199997459206532, 0.08412264000865921, 0.07755189169217336, 0.06454533261991258, 0.13511363252666564, 0.1602001460478748, 0.11444985235121674, 0.18861315314350657, 0.16133112235914737, 0.15919164592202562, 0.12630566607604543, 0.053978379217776484, 0.12688980485637946, 0.5202853833709513, 0.48681926544648313, 0.4909303350499108, 0.5338441456486698, 0.49768658834943313, 0.4714108338506309, 0.5233442597613971, 0.47420592216868185, 0.4927360585012004, 0.08017508773215709, 0.08054046766128864, 0.07340800984442031, 0.09691869173486467, 0.09562083320382231, 0.08398390506033016, 0.097923328910404, 0.08003515051864818, 0.05367192554562539, 0.11602052463560009, 0.18234843385529054, 0.16353664457675254, 0.14672608154735367, 0.12987100863256906, 0.1775930021145441, 0.174433888901514, 0.2591715836776449, 0.12458619934711623, 0.36664926003927134, 0.24252092986658025, 0.2247392524782913, 0.27508732339616704, 0.2706992951778602, 0.22021626933502692, 0.36737224229725574, 0.29215168122249724, 0.30603651945913957, 0.19161609920019995, 0.267773020802036, 0.16475874140807956, 0.23627038186913318, 0.18079464637538656, 0.2097321634916708, 0.19237623968725082, 0.24957559657242834, 0.21601412972452172, 0.1747382282469072, 0.18864738291436256, 0.1817600684552103, 0.16771246476437152, 0.17244655525448727, 0.16019064338528277, 0.1487091365048464, 0.2000271801308905, 0.18523017998460278, 0.19369106814742698, 0.17242904731946307, 0.20165611611548762, 0.18820899006354253, 0.21623352245545968, 0.18554429159189934, 0.19715629767678422, 0.20787653864623468, 0.18641937835583722, 0.16511078770086662, 0.16101622598914345, 0.1148227029699812, 0.18726800915855124, 0.5843294211802184, 0.4752365697348673, 0.12086010171580874, 0.1634264706379951, 0.1517657490574258, 0.07910966821304866, 0.1563911999435591, 0.17175871458253855, 0.279254774946633, 0.4107641446652702, 0.20146601639980533, 0.21234029518819275, 0.18910442020812057, 0.3975052192177978, 0.18675530661344875, 0.1758387345746314, 0.19621641847528004, 0.1755181339461238, 0.19466993540932942, 0.16931376147118793, 0.18683499107084844, 0.17261676223958888, 0.18234255714495062, 0.08194728887664893, 0.060550538492086914, 0.05093865425504407, 0.0723032344902802, 0.06918180544969676, 0.056556741699077095, 0.05929648903017426, 0.07679658620741647, 0.07043242106789516]}, "mutation_prompt": null}
{"id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 24, "fitness": 0.3194488384369823, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "865611e6-1a5d-46b9-8a51-f5f834ca26cc", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "e858035b-41db-48d0-8da4-16f86ee25e30", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "db76efd6-6d63-46b6-85a1-158d5c2a461b", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.7  # PSO cognitive parameter (tuned)\n        self.c2 = 1.7  # PSO social parameter (tuned)\n        self.w = 0.5  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def levy_flight(self, L=1.5):\n        sigma = (np.math.gamma(1 + L) * np.sin(np.pi * L / 2) / (np.math.gamma((1 + L) / 2) * L * 2 ** ((L - 1) / 2))) ** (1 / L)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (np.abs(v) ** (1 / L))\n        return step\n\n    def adaptive_update(self, evaluations):\n        # Adapt DE mutation factor and SA cooling schedule with history-based cooling\n        self.F = 0.6 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        if evaluations > self.budget / 2:\n            self.T *= 0.95  # Faster cooling in later stages\n        else:\n            self.T *= 0.98  # Slightly slower cooling initially\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            \n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                # Differential Evolution enhanced with Lévy flight\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c) + self.levy_flight()\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Enhance global search efficiency by integrating Lévy flight-inspired steps in DE mutation and adaptive SA cooling with historical performance.", "configspace": "", "generation": 26, "fitness": 0.2724291178845579, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.8244363708628077, 0.8311455327658434, 0.8373185054114494, 0.8377854847247501, 0.8340571757322893, 0.8307858695970269, 0.810513910950402, 0.8179365552848263, 0.8019216964385758, 0.3172714372220323, 0.28052299977594874, 0.31225942261020545, 0.3393662659904728, 0.4254125463369717, 0.3227140447803565, 0.19278637503000562, 0.40581465573607767, 0.3318680091161901, 0.1051702918379166, 0.1496289635603032, 0.13207804183068295, 0.12376846110490192, 0.16497916065097873, 0.12814690183435362, 0.09066657297604197, 0.12443280765384357, 0.16592438783829166, 0.1192904701908255, 0.10812040475122708, 0.10413909750523731, 0.11786311066367217, 0.13473925618877636, 0.11999353467365836, 0.09187172172992264, 0.1336787838358885, 0.11251313663146956, 0.9852053478162879, 0.9847512104024203, 0.9839125531530899, 0.9784378965403078, 0.9916709880286159, 0.9824004290807243, 0.9853056543310497, 0.9897308374986743, 0.9904315863905598, 0.2293559715103748, 0.29070020932411667, 0.25324899826530967, 0.28752050373637605, 0.34525996940630477, 0.22513888974573548, 0.2605766363530927, 0.2578143029616845, 0.23410901798108086, 0.3064852803324517, 0.1938139856844031, 0.2178050175411821, 0.19262352358691837, 0.2126568675994297, 0.2707003042104782, 0.20267229078359716, 0.6375029800475017, 0.23517263266740251, 0.1536213181041567, 0.16027739093575, 0.14132288071088683, 0.14065230469264167, 0.2217346706162714, 0.19979606561639462, 0.16072814141023795, 0.13832920386663394, 0.263250698831606, 0.138360122281312, 0.13452286754030462, 0.20402777505331593, 0.34136671591861956, 0.14925776112215483, 0.19725980292326617, 0.33374104430560636, 0.1279782235772462, 0.11695730474562716, 0.05999893880683993, 0.0432282082965223, 0.00488200657966642, 0.04090637716975598, 0.2616979421575776, 0.019458813009629372, 0.07796795307455429, 0.03873003813511133, 0.12731533394686667, 0.09484337188867176, 0.1657331948183921, 0.17717321310631573, 0.11644638105242322, 0.020620159167238472, 0.1605018604551356, 0.13418176871374377, 0.1617724560190974, 0.09977530233165033, 9.999999999998899e-05, 0.31590442142565756, 0.22887551607925383, 0.09365943958419642, 0.0714293518449991, 0.0913461949625074, 0.095815434805961, 0.07364594898405397, 0.09027152198146016, 0.06431603006800035, 0.12734588037922734, 0.06853912393254247, 0.0064208878694486105, 0.0468236924442208, 0.09590543296228715, 0.04820832722946711, 0.18239247833746197, 0.305863345526445, 0.6024897508353299, 0.5893933161019345, 0.5074117758335602, 0.5574609447504526, 0.599345539301301, 0.6211149143511572, 0.5445234713361506, 0.5303106827624424, 0.5663940063522988, 0.07048106814232413, 0.13885068550130875, 0.09456603285979037, 0.0766158010382143, 0.06404079310872135, 0.14194464174352195, 0.08747761995533543, 0.11010553099904896, 0.05348534928042625, 0.18317649956391846, 0.16590707350614664, 0.18068440132182184, 0.20209530139735266, 0.22401075383968638, 0.19669663923459202, 0.16611404430445487, 0.18171827758097792, 0.2045088885673475, 0.17802354188485225, 0.22239561015831, 0.2016590795485098, 0.24185307633273057, 0.2805282988898131, 0.20026884280135082, 0.28079954354907877, 0.3012399229112248, 0.25364972419552245, 0.23891242746888675, 0.24634090031276323, 0.14504101545014036, 0.19921369506625752, 0.20446093859011116, 0.17264285226135434, 0.2474267730119749, 0.21209030320143862, 0.09199609253641139, 0.20013886042084628, 0.17121667024666698, 0.22308844045501908, 0.19903202891394467, 0.19652121695498825, 0.21827599229479622, 0.24844778642038912, 0.21698848959497885, 0.2285633977808773, 0.19107973807813983, 0.20460683526953993, 0.18110008287546575, 0.18640753823209888, 0.19061239473369596, 0.18861573898733408, 0.2031621015920536, 0.19088480200390934, 0.21350448541207157, 0.8902981305500726, 0.16538565963692398, 0.15397270017402775, 0.8847074413878984, 0.2000289628445745, 0.8873055794654778, 0.12476604093419341, 0.17037417449807113, 0.16231365847053913, 0.8646702383374313, 0.11215157062089909, 0.7316102612539901, 0.15217597096702795, 0.16881377019728283, 0.20850628060796284, 0.21153827704955408, 0.7764505680449054, 0.7730347584976083, 0.17544506847265984, 0.19808253504174467, 0.18541125290689298, 0.2095539346105546, 0.1879623833454539, 0.2064509595595576, 0.19380157796450936, 0.1988691855362642, 0.18884619593719532, 0.09383799938452297, 0.10475932083185957, 0.10054837838932362, 0.08289297083256497, 0.07745592602764517, 0.09328744936946809, 0.08259936900219655, 0.07163389334157766, 0.08222748876310193]}, "mutation_prompt": null}
{"id": "27df9b8c-55d2-4334-8689-31937a62933f", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "31ba11c6-2005-4be5-a25e-ae926c673a80", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "0f8fc216-f2a9-4f98-a2f4-bf5386858114", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "e90560ac-4232-4a39-bb5a-ccf28b752696", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "d18f49a0-ace2-4b79-8d75-9ec5067721fd", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "b5706653-c49e-4413-8d52-35b081e3c8c1", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n        self.elite_fraction = 0.2  # Fraction of elite individuals retained\n\n    def levy_flight(self, L):\n        # Levy flight for random search with heavy-tailed probability distribution\n        sigma = (np.math.gamma(1 + L) * np.sin(np.pi * L / 2) /\n                 (np.math.gamma((1 + L) / 2) * L * 2 ** ((L - 1) / 2))) ** (1 / L)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / L)\n        return step\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.95  # Exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            scores = np.apply_along_axis(func, 1, population)\n            evaluations += self.pop_size\n            \n            for i, score in enumerate(scores):\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            elites = population[np.argsort(personal_best_scores)[:int(self.elite_fraction * self.pop_size)]]\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n\n                mutant = a + self.F * (b - c) + self.levy_flight(1.5)  # Levy flight enhanced mutation\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n                \n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Enhance solution diversity and convergence rate by introducing an elitist strategy and adaptive mutation scaling using Levy flights.", "configspace": "", "generation": 32, "fitness": 0.25083160066006654, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.8567694493564999, 0.7618420966803521, 0.8960401785942151, 0.841997676118678, 0.8987573524885101, 0.8500810228379196, 0.8646819201071869, 0.7898823774756251, 0.8796101165658877, 0.1966527935101683, 0.23293566378513753, 0.2522616177962981, 0.2967890198582006, 0.23114829382772317, 0.09344097072281221, 0.15836860803087383, 0.29808622257817374, 0.10034141493240134, 0.13918013575237598, 0.18349175493181413, 0.1410461254655655, 0.1533469515114364, 0.13257991261240532, 0.13674294664482878, 0.15197394258288222, 0.1765596971774699, 0.1717363570822359, 0.1460164277012569, 0.10775022894386943, 0.11249257306689542, 0.22712295631613455, 0.12072111868854296, 0.11757849833340328, 0.1160507656370251, 0.118269940128374, 0.10324077131959808, 0.9850088772897749, 0.990202821891418, 0.9843726002613329, 0.9804767458912106, 0.9866834139277723, 0.9786136442293302, 0.9806331671516022, 0.9846219973475606, 0.989471545913325, 0.3356149664589567, 0.2350937960744961, 0.28253010519988053, 0.2349833755519941, 0.40743953112494224, 0.23977640558026303, 0.21824759163272034, 0.2626695655359701, 0.22449897145474473, 0.2296865229124342, 0.23669315380318634, 0.2710870241467275, 0.2139080912319009, 0.20659719375343044, 0.2788536556811736, 0.261263333397611, 0.32888325256321227, 0.2926480958941293, 0.13715404954287735, 0.16654147475161785, 0.13608299154853998, 0.16496180916799763, 0.14297007938253847, 0.1405246797703723, 0.1538465375291409, 0.13373037686874412, 0.15617074194425518, 0.16431849920000663, 0.13224116969604693, 0.11447874767779997, 0.23138973050498202, 0.1953614932280161, 0.17850089973119243, 0.24412228891084364, 0.1413215467490092, 0.13548603742171894, 9.999999999998899e-05, 0.06878711718970842, 9.999999999998899e-05, 0.08830878289770883, 0.07132834050674774, 0.02076860697947447, 0.02540014377652955, 0.02075728951542788, 0.14972989849609963, 0.05522063562623025, 0.04025827160971607, 0.20058557874623217, 0.08045568057549757, 0.04200361038820777, 0.07852315753495698, 0.12334677616734113, 0.11113633258407773, 0.13887433355760892, 0.05078587884685526, 0.03702842142188145, 0.04861666553797772, 0.08100364535399562, 0.0043620013417404735, 0.08294993161059594, 0.12656514466678215, 0.07618070470585203, 0.07195088814976824, 0.09220531734324722, 0.09519977727327678, 0.19998710863106506, 0.05833134496773795, 0.11505968508140851, 0.00676840372889842, 0.08435098170940325, 0.15085431206084088, 0.18452990545127945, 0.6177142565436737, 0.5973805199877654, 0.5182739962074301, 0.5979117316201283, 0.5866967762156075, 0.573514991902941, 0.5306100654236321, 0.47967385297435305, 0.5913235068318138, 0.10440191192131065, 0.1177343446152247, 0.08953028418926401, 0.11715191578383888, 0.0881986537178513, 0.07999986738217979, 0.09877094214814208, 0.09181970615101986, 0.07215327507010738, 0.17240488557486444, 0.270971602006451, 0.18613140995097122, 0.1536543594251054, 0.22258672092432807, 0.12045990601555046, 0.2031487529620244, 0.18681769511365864, 0.21747103406427826, 0.20557113275368033, 0.24553765268374483, 0.2321258745143998, 0.2664661660682739, 0.2246019097081714, 0.20739979340789672, 0.2625488325740357, 0.22290558343010147, 0.28544453364253075, 0.223233571119004, 0.21433771192548667, 0.1329539707448988, 0.20532507346204876, 0.1643403655057355, 0.17466547923170328, 0.20856363341168782, 0.2243756332459249, 0.19686695946269805, 0.22185965856715095, 0.23455270341129864, 0.1745189481476387, 0.21050392731099488, 0.19712756320573488, 0.20528796801656446, 0.22566289149161511, 0.22270639847416163, 0.18792114463433973, 0.1810907669009615, 0.19217813135276385, 0.19608081664272614, 0.19520630715481413, 0.1891381192398276, 0.19772377944991515, 0.18089910379628826, 0.2047570030752679, 0.18162181300994962, 0.16510351641528864, 0.16873693732607387, 0.15359768396039886, 0.7335982524743963, 0.2015312727217926, 0.16904002953289832, 0.12490725315827389, 0.16991575188888963, 0.16801588572532877, 0.12215469885074759, 0.3992468880557992, 0.8892757286396619, 0.20837637468296366, 0.16868293103742327, 0.20902687693611255, 0.16825030458158852, 0.5185453174999184, 0.1533598153191701, 0.17659425793969563, 0.2228096340062966, 0.22948694486095378, 0.22599414710312782, 0.22926447623345125, 0.19518795573861414, 0.20084660513746322, 0.2296251749243413, 0.21546789628364438, 0.07202707735924263, 0.07759515990949217, 0.07467930845075677, 0.09534256152898013, 0.08694470695542622, 0.09603783235961294, 0.07746190402884334, 0.08612692508275, 0.08639459764365698]}, "mutation_prompt": null}
{"id": "99b57b54-141b-499a-9fb3-739766514c3e", "solution": "import numpy as np\nfrom scipy.stats import norm\n\nclass EnhancedHybridDEPSO_Bayesian:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.6\n        self.F = 0.8\n        self.CR = 0.9\n        self.T = 1.0\n        self.kernel_noise = 1e-6  # Small noise to ensure numerical stability\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.5 + 0.4 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.85\n\n    def gaussian_process(self, X, y, X_star):\n        K = np.exp(-0.5 * np.subtract.outer(X, X)**2) + self.kernel_noise * np.eye(len(X))\n        K_star = np.exp(-0.5 * np.subtract.outer(X_star, X)**2)\n        K_star_star = np.exp(-0.5 * np.subtract.outer(X_star, X_star)**2)\n        K_inv = np.linalg.inv(K)\n        \n        mu_star = K_star @ K_inv @ y\n        cov_star = K_star_star - K_star @ K_inv @ K_star.T\n        return mu_star, cov_star\n\n    def expected_improvement(self, X, y, X_star, xi=0.01):\n        mu_star, sigma_star = self.gaussian_process(X, y, X_star)\n        sigma_star = np.sqrt(np.diag(sigma_star))\n        y_min = np.min(y)\n        z = (y_min - mu_star - xi) / sigma_star\n        ei = (y_min - mu_star - xi) * norm.cdf(z) + sigma_star * norm.pdf(z)\n        return ei\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        eval_points = []\n        eval_scores = []\n\n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            \n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                eval_points.append(population[i])\n                eval_scores.append(score)\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Bayesian Optimization Exploration\n            if evaluations + self.pop_size <= self.budget:\n                X = np.array(eval_points)\n                y = np.array(eval_scores)\n                X_star = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n                ei = self.expected_improvement(X, y, X_star)\n                new_indices = np.argsort(-ei)  # Select based on max EI\n\n                for i in range(self.pop_size):\n                    suggested = X_star[new_indices[i]]\n                    suggested_score = func(suggested)\n                    evaluations += 1\n                    if suggested_score < global_best_score:\n                        global_best_score = suggested_score\n                        global_best_position = suggested\n                    eval_points.append(suggested)\n                    eval_scores.append(suggested_score)\n                    if evaluations >= self.budget:\n                        break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO_Bayesian", "description": "Incorporate a self-adaptive Bayesian optimization component into the hybrid DE-PSO framework for enhanced exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,5,20,5) (20,20) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,5,20,5) (20,20) ')", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {}, "mutation_prompt": null}
{"id": "bb34c7e3-227f-4291-815f-b259aa28e8c6", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "2d249497-4536-42fc-a5a7-5e7e1b5d47f4", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.c1_initial, self.c2_initial = 1.5, 1.5  # Initial PSO parameters\n        self.F_initial, self.CR_initial = 0.8, 0.8  # Initial DE parameters\n        self.T = 1.0\n        self.learning_factor = 0.99  # Adaptive learning rate\n\n    def levy_flight(self, step_size):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/3)\n        return step_size * step\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = self.F_initial * np.random.rand()\n        self.CR = self.CR_initial * np.random.rand()\n        self.T *= 0.95  # Enhanced cooling rate\n        self.c1 = self.c1_initial * (self.learning_factor ** evaluations)\n        self.c2 = self.c2_initial * (self.learning_factor ** evaluations)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c) + self.levy_flight(0.01)  # Added Lévy flight\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Integrate Lévy flights for enhanced exploration and adaptive learning rates for dynamic parameter tuning to improve convergence.", "configspace": "", "generation": 35, "fitness": 0.18562104549397793, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.45491854688548305, 0.45884747493635825, 0.45384129058210876, 0.4501891288033394, 0.4716344077697372, 0.46565403237719716, 0.4327968211938934, 0.43871296643595004, 0.42935286509512616, 0.05692587554020079, 0.21150591658754592, 0.21320387560126897, 0.22886214675037908, 0.007361271539298442, 0.18107264325234174, 0.10492291152790911, 0.22646949154059437, 0.056632053876187416, 0.15866383738631762, 0.23185377719948708, 0.2563473593332447, 0.16684332450824846, 0.14871587099576922, 0.12336090596978722, 0.12353374379411419, 0.10563432907802595, 0.14622884201198116, 0.11313839453202057, 0.1620804929707509, 0.07443133881284703, 0.16286978795169849, 0.10560431665423398, 0.048082918632468274, 0.11811355849064709, 0.11879694499537741, 0.1122133973134587, 0.7978983525229993, 0.09004134118023577, 0.994855419843349, 0.12340404817859307, 0.09159789207539948, 0.6883462031619506, 0.1052499177691989, 0.6572527847116348, 0.5776965610941968, 0.17785191060281158, 0.1098443444091467, 0.06805863152111757, 0.10375821299350685, 0.12410915915269138, 0.2521738554075794, 0.17729334519888051, 0.1144255806253055, 0.09206101834514047, 0.5487746100426323, 0.20285538264685976, 0.16456719837891176, 0.21041640370275283, 0.21155460720758068, 0.27788665473047913, 0.15213007838058945, 0.15050780886834614, 0.3539195192276786, 0.18778225161628748, 0.17729274065161538, 9.999999999998899e-05, 0.23969532046811604, 0.10737851374961371, 0.18283782253619263, 0.21128823255931206, 0.14819857726187746, 0.15494429105222207, 0.14011645894344116, 0.12480838319797183, 0.12656635583832543, 0.14233101670536508, 0.20901526476765697, 0.1307688957497174, 0.17710795171754745, 0.059075879466642944, 0.09207006564583042, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007225203226027044, 9.999999999998899e-05, 9.999999999998899e-05, 0.08934665511486761, 0.04910638704552761, 0.08703025282623966, 0.06825580347904148, 0.0048636529416037355, 0.11746097937500621, 0.17870682913961267, 0.058654662867428486, 0.052261440971625106, 9.999999999998899e-05, 0.00028824268429850086, 0.03551899566755545, 0.012521918717257718, 0.05165963569854426, 0.03675289598276854, 0.05574003075205369, 0.05068777263306545, 0.002423450930066795, 0.09438943780068987, 0.10177323752197354, 0.10067104254725512, 9.999999999998899e-05, 0.14747966516057553, 0.07504551800617176, 0.14854956972655198, 0.06134198446732375, 0.08469203006241499, 0.3862221805596302, 0.4227677771880596, 0.38397522258060124, 0.40747816277321136, 0.2597881478495455, 0.387551649621683, 0.39992083262167044, 0.44106710808281757, 0.425937212916933, 0.09027526668397223, 0.0660934376914889, 0.05292190557950727, 0.10605016715790572, 0.09015400688585473, 0.12141376746426136, 0.07434724598328935, 0.1090511644604425, 0.08102370683247284, 0.20423516024015131, 0.17567707878667138, 0.14580247269682112, 0.13870189740984828, 0.1597600231454559, 0.12072010818043566, 0.169037879711186, 0.1455171898210108, 0.16122700937208845, 0.2427908408008762, 0.2821848043391887, 0.18765390809802407, 0.27727182021538754, 0.3268473239155826, 0.3042916061859413, 0.25850553698484424, 0.3308950605929747, 0.28907766929028555, 0.22825090868641928, 0.26249977294619753, 0.14016363838254042, 0.20941460011947766, 0.20248128775814767, 0.15998788974749445, 0.22341976306064393, 0.29335257175441776, 0.16893963549811108, 0.1896265589875631, 0.1975357437822205, 0.17037742480659412, 0.17586759014115128, 0.20308615005458464, 0.2055556130699031, 0.19473669910632574, 0.1875194247620504, 0.18734283909789684, 0.20716160249812876, 0.20670905397917982, 0.20599628371657763, 0.2104295352150659, 0.22335352333123193, 0.1907955625525094, 0.22855351600267126, 0.2280712203925127, 0.18350991764636726, 0.3513515144069155, 0.5372864338042899, 0.1544687536681295, 0.1715484984847313, 0.19886411855062247, 0.19960080640415345, 0.13685674774864443, 0.16890714948659913, 0.15305865599564827, 0.4162123120903035, 0.16123970244756314, 0.42645814973755247, 0.19813133639810188, 0.17024343406789666, 0.1927672861364237, 0.10542519139243356, 0.33034898164062765, 0.19573768535485092, 0.16799104897695216, 0.18989915712660954, 0.1713850891468537, 0.1758515179869431, 0.19258287795829732, 0.18256442755076752, 0.19500205600714005, 0.16505708338124914, 0.18211041511361614, 0.07984370868581103, 0.07604102872886054, 0.0772165839166209, 0.07755814028944641, 0.07747481914480181, 0.0715351400774471, 0.05912787343195092, 0.08002855642147255, 0.07062184494455614]}, "mutation_prompt": null}
{"id": "e2abce96-55ad-4906-b357-5d4e0fac4031", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "810f03e1-430f-4f3f-a343-39ddc9b07140", "solution": "import numpy as np\n\nclass RefinedHybridDEPSOPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter\n        self.c2 = 1.5  # PSO social parameter\n        self.w = 0.5  # Inertia weight for PSO (adapted)\n        self.F = 0.9  # DE Mutation factor (adapted)\n        self.CR = 0.9  # DE Crossover probability (adapted)\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def dynamic_update(self, evaluations):\n        # Dynamic strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.4 * np.random.rand()\n        self.CR = 0.7 + 0.3 * np.random.rand()\n        self.T *= 0.95  # Slower cooling\n\n    def orthogonal_crossover(self, parent1, parent2):\n        # Generate offspring using orthogonal crossover\n        offspring = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < 0.5:\n                offspring[i] = parent1[i]\n            else:\n                offspring[i] = parent2[i]\n        return np.clip(offspring, self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = self.orthogonal_crossover(population[i], mutant)\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSOPlus", "description": "Enhance diversity through orthogonal crossover and dynamic parameter adjustments for improved exploration-exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.31566242054046467, "feedback": "The algorithm RefinedHybridDEPSOPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.577895113521385, 0.8656665727734263, 0.5616981950844564, 0.633102308948799, 0.7101345868272935, 0.7660711804282898, 0.7817107270703035, 0.8479668790074241, 0.7120233598517335, 0.0794725832408989, 0.5125914682267143, 0.0760927251850686, 0.5383268008026105, 0.6866118071677355, 0.5232663073281976, 0.054178596515236266, 0.018900969149047486, 0.6872849994274768, 0.11550970024697416, 0.17523315597261457, 0.10849298863389212, 0.15911879373942828, 0.5214668779298701, 0.17647592060846895, 0.1572157466588021, 0.1828573503737826, 0.1415164695135962, 0.1537947319659565, 0.11711131951902021, 0.11810235463278118, 0.11477144372876313, 0.16906871538617074, 0.12098498271964842, 0.16625798543353065, 0.15473091632250802, 0.11450144551009711, 0.9858955207903143, 0.9803708653335521, 0.9864039357489982, 0.9685527882520915, 0.9803929782820691, 0.9812309240849402, 0.9842357444932364, 0.9796796895806574, 0.9757948502356393, 0.05785271883980836, 0.49823580463616857, 0.5337396109319861, 0.4892999393439208, 0.4932126047608506, 0.5488848727732558, 0.5011767613513889, 0.5587588065545369, 0.08808505735871897, 0.8529429107555826, 0.3447135329352483, 0.39079760127440877, 0.18702392807888624, 0.9009319071836698, 0.4901628464138088, 0.15051629075748119, 0.9266015738484487, 0.22143118301132325, 0.5394007266058587, 0.5501205626819765, 0.5277035849740581, 0.3721986623721186, 0.13453403060404345, 0.13272694703244636, 0.5342536899768031, 0.13252585277671092, 0.13302240429222734, 0.4663804236041308, 0.552011721814213, 0.135429928428471, 0.5451504198858155, 0.1359444343856996, 0.5324373967651104, 0.5973816105247881, 0.5088067319969232, 0.13113270040139724, 0.10746906351224239, 0.08489252524793023, 0.18050668639595535, 9.999999999998899e-05, 0.25885935466907306, 0.020026636384120278, 0.264937773096812, 0.13839803998914613, 0.08268114784303782, 0.04179049674636104, 0.16461340360055288, 0.38807149890923176, 0.17846502173528112, 0.06996096992046208, 0.08109786940255048, 0.5997071315297398, 0.2188930373770941, 0.11130050579822581, 0.050829421555969256, 0.11959231442345941, 0.08299802575673798, 0.08012859141597761, 0.3329410234729171, 0.07902137559321232, 0.10222004094929493, 0.11648024686361713, 0.07512303099397011, 0.30291856449690324, 0.4180458680292207, 0.18473837435572482, 0.3832936316289104, 0.2912028718186739, 0.20919434277527948, 0.4295961179603204, 0.05764971306223965, 0.08380102875411799, 0.46878383571301374, 0.5035775095031786, 0.5186190991852815, 0.5383491266829432, 0.5529262792561095, 0.5289745496384716, 0.4993361031683313, 0.6189621957637139, 0.5191344626190407, 0.0639638214398176, 0.09079371779265744, 0.07456862717082002, 0.08473546184860548, 0.11047569318189376, 0.11217242618739509, 0.12956658276842858, 0.11108110604598165, 0.08189327487345255, 0.2740003800269888, 0.17003730308059783, 0.20421600992880562, 0.2442798446280392, 0.20192542639350708, 0.10457582730615633, 0.2757584039587765, 0.33106005417835693, 0.19120239745403356, 0.1707148062232522, 0.37233546888680535, 0.15615603749381568, 0.4216308827918773, 0.3042704033663399, 0.39301352019626556, 0.416367011593626, 0.4076925291059247, 0.24065989277590327, 0.1167240567202813, 0.2170523135324418, 0.14846854539919785, 0.24592489810103468, 0.2913883004054515, 0.25192228584834964, 0.23483672971615688, 0.30853694841878254, 0.08356080792641629, 0.20628495723957263, 0.20188024781465252, 0.19093469313930633, 0.2398939264921267, 0.19282910261339015, 0.2171244641818867, 0.24724758389604562, 0.18733444917187092, 0.2070967793434727, 0.20311471511092072, 0.2267863790654302, 0.21059215579677737, 0.2124842671614705, 0.22435698876722332, 0.24596526926433804, 0.19129014938569133, 0.21727719034661452, 0.18924099968495534, 0.9172379221432383, 0.18472750743338529, 0.15405328163299603, 0.17164137772523913, 0.2009005637725355, 0.19984691643590946, 0.12628974581060903, 0.17008672627994859, 0.16262151792104684, 0.1288129492509794, 0.2103417190795207, 0.8635682157323802, 0.7387192721667608, 0.1693137661655415, 0.2077190451429235, 0.1866536220555809, 0.8740321271145659, 0.8591221670725989, 0.1875050290473057, 0.19711887388198368, 0.21186490076639564, 0.17028032708684027, 0.21199545024261057, 0.20521662408575425, 0.19433422660595612, 0.23723605172538387, 0.24359665884939008, 0.09796993470298443, 0.12320682291728968, 0.08918577031689146, 0.09324627350601056, 0.08248886056054994, 0.15003085345465683, 0.0996399483869167, 0.07766665023946939, 0.07701295840600397]}, "mutation_prompt": null}
{"id": "df87c0e0-a39b-45d6-9500-1816d4221233", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "d823c5af-77d7-40bd-9196-41dee9ef7346", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.4\n        self.F = 0.8\n        self.CR = 0.8\n        self.T = 1.0\n        self.restart_threshold = 0.1  # Threshold for restart\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9\n\n    def collaborative_differential_grouping(self, population):\n        groups = []\n        for i in range(self.pop_size):\n            indices = np.random.choice(range(self.pop_size), size=3, replace=False)\n            a, b, c = population[indices]\n            groups.append((a, b, c))\n        return groups\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            groups = self.collaborative_differential_grouping(population)\n            for i in range(self.pop_size):\n                a, b, c = groups[i]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            if np.std(personal_best_scores) < self.restart_threshold:\n                population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n                personal_best_positions = np.copy(population)\n                personal_best_scores = np.full(self.pop_size, float('inf'))\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Incorporate collaborative differential grouping and a restart mechanism to improve diversity and convergence speed.", "configspace": "", "generation": 39, "fitness": 0.29258345366656474, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.45204413209096206, 0.50179494707063, 0.5016524781762937, 0.460070017428023, 0.48247437842922836, 0.46650191946909636, 0.49510789310039627, 0.47410892270782834, 0.48189181990221863, 0.2971640173041066, 0.2667833216239196, 0.17909834592062268, 0.4034604976848172, 0.34526476297501263, 0.45499886248811794, 0.34128048012500345, 0.34273675247167334, 0.3647514864395295, 0.48631811912002854, 0.46003791255296533, 0.16704041548429194, 0.1594513155494688, 0.23076178198843478, 0.1486256396537894, 0.1349415872859372, 0.14070886675885208, 0.14289702608845833, 0.1515983247891758, 0.1404829353823408, 0.39853463994013305, 0.13444365776679756, 0.16765203286838604, 0.1816455112011367, 0.36965447642713944, 0.15499699954074875, 0.14216657519170273, 0.9893389147707575, 0.985618726518531, 0.9945461988119924, 0.9467854092512225, 0.9676466745346116, 0.9797352546648227, 0.9857830808918194, 0.9788432425941583, 0.9740848891065224, 0.3604583377211561, 0.45782255167890984, 0.4585028208589651, 0.44298919835273587, 0.38627914908446637, 0.4080095190944397, 0.46895815221643466, 0.4252706669175813, 0.4009592971707451, 0.7567073972952226, 0.30117395844032135, 0.3744082717284818, 0.5246305225178162, 0.21811418574296038, 0.2794312149356055, 0.20374442047962094, 0.2303871427997738, 0.19761470296404937, 0.1884049439968959, 0.24033070065247764, 0.23983884659878263, 0.2379729116274466, 0.27698963100188323, 0.2438778149655415, 0.2480387494413665, 0.24242196178203945, 0.22978553547637592, 0.28012339141514364, 0.13566297900517765, 0.13490794223467406, 0.26225857496134786, 0.2696458348561772, 0.278605445237202, 0.22637917338927094, 0.2400673521533706, 0.2385271686965058, 0.06723455836030567, 0.22760752447369137, 0.09808984358377637, 0.029807643083783697, 0.14494200203529095, 0.012241648808091532, 0.05017681331418722, 0.06957780833342098, 0.08640233408128772, 0.3632640890530423, 0.3083665577651221, 0.3685895627524409, 0.408954294037844, 0.11307203118771181, 0.23167348979925306, 0.4209466767249257, 0.36331594370458364, 0.2682800805049851, 0.05235013294251023, 0.14706031562431854, 0.27581616945515164, 0.10886520471004901, 0.0874631403081777, 0.1625395274977829, 0.1526169008112327, 0.23647840596422642, 0.0753201332671839, 0.04301182294840655, 0.21018364059340222, 0.2462199985453496, 0.23132938109270051, 0.2949286589988803, 0.2780955494910391, 0.08976427653816155, 0.051066554266590014, 0.08496518056664648, 0.44322607484559906, 0.4679285281774944, 0.42185790807923906, 0.43155926599092354, 0.4045090927270336, 0.40500275144878095, 0.42243625170062804, 0.38499092738884877, 0.413758842576578, 0.0649945080892752, 0.07828855860844852, 0.11025148919888872, 0.10473067336645436, 0.10115913714813574, 0.10751628922053291, 0.15839089324354882, 0.14722178257027085, 0.07932358871705258, 0.27843326346650843, 0.28037969628093373, 0.4021658634228915, 0.27185541229824917, 0.18016231442789, 0.25336906553803695, 0.20826782107928543, 0.13946200017664, 0.2173698790820181, 0.2467912734528228, 0.21954184419983946, 0.17974623030922943, 0.3311509110323523, 0.2940654699794931, 0.3379322090439185, 0.24261946911236254, 0.30344573179964063, 0.2322471940325298, 0.238298587445544, 0.27505281283069194, 0.231965535523336, 0.30533828924245576, 0.29458575778437524, 0.27584214437826615, 0.2310593393270658, 0.27482473209758507, 0.09802324208193036, 0.19228094381780425, 0.22677111819952112, 0.19598129846696133, 0.25591387243775976, 0.18129713022572846, 0.2294457556325069, 0.23155554756537156, 0.2581089559158356, 0.23399661001116123, 0.20340613773557603, 0.21854146724152668, 0.22376213043782223, 0.22646011221243045, 0.1863407537966354, 0.2119150440240818, 0.19451964602374172, 0.2282356868743738, 0.19697170595941393, 0.8138539361911471, 0.17613751808451872, 0.18898184069380175, 0.7936394156716561, 0.20138907294444297, 0.20040023634770798, 0.5628835419376617, 0.7030266701414507, 0.17792250989503333, 0.22958038955533533, 0.21293269833907558, 0.14967016016515466, 0.7976423133359778, 0.2120615346214808, 0.735778104082885, 0.8174829240421102, 0.21024726801058446, 0.21020027684243248, 0.24928436699043777, 0.17663304887366338, 0.19516577365787202, 0.2610720127780174, 0.20623243344312936, 0.20904587034841104, 0.1988653762580418, 0.20089099634840224, 0.19610388199234574, 0.09700470008026407, 0.08757038341884693, 0.09671934541141836, 0.09241233409803495, 0.08683599572654488, 0.0879128788650787, 0.08718159814733639, 0.09098064300474162, 0.10219376565283078]}, "mutation_prompt": null}
{"id": "4cffbd39-7310-4824-a810-53e7c735b4d4", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "52eda9a0-7484-4bb5-a645-e673175acd26", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "36098294-3723-4182-be6c-d2afe2de53e8", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "43576e78-4af0-4f11-970b-60c7db14bd20", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.bounds = [-5.0, 5.0]  # Search space bounds\n        self.c1 = 1.5  # PSO cognitive parameter (tuned)\n        self.c2 = 1.5  # PSO social parameter (tuned)\n        self.w = 0.4  # Inertia weight for PSO (tuned)\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def adaptive_update(self, evaluations):\n        # Adaptive strategy for parameters and cooling schedule\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T *= 0.9  # Exponential cooling\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)  # Adaptive parameter adjustment\n            # Evaluate population\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Apply DE/PSO hybridization with Simulated Annealing\n            for i in range(self.pop_size):\n                # Differential Evolution\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Simulated Annealing acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Particle Swarm Optimization\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Integrate Simulated Annealing for global exploration and adaptive PSO-DE hybridization to enhance diversity and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.9151825042674373, 0.9096118335587674, 0.9225439128044711, 0.8853485420783976, 0.9113487832997194, 0.7839685513210842, 0.8092807493343392, 0.9155016632109061, 0.8709600941727229, 0.7825724684835458, 0.7301702478129031, 9.999999999998899e-05, 0.8468298529708215, 0.7267585464254743, 0.06622910442371088, 9.999999999998899e-05, 0.059446939333743454, 0.05404910742075808, 0.13440235954480428, 0.10563182432796969, 0.08293815645799585, 0.11436017227357076, 0.16109423043570825, 0.11906068048729035, 0.1362606449860876, 0.07995549789105261, 0.07745734664230497, 0.08872316454813267, 0.16121572778270055, 0.08198344679664227, 0.12652118742627605, 0.11187056815359742, 0.13740404602705603, 0.11792251602932158, 0.11813977834850287, 0.1167211520369621, 0.9727423737627158, 0.9759291955570025, 0.9912686793082802, 0.9552327695487537, 0.9821191975003223, 0.989495308620736, 0.9815826753734233, 0.986467740520138, 0.9704121226577848, 0.5956103173573537, 0.6001334631418267, 0.6526363001919868, 0.670758488793908, 0.6698004527601091, 0.6647506962019221, 0.08844616176667841, 0.5952230247509418, 0.06898661279693785, 0.1722539526441349, 0.5510901088584241, 0.24645665713934928, 0.2785303537353446, 0.38789449082991634, 0.15710547586039125, 0.15934145851936643, 0.238736494723632, 0.2768768958331258, 0.1345647392508028, 0.6127924020240685, 0.5581183364184298, 0.6456064192029556, 0.646255891850621, 0.5635584823408011, 0.13556793540727807, 0.5730151472121279, 0.5130770282835129, 0.6723724666027089, 0.1352509282776535, 0.13285933051794985, 0.6371590557791644, 0.13580804125094614, 0.6903089352935454, 0.6652790380527951, 0.1343893457240225, 0.554935727118114, 0.28788364463589156, 9.999999999998899e-05, 0.10657413086258094, 9.999999999998899e-05, 9.999999999998899e-05, 0.017242806845164327, 0.05479059858306867, 0.033041073055668835, 0.3433519260572673, 0.19758594151264386, 0.17738554093867442, 0.19436526630621354, 0.21817018244205522, 0.09560272154255456, 0.08646226474488627, 0.05043705648723551, 0.1415289604920923, 0.1634802399037526, 0.07268251110673174, 0.153923597344773, 0.42712082133563667, 0.08387656300049295, 0.3465248470731168, 0.31433712826045324, 0.22171597904670137, 0.07629396732358817, 0.076024021232312, 0.2401563354462567, 0.4716413457832309, 0.2762631821819863, 0.14522517572858085, 0.353803788099766, 0.4610920652930649, 0.08516468325347137, 0.4165516937043673, 0.21730460262622298, 0.6186591207925773, 0.5434191997427649, 0.638242725991929, 0.5910570844036849, 0.5865956832437726, 0.5542159176671653, 0.5688663416649162, 0.616254532065928, 0.6231916911027997, 0.06223008816772346, 0.11010988755447071, 0.0738572395970385, 0.08595181522974094, 0.03249367533708514, 0.1108116055902677, 0.11038732564567688, 0.1065651024778006, 0.09452515777561454, 0.2199638266369328, 0.25089397348641673, 0.15535871682515512, 0.18055410252976778, 0.20079196716597714, 0.1448017493754138, 0.28403895687476133, 0.36749904692946733, 0.1907333647445173, 0.236790762120191, 0.19492563895853854, 0.19761353999648834, 0.23961040979644588, 0.28111989518125857, 0.3115079989649776, 0.5974276599214163, 0.37571396959067316, 0.20412610484297478, 0.10954891833313796, 0.17170856519031963, 0.2106293692915313, 0.19477256659824294, 0.3077248017637608, 0.19585848436204445, 0.19130626923367977, 0.34352287180377017, 0.22585248699955596, 0.25158279340914347, 0.19573762967044506, 0.19454210108772108, 0.2173819342525115, 0.24729102501751454, 0.2120229522725059, 0.2641937425367441, 0.20806715670204723, 0.22811104808560223, 0.17299883633438895, 0.21126344700081734, 0.1937542750739214, 0.20114166251034427, 0.19438415600176884, 0.17093271261533793, 0.1805182353201119, 0.2321637396774031, 0.20670660540978025, 0.26449439123963026, 0.16965211107829326, 0.15459811267299062, 0.9524285358553006, 0.20112198445196927, 0.2012246659030389, 0.9214764060029041, 0.17015947262034037, 0.1659680583964993, 0.08338559606166296, 0.20625656663870118, 0.16799172326368184, 0.10486717753207175, 0.15528383922896194, 0.9191296130770615, 0.10425555552271804, 0.168642227518511, 0.7994328083419323, 0.19619352987511507, 0.1960647888152428, 0.18904066547143183, 0.22169253314539017, 0.21340569595831693, 0.19874932427779757, 0.25392572621323106, 0.19210813483396383, 0.20627570158899478, 0.0923835729058321, 0.09296140938097541, 0.10195698606854908, 0.10003715800701107, 0.080669813422516, 0.10745508435168327, 0.09306237146463814, 0.09096914806153034, 0.07863356586591963]}, "mutation_prompt": null}
{"id": "3841cef9-943a-4071-9649-94f1d737b0e6", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.2  # Adjusted PSO cognitive parameter\n        self.c2 = 1.2  # Adjusted PSO social parameter\n        self.w = 0.5  # Increased inertia weight for PSO\n        self.F = 0.7  # Adjusted DE Mutation factor\n        self.CR = 0.9  # Increased DE Crossover probability\n        self.T = 1.0  # Initial temperature for Simulated Annealing\n\n    def levy_flight(self, size, alpha=1.5):\n        sigma = (np.math.gamma(1 + alpha) * np.sin(np.pi * alpha / 2) /\n                 (np.math.gamma((1 + alpha) / 2) * alpha * 2 ** ((alpha - 1) / 2))) ** (1 / alpha)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / alpha)\n\n    def adaptive_update(self, evaluations, improvement):\n        # Adaptive strategy for parameters and cooling schedule\n        if improvement:\n            self.F = min(0.9, self.F + 0.1 * np.random.rand())\n            self.CR = min(1.0, self.CR + 0.05 * np.random.rand())\n        else:\n            self.F = max(0.4, self.F - 0.1 * np.random.rand())\n            self.CR = max(0.5, self.CR - 0.05 * np.random.rand())\n        self.T *= 0.95  # Slightly slower cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            improvement = False\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    improvement = True\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            self.adaptive_update(evaluations, improvement)\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c) + self.levy_flight(self.dim)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "RefinedHybridDEPSO", "description": "Enhance solution diversity and convergence by incorporating adaptive Levy flights for global search and dynamically adjusting DE/PSO parameters based on fitness improvement.", "configspace": "", "generation": 44, "fitness": 0.27441008219638185, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.8605788221600689, 0.8589032984489173, 0.8456749211696101, 0.8345905209119193, 0.8492066932540526, 0.8347574471688, 0.8546581270639362, 0.8627627197693373, 0.8409726586144285, 0.2361742963379041, 0.6141260167442737, 0.3261011289376621, 0.27988209667721586, 0.38317218889374927, 0.27312488529951795, 0.21332563808259153, 0.21234713333331634, 0.16467243209006788, 0.26110424799470733, 0.17365403915889488, 0.15812623476998755, 0.20142244735445447, 0.3191300203360883, 0.15901073168769198, 0.21264633211663397, 0.2533396632497459, 0.16431179932004014, 0.20637511274583153, 0.1420410985197439, 0.17092696518502892, 0.2915246641421577, 0.14225373768491534, 0.2749645881278834, 0.166332198803402, 0.14923839135736638, 0.19721436524234148, 0.9784354011283429, 0.9870211486443149, 0.984379915148955, 0.975401275104911, 0.9863431516669505, 0.9804396072440267, 0.9898815145064158, 0.9797107409593043, 0.9814838675746265, 0.39316578165566674, 0.22430570605687528, 0.34147661986914946, 0.32053832330359333, 0.3222230043036729, 0.27382856202500594, 0.26343587355625775, 0.301843111090891, 0.2965432458672269, 0.3394123808610927, 0.21815940476558837, 0.1790198356311835, 0.193896434814692, 0.19508743261602013, 0.28132716014623715, 0.17926874915074553, 0.2265140332286939, 0.3520714082267723, 0.1466513058002269, 0.13946867708058686, 0.1759735164727919, 0.17532410960476574, 0.14048900016765853, 0.3232988724333927, 0.21072703829923733, 0.22056053846300938, 0.17515958737279103, 0.263562015037184, 0.1181952826435807, 0.2381911479511044, 0.22409142138268145, 0.1660457632878457, 0.12662163214363464, 0.44087438666313583, 0.166124588013277, 0.14730273956668227, 9.999999999998899e-05, 9.999999999998899e-05, 0.056579752517701865, 0.03063606692982035, 0.058252564390375294, 9.999999999998899e-05, 0.005226597326331683, 9.999999999998899e-05, 0.07593280707401995, 0.1415478373903548, 0.07662718776631006, 0.07603050426427038, 0.26414007787120686, 0.11974680193266307, 0.061299100676020846, 0.244053976241412, 0.23435710195728532, 0.06935105329489011, 0.050188030962394437, 0.035025116061398465, 0.1014255936495927, 9.999999999998899e-05, 0.12431509220258774, 0.1602167476855344, 0.18265461889300127, 0.20156477867486877, 0.06967595647568048, 0.1547828590131176, 0.258361757526845, 0.13654223647957786, 0.10126632711205985, 0.094333191302016, 0.19281838868012158, 0.26147309363144067, 0.06308027336794197, 0.0824664582491268, 0.3663665243901777, 0.5584108199233622, 0.6289589408988037, 0.5839091542885897, 0.5645857970211916, 0.5705176014292845, 0.6323492420956341, 0.669091709441292, 0.48756603370345175, 0.10595534051711197, 0.06174111214393341, 0.11106890614262044, 0.11314694757809907, 0.05944647228369848, 0.11937826292908671, 0.0747670333257906, 0.09867788374436881, 0.0779153142341591, 0.14822894383658225, 0.17028562245617562, 0.1271546964059984, 0.23134882098036702, 0.22637414883631124, 0.14913311881951508, 0.2800958599878267, 0.13136965580146187, 0.23701979514470028, 0.27570000864510125, 0.2511622924386112, 0.18222178666123712, 0.24186751507242854, 0.2639289001276105, 0.30229670183906165, 0.32261165139872994, 0.2987508576731336, 0.2463539977326561, 0.21598291378256795, 0.22896598373693733, 0.14291231662416481, 0.20522386142717375, 0.20046814359269827, 0.24599439655307354, 0.22680280615405324, 0.16784528449898317, 0.18887961605783465, 0.2625455808325079, 0.19580925556023554, 0.19255952664738685, 0.27778829684571105, 0.26568343176806697, 0.19702808451935905, 0.2877815841988759, 0.30576867167197364, 0.18871684937396405, 0.19452005868412614, 0.4058643597499839, 0.1949930959145867, 0.21147327831091556, 0.2082795991442996, 0.2088389717686936, 0.20032139440461127, 0.21734251786403425, 0.24988924536876833, 0.17005681729298516, 0.1261148791559945, 0.15417518949795872, 0.7343530545484744, 0.20057095234527578, 0.19946444455023493, 0.14777806638236146, 0.16931940613600904, 0.1622834844764648, 0.08309019577032273, 0.2099446049885636, 0.12423283927433171, 0.9126081110519513, 0.20849711223241696, 0.6714868060086701, 0.21110487864057248, 0.16957799972323084, 0.8796002763655044, 0.20132332728874203, 0.20017046861319754, 0.17399910225689708, 0.2056031302178929, 0.20205966075076975, 0.18103351156414382, 0.19205364437612849, 0.2011237665511726, 0.19382720141838317, 0.08261817397454618, 0.09602730479029775, 0.06823995363768265, 0.10024900943447979, 0.0795539772302245, 0.09679176809913193, 0.10560286486449855, 0.07652704838877666, 0.1064832036313903]}, "mutation_prompt": null}
{"id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 45, "fitness": 0.34382613278574703, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "4f8e62c1-8417-42ce-b79d-a6b947638f9d", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "085da76c-1f38-4847-9604-77ee1eda1106", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Initial population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Cognitive parameter\n        self.c2 = 1.7  # Social parameter\n        self.w = 0.5  # Inertia weight\n        self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive DE Mutation factor\n        self.CR = 0.6 + 0.3 * np.random.rand()  # Adaptive DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3  # Minimum temperature\n        self.alpha = 0.98  # Cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.2 + 0.4 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n        if evaluations % 50 == 0:  # Dynamic resizing every 50 evaluations\n            self.pop_size = max(10, int(self.pop_size * 0.95))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveEvolutionaryPSO", "description": "Integrate adaptive evolutionary parameters and dynamic population resizing for enhanced exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.3149657046452687, "feedback": "The algorithm AdaptiveEvolutionaryPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.8687341282764633, 0.8396867313849086, 0.7232965663731372, 0.8730498740187731, 0.8049690694539788, 0.8402281524446372, 0.7595461077827503, 0.8751322830865763, 0.7808098693954669, 0.04184538191283449, 0.6780528191592644, 0.6941367794745061, 0.7696098316963789, 0.06242695213731708, 0.7172106550142024, 0.717926440962791, 0.6163940674648726, 0.05852654121410539, 0.16583788610096195, 0.15293773711457836, 0.0688857428699966, 0.15484535966503554, 0.17010894167208024, 0.12200739370554459, 0.11903426513657045, 0.16166434197994273, 0.15465911454854597, 0.14494446322443988, 0.1455628400895581, 0.12684100507457263, 0.1129875683362006, 0.13268746063396208, 0.11319670644929669, 0.1729799255444654, 0.11615810473673627, 0.0934881596220366, 0.9498798797979586, 0.9890394914579249, 0.9879446973675559, 0.987447130285863, 0.9902620294099151, 0.9756424169706538, 0.9700956470997542, 0.9902648340573479, 0.9647433041523443, 0.37675529167132704, 0.45334908781963856, 0.43611062924134036, 0.38762402892299497, 0.3092962400613355, 0.41307032861559834, 0.20336421185640807, 0.3674410038820698, 0.40840115327140725, 0.22230682910853206, 0.22424766786907335, 0.3938677046641579, 0.15884725598254024, 0.2130000822171949, 0.2807705252789403, 0.32486660129876743, 0.9460952614306057, 0.34984174609837615, 0.395329322872905, 0.40653056841578505, 0.13119081870349314, 0.5180536679607266, 0.39625590842634006, 0.374866700947756, 0.38004090125064527, 0.37054985067901713, 0.459542996539858, 0.13422412785865778, 0.4920978489603849, 0.45777217453156016, 0.32194469046901597, 0.34602350615970867, 0.1337873614568711, 0.4563741981624281, 0.41270218424652416, 0.13344682739368086, 0.06656092116389956, 0.09060349264888723, 0.052958741040286084, 9.999999999998899e-05, 9.999999999998899e-05, 0.357031518158727, 0.008794066415658053, 0.07978773248502935, 0.13860348426405344, 0.14343179298733266, 0.34710272939219255, 0.4945357715426587, 0.3251710300416276, 0.1818218975776964, 0.2809093733962357, 0.05740094381102678, 0.4745879416681813, 0.3595319919123293, 0.08892790868398259, 0.051448167980813975, 0.31467167907641924, 0.17274012138624328, 0.21172770927448625, 0.08060540772356817, 0.24844020917096943, 0.20323294659717328, 0.130453794288672, 0.3620341995978421, 0.3133464610041451, 0.3275224045705115, 0.31029841233189104, 0.24836400398384195, 0.381492426233192, 0.17529551831206958, 0.4545755799919877, 0.09478261047117498, 0.48909346510829654, 0.5493760427999583, 0.5707898511382747, 0.5446045914558475, 0.48306671138417345, 0.4461616987059086, 0.503595658000153, 0.5315379493639653, 0.503061622598773, 0.048708128765634906, 0.13647915812184241, 0.0859433100012218, 0.15796220185983822, 0.18170007385274034, 0.08516184846353514, 0.09652848203413178, 0.12444304886223212, 0.09408914920973366, 0.2654619625860556, 0.2351202737650896, 0.19491251014915367, 0.19541466026779897, 0.46523824716095685, 0.14553681774332583, 0.2671121958991318, 0.16952323849359419, 0.5620510138116117, 0.31742916812895283, 0.3040884763178575, 0.2741260533881359, 0.3101853545814177, 0.27800447837684394, 0.37260023532875575, 0.16282883925277658, 0.37208640189503617, 0.21970150217312812, 0.16398170859974348, 0.22049048049873066, 0.23479496839307634, 0.1967421623743384, 0.38467757815322046, 0.21549886728425194, 0.22536562098092827, 0.22577167351741367, 0.24149899463910107, 0.24924368223534132, 0.19992535917408571, 0.22641023194493226, 0.24093624031146565, 0.21608354314961198, 0.2697958567291152, 0.19334827994145598, 0.2113474460783581, 0.24855683379309979, 0.6378206540791845, 0.20860122241266676, 0.5716544704120268, 0.19699896730771438, 0.2167864125453116, 0.20146240543027283, 0.19930197251343806, 0.18835390661985163, 0.18167669633699213, 0.17917411838400843, 0.18915912117448586, 0.18775132870762323, 0.19785892605160016, 0.16955897410923249, 0.17089077782178663, 0.17776724844858294, 0.16383556860636217, 0.16952460037807182, 0.11273602029192387, 0.17038982604573627, 0.8094116072509054, 0.16882866920202555, 0.21371166345484283, 0.20981388599015272, 0.16728339386543412, 0.8681239797232457, 0.16637253031303734, 0.19469914780607978, 0.19778274510947735, 0.19505790047549876, 0.19991710683379993, 0.1676276303430586, 0.2052188049391097, 0.19374015276644163, 0.2026635070892474, 0.22039540276122027, 0.08092923552093378, 0.10015294874366776, 0.06808553465774836, 0.1284875350522925, 0.08939383637450848, 0.12635050074181853, 0.0951981711701666, 0.08766192884149604, 0.10147622596351324]}, "mutation_prompt": null}
{"id": "1c84ad19-91a6-4477-8fd4-f9d87b3e67c9", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "392dbe37-5380-4ac9-b8b0-1aa9aeaeb58f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "801e7b1b-444c-49b2-aa8d-d503f4b4ff06", "solution": "import numpy as np\n\nclass ChaoticHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased population size for diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Increased cognitive parameter for enhanced local search\n        self.c2 = 2.0  # Increased social parameter for improved global search\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.8  # Increased DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.chaos_start = 0.1  # Initial value for chaotic sequence\n\n    def chaotic_map(self, current_value):\n        return 4 * current_value * (1 - current_value)\n\n    def adaptive_update(self, evaluations):\n        chaos_factor = self.chaotic_map(self.chaos_start)\n        self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n        self.F = 0.5 + 0.3 * chaos_factor\n        self.CR = 0.5 + 0.2 * chaos_factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.chaos_start = self.chaotic_map(self.chaos_start)\n\n        return global_best_position, global_best_score", "name": "ChaoticHybridDEPSO", "description": "Integrate chaotic maps with hybrid evolutionary-swarm optimization for enhanced exploration and exploitation dynamics.", "configspace": "", "generation": 49, "fitness": 0.2575196965057888, "feedback": "The algorithm ChaoticHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.6298399488227207, 0.6518616192220277, 0.6525613791570946, 0.6636617127776812, 0.6672219373295118, 0.6340666439239859, 0.6369782729141684, 0.6333580515556543, 0.6467986297360695, 0.3994892413650206, 0.3669365158496375, 0.3864668373131127, 0.39848603660282866, 0.37006236782468105, 0.4045354949418033, 0.3736464853006799, 0.3930162387743309, 0.34247596168342753, 0.13381931536771008, 0.1253602815248298, 0.12267067349330862, 0.20346113357164963, 0.13702530852498862, 0.20653070113189098, 0.12151911844734864, 0.1322721219710704, 0.15177611510492284, 0.10885765801429748, 0.11002881987255153, 0.10948885262307628, 0.11814023580524535, 0.10977370159989586, 0.11832127659976033, 0.10605915270407162, 0.10099906488584476, 0.15310101512285457, 0.9884758637667381, 0.9942377213418385, 0.994318128147184, 0.9564881998084063, 0.9847638679366076, 0.9677477922856411, 0.9880305234381827, 0.9857383551294688, 0.9856864059147898, 0.2579552619814576, 0.2008460075699975, 0.19707206471291128, 0.245533777006664, 0.24160706421191858, 0.2628677284055817, 0.20708867709077705, 0.2608019053536317, 0.22770610398649282, 0.28270235101742536, 0.24956899253103115, 0.37958340000743485, 0.5375045888215664, 0.45450599875558295, 0.19660812743701128, 0.44712388092483313, 0.48440656482492583, 0.4798290684938261, 0.19933439125812913, 0.17101051496035857, 0.15552894218376567, 0.2395917643887392, 0.2304984272092313, 0.16692927117322087, 0.1745613875803279, 0.19635251734417747, 0.21887329039603132, 0.24740209581006634, 0.07681601571685137, 0.17092507285693648, 0.19435200842854383, 0.15498670576946827, 0.2153658628274362, 0.094249563431412, 0.128649676600034, 0.18760647005976894, 0.02177284296457238, 0.02443119504593505, 0.05988217317416433, 0.030103270351698685, 0.1688937231016684, 0.13041132840821212, 0.13340612281683772, 0.08016273470090474, 0.09590551579340467, 0.2216117748865052, 0.10554539495315696, 0.25365866248167546, 0.17534303424144415, 0.13650570766839787, 0.17312959604363132, 0.21543896419811048, 0.2803657325136868, 0.2038795886744953, 0.03265600538767777, 0.05692735683034478, 0.02519065351841454, 0.060371724914712654, 0.0952884315962601, 0.0642300544930311, 0.04732997217869328, 0.03831334669130715, 0.05801841327796864, 0.15597161139862314, 0.14896144226706198, 0.14689554020200246, 0.17412627994691832, 0.16065077919902193, 0.1539312653827164, 0.12110917259280363, 0.12134397376156192, 0.16176905130054908, 0.48777225252360545, 0.5031620678073676, 0.49869069895335194, 0.5531597581952762, 0.4878040313889661, 0.47633493425240403, 0.4997395358661031, 0.5226771427758582, 0.5018527373623203, 0.08257953062561663, 0.09209008780133776, 0.09370584970219387, 0.09248920144689565, 0.08530983234516476, 0.0990525431428847, 0.12249985429154508, 0.09824549866072974, 0.10532044161786003, 0.15148944754182014, 0.1331458759769235, 0.15802021602901184, 0.13394135221221826, 0.1563338901457939, 0.13428932688963302, 0.17479151619006883, 0.1378736510183508, 0.1469622440085484, 0.2880716502576699, 0.2657782611370618, 0.293384320181569, 0.2847975657444952, 0.25153919914192857, 0.3029539781818317, 0.2999412735834993, 0.3168891074986885, 0.3011385598804295, 0.21519566464337914, 0.20613736922358927, 0.20719919928387143, 0.21602885227957225, 0.18595177832794962, 0.20151209552163585, 0.2473295882048132, 0.2027274465427149, 0.24396344454335728, 0.18805413104747903, 0.18170039208064725, 0.2108560967676122, 0.17799416227867004, 0.18446495241068295, 0.17328408956509433, 0.1775907551284872, 0.20220069063212154, 0.20081511329144308, 0.25634092672975506, 0.20526054502274016, 0.20301529991842582, 0.1952218944188625, 0.22536395034802292, 0.19464313484591933, 0.19006690027184903, 0.1945184064833806, 0.1970006960178653, 0.19965723999619855, 0.16070344635537892, 0.15092151537013432, 0.16786148546320745, 0.19022782852886477, 0.1944704407670571, 0.1149971222816768, 0.16843897870022917, 0.6266547398539706, 0.545986281460295, 0.456240418547611, 0.1742742036859114, 0.3646628838725785, 0.47130133883423664, 0.1996793006671348, 0.3510468298379975, 0.18904483299342556, 0.20156775996962817, 0.2025300769680004, 0.17580001430503323, 0.17095819182138117, 0.17711071622490804, 0.1661550671264287, 0.17339637206519143, 0.17154187450377012, 0.1699030648997647, 0.19015850024066028, 0.0816959185916728, 0.07176918782764297, 0.06565540774819201, 0.0712447932441268, 0.06493136362218788, 0.07441251134727567, 0.07199192226888174, 0.07252512358423335, 0.07043992415217903]}, "mutation_prompt": null}
{"id": "b7e75421-05a2-4847-9d03-d40b546ff5f8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "7a8cb957-6519-4220-b4cb-ddaee1b3e822", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "f4919533-01ef-4864-81ce-0198f1329701", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "c7f116ed-2e30-49b0-885d-f00ca8ef5af1", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Slightly increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Refined cognitive parameter\n        self.c2 = 1.5  # Refined social parameter\n        self.w = 0.6  # Adjusted inertia weight for better exploration\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.85  # Refined DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # Minimum temperature remains the same\n        self.alpha = 0.90  # Adjusted cooling rate for slower annealing\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.5 + 0.3 * np.random.rand()  # More dynamic mutation factor\n        self.CR = 0.7 + 0.2 * np.random.rand()  # More dynamic crossover rate\n        self.T = max(self.T_min, self.T * self.alpha)  # Exponential cooling remains\n\n    def chaotic_local_search(self, position):\n        # Introduce chaotic perturbation for local search\n        return position + 0.01 * np.sin(10 * np.pi * position) * np.random.normal(0, 1, self.dim)\n    \n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        topology = np.random.randint(0, self.pop_size, (self.pop_size, 3))  # Dynamic neighborhood\n\n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = topology[i]\n                a, b, c = population[indices]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or\n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                # Apply chaotic local search occasionally\n                if np.random.rand() < 0.1:\n                    trial = self.chaotic_local_search(trial)\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Enhance solution quality by integrating dynamic neighborhood topology and chaotic local search to improve global exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.3351817794914857, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.545902453564771, 0.5848818275434755, 0.6077959774633463, 0.575578758111551, 0.5517549260898265, 0.6372245458813732, 0.5907682027980834, 0.5744568526127142, 0.5688351996243359, 0.07329244859292483, 0.5128686398731528, 9.999999999998899e-05, 9.999999999998899e-05, 0.5374383983764902, 0.5420887366843142, 0.49278717981210374, 0.4655145615334487, 0.49523399247952415, 0.1563501707837649, 0.1368512859119908, 0.15569682821150688, 0.15208468503219574, 0.15215402801015077, 0.16397093967271825, 0.10432311603666222, 0.14475226747582526, 0.16306130123552243, 0.12300263984073267, 0.11994665495819701, 0.08764879325159725, 0.11606363524399799, 0.08546924508681719, 0.10415774739090644, 0.1541894990987105, 0.1128700336322801, 0.11190604750315047, 0.9869443586731882, 0.9890158450237236, 0.9847146823550043, 0.9516169138646873, 0.969487232813713, 0.9551967510791304, 0.9813475631660181, 0.9875497370929229, 0.9883899406498989, 0.3271729701567876, 0.28768306211584616, 0.3121323622534261, 0.3714367791965395, 0.4248296560295336, 0.32774775580270776, 0.35545167599375105, 0.317920913345776, 0.35179595764598803, 0.23012645672411236, 0.22649579704010647, 0.645947468580965, 0.3893532185967117, 0.7995515880513673, 0.21199806174170266, 0.2041995325347138, 0.18029210233515802, 0.4396363477113673, 0.5325698073482239, 0.13342130886345238, 0.5390254389271012, 0.48571964968218695, 0.4134404297653832, 0.12827531501484413, 0.48071326886024235, 0.42072504282571666, 0.5557264127940753, 0.42417827984001777, 0.5387796093514129, 0.4136463331892485, 0.47964945929848823, 0.5195862894695431, 0.44566452829098036, 0.13272366963790994, 0.455685356773755, 0.12554349148602328, 0.06514402924715301, 0.0841530513931571, 0.029397483026968096, 0.041405811774070767, 9.999999999998899e-05, 0.251375857925928, 0.18130307334965556, 0.3621802927277742, 0.4754385971325491, 0.6411733075578223, 0.5406701230087656, 0.5397977081525478, 0.48584434991215353, 0.5611088476262893, 0.5527837294406748, 0.5976059381958829, 0.11550269938993063, 0.6004459736417659, 0.18738710866075126, 0.1469110779629471, 0.1698296328460145, 0.08571011482740609, 0.13036777176746073, 0.4242349755694773, 0.1392278329358222, 0.19005410964549974, 0.08877981246841715, 0.3955936349588378, 0.41984794982335805, 0.4447112394517464, 0.4214401259893593, 0.03671549789812456, 0.42122773547766645, 0.38812293751967697, 0.055845499994246484, 0.397286807358169, 0.5100169295505004, 0.5231640416209412, 0.5166178788175234, 0.47707303435171244, 0.49877217607645175, 0.5594077748834325, 0.49442153570418135, 0.47739012642526724, 0.5223302627199602, 0.1319017088462635, 0.09294834400990604, 0.08745325034217799, 0.11704418990486842, 0.07613645333920538, 0.07982041470514833, 0.1429192704802783, 0.08500200093536492, 0.09498258241911539, 0.19926875811817812, 0.15198296596657235, 0.5273801021445539, 0.20367017051609038, 0.4750901965675214, 0.17159765111086256, 0.4036641617112978, 0.20750392293120745, 0.3475916449081501, 0.2609919705898246, 0.4329806834589284, 0.28041140590147395, 0.3576977006865333, 0.34889948244699787, 0.4571877773387648, 0.43769264722755374, 0.442954671791323, 0.4037453070056376, 0.2723808740268342, 0.31506792406079454, 0.37923423789575705, 0.3176320145533569, 0.20081102363485048, 0.4465392389438111, 0.32010555083114944, 0.2511361711352631, 0.40347046444448875, 0.19108943339557083, 0.20374193729228063, 0.1792345411402313, 0.223547420674574, 0.195725233792871, 0.20309067880695986, 0.22312091583627325, 0.20658005806228852, 0.1935177739792231, 0.2049223768023377, 0.19079216756537232, 0.24917552406469046, 0.2016532419969126, 0.21511255812834484, 0.1961304214692562, 0.20779222716010703, 0.19885054898606602, 0.1966774764002539, 0.7686032800340754, 0.18803286042457612, 0.15414849386136464, 0.17361976903177945, 0.20028818795261227, 0.2002451305080324, 0.7197897363666527, 0.1695173254177751, 0.8222502521909089, 0.8706296790912957, 0.15634674599381282, 0.12704612043717556, 0.6826599264383435, 0.7051794851721442, 0.20564521773800049, 0.7514173664834898, 0.10502421624594704, 0.7866752289398462, 0.17963480976882817, 0.1868976968697066, 0.2004881733798678, 0.17566339990589763, 0.20000578137019387, 0.19207924718597036, 0.19660498488593026, 0.21145388448425229, 0.2030208248059342, 0.0991550669122152, 0.10656459071748237, 0.08821869517980885, 0.09796071755386437, 0.08102526894611806, 0.07253984518758949, 0.08559401608247608, 0.1688933088065958, 0.08854502508696804]}, "mutation_prompt": null}
{"id": "76916099-fffa-4f41-9dd2-0851c3c37521", "solution": "import numpy as np\n\nclass LevyFlightHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Adjusted cognitive parameter\n        self.c2 = 1.5  # Adjusted social parameter\n        self.w = 0.4  # Updated inertia weight\n        self.F = 0.6  # Modified DE Mutation factor\n        self.CR = 0.8  # DE Crossover probability\n        self.alpha = 0.9  # Cooling rate for simulated annealing\n        self.levy_alpha = 1.5  # Levy flight parameter\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * np.power(np.random.normal(0, 1, size), -1 / self.levy_alpha)\n        return u\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.3 + 0.3 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i] + self.levy_flight(self.dim)\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "LevyFlightHybridDEPSO", "description": "Integrate Lévy flight exploration with evolutionary and swarm methods for enhanced global search and convergence.", "configspace": "", "generation": 54, "fitness": 0.3017606305607882, "feedback": "The algorithm LevyFlightHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.8429941676725574, 0.8477596841955943, 0.832986046605683, 0.8063439807092254, 0.8420274786916883, 0.81754264947703, 0.8310331510376013, 0.7951940987948607, 0.819959315493257, 0.6897944890452321, 0.7012616995010897, 0.6682781100488239, 0.6682222640996411, 0.6890331026495493, 0.678008975675101, 0.7007658145662816, 0.7143258976121163, 0.6019691115174752, 0.1247755014224482, 0.13777760879229262, 0.12867219650397088, 0.15539744845718084, 0.15753788243571276, 0.3247146836268865, 0.13397188727427856, 0.23222122961988412, 0.18773869728232062, 0.14054354239736255, 0.13189772893026108, 0.13260502353328663, 0.114829794881246, 0.113817842531313, 0.13433480207160176, 0.1504560263274186, 0.12937035558794197, 0.12721561495322187, 0.9585356795860571, 0.9620992642890692, 0.9139355582716286, 0.8803147601791977, 0.9283871778085574, 0.9398263848925694, 0.9476686879369368, 0.9403958197496894, 0.94618544660591, 0.19662211417365238, 0.3701323307760548, 0.3480162406530155, 0.37608058039511505, 0.17291536739822932, 0.42006003976567496, 0.1564120769768651, 0.30357303726418194, 0.31866005410794074, 0.22267060031004804, 0.7099967965190201, 0.6761853270176716, 0.3572572561171511, 0.25573531015637474, 0.8320862191963937, 0.22880484172263116, 0.7279949913510316, 0.7052726890392738, 0.1596652574401607, 0.13662754857024195, 0.15779584674371816, 0.2568366788425712, 0.15890264629785655, 0.20431151336421427, 0.20295925122456515, 0.12333653273367906, 0.14420969097123126, 0.1138643351043871, 0.13612893570656948, 0.1635973293119254, 0.16302192695374074, 0.19842775776230237, 0.14380466287194016, 0.14501288453931227, 0.21220971902075614, 0.16094809805211974, 0.03592854669478496, 0.11603920567509418, 0.15344624462215584, 0.09388817402767768, 0.011154342132446815, 0.002538022107097637, 0.14862252716161128, 0.0, 0.05457430267447849, 0.23445316880116074, 0.21698729830567043, 0.14817452550166565, 0.14402042346827615, 0.1638048311743049, 0.13207186795261183, 0.27569719645450064, 0.3212499690795977, 0.18083044524403513, 0.10895947792449479, 0.11945047456284974, 0.09133322813326872, 0.07677202253122417, 0.08647246481186244, 0.06540494450487455, 0.08471184991832703, 0.15566664238032313, 0.07109207986241528, 0.19569301325551614, 0.18880257885110807, 0.17797498106313758, 0.25421971582761704, 0.19898016735013913, 0.22829728634039015, 0.16061172820144654, 0.210495428293349, 0.09817890916755512, 0.5736771826253015, 0.5861081735230496, 0.5453236339009784, 0.5510822037193123, 0.5207889392695901, 0.5821772311799459, 0.6084425230874315, 0.5868473522852506, 0.6304761575750422, 0.12006708865860638, 0.10440182301446166, 0.10860370817869536, 0.08438795437824553, 0.08460367115980916, 0.11004099668442446, 0.09385062290114687, 0.0960899779466603, 0.11906409169374133, 0.12475533936131722, 0.11602621282264958, 0.16101093377150955, 0.13894991843421833, 0.1293066802343219, 0.13559452805915262, 0.1559219119764491, 0.13895403243910842, 0.1270846061990789, 0.3304755113075871, 0.3411195601028829, 0.33302987463499334, 0.36108203516161885, 0.37185519000115697, 0.3861521915533761, 0.4413078458374011, 0.4181494426469853, 0.3667801514170521, 0.3241414325363807, 0.2847374209419864, 0.2511778094063485, 0.1985077774292966, 0.2967286223151411, 0.2661281452521267, 0.3170620916493069, 0.25540664179981665, 0.2884849730655057, 0.2152151574787018, 0.22291162056801928, 0.17007477376874192, 0.21049562484042073, 0.19834935382401053, 0.18786530865106177, 0.179320240471591, 0.18895595319023473, 0.1972710752332203, 0.22668970846899428, 0.209835121350595, 0.21269680714833028, 0.1778495663910702, 0.18818611101003202, 0.19802956655898818, 0.20711405772384917, 0.18800708641373687, 0.23228703040383347, 0.17287774723806926, 0.18518080773359924, 0.18321000693035427, 0.8227089982474975, 0.6720707598610562, 0.6534274512296738, 0.16813783944411775, 0.1604348693566906, 0.7948630101317681, 0.5575463165853846, 0.16128758293772405, 0.162291474488773, 0.19581806344027586, 0.12081501395561134, 0.16417761120969698, 0.2022030707737109, 0.4023463901915382, 0.20178792725331696, 0.17312819349666042, 0.17367824027551138, 0.17308540114448046, 0.19535824961438097, 0.1775329151072922, 0.18403364999529448, 0.19204352356607146, 0.17769720048609994, 0.16575258825291161, 0.09454993345596596, 0.07577783327691157, 0.07393652093603764, 0.091812636864683, 0.08229444124148855, 0.0696968626156591, 0.07726894394183781, 0.0755661609584547, 0.07931833340802663]}, "mutation_prompt": null}
{"id": "4e511e1d-5c6e-44c9-9a9d-a679b1476956", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.8  # Adjusted cognitive parameter\n        self.c2 = 1.8  # Adjusted social parameter\n        self.w = 0.4  # Updated inertia weight to increase exploration\n        self.F = 0.5  # Modified DE Mutation factor\n        self.CR = 0.8  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.9  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.5 * (1 - evaluations / self.budget) + 0.2 * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def competition_based_diversity(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        return population[sorted_indices[:self.pop_size // 2]]\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            scores = np.zeros(self.pop_size)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                scores[i] = score\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Enhance diversity by keeping top half of population\n            population = self.competition_based_diversity(population, scores)\n            population = np.concatenate((population, np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size // 2, self.dim))))\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Integrate competition-based adaptive learning with enhanced diversity preservation for improved optimization.", "configspace": "", "generation": 55, "fitness": 0.2589636622584103, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.6083454473873263, 0.5913496457154301, 0.6011207533741321, 0.5716232796183169, 0.5969532481133997, 0.5066223358516992, 0.5990122151814967, 0.5131915980604032, 0.5835784375443793, 0.2698521173337981, 0.2984633329904237, 0.27497485242475417, 0.18784191180263565, 0.3258914257366008, 0.18958414057636108, 0.21217328229499643, 0.21325164033988198, 0.23089027169452525, 0.12063070356693983, 0.10100882711581582, 0.15360719650837984, 0.0935015657712549, 0.11007375249874007, 0.10307698007613508, 0.1309404635183684, 0.13037538768493973, 0.10596842378885374, 0.10143215424452046, 0.0945921913839678, 0.10522685435272527, 0.09461996029084008, 0.08591725242600046, 0.08847087169734746, 0.10473149792247971, 0.08885619191451355, 0.0911001794088907, 0.9945045154749425, 0.9786435389352847, 0.9873416242231035, 0.9861200036271883, 0.9868148462951152, 0.9877847443199115, 0.9850711467800641, 0.994918822873546, 0.9793242508008543, 0.2727547641847823, 0.25630051500072193, 0.31602384555110763, 0.2730597378907057, 0.2899017056908164, 0.18247932510165488, 0.2653634584820622, 0.17867096702442775, 0.2783824319116486, 0.29679592851462366, 0.41036497535157923, 0.28317853092347445, 0.19929039802237425, 0.22305504286611633, 0.21066279948663613, 0.21351998083531376, 0.22890482890646413, 0.22337730958885083, 0.15206360424203902, 0.144600070410706, 0.15055510845189146, 0.1942675568398442, 0.16988202514839945, 0.13875294647706082, 0.1427170187818716, 0.22250957873072452, 0.15707183423567317, 0.13787052213272977, 0.2220942824904033, 0.1190254869248829, 0.1464629968329576, 0.12376538410074922, 0.11466060016958568, 0.2560470968107902, 0.11923996629105482, 0.11876990613334915, 0.19381954408784352, 0.13832583358665107, 0.03536900744867033, 0.11496177920136763, 0.08832524296290034, 0.12577827132804065, 0.19492766758519908, 0.19373585559701545, 0.08043088097559525, 0.2850368064302453, 0.33714948592552585, 0.3378298940841913, 0.4039103976621936, 0.3556606601352964, 0.30872720222355343, 0.3000414030213352, 0.38546085375457817, 0.25533246235241636, 0.019212089493983897, 0.11970680091967989, 0.13497059677107204, 0.05185709140211381, 0.08012658198262057, 0.0530993178104161, 0.09117485422312055, 0.042826593007918023, 0.05781473649438118, 0.15429025168289556, 0.15521966085405836, 0.12680860143878403, 0.13475397340473205, 0.1501085162708068, 0.18259939526188174, 0.16922865005652676, 0.13047014270620005, 0.09494990831564287, 0.49084688173636437, 0.4370439380025585, 0.512595585628211, 0.45980812422051054, 0.4598928296248479, 0.40043490561669803, 0.5226469518264547, 0.4170480450031361, 0.4325723418970272, 0.06839816990406289, 0.07428801205166913, 0.07949382297169827, 0.09264850022331372, 0.1032718349545001, 0.14755027467357817, 0.1039882666515527, 0.0999110174675738, 0.08640761719040313, 0.18379478741945587, 0.16197013356294288, 0.15281827022860484, 0.1557075755072418, 0.2066493274166894, 0.1567537466599087, 0.14414199088379287, 0.15321940391883637, 0.15988211308262035, 0.25615027876966523, 0.22592839571892154, 0.2703682789435081, 0.2510319015921093, 0.22844568433179369, 0.21657461331864747, 0.20792391800964505, 0.23726412420947285, 0.2561100757835981, 0.15899782347266578, 0.2955361117598402, 0.1522709926142728, 0.234968848654026, 0.180766194876255, 0.18197157213345205, 0.1622419461864696, 0.22255173247251792, 0.26334660286276546, 0.20212329649830985, 0.16842930668804512, 0.1737202916153643, 0.18375703811648458, 0.19673627464748167, 0.16975238717503782, 0.19580665047671442, 0.2203226153472636, 0.17470027367202878, 0.21352395886958297, 0.1839166953610355, 0.1947746160265299, 0.17682770563164163, 0.18346272330292557, 0.18392831352846573, 0.19011385986931462, 0.16545371339920856, 0.19045683309882988, 0.7388170348556403, 0.5529467631559266, 0.19554815021464533, 0.6989908878296377, 0.19720281325363953, 0.5231581497743281, 0.1653917926328009, 0.16468239595286482, 0.7111401467268419, 0.7369518340174204, 0.4379599132940505, 0.6516236417872452, 0.4172451416036148, 0.1655546501546905, 0.688185851457737, 0.23889035969641914, 0.21027280170350815, 0.5975028799412206, 0.18162818073116882, 0.1885627423442784, 0.1905379203905906, 0.1788905033822844, 0.18346288057395765, 0.18028994980926127, 0.1799170194535149, 0.19318316220637777, 0.1844807653431343, 0.08113155546495932, 0.07445755440628987, 0.08273454139278769, 0.0830897906814958, 0.08787742530057441, 0.06760639331673624, 0.07008081656370102, 0.0638053298625475, 0.062451766643772166]}, "mutation_prompt": null}
{"id": "c3b97edc-29a7-402f-ba81-b7e60181e762", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter\n        self.c2 = 1.7  # Adjusted social parameter\n        self.w = 0.5  # Updated inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.9  # Enhanced DE Crossover probability\n        self.T = 1.0 \n        self.T_min = 1e-3  # New minimum temperature\n        self.alpha = 0.95  # Enhanced cooling rate\n\n    def adaptive_update(self, evaluations):\n        self.F = 0.4 + 0.2 * np.random.rand()\n        self.CR = 0.6 + 0.3 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)  # Enhanced exponential cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Random initial velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_update(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if (trial_score < personal_best_scores[i] or \n                    np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand()):\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridDEPSO", "description": "Employ evolutionary and swarm intelligence synergy with adaptive learning for robust function optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.5880033431552022, 0.8160801907084732, 0.6505341257621893, 0.582564702960831, 0.7668086598073478, 0.8083586319070419, 0.7367133559851042, 0.6075114419971193, 0.6761046283282819, 0.5023818813459919, 0.7207446183676135, 0.6840252849586577, 0.6907650557633478, 0.610016956587397, 0.5648237223834477, 0.052820029074365116, 0.6017207903020811, 0.7422231030073487, 0.6657054500590031, 0.17325842443484984, 0.09543679927671767, 0.12348354652973159, 0.5804816823830886, 0.1223576277109154, 0.15282641654886742, 0.12062297872006855, 0.18002479426101214, 0.13683460152570315, 0.17825024521861066, 0.1148872258224255, 0.13966474702477516, 0.13140675323363482, 0.10697162645198133, 0.10647743904256202, 0.10805158932514647, 0.16216853801414766, 0.9878770890904979, 0.9899644467347625, 0.989879291525531, 0.9818881058626714, 0.9879184332299553, 0.970458965699595, 0.988451296340653, 0.9836864200918594, 0.9807725820836555, 0.4490001331840987, 0.42014544063212744, 0.36898285185297086, 0.4129119873435071, 0.4638594214616586, 0.46725010781808496, 0.46690996979058885, 0.4741259643232888, 0.05109360266553509, 0.22808045602050409, 0.1618371880455659, 0.6427710880732127, 0.2140561081079525, 0.3569798323836172, 0.19463962941094992, 0.588958662954659, 0.392297595524986, 0.23469934780362078, 0.5090223367237333, 0.49375359102970295, 0.45921676047271753, 0.4912227357863548, 0.6223010367231827, 0.4071701295219855, 0.49025094996196106, 0.43403966667839944, 0.44084286640198067, 0.4879148293626455, 0.5406247914699491, 0.1262365637619336, 0.5035618849696492, 0.4506918266754104, 0.4669862471992585, 0.5156694252627367, 0.43468092896148314, 0.13251063239780292, 9.999999999998899e-05, 0.07216715019305242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1572454673632172, 0.5536641208159068, 9.999999999998899e-05, 0.47097515624945685, 0.15250200147650061, 0.19494340774423458, 0.5482827857437242, 0.537266038903467, 0.14470330505601525, 0.5352601080339708, 0.5929141393945017, 0.5609334792264562, 0.31841993834169147, 0.1066538483677999, 0.11567311152909465, 0.1594208591302868, 0.07701837953715529, 0.4908875159716032, 0.08079936764199214, 0.49786098104327037, 0.07088172370932821, 0.09727534646266922, 0.3897887204413353, 0.04334080744348778, 0.33364949742508265, 0.3374231597325794, 0.36525508220919434, 0.3187121697105678, 0.33521090152735955, 0.3357633683476038, 0.08484922218172308, 0.4777894523208275, 0.537554519190644, 0.5183399190513078, 0.4779376703625374, 0.48430837086658374, 0.5296373332847594, 0.48834318222506623, 0.5604742460208723, 0.49105129633147737, 0.07400476424993452, 0.09180184578420636, 0.15606071575541447, 0.09698501554673145, 0.09710606031036895, 0.12185148550620428, 0.13631575603374713, 0.11149220757079636, 0.10386453984601263, 0.19908683322348575, 0.22206188075323752, 0.254288267567953, 0.15946348529336463, 0.23479860999585, 0.43562124172812233, 0.26788530028828494, 0.2131556391990459, 0.19935487015832387, 0.38773475969139726, 0.3974838103135475, 0.36996021927083367, 0.3914794459302754, 0.4196465056297046, 0.3707949891718244, 0.279031265076915, 0.3875434772360413, 0.4326763988395049, 0.2819409712257528, 0.4589847227342202, 0.37010858940094016, 0.28667648736338425, 0.3214297721361097, 0.275902738809475, 0.20680791720222746, 0.28208953919848934, 0.3507683299410529, 0.20660797441763656, 0.21871545313584506, 0.21821219894616084, 0.26415688852065233, 0.23233995254442763, 0.20829808735900124, 0.22582464405763736, 0.23162561476298904, 0.2039319866907796, 0.22158636359600892, 0.22271099043735376, 0.19850779687077535, 0.5924694154789769, 0.19790943847714282, 0.2085493822593698, 0.20966030132223068, 0.223455609636388, 0.20588556097275978, 0.18900394777544793, 0.18884961658718125, 0.15387815525761273, 0.7840982423377777, 0.20023599930723468, 0.20111785269540905, 0.10001775859843653, 0.1697299110391688, 0.21084878682752806, 0.08289819971774393, 0.15764557018495762, 0.11139465141709193, 0.8047190365429463, 0.16950501476975055, 0.678434763768715, 0.21089470765548113, 0.8786611812787002, 0.7128831556200379, 0.19797447697080273, 0.19639605817122907, 0.1959072870250279, 0.22416013535886503, 0.17824179173060262, 0.21044195478867522, 0.1962722999350005, 0.19316735803078822, 0.19025641280152672, 0.08603675066184535, 0.10478528410875698, 0.08023470721837134, 0.1097513156226192, 0.0786574708073795, 0.08437777667885804, 0.0976032939187984, 0.10747331204993937, 0.09020294698164966]}, "mutation_prompt": null}
{"id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 57, "fitness": 0.35516254451157314, "feedback": "The algorithm AdaptiveMultiStrategyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "c4f2be65-0ef6-40a5-a366-1257cfe529b2", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "d5af5a73-a626-4cc7-85f2-5e0d94cb3713", "solution": "import numpy as np\n\nclass EnhancedMemoryDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size for more diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Enhanced cognitive parameter\n        self.c2 = 2.0  # Enhanced social parameter\n        self.w = 0.5  # Reduced inertia weight for quicker convergence\n        self.F = 0.5  # Modified DE Mutation factor for better exploration\n        self.CR = 0.6  # Modified DE Crossover probability\n        self.memory = []  # Memory to store historical bests\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE and PSO parameters dynamically based on function evaluations\n        self.w = 0.9 - evaluations / self.budget * 0.4\n        self.F = 0.4 + evaluations / self.budget * 0.1\n        self.CR = 0.7 - evaluations / self.budget * 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                    self.memory.append(global_best_position)\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.w) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                memory_influence = np.mean(self.memory, axis=0) if self.memory else np.zeros(self.dim)\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]) + 0.1 * r3 * (memory_influence - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n                    self.memory.append(global_best_position)\n\n        return global_best_position, global_best_score", "name": "EnhancedMemoryDEPSO", "description": "Enhance global search capabilities by integrating dynamic memory-based guidance with adaptive parameter tuning in a DE-PSO hybrid.", "configspace": "", "generation": 58, "fitness": 0.21364097195336312, "feedback": "The algorithm EnhancedMemoryDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.35264445260490784, 0.3699234145833499, 0.3529287486457259, 0.3578593880646457, 0.3802009604411707, 0.3667945014265891, 0.35240142970111044, 0.3586796248216203, 0.3766038358713556, 0.2417358432590181, 0.1866392245659768, 0.20890171201994345, 0.21723782819841875, 0.2074637543112643, 0.23772633740969984, 0.22347046891153155, 0.24103336253857188, 0.23136854819541774, 0.13855102413788667, 0.11670739634466587, 0.11724216469899074, 0.12748573662072704, 0.10940957485801572, 0.11297062849675732, 0.10874016164348466, 0.17793764121041544, 0.1368882664192399, 0.10428356341771283, 0.15830854318722398, 0.10532656410256003, 0.09471349953433617, 0.10144293502223412, 0.11203973408125933, 0.09895611786773373, 0.09970100444726926, 0.12472811753729762, 0.9809465480279344, 0.9951148815393634, 0.9951539531050163, 0.9725249893354346, 0.9890290037939211, 0.9794633761353658, 0.985432992710434, 0.9889755396380218, 0.9825491065515426, 0.24684522231061834, 0.2005233779029978, 0.19533132767557493, 0.23907300569357326, 0.19309747661422483, 0.19973999551189792, 0.19670230123885035, 0.20541728328855335, 0.22743902131429228, 0.3008746023807861, 0.32048255776774304, 0.2850448474198348, 0.3106169419483522, 0.24381682540133054, 0.25038260439700766, 0.2881210429152756, 0.23750970194268362, 0.4459473072685688, 0.18361949461809823, 0.1693015439910891, 0.1422379368882143, 0.21326339120445947, 0.15266706837584731, 0.19145050212923054, 0.17475964361196417, 0.1755485648823658, 0.17616456333297736, 0.17791841694496946, 0.14315297544713523, 0.12453203559415271, 0.15922127070305125, 0.17282150083479442, 0.1746012898705609, 0.1663613610284006, 0.12688278928061025, 0.1244409715132393, 0.03672778583615344, 0.04561116677268928, 0.023467520976008016, 0.0395460781271777, 0.011999000755043787, 0.008666298544413475, 0.06257796629673207, 0.031684860978284046, 0.05870809735169624, 0.14154781180386466, 0.15185379388422449, 0.13388308445476882, 0.14183065748419232, 0.08090243862940827, 0.1116624896993772, 0.19792721059391793, 0.17809742716957355, 0.11867885857499971, 0.04032075979196925, 0.004441923079109622, 0.020534772218066433, 0.03978563118457912, 0.006422244629829543, 0.01876255480568434, 0.03167547216857458, 0.0016329681734711388, 0.027168995293071374, 0.09253490369039141, 0.11835621198257684, 0.10974691013434534, 0.08322951516823818, 0.10335817225044575, 0.12710391700297097, 0.1097459149402461, 0.11579396362600636, 0.12816970504816527, 0.33861633864432494, 0.32944570354385305, 0.3282818175222314, 0.3213204124864324, 0.3286112185392144, 0.3169938021224391, 0.33441302481766766, 0.3351615958750451, 0.3895734036303905, 0.08195972453779798, 0.08790467262102197, 0.09419124743969787, 0.09518354243553462, 0.08190746381907865, 0.08994673066906833, 0.08225758282303564, 0.11478141510666062, 0.08825117937990967, 0.14229001869860836, 0.12703007763852603, 0.1752905624929002, 0.12420057434155407, 0.14831210541001005, 0.12161102313303129, 0.15432078345936084, 0.15814423728502602, 0.13869270248290355, 0.26964547948979967, 0.2553940112644918, 0.25083691897371363, 0.24377840396544548, 0.2617369341332897, 0.2526954377848242, 0.25666659346769893, 0.26607349178967066, 0.25285638483202755, 0.19357795338640393, 0.22266744990249632, 0.2072142230129912, 0.21812717856063124, 0.2002181137145771, 0.20218722774558018, 0.20863748687613948, 0.2319542745479506, 0.22447696643965542, 0.18849879024591076, 0.19442823291914324, 0.17042075230504927, 0.2395907169751963, 0.18626619494774743, 0.18937754265286288, 0.22515716929550367, 0.19466647059693154, 0.20290875356408, 0.18206215102763446, 0.1768980742164964, 0.17848424790583772, 0.19477060788771683, 0.18320208472085842, 0.19094064407971845, 0.2064231840092301, 0.2186945789727862, 0.17719123517471758, 0.5043539695721524, 0.15150284472297137, 0.15335166109869092, 0.47121552761555363, 0.1944904350754949, 0.19729233990298278, 0.1414546023262876, 0.17051471097787962, 0.20300422466671808, 0.4626136406266157, 0.20439996242148895, 0.4762220743743515, 0.2024232994490307, 0.16692065506748788, 0.14990215183184286, 0.10512910579825674, 0.1050293293231116, 0.3499537245874266, 0.17211365851655624, 0.17829678343403121, 0.18357302240646978, 0.2160984514577462, 0.19439861218295862, 0.1698539895704937, 0.17965622149683458, 0.18237595635330817, 0.1725796767593234, 0.07602931681752667, 0.06579269523063724, 0.07077687635544738, 0.07133396690408134, 0.07298238004328561, 0.07720568453828613, 0.07753890254215479, 0.07937486775801716, 0.08097135138204781]}, "mutation_prompt": null}
{"id": "f9be8064-2de9-4c53-b978-8343ef7940c5", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "907d01c2-62f1-4cdc-b81a-3c9e121591f0", "solution": "import numpy as np\n\nclass HybridLevyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.4  # Fine-tuned cognitive parameter\n        self.c2 = 1.6  # Fine-tuned social parameter\n        self.w = 0.5  # Adjusted inertia weight\n        self.F = 0.8\n        self.CR = 0.9  # Increased DE Crossover probability\n        self.levy_scale = 0.5  # Scale for Lévy flight\n        self.alpha = 0.95  # Adjusted cooling rate\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (sigma := (np.random.normal(0, 1) ** -1) ** 0.5)\n        v = np.random.normal(0, 1, size)\n        step = u / (abs(v) ** 1.5)\n        return step * self.levy_scale\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j] + self.levy_flight(1)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridLevyDEPSO", "description": "Hybridize adaptive differential evolution and particle swarm optimization with Lévy flight for improved exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "172b9410-ac7a-4d4c-ae6d-f9b02127c42a", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "04b2aa3c-9bb4-4611-8f98-c52b18a88490", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "60cd6191-a824-4446-87fd-6ffb40c48c90", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "50a3b060-a327-455b-b4dd-8394a645dca9", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "351716b1-d872-41db-9e90-1d9191779cf1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Adjusted cognitive parameter for better exploration\n        self.c2 = 1.3  # Adjusted social parameter for improved convergence\n        self.w_max = 0.9  # Dynamic inertia weight range start\n        self.w_min = 0.4  # Dynamic inertia weight range end\n        self.F = 0.8\n        self.CR = 0.7\n        self.T_min = 1e-3\n        self.alpha = 0.95  # Faster cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.5 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.5 - evaluations / self.budget) * np.random.rand()\n        self.w = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget))\n\n    def stochastic_local_search(self, candidate, score, func):\n        # Introduce small perturbations for local search\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_candidate = np.clip(candidate + perturbation, self.bounds[0], self.bounds[1])\n        new_score = func(new_candidate)\n        return (new_candidate, new_score) if new_score < score else (candidate, score)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Apply stochastic local search\n                population[i], personal_best_scores[i] = self.stochastic_local_search(population[i], personal_best_scores[i], func)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], self.bounds[0], self.bounds[1])\n\n                trial_score = func(population[i])\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = population[i]\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveMultiStrategyDEPSO", "description": "Enhance AdaptiveMultiStrategyDEPSO by integrating stochastic local search with adaptive learning rates for improved exploration and convergence in black box optimization.", "configspace": "", "generation": 65, "fitness": 0.1828414399294152, "feedback": "The algorithm EnhancedAdaptiveMultiStrategyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.37409289105141674, 0.3485983504678989, 0.3448461072030369, 0.3844428909747025, 0.41575647108084635, 0.39029268055950705, 0.35576816087387564, 0.3429195845691122, 0.33279276269296587, 0.010282345330357545, 0.04310262027028888, 0.013656582343002821, 9.999999999998899e-05, 0.019387833255991027, 0.04343817349317136, 0.008659426048258867, 0.03314877891883372, 9.999999999998899e-05, 0.06384923455687863, 0.08430919428022532, 0.0973459092096236, 0.1083136659495636, 0.07484823905759708, 0.09287124037348626, 0.09657833309375707, 0.07301519913364174, 0.07771660675247183, 0.06754122311397681, 0.060889901769218935, 0.09932169873658714, 0.07710646523680464, 0.07767140066552092, 0.08505717162940185, 0.07146479601608757, 0.0805271937913059, 0.09039805766033682, 0.951318980038881, 0.9631156628794606, 0.9834824806821509, 0.9251941577854871, 0.9654055299277162, 0.9620963079194811, 0.9840789568563623, 0.9735197995466437, 0.9736753735806145, 0.1949005882850645, 0.20126142723535034, 0.15931359150027402, 0.16318552549180398, 0.16994072813651695, 0.22214018016138903, 0.16514289335355448, 0.20849451040970646, 0.13335410624088107, 0.18008249410104926, 0.30570044997624624, 0.1664158237821881, 0.21452764632621724, 0.20147909037720813, 0.18882172333467007, 0.18676328705206302, 0.31064457046303817, 0.2687867823841458, 0.06841298380079786, 0.11354379167391271, 0.12258313027949663, 0.07835156006004385, 0.10473868812722065, 0.10380542853544594, 0.10040046354298315, 0.09958211615475576, 0.10653465615260216, 0.11542286730987161, 0.0852250461558488, 0.10927451636357854, 0.06416834078993283, 0.12496955993439385, 0.0800207955397475, 0.07476447741362646, 0.058183572845801224, 0.10284698848631857, 9.999999999998899e-05, 9.999999999998899e-05, 0.00207415285291479, 0.024636362779985377, 0.00010655782449231488, 0.0001555997202905557, 0.003969158536493156, 9.999999999998899e-05, 0.03882250214455307, 0.04691944676482185, 0.028595929408055, 0.07822409459497304, 0.06444246330400749, 0.0061295178905854675, 0.0174660863054924, 0.09967777232190655, 0.0929074346141604, 0.06490645828886277, 0.012218734565470402, 0.007687020641600206, 0.0075178431697980885, 0.0006505814114258213, 0.013214285059519937, 0.03513760575425806, 9.999999999998899e-05, 0.0009379316178809161, 0.008450197185395858, 0.10800641678799605, 0.07710117616068235, 0.07348910997417968, 0.034187433412597446, 0.05247939865480589, 0.06143952504707961, 0.08053614803865894, 0.0620273007254416, 0.05813781009611907, 0.3367658868670984, 0.32442148079794797, 0.3854058562981518, 0.3556528414169601, 0.36213556617863485, 0.35110201996834434, 0.3636465808516718, 0.34516292326668796, 0.3270515954088463, 0.06521224975454931, 0.07833648855611208, 0.10139717381653024, 0.0824889521873674, 0.07411052017459918, 0.08679115398599224, 0.08397976308103139, 0.07312903907294144, 0.08658398061664285, 0.16472593072195574, 0.16678850441339232, 0.15852457971070666, 0.19930226867578626, 0.2054551084107442, 0.14978980168701783, 0.15697780023837826, 0.11804975244496896, 0.17418758125108436, 0.21725182560719192, 0.2160295797296996, 0.24718509477840367, 0.24765814167167644, 0.18845589065483193, 0.2518268601434984, 0.22999593691134568, 0.28194199309407453, 0.22227179308364164, 0.1665335196850588, 0.1381274552659677, 0.19296985906532105, 0.18990313464831643, 0.1508481076002094, 0.16809225657244098, 0.18510832345273143, 0.2113276759166458, 0.15442409273605917, 0.19681286300050005, 0.1910204776318033, 0.1692252100035736, 0.17162032436516017, 0.17947893964659656, 0.21106614209122831, 0.1839815821205082, 0.16747935263726343, 0.18409567102185598, 0.18737118921794893, 0.17606117167453972, 0.1683140824385173, 0.17625983668867706, 0.17542949049083223, 0.1703769862981055, 0.17520025973572406, 0.17496732190055952, 0.18153761104954336, 0.45848654393638355, 0.18055599782658172, 0.15030820513276466, 0.3526410818522878, 0.1875774036285499, 0.5085856663397537, 0.12282596841700266, 0.16716770191295494, 0.46547745420099795, 0.4312259871692382, 0.41245265169998313, 0.24747896751862175, 0.18658369710837752, 0.16469863362660342, 0.17930606404547456, 0.2023181914940284, 0.1748510089988855, 0.13804439554057735, 0.1668274954184179, 0.16564036810861094, 0.1768007789706979, 0.17899278681074593, 0.189186076271063, 0.19696158795712015, 0.18261525250451005, 0.17529224396995813, 0.17047034087566937, 0.08188775989303299, 0.06852361992915534, 0.07466697353596685, 0.07349421202370832, 0.06300252974601095, 0.06919093212456262, 0.06306931385469039, 0.07552066666135904, 0.07506211635634374]}, "mutation_prompt": null}
{"id": "ce7edefa-39da-4e29-9995-b04afbf8bc48", "solution": "import numpy as np\n\nclass QuantumLevyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Cognitive parameter\n        self.c2 = 2.0  # Social parameter\n        self.w = 0.7  # Inertia weight\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # DE Crossover probability\n\n    def levy_flight(self, L):\n        sigma = (np.gamma(1 + L) * np.sin(np.pi * L / 2) / (np.gamma((1 + L) / 2) * L * 2**((L - 1) / 2)))**(1 / L)\n        u = np.random.randn() * sigma\n        v = np.random.randn()\n        step = u / abs(v)**(1 / L)\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                quantum_step = self.levy_flight(1.5) * (population[i] - global_best_position)\n                trial = population[i] + velocities[i] + quantum_step\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "QuantumLevyDEPSO", "description": "Enhance convergence by introducing a hybrid Quantum-inspired DE with PSO elements and Levy Flight for improved exploration-exploitation balance.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "e6af296c-bca4-4d74-a2f6-5c3122815acf", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "93ee420d-6760-4855-a2b3-c80623205f1c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Increased cognitive parameter for more local search\n        self.c2 = 2.0  # Increased social parameter for better global search\n        self.w = 0.5  # Modulated inertia weight for dynamic adjustment\n        self.F = 0.8\n        self.CR = 0.7\n        self.T = 1.0\n        self.alpha = 0.95  # Adjusted cooling rate for smoother transitions\n\n    def orthogonal_design(self, population):\n        # Apply orthogonal design to enhance diversity and exploration\n        orthogonal_population = np.zeros_like(population)\n        base = np.mean(population, axis=0)\n        for i in range(self.pop_size):\n            perturbation = np.random.normal(0, 0.1, self.dim) * (population[i] - base)\n            orthogonal_population[i] = population[i] + perturbation\n        return np.clip(orthogonal_population, self.bounds[0], self.bounds[1])\n\n    def dynamic_learning_rates(self, evaluations):\n        # Adaptively adjust learning rates\n        self.w = 0.9 - 0.7 * (evaluations / self.budget)\n        self.F = 0.5 + 0.4 * (1 - evaluations / self.budget)\n        self.CR = 0.4 + 0.3 * (evaluations / self.budget)\n        self.T = max(0.1, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_learning_rates(evaluations)\n            population = self.orthogonal_design(population)\n            \n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveDEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and orthogonal design for efficient exploration and exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.23719425253864743, "feedback": "The algorithm EnhancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.6346201705832424, 0.6422492950710156, 0.6600766594904453, 0.6353680337418341, 0.6242753035594693, 0.6373746698971363, 0.630947785580825, 0.6688703672996297, 0.6134430202333983, 0.4104006931394105, 0.430915930199983, 0.40317774493849323, 0.4121807537271609, 0.4239825038690058, 0.4246059052188118, 0.4428821561024142, 0.4067393151758003, 0.4104853100747088, 0.09391163757065346, 0.10131851706314898, 0.11410917236228901, 0.10393195753250761, 0.09414186299987393, 0.11019318092057728, 0.11802956288035771, 0.1034595855471584, 0.10503110577342434, 0.09220688540751942, 0.08944801263503122, 0.08510177559821663, 0.10249967888483447, 0.10075880698901307, 0.08013951783535178, 0.08368638363239866, 0.09322658725533017, 0.0855968435504263, 0.9942419008193968, 0.9933697717443966, 0.992818947475316, 0.9532357785124506, 0.9862171626964022, 0.9922989847669655, 0.9935682785856227, 0.9809681973938094, 0.9853416377558266, 0.1940959815818828, 0.23114083150183062, 0.2466226925883459, 0.24737501067196077, 0.2885086098561592, 0.24027392623287647, 0.24655776492250092, 0.20592514465458212, 0.24984931112005992, 0.27231293152260927, 0.3811853739935084, 0.3708459657028643, 0.4045356370594031, 0.4323426846066766, 0.23205693594502963, 0.5071319702265162, 0.32491633386453256, 0.26239298524460763, 0.12280180449263989, 0.16221332430765945, 0.17176847309962684, 0.1093811463559734, 0.17394500122285084, 0.1337314170854037, 0.17596081171055544, 0.11482639086767121, 0.15777561001803697, 0.16641771480691858, 0.1791384802259245, 0.18133705422452473, 0.13886781630137524, 0.1737067333808714, 0.15529595912412864, 0.0775602631183836, 0.10592009365478972, 0.1311032429988218, 9.999999999998899e-05, 9.999999999998899e-05, 0.013138637960572686, 0.020661001925829314, 0.004883321283718711, 9.999999999998899e-05, 0.00010234730754887789, 0.0019051146228717952, 9.999999999998899e-05, 0.1258158593562957, 0.043034496469261274, 0.08915981800405715, 0.05932588286411178, 0.048051030192928, 0.05097621727939694, 0.09990858017575588, 0.07520336192080379, 0.13834420320317908, 0.046466522758064066, 0.0394678693779984, 0.06617887285602209, 0.01346127643568884, 0.00019365739817656102, 0.038856744234131324, 0.08976361469694183, 0.02688886248030431, 0.04369303695061122, 0.11573375709495759, 0.10086468485711864, 0.15447860344806563, 0.06656245529928018, 0.06477879340787984, 0.1638902236347367, 0.09892051303836125, 0.12122337690893015, 0.09575679005374205, 0.4360347051665183, 0.47273696003565124, 0.4374987259906479, 0.4348962880995366, 0.4519820007536539, 0.45345210043128503, 0.44439927009647273, 0.44656209782644496, 0.4694037587099622, 0.09897453140058476, 0.09793726900814836, 0.10203414800161315, 0.0838387765628762, 0.08793097666850813, 0.092052034997679, 0.09572084024280703, 0.08662398169296825, 0.09539704628773071, 0.14721745886255144, 0.13345663938852126, 0.14393068114013763, 0.13562848189773957, 0.19285368399877456, 0.15792780132508177, 0.15584707790759145, 0.15801122673380708, 0.15175641250792438, 0.2802141028846896, 0.2146739808409267, 0.25881883551600837, 0.29485508636615954, 0.26106052055350126, 0.2945162909561575, 0.350308384394338, 0.336219187317396, 0.33491680370516685, 0.1927677477300047, 0.16269013094783857, 0.17540067528500936, 0.21723544962476704, 0.17147582283684315, 0.20109858906551792, 0.2076635440682748, 0.2418033576857309, 0.17788214549105286, 0.1897825918556929, 0.18651538669197398, 0.18245960854393384, 0.1937825171934655, 0.18655701430986593, 0.19290454405544621, 0.2015266529902654, 0.17696825900462987, 0.20110680668969483, 0.17677519751946325, 0.18425450579972558, 0.17605658789294, 0.1715375349631466, 0.18400083445237791, 0.17632408717564685, 0.17934485902184494, 0.18665659820683245, 0.17639238867848528, 0.17841560366199372, 0.20410193044136982, 0.16434984634763972, 0.40349949776438165, 0.19442099948142733, 0.16250148081199445, 0.3980507908621662, 0.16902137425455876, 0.6060653834165408, 0.39495802912882105, 0.2831383094613945, 0.12683878056127829, 0.20250450184839108, 0.24673390168732412, 0.19656278106889802, 0.19929344336098997, 0.2064429507703236, 0.2987079379829546, 0.18103766401777144, 0.20567403469635692, 0.19500099005789862, 0.1781383599759676, 0.1819875079474791, 0.18452941906221454, 0.18135716578917405, 0.18345036018649852, 0.19349903840870752, 0.07468376998961934, 0.08002435429197396, 0.07727419628349308, 0.07714524044285442, 0.08148666022871276, 0.09074133685352048, 0.09396806996207707, 0.07869394187657908, 0.06964898143393039]}, "mutation_prompt": null}
{"id": "141f97eb-baeb-4ee0-8c8b-9a9d2273aaf5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveLevyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Modified cognitive parameter\n        self.c2 = 2.0  # Modified social parameter\n        self.w_max = 0.9  # Inertia weight max\n        self.w_min = 0.4  # Inertia weight min\n        self.F = 0.5  # DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.95  # Cooling rate\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, len(L))\n        v = np.random.normal(0, 1, len(L))\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.1 * step * (L - np.mean(L))\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + 0.3 * np.random.rand()\n        self.CR = 0.7 + 0.2 * np.random.rand()\n        self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Perform Lévy flight-based exploration\n            levy_steps = self.levy_flight(global_best_position)\n            for i in range(self.pop_size):\n                new_position = personal_best_positions[i] + levy_steps\n                new_position = np.clip(new_position, self.bounds[0], self.bounds[1])\n                new_score = func(new_position)\n                evaluations += 1\n                if new_score < personal_best_scores[i]:\n                    personal_best_scores[i] = new_score\n                    personal_best_positions[i] = new_position\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveLevyDEPSO", "description": "Hybridize adaptive multi-strategy differential evolution with enhanced dynamic learning and Lévy flight-based exploration for superior convergence in diverse landscapes.", "configspace": "", "generation": 69, "fitness": 0.2203821323288056, "feedback": "The algorithm EnhancedAdaptiveLevyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.3825713025831554, 0.4006104383138226, 0.3945287276427317, 0.382139518103469, 0.39378251311968915, 0.40779128396605624, 0.41503859688644107, 0.40134612080356447, 0.40758517189274346, 0.205648785083263, 0.20776650388267004, 0.1953962902532843, 0.07772148772567977, 0.20710102481031145, 0.19008865323472723, 0.20975450637500725, 0.17247020413921832, 0.24069578136363246, 0.09943583011619483, 0.1128255589867333, 0.11027195464819783, 0.09208700413622972, 0.10647681964894551, 0.11126303135537274, 0.0744391168488181, 0.11856593526145642, 0.09930241706022147, 0.09911839072155271, 0.09426609705215383, 0.09985180756609568, 0.0906246442857973, 0.09391915345073598, 0.09102603495847084, 0.08346184539894164, 0.08813832001731314, 0.07325413550454873, 0.9917636650135137, 0.9946924628196276, 0.9963098115408101, 0.9765623564793109, 0.9399888840694846, 0.9609245818942147, 0.9845996692667321, 0.9843235745069531, 0.9741746320553061, 0.22973172108025608, 0.16516741234516796, 0.25133387402457086, 0.1817966112611773, 0.2161941498035237, 0.1930202354985885, 0.1959129418216734, 0.21148508764661345, 0.22345929144379628, 0.3921117845633073, 0.29595420318735566, 0.2512730749775397, 0.4416434068445839, 0.459120724462997, 0.31563180787286016, 0.3962531463808112, 0.4743778780754012, 0.33347865492470774, 0.13576876834882134, 0.10694983878512232, 0.12260603264630676, 0.11583677870157738, 0.16023824578055923, 0.09902036018561522, 0.1379337128981879, 0.11698055485360515, 0.14586066651556762, 0.15421498348448803, 0.08591292349218238, 0.13735121498208414, 0.160280524458851, 0.1370009958138919, 0.13613776800378452, 0.1345207178886041, 0.11026209468755077, 0.14712771263903013, 0.057679705978046836, 0.03983383681548125, 0.128335373593083, 0.01664381391459624, 0.061047017419806116, 0.06041844973510635, 0.055102940219891705, 0.01842082721477767, 0.08089941687536306, 0.1521780352366091, 0.08154773351875555, 0.16406662431348418, 0.09363843260130778, 0.22926145839356482, 0.09445217171771203, 0.2632169141694609, 0.09120679008914179, 0.2015554905274186, 0.06838562670600312, 0.017485097120186976, 0.018895678942389305, 0.006341069074434436, 0.006665234943095455, 0.02402201136332771, 0.03879320569535827, 0.01128235356157714, 9.999999999998899e-05, 0.1496228917122122, 0.11687593080485237, 0.11434802110158238, 0.14916250755790128, 0.11068510090658878, 0.10423209392162758, 0.1054455942023158, 0.11186398085769922, 0.1305660088562023, 0.3634045304089123, 0.3947235746405524, 0.38599495022768804, 0.3702877322653997, 0.3695863958922083, 0.34335783602843006, 0.38409428784828625, 0.3879840021448504, 0.3827278516317658, 0.08536644451599018, 0.09879955046460343, 0.11269285898892356, 0.09246000560130174, 0.10109653257302853, 0.11090860420574666, 0.08316389975644711, 0.11040180179662362, 0.09733492871732974, 0.1553837692653144, 0.16905072220234618, 0.15123722457081334, 0.18161429822984843, 0.15903876202791056, 0.16298461318402935, 0.17433423247707902, 0.14813724481312074, 0.19249798604734836, 0.26819139900841105, 0.2695316740509115, 0.30684810152797826, 0.27548936312438677, 0.24990393933407584, 0.24422919878404614, 0.2818660646740879, 0.28774578144928054, 0.30017733543872704, 0.17791123332966818, 0.17848981587661417, 0.17124818825756516, 0.19823665199543805, 0.19636916514057934, 0.228893659783315, 0.19041897279000475, 0.23157393422702566, 0.2116422539470375, 0.19770848298665367, 0.1858796740921108, 0.1830288180207016, 0.19149773497793177, 0.17781453419192128, 0.1839981913092742, 0.18908655386152462, 0.20406839085242567, 0.1969087170093955, 0.18003888090036002, 0.19444581619950607, 0.191945528640451, 0.2037745763930049, 0.19788084889288404, 0.18601089446280605, 0.20198413075857902, 0.19334094317872563, 0.1901558630307455, 0.16536825929810406, 0.17469641789494295, 0.15386420229510533, 0.5438207745168099, 0.19432438862721169, 0.31710560939540255, 0.24585340792910249, 0.16879016755084197, 0.5038865972104534, 0.5328335415645358, 0.4320716918774776, 0.20466147861051365, 0.2661814596808406, 0.16725180865723377, 0.2818105233697171, 0.20944504568919253, 0.10382404979589321, 0.5013022550702477, 0.17892602696997983, 0.20819244721414198, 0.18020231316457724, 0.1993688332209147, 0.1704596603518317, 0.17481094080346915, 0.18034324444131922, 0.18978415253598957, 0.20403650198614232, 0.07779450573179458, 0.07307049130302057, 0.07542867340764392, 0.07682181749855121, 0.07137115229047397, 0.08390977582482506, 0.06677114035284848, 0.06833609109435712, 0.08888919788753502]}, "mutation_prompt": null}
{"id": "32446859-ea02-4a0e-bed1-d177ff91e1e2", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "c7c0fbb8-2bc5-4a58-9dcd-d916655371d5", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "523d1a8d-df14-427a-a966-613b5f1993e2", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "2f316ad9-a5b4-45b3-a722-96252ebbbce8", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "1b69fe33-1810-40cc-95b0-fe8634eba4f0", "solution": "import numpy as np\n\nclass ImprovedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.4  # Adjusted cognitive parameter\n        self.c2 = 1.6  # Adjusted social parameter\n        self.w = 0.7  # Modified inertia weight for improved exploration\n        self.F = 0.9  # Enhanced DE Mutation factor\n        self.CR = 0.6  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-4\n        self.alpha = 0.95  # Cooling rate\n        self.diversity_threshold = 0.1  # Diversity threshold for local search\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations and diversity\n        self.F = 0.6 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.6 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def diversity_measure(self, population):\n        return np.mean(np.std(population, axis=0))\n\n    def local_search(self, position, func):\n        perturbation = np.random.uniform(-0.1, 0.1, position.shape)\n        candidate = np.clip(position + perturbation, self.bounds[0], self.bounds[1])\n        return candidate if func(candidate) < func(position) else position\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                if self.diversity_measure(population) < self.diversity_threshold:\n                    population[i] = self.local_search(population[i], func)\n\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedDEPSO", "description": "Enhance convergence by integrating adaptive local search strategies with a focus on diversity preservation and temperature-based stochastic acceptance.", "configspace": "", "generation": 74, "fitness": 0.2630228863220292, "feedback": "The algorithm ImprovedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.4300412696305378, 0.4249247665045356, 0.4435457321200982, 0.4462926777611568, 0.47883307740072345, 0.44643643786196086, 0.44974244321281254, 0.42944489574371314, 0.44951924801690957, 0.31747837360297204, 0.32404116482942646, 0.30125326275906694, 0.32321354041580097, 0.3077398522533543, 0.33228617765054, 0.3301106896835747, 0.32397921775084504, 0.3245571550749371, 0.12425146069687343, 0.13874660388590365, 0.1268139130625917, 0.15645786491867442, 0.16457110826654497, 0.15378790353467942, 0.14555084767222748, 0.1598317229288274, 0.1252442795584371, 0.11882826775819577, 0.10623157456031129, 0.10945539363479273, 0.12109902870605149, 0.11091711603454246, 0.14248912034470562, 0.0954952477554436, 0.10457111677392661, 0.11252010873587237, 0.9813729602337187, 0.9941679379592679, 0.9945344639113848, 0.9706602920175564, 0.9807473294322011, 0.962851548980665, 0.9878447739419655, 0.9854601076441968, 0.9771456755898897, 0.26151174221632023, 0.25767321645036423, 0.2760991566867754, 0.28141805067315373, 0.2680675696779117, 0.25615232824219536, 0.28508514980893673, 0.259551952284073, 0.2446514293401727, 0.22797998620623872, 0.4348833741802576, 0.5600778050622435, 0.596667678078045, 0.7376281215733889, 0.5449413684212965, 0.6937245836844175, 0.5366188092725906, 0.3954149689520604, 0.20660118334047606, 0.20974712932580875, 0.18732112450959426, 0.19082233621407318, 0.222832139175982, 0.15995244032737266, 0.30345758811474655, 0.22974057378934132, 0.1702730820355779, 0.19197613390606316, 0.1761816569020619, 0.1877053856055626, 0.1508666972166307, 0.1956114448042905, 0.18559562827883702, 0.18749924366767812, 0.11513247266450743, 0.167574330143616, 0.02533379447209083, 0.2879817992322615, 0.07279204876815837, 0.04431168000610508, 0.07816397218782678, 0.010422042984253643, 0.17941034052851845, 0.04709922681245249, 0.052042146648653254, 0.31626437589397616, 0.36095388510159865, 0.2695200242334216, 0.20176255569892398, 0.12030943493915602, 0.21630352484949789, 0.3855834113093408, 0.37879467765009844, 0.3967087575083379, 0.03714642155960157, 0.05485772035471215, 0.0471131110122226, 0.046767235871871704, 0.04921274175709056, 0.13971539151000156, 0.10043721183816834, 0.049848981269402626, 0.09613199323096522, 0.21188797948652205, 0.19097977386281872, 0.1986219046280897, 0.1952858618299419, 0.17970207609934696, 0.1721391532375237, 0.20591086467637998, 0.17367116662525317, 0.19719283729510062, 0.4265817886210488, 0.4208249037756707, 0.39915795039881596, 0.40287662741664776, 0.39470209129558587, 0.387604140708633, 0.40123898686146175, 0.4217336385514624, 0.3993264796062187, 0.08726333527821628, 0.12743510310849449, 0.09432761933004352, 0.08617568129840947, 0.08689316235491606, 0.08175643406333277, 0.07940427798122196, 0.09131230023612402, 0.10564496220767272, 0.17830762664909894, 0.1920036538642721, 0.12955555167076016, 0.26783837984581726, 0.17459911171542442, 0.13820533043732908, 0.2940184792746051, 0.13126826088187704, 0.19004565273416751, 0.29721688035198746, 0.31340129034574227, 0.3052573497449921, 0.29858970639236215, 0.28553478694218926, 0.281899836388413, 0.2635995286391667, 0.29815643317701224, 0.3080550732672256, 0.23105551422489545, 0.2413161792453964, 0.22614714812143033, 0.27006972367164206, 0.17411420505239872, 0.2504964602583002, 0.23994307947066718, 0.2600653400386391, 0.2565005837397857, 0.19135568474089804, 0.17648798190750692, 0.18285643766579807, 0.20898114340027263, 0.19371151646030993, 0.213483921525495, 0.1917635064730907, 0.1846207298299588, 0.20329455093767645, 0.22800856832413252, 0.23112956045901456, 0.2693204747606448, 0.20116035906341068, 0.19232507822710387, 0.18382196219547264, 0.22488252107746753, 0.22031227690757083, 0.22526253594619883, 0.5121734089629797, 0.15887802926197014, 0.18203668147297614, 0.647154136128905, 0.19933817662016673, 0.1962821523955297, 0.15375503391265444, 0.1700907741434583, 0.6414486201153662, 0.6580612608347498, 0.15608363534728653, 0.11069037234004431, 0.2011267180558438, 0.16705207867119187, 0.20962020506346202, 0.20493326378138754, 0.2700403050712338, 0.5623619561625144, 0.1800867705055873, 0.18844859391214064, 0.19296173117617732, 0.18130445452001875, 0.17165270639983732, 0.1825590022471807, 0.1866954661178003, 0.18071412032157108, 0.17460953243910515, 0.07662438929850757, 0.0774760749514617, 0.06497400413086107, 0.08160865559233121, 0.07350435545352718, 0.08002427823470282, 0.07586631100604468, 0.07088168691908336, 0.07501928823428894]}, "mutation_prompt": null}
{"id": "173aa311-d4bf-4905-96e1-8a1b56c60d6c", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "00bca41e-f0d6-492c-bb55-c6ddf4d99b29", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.6\n        self.F = 0.8\n        self.CR = 0.7\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9\n        self.diversity_threshold = 0.2\n        self.min_pop_size = 10\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def calculate_diversity(self, population):\n        mean_position = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_position, axis=1))\n        return diversity\n\n    def resize_population(self, diversity):\n        if diversity < self.diversity_threshold and self.pop_size > self.min_pop_size:\n            self.pop_size = max(self.min_pop_size, int(self.pop_size * 0.9))\n        else:\n            self.pop_size = min(50, int(self.pop_size * 1.1))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            diversity = self.calculate_diversity(population)\n            self.resize_population(diversity)\n\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "ImprovedAdaptiveDEPSO", "description": "Incorporate a multi-objective inspired approach with adaptive parameter adjustment and dynamic population resizing for improved exploration and exploitation balance.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "c5233c8c-264c-44d6-813d-00853960fb79", "solution": "import numpy as np\n\nclass EnhancedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Slightly increased cognitive parameter\n        self.c2 = 1.7  # Slightly increased social parameter\n        self.w_min = 0.4  # Minimum inertia weight\n        self.w_max = 0.9  # Maximum inertia weight\n        self.F = 0.5  # Initial DE Mutation factor\n        self.CR = 0.5  # Initial DE Crossover probability\n\n    def adaptive_parameters(self, evaluations):\n        # Self-adapt parameters based on current evaluations\n        self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n        self.F = 0.5 + 0.5 * np.random.rand()\n        self.CR = 0.5 + 0.5 * np.random.rand()\n\n    def elitist_mutation(self, population, global_best_position):\n        # Perform elitist mutation with the global best\n        indices = np.arange(self.pop_size)\n        np.random.shuffle(indices)\n        for i in range(0, self.pop_size, 3):\n            if i + 2 < self.pop_size:\n                a, b, c = indices[i:i+3]\n                mutant = population[a] + self.F * (population[b] - population[c]) + 0.1 * (global_best_position - population[a])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n                if np.random.rand() < self.CR:\n                    population[a] = mutant\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            self.elitist_mutation(population, global_best_position)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedDEPSO", "description": "Enhance the integration of DE and PSO by introducing self-adaptive parameter tuning and a novel elitist mutation strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.11858896368999078, "feedback": "The algorithm EnhancedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.12138835944631154, 0.16573112878346252, 0.2152854962705545, 0.1890226398302738, 0.1997185073318828, 0.17272907044726293, 0.15889210448662705, 0.18038358740818972, 0.17732669786976507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023037341809993395, 0.020670030069384837, 0.040777185995531595, 0.04936147766453958, 0.03392927845788085, 0.04294814146318948, 0.05722431226032754, 0.06306331260248355, 0.0360539122947493, 0.009173346089360379, 0.02080498637327055, 0.03748892865851794, 0.061269754717952485, 0.008654774633589102, 0.019148162041281336, 0.01916905197868579, 0.023119536497086868, 0.04346030732287032, 0.9899277024221639, 0.9961777541505263, 0.9951132529649912, 0.9841014461123222, 0.9847041002287371, 0.9950633667402907, 0.9846085565943457, 0.9902368326219136, 0.9949538019624629, 0.04977010089916678, 0.0641853118819945, 0.13417755566887102, 0.11078387314990357, 0.07637218000154755, 0.06791799062787685, 0.059591056795199604, 0.07888303883373504, 0.06952870209217377, 0.10077278233217024, 0.1086563591966655, 0.09767861303767966, 0.11045016603698243, 0.10293026856191267, 0.11031742601215067, 0.0770100796745522, 0.11565478556706477, 0.09992986185273134, 0.0013030319594057316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018030878273498807, 0.0015325286874046107, 0.026945319665450218, 0.01542381370828716, 0.005474316492060094, 0.008824262742410438, 0.017230251909802652, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013790975891173507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017613107977265785, 0.011699205169871107, 0.01389133015346855, 0.028799325228393124, 9.999999999998899e-05, 0.005887216644291038, 0.020260159444254744, 0.06369978952951061, 0.027942600656912675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004091286625401369, 9.999999999998899e-05, 0.0036664911517551024, 0.18923615799492133, 0.21520866601253197, 0.18302297946046342, 0.1795571072220964, 0.15402560278383792, 0.16245092829451446, 0.21386882450936984, 0.15990024645181966, 0.18881782978712058, 0.04824073576095056, 0.0436214865655522, 0.04845148429520085, 0.047467970447349406, 0.03781071761236998, 0.0476931095562535, 0.03335481819424113, 0.042133740395296604, 0.030135048133762443, 0.14832166750053855, 0.14747092594718947, 0.13531961948001647, 0.12703984493106513, 0.12834403239044456, 0.12016819372458609, 0.13675319919983175, 0.11970134813241295, 0.13382061370525067, 0.15507714231835268, 0.14355237736652549, 0.15261946028402795, 0.1565551679908762, 0.13354764648928774, 0.194746608466572, 0.14504060308982114, 0.17377774300845283, 0.18162710401192106, 0.11392184916298198, 0.09925891333396031, 0.12702370808373686, 0.14098645259518494, 0.09570716328188189, 0.1409328977837302, 0.08947655076294958, 0.10830252669002494, 0.11328658206466202, 0.13827209553324105, 0.1325411728371464, 0.15985166018010366, 0.12061631567774844, 0.1510392070298533, 0.13122286004533612, 0.15930110788076413, 0.15532766445570556, 0.15181696786215126, 0.13864186817338775, 0.09372385503515035, 0.15472630709860946, 0.14757617398786638, 0.14823866835137522, 0.1316078151875899, 0.13928560717994276, 0.14147739559512607, 0.14503944642510447, 0.13406159536335904, 0.13063646614414737, 0.11912045963339002, 0.11119973817508377, 0.133184381416951, 0.14374717324300257, 0.1094355121985342, 0.10281674931891793, 0.14124189593636816, 0.17671793379551892, 0.1362373404868864, 0.1401792834135338, 0.11667384040159645, 0.11728434727934312, 0.08806935042472508, 0.18326470791764138, 0.13490368817756293, 0.181316265058306, 0.19105454925364262, 0.18975553986851712, 0.16232306506128558, 0.1636527174364354, 0.17301096993865162, 0.17847297060697143, 0.1734909481168948, 0.17547327829264903, 0.1691879361359564, 0.03777268472351569, 0.03858151792090936, 0.03315396810474902, 0.05801638446666002, 0.037296895859276646, 0.041022841490435114, 0.042182497173010036, 0.035392399269170705, 0.03776639038849461]}, "mutation_prompt": null}
{"id": "78fbaa2a-a869-485f-aeaa-e4cf27cd0abb", "solution": "import numpy as np\n\nclass AdaptiveMultiPopDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size for diversity\n        self.sub_pop_size = 20  # Sub-population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.4  # Adjusted cognitive parameter\n        self.c2 = 1.4  # Adjusted social parameter\n        self.w = 0.7  # Increased inertia weight\n        self.F = 0.9  # Adjusted DE Mutation factor\n        self.CR = 0.6  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.85  # Adjusted cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.4 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            # Split population into sub-populations and process them\n            for k in range(0, self.pop_size, self.sub_pop_size):\n                sub_population = population[k:k+self.sub_pop_size]\n                sub_velocities = velocities[k:k+self.sub_pop_size]\n                sub_personal_best_positions = personal_best_positions[k:k+self.sub_pop_size]\n                sub_personal_best_scores = personal_best_scores[k:k+self.sub_pop_size]\n\n                for i in range(self.sub_pop_size):\n                    indices = [index for index in range(self.sub_pop_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = sub_population[a] + self.F * (sub_population[b] - sub_population[c])\n                    mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                    trial = np.copy(sub_population[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR:\n                            trial[j] = mutant[j]\n\n                    trial_score = func(trial)\n                    evaluations += 1\n                    if trial_score < sub_personal_best_scores[i] or np.exp((sub_personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                        sub_personal_best_scores[i] = trial_score\n                        sub_personal_best_positions[i] = trial\n                        sub_population[i] = trial\n\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    sub_velocities[i] = (self.w * sub_velocities[i] + self.c1 * r1 * (sub_personal_best_positions[i] - sub_population[i]) + self.c2 * r2 * (global_best_position - sub_population[i]))\n                    trial = sub_population[i] + sub_velocities[i]\n                    trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < sub_personal_best_scores[i]:\n                        sub_personal_best_scores[i] = trial_score\n                        sub_personal_best_positions[i] = trial\n                        sub_population[i] = trial\n\n                    if trial_score < global_best_score:\n                        global_best_score = trial_score\n                        global_best_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n            # Integrate updated sub-populations back to the main population\n            population[k:k+self.sub_pop_size] = sub_population\n            velocities[k:k+self.sub_pop_size] = sub_velocities\n            personal_best_positions[k:k+self.sub_pop_size] = sub_personal_best_positions\n            personal_best_scores[k:k+self.sub_pop_size] = sub_personal_best_scores\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiPopDEPSO", "description": "Combine adaptive differential evolution and particle swarm optimization with a multi-population strategy to enhance exploration and exploitation.", "configspace": "", "generation": 78, "fitness": 0.29484886365709695, "feedback": "The algorithm AdaptiveMultiPopDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.5835898326295008, 0.553572967123549, 0.5702395276567147, 0.5701679390752127, 0.5534012562147312, 0.572583487756553, 0.6544162907169053, 0.6429234625424026, 0.6179194874593315, 0.3630092410686705, 0.39440444864224167, 0.3634022636187667, 0.4000537803465821, 0.3615178109197912, 0.3565669401604632, 0.37707335469724745, 0.42255309288795717, 0.044209755544197815, 0.19724081143737449, 0.1599110737036492, 0.13798678094648653, 0.13414779205067695, 0.13349611065730604, 0.12518572032016162, 0.19357672276076354, 0.20157837993783978, 0.13132801189810395, 0.12494811174241627, 0.1421589732687757, 0.11833362503806444, 0.15079614608054404, 0.12761057797464292, 0.1137570125016929, 0.12738631108033338, 0.12975353842921633, 0.12994604272446708, 0.973429901997878, 0.9909697715747716, 0.9905513520493325, 0.9705736667913134, 0.9804501623203312, 0.9587726624557734, 0.9828509638892509, 0.9726776433214726, 0.9788619232290747, 0.23645623363780333, 0.2445290410958728, 0.20854338965884567, 0.20719563847677158, 0.26211072417366255, 0.2423440597509675, 0.23389914326555705, 0.22115489179184522, 0.2904456963618388, 0.6586603176966008, 0.6128122557433315, 0.7530531964033172, 0.21179081757010443, 0.5745536499410464, 0.6702294160436786, 0.4710964163973782, 0.7715215419012752, 0.7080437040483972, 0.32758514535803107, 0.18165769342209448, 0.10454655072505281, 0.19413657854045974, 0.29356972837396755, 0.11215587362375479, 0.24785944501792045, 0.2880519114827286, 0.20563645591636615, 0.3087375824797034, 0.24201226106113305, 0.12135148812969687, 0.18598962212615433, 0.3525629286852626, 0.316169668140159, 0.18342639411105732, 0.20410776759081317, 0.12234362828920964, 9.999999999998899e-05, 9.999999999998899e-05, 0.08634602682751502, 0.26531307042909724, 0.20994951280780272, 9.999999999998899e-05, 0.06163452498145183, 0.04430760411771062, 0.2783130038975842, 0.3180314801609957, 0.37448431049387465, 0.3602962166029997, 0.4013722133251044, 0.1611740831721592, 0.1550972881080519, 0.19083709949218886, 0.36125413907341464, 0.2354914591241275, 0.03754082219605115, 0.07019800337788906, 0.050666377050221145, 0.1550144634456725, 0.11143090898270913, 0.05666423300746648, 0.07689668838465002, 0.08767364073492612, 0.14127747081786834, 0.21005174534552995, 0.23607916470402346, 0.22979696142941108, 0.21596698251727586, 0.22648966545498317, 0.2128051899143346, 0.25036059804155386, 0.19034752759724616, 0.23610424635953053, 0.4792692182934635, 0.5083498169749838, 0.5035525517581532, 0.5283894461531655, 0.5504431578286464, 0.498401554708641, 0.512533590875774, 0.5035516080720419, 0.5183475480722693, 0.12688310923384705, 0.12854697452760333, 0.12217174925744823, 0.08639690552138513, 0.0917872345341777, 0.12529326587112388, 0.10439388954549844, 0.11831405744370371, 0.0962488784291552, 0.14430736229693175, 0.25964263136115673, 0.20843897895979613, 0.22199951902658888, 0.17194057102731097, 0.1648535587945209, 0.3417462426800031, 0.22890822437811276, 0.1938436329354989, 0.30133046286645804, 0.33233775514345787, 0.28467030686577177, 0.30030742325769255, 0.35652096844690184, 0.3335408130854641, 0.35709757427154853, 0.36281657793753397, 0.35253453770300147, 0.26219708571043543, 0.19741042397097774, 0.2967746042303554, 0.29077019018803807, 0.25734493731847563, 0.27203289717909285, 0.2593958379316317, 0.25634852842591194, 0.24800046237799445, 0.1963284554034762, 0.20542022268938132, 0.1897268826214208, 0.19737627256458057, 0.23957523895298916, 0.1892304564076016, 0.20328223869151585, 0.20511655507210758, 0.23852668411120626, 0.2340696624621773, 0.22961708626850486, 0.20645596462719318, 0.21298345131378882, 0.3031706868606423, 0.19801245517941635, 0.20945427093856672, 0.1957711708969495, 0.2316991827210998, 0.5789767269002232, 0.6782791959559589, 0.15187331790893766, 0.7598393309306501, 0.1942812577479136, 0.19754447880900272, 0.14258582646396067, 0.1703423544875211, 0.21004159119703258, 0.6731960423142116, 0.2108210415520685, 0.6156986631645829, 0.2066941801585459, 0.16848358795463114, 0.5215077987022911, 0.10492737131213103, 0.6330530727636214, 0.7403657557683636, 0.17325713976339574, 0.1755764710964941, 0.17399284571393003, 0.17873127907429553, 0.1841648409138288, 0.20266244083149088, 0.18439234301939378, 0.17513393238494646, 0.17622041195220317, 0.07585561945687169, 0.08413719186005386, 0.08103725940710449, 0.07660029825208714, 0.07417004659507931, 0.08150282903886019, 0.07257144069975707, 0.09520389558592157, 0.06803675869140502]}, "mutation_prompt": null}
{"id": "f3ecfcac-15a8-4a38-b453-fc706dadfef4", "solution": "import numpy as np\n\nclass EnhancedLevyChaoticDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population size for diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Adjusted cognitive parameter\n        self.c2 = 2.0  # Adjusted social parameter\n        self.w = 0.5  # Reduced inertia weight for better exploitation\n        self.F = 0.5  # Reduced DE Mutation factor for stability\n        self.CR = 0.9  # Increased DE Crossover probability for higher genetic diversity\n        self.T = 1.0\n        self.T_min = 1e-4\n        self.alpha = 0.95  # Adjusted cooling rate\n        self.beta = 1.5  # Levy flight exponent\n\n    def levy_flight(self):\n        # Levy flight step\n        u = np.random.normal(0, 1, self.dim) * self.F\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/self.beta))\n        return step\n\n    def chaotic_map(self, evaluations):\n        # Chaotic map for parameter adaptation\n        return np.random.rand() * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial += self.levy_flight()\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), self.chaotic_map(evaluations)\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedLevyChaoticDEPSO", "description": "Enhance AdaptiveMultiStrategyDEPSO by integrating Levy flights for better exploration and chaotic maps for parameter tuning to improve convergence speed and solution quality.", "configspace": "", "generation": 79, "fitness": 0.25314912521482424, "feedback": "The algorithm EnhancedLevyChaoticDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.6442059101073053, 0.6626393253132368, 0.6771699612008861, 0.6917062862366624, 0.7284743585544351, 0.6466785687909931, 0.61181594166386, 0.6182695838937295, 0.5726611478357289, 9.999999999998899e-05, 9.999999999998899e-05, 0.01420088147293952, 0.0405983139387065, 0.34846231189912125, 0.08686051355929847, 0.08668977780451914, 0.017101493635055753, 0.048568701245853996, 0.08248827897054256, 0.12381907841623019, 0.09039421903919231, 0.09249660293239215, 0.10356335223113111, 0.09189599841817675, 0.06859047216586567, 0.11688213990470309, 0.09212388362782586, 0.07038727440005454, 0.11311143851946037, 0.11916213064885905, 0.10286306286563007, 0.12048956374557729, 0.0839609645728786, 0.08110958684754532, 0.05796098615342038, 0.10359816430201318, 0.990353170203031, 0.9799661344874242, 0.9907256957390451, 0.9802454346910916, 0.9669577856046305, 0.9623109636122995, 0.9914011342270498, 0.9806127520954596, 0.9883886943081841, 0.2714338394068433, 0.2886922997900224, 0.2611873995484352, 0.23769769515995598, 0.19907951159837634, 0.18913070069204652, 0.2633805870920466, 0.29460368761326017, 0.1889146996840655, 0.2067078691395836, 0.6410311011252665, 0.7802719981635837, 0.2112024758591533, 0.2744375706443709, 0.2347570335976873, 0.3083143112652822, 0.23284515804858397, 0.17538557155682866, 0.3870350843525281, 0.11204250577526509, 0.3889622805181763, 0.09223865050330993, 0.15522484852396157, 0.11356517291038415, 0.1889483573228692, 0.18003024580771976, 0.14625899052880087, 0.31335042193413376, 0.26926786927034396, 0.28664512598559655, 0.18604075718011692, 0.4720779406342943, 0.19981435862637942, 0.22564466943623662, 0.11267116699575763, 0.46447379447577164, 0.031458634771526106, 0.06967899776168818, 0.1483287240703357, 0.037337014232900034, 0.1808690336289034, 0.017572126549058487, 0.1881189669214942, 0.06552136421695942, 0.10450216261329259, 0.17518018389689882, 0.20342642585330473, 0.118323554433858, 0.32127010497896114, 0.16810152615258944, 0.16836130332316968, 0.21581254353420043, 0.3273325325602833, 0.1283030394359097, 9.999999999998899e-05, 0.028805145352641892, 0.09528761590948487, 0.21489900068454493, 0.06085985094118551, 0.10828813168065243, 0.08487882134683278, 0.08202647808350672, 0.06822343396805575, 0.2807457470060133, 0.1483585427773223, 0.2447472453508034, 0.19638270474136754, 0.18390058543577925, 0.2536325007469029, 0.19920494741380668, 0.05443755961164565, 0.07886543930675594, 0.4790571948508987, 0.45108775448558747, 0.46153716725365646, 0.4437548868217217, 0.4485958415253639, 0.4289153800520564, 0.4631351039611341, 0.4177040828744205, 0.4022576407352212, 0.09580307293158608, 0.11877940661679476, 0.08467388705033463, 0.1353072471954696, 0.07358558388350134, 0.08324938414085759, 0.07818447786221239, 0.10127786531043426, 0.10214556239492723, 0.21244985753355827, 0.18069310432393482, 0.16777111212262297, 0.1496261940866057, 0.24322131182096995, 0.17816902615781105, 0.19844675963443947, 0.16093426623822238, 0.16959827139343453, 0.26167845829649405, 0.2845719252028117, 0.2814517660424388, 0.23905215466979246, 0.3466698029744101, 0.2843245303176578, 0.32199114803936535, 0.3460018535592584, 0.3023632149024045, 0.2601901297204541, 0.18175457809623163, 0.1700727313538679, 0.259260992159806, 0.18935952486742247, 0.2099505212555931, 0.16721573864755557, 0.18213252587236461, 0.22682604470055834, 0.18824184051534876, 0.18313765050378483, 0.18931393858792256, 0.1820860501511513, 0.17892474578535544, 0.25061197346250164, 0.22842080195829972, 0.18677852366553638, 0.178978269829567, 0.19470219364076102, 0.23669227183407415, 0.5143719403767277, 0.4295540125257149, 0.20551500121361055, 0.21656320016992658, 0.18253661217831685, 0.1895892433482771, 0.17728911574408102, 0.17137702356864903, 0.14638915663671537, 0.15290578770175156, 0.7055108489443682, 0.1988973228167784, 0.1987979400873715, 0.14167198797090075, 0.16302032559291968, 0.8182402531709405, 0.7898788830642298, 0.2062182901850843, 0.662624175258546, 0.2084907578404699, 0.16800215364708926, 0.16272074034448358, 0.10461062222422801, 0.18195469489879101, 0.2077564158868327, 0.1996684009664974, 0.18308130634845132, 0.18398110100378795, 0.19692486690576105, 0.18762232826832326, 0.18240702648911278, 0.21739475938963082, 0.1891710960139893, 0.2085581772831775, 0.08579392033394073, 0.07815593683072553, 0.09076900494572415, 0.08742035421389571, 0.0836906151969854, 0.07334761943537527, 0.08055401034806509, 0.08150521468385852, 0.074291678535641]}, "mutation_prompt": null}
{"id": "1aec8d18-ec69-40df-aa11-f3e303cda1d0", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "a6107835-2dee-498a-8a8c-9c7dca7504f1", "solution": "import numpy as np\n\nclass EnhancedDEPSOLocalIntensification:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.0  # Adjusted cognitive parameter\n        self.c2 = 2.0  # Adjusted social parameter\n        self.w = 0.5  # Reduced inertia weight\n        self.F = 0.9  # Modified DE Mutation factor\n        self.CR = 0.9  # Increased DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.95  # Enhanced cooling rate\n        self.local_intensity = 0.2  # New parameter for local search intensity\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.3 + 0.5 * np.random.rand() * (1 - evaluations / self.budget)\n        self.CR = 0.3 + 0.6 * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Adaptive local search intensification\n                local_best = personal_best_positions[i] + self.local_intensity * (global_best_position - personal_best_positions[i])\n                local_best = np.clip(local_best, self.bounds[0], self.bounds[1])\n                local_best_score = func(local_best)\n                evaluations += 1\n\n                if local_best_score < personal_best_scores[i]:\n                    personal_best_scores[i] = local_best_score\n                    personal_best_positions[i] = local_best\n                    population[i] = local_best\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedDEPSOLocalIntensification", "description": "Enhance the integration of Differential Evolution and Particle Swarm Optimization with adaptive local search intensification and guided mutation strategy for improved convergence speed.", "configspace": "", "generation": 81, "fitness": 0.3378349570021664, "feedback": "The algorithm EnhancedDEPSOLocalIntensification got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7932322063685266, 0.82914315090162, 0.8177447343651516, 0.8182511110943149, 0.8242565480197996, 0.8023501643205532, 0.8184125457898439, 0.8341836612169918, 0.8133014098274192, 0.6873430426974705, 0.6491706809230577, 0.6233357584961201, 0.675777480299635, 0.498837825870615, 0.6761987817317836, 0.6184165253021301, 0.38724484620310284, 0.6486088595364037, 0.14009824639397994, 0.17935877946233159, 0.15348631676638802, 0.15798445372041936, 0.50972521765288, 0.2025969749832507, 0.19934445273353896, 0.4582672633467779, 0.22698042831750953, 0.1316308206361433, 0.09144917846730727, 0.143702845570431, 0.14441127506643192, 0.1127079584170011, 0.14593925859888057, 0.11254790670376091, 0.15843905070486597, 0.14293459357694605, 0.9888939801910548, 0.9859689709661883, 0.989909101294994, 0.9430495757116744, 0.9525415518924267, 0.9566564254080853, 0.9814860348845471, 0.9729062798861264, 0.9835980904266894, 0.5246211560099708, 0.10577455946725456, 0.3172881205571456, 0.35593806216294066, 0.5204813221349973, 0.1949593759445658, 0.22696024703827866, 0.2117509022860139, 0.3662279388344637, 0.7251482042828569, 0.8003197820134873, 0.7552333353765142, 0.38296341662359246, 0.8903076707505975, 0.19340806744262617, 0.7850919430734353, 0.1304205660987775, 0.23041769532933454, 0.4592398931482261, 0.529997363760959, 0.18209283174202817, 0.36772009139126927, 0.445084034730693, 0.12901468473953281, 0.43465284586178476, 0.12924780127627455, 0.37132925621496427, 0.1329480275784899, 0.4147739653911764, 0.43462543205683213, 0.3585238197101295, 0.44055900206436627, 0.429449600160398, 0.4677400417211678, 0.2596584268474288, 0.11366392082172005, 9.999999999998899e-05, 0.03181518779792514, 0.09364227532835334, 0.12862871486943406, 0.09717008709420882, 0.01861046067861316, 0.26049390073869716, 0.19704195678009706, 0.09027875541838581, 0.1119283779457102, 0.16625228366932132, 0.2147915155124619, 0.313786787615149, 0.04993718341065212, 0.056240353266045484, 0.5426058324991097, 0.24524094785949335, 0.5323131412383846, 0.13366781588021226, 0.05525443621283321, 0.0644342526035071, 0.12496134758793609, 0.11479154023787319, 0.2202737398600274, 0.18774533464929077, 0.13599612338330935, 0.1150971451778916, 0.37786679373613274, 0.35525134696037064, 0.35117912648256033, 0.3938888317798934, 0.25313846370825477, 0.334739973346044, 0.19602751600420987, 0.3080557256557013, 0.08353358526898336, 0.5551062257622846, 0.5736575090547078, 0.48511203832202987, 0.48952717345048924, 0.48961247261686325, 0.3915081285274238, 0.4594865147626006, 0.4979473101134704, 0.6826013386932108, 0.1307912120778999, 0.10338220782662533, 0.08559249172452676, 0.15303405183811414, 0.11319810044206347, 0.12718344013521632, 0.06783210217079672, 0.10941037443622115, 0.07952538545365262, 0.1673084827659359, 0.16719740585341625, 0.1744804767270629, 0.30830766793334974, 0.2595136740481606, 0.13324550297624826, 0.3266433281035921, 0.2004345177838307, 0.2212934573725973, 0.3551602988418535, 0.40237156890293946, 0.2986975227639952, 0.40036684238693665, 0.3630288722215803, 0.2801314331354816, 0.42350194864984414, 0.33941322320856204, 0.40513823926945414, 0.2606288868677802, 0.3413499955239879, 0.3272954000688192, 0.37935603894462067, 0.17633913343357677, 0.26903271285940855, 0.24612322844326595, 0.28864546371988853, 0.34428370794966123, 0.18566479064785812, 0.17170130041310316, 0.19266045685702604, 0.20788382318267806, 0.20462664368805827, 0.2101428124392133, 0.2039183858417971, 0.2667112668115813, 0.19939690903747542, 0.6357825263460675, 0.20627703812706188, 0.19883599683556896, 0.243581095381183, 0.1910868741103724, 0.22602775151628807, 0.21072633405981056, 0.21956266467340046, 0.19636249609610745, 0.1754501501523733, 0.840664593325013, 0.1525946529224198, 0.8756285014337599, 0.19957538583207368, 0.1996518292754802, 0.12219575330634946, 0.16953960028116433, 0.2094302333216611, 0.8585533924890292, 0.15702052586022763, 0.8853958470528999, 0.8299399789320652, 0.16685748544556156, 0.8242546230745733, 0.10518946769464854, 0.10513613755753248, 0.16636894666563007, 0.197279483948134, 0.19571579221567303, 0.19315314982078202, 0.1746450593871427, 0.17549151216147252, 0.19382371817942046, 0.1989960026344718, 0.20772331269995636, 0.19762635674888707, 0.09754045122098798, 0.09061855353062909, 0.09596055142477522, 0.10406599461821298, 0.0856967659586062, 0.0770845502448283, 0.09054571923729615, 0.08891362810964787, 0.08243810182932354]}, "mutation_prompt": null}
{"id": "c17f54a5-9c80-47fb-b28e-079f0d4770ee", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "421f6ba8-5235-4b48-9f34-52b0debe96f4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size for better diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.6  # Tweaked cognitive parameter\n        self.c2 = 1.4  # Tweaked social parameter\n        self.w = 0.7  # Adjusted inertia weight for better convergence\n        self.F = 0.9  # Improved DE Mutation factor\n        self.CR = 0.6  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.95  # Enhanced cooling rate\n        self.velocity_clamp = 0.1  # Introduced max velocity to prevent explosion\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.4 + (0.2 * evaluations / self.budget) * np.random.rand()\n        self.CR = 0.3 + (0.5 * evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def fitness_proportional_selection(self, scores):\n        # Select indices based on fitness proportional selection\n        total_fitness = np.sum(1.0 / (1.0 + np.array(scores)))\n        probabilities = (1.0 / (1.0 + np.array(scores))) / total_fitness\n        return np.random.choice(range(self.pop_size), p=probabilities)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                # Fitness proportional selection\n                a = self.fitness_proportional_selection(personal_best_scores)\n                b = self.fitness_proportional_selection(personal_best_scores)\n                c = self.fitness_proportional_selection(personal_best_scores)\n                \n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = np.clip(self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]), -self.velocity_clamp, self.velocity_clamp)\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveDEPSO", "description": "Enhance adaptive DEPSO by integrating fitness-proportional mating and adaptive velocity clamping for improved exploration and convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "7968df4d-52ab-4838-848f-ac55bfd2b562", "solution": "import numpy as np\n\nclass HybridQuantumDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size for diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.2  # Adjusted cognitive parameter\n        self.c2 = 1.8  # Adjusted social parameter\n        self.w = 0.7  # Modified inertia weight for improved exploration\n        self.F = 0.7  # Balanced DE Mutation factor\n        self.CR = 0.9  # Increased DE Crossover probability\n        self.q = 0.5  # Quantum cloud radius initial\n        self.alpha = 0.95  # Updated cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE and Quantum parameters dynamically\n        self.F = 0.4 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.7 + (0.3 * evaluations / self.budget) * np.random.rand()\n        self.q *= self.alpha\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Quantum-behavior PSO update\n            for i in range(self.pop_size):\n                quantum_vector = np.random.normal(scale=self.q, size=self.dim)\n                trial = personal_best_positions[i] + quantum_vector\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridQuantumDEPSO", "description": "Hybridize adaptive differential evolution with quantum-behavior particle swarm optimization for diversified search with enhanced convergence.", "configspace": "", "generation": 84, "fitness": 0.26511339891492897, "feedback": "The algorithm HybridQuantumDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.6779556086286054, 0.6469098708876594, 0.6691363385908087, 0.6555990941642035, 0.641604277398423, 0.6357606703896375, 0.6739809330212869, 0.6826198802188244, 0.6265482303541567, 0.37485359085919223, 0.3479737458943084, 0.36825375782555136, 0.3190705152162945, 0.32187925096676706, 0.3465813599013814, 0.3712415962432237, 0.32575188320955417, 0.3454794914903474, 0.1526267724364203, 0.11314756785241076, 0.1264551061448872, 0.14706940703313065, 0.12145533673660669, 0.1364467204918839, 0.16477580619552246, 0.11908638839443153, 0.14436554237406674, 0.12865776003175344, 0.10827415295253762, 0.10936653454109291, 0.1261948631737272, 0.12373861903195793, 0.13749126295533787, 0.11000581236535456, 0.11259044697583487, 0.10952840123799601, 0.8614111081623193, 0.8675177334642296, 0.8365792347936221, 0.889988177733013, 0.882204463420006, 0.8844623193070855, 0.9303134344265406, 0.8826610216750715, 0.9050631493225256, 0.29671524961988194, 0.2941027505312942, 0.28870020136187036, 0.276391739200469, 0.24122076982114404, 0.2623043616962506, 0.31085837644144165, 0.2785132644870675, 0.28504906538412855, 0.5332058833317477, 0.4819868528623379, 0.5081046847188406, 0.60155645642305, 0.5310151473295408, 0.5722447333184011, 0.20670430635986514, 0.5120880788294155, 0.5386974699620855, 0.18462765274529824, 0.15481030680236163, 0.19352706798703356, 0.13549678199629545, 0.13675494056997228, 0.20214268542270342, 0.19716163003473364, 0.15880263593320798, 0.22582488045767557, 0.17919804186349042, 0.16197564019728816, 0.14815437968128353, 0.15702030818099189, 0.152982074044128, 0.14558632742211686, 0.17878949926033527, 0.14501179856076318, 0.16615388146647037, 0.037105624158137784, 0.07968347397921827, 0.038975967334305084, 0.09581591111639887, 0.07689442786250966, 0.06222276138185512, 0.08568759931490366, 0.05769275472567292, 0.05000378580453668, 0.1537681437358609, 0.1550432885853481, 0.16534871272125073, 0.13985729520540457, 0.13972416029172396, 0.15056014734016077, 0.18875222669050407, 0.18863894090449307, 0.2063406196063058, 0.03963751820462347, 0.041586819025644206, 0.018864677746030956, 0.04778233705944135, 0.05433888377459517, 0.03921277506433818, 0.033116877880586926, 0.040240868149577946, 0.02722643131938951, 0.15795735392255883, 0.14896835668689745, 0.1276049353151566, 0.13104963151255578, 0.1369974200679306, 0.14736483053745375, 0.14277124544270592, 0.12757083654401125, 0.13040666460165962, 0.46966399329914976, 0.47201579280246087, 0.4837467993418081, 0.4659273932665786, 0.4777770294826815, 0.4490589967154479, 0.4524686310742906, 0.4670022656754652, 0.46132885695655346, 0.12926502131876583, 0.10406940144414889, 0.12373401771396053, 0.11450387034964138, 0.11770212332789631, 0.11180955456618535, 0.11914865500186589, 0.10466893487667361, 0.10583195991762673, 0.1963934841092203, 0.18718364920432706, 0.18804053131981435, 0.21521082799456293, 0.2347917642482047, 0.19403766564518365, 0.18993946232850722, 0.21519659181421624, 0.20981588352229985, 0.29639904475894185, 0.3074799145908518, 0.2636228948824497, 0.27488268977307406, 0.28590959517134806, 0.2821474656917199, 0.30846174498166357, 0.3513918446426656, 0.331703276491196, 0.22353186706738215, 0.22155699558839237, 0.21075629578224275, 0.2175547678616172, 0.21264886655445803, 0.19494728771761838, 0.2559367153050013, 0.23425125217825582, 0.20530911276225383, 0.20233201018170333, 0.18424731462543542, 0.19356435207937916, 0.1899579329625507, 0.17772694733161642, 0.20776541911565127, 0.208174811704808, 0.19138698627764905, 0.20453079874362523, 0.21630228293846843, 0.1917874248130279, 0.19384632091798126, 0.19874204415609842, 0.2106988007202213, 0.20552103221605578, 0.19032954373637623, 0.266964297886356, 0.26559864704457925, 0.4776065314734913, 0.380040604637491, 0.5021504956847783, 0.6526625664216147, 0.1918461764331143, 0.48339698700973077, 0.2907788890425248, 0.166410320875383, 0.31600150311352615, 0.42798288580422805, 0.21836270672340752, 0.2419431894971037, 0.2573525413935235, 0.2715066459042538, 0.42085515880877233, 0.2542037395661879, 0.5321165480490049, 0.37805981499473595, 0.1728989814050338, 0.17976725976164032, 0.17646414332898674, 0.17927902392162232, 0.1870845179935845, 0.20336070870915024, 0.19863295521890434, 0.20713563030653936, 0.17667077206733917, 0.08226806684569388, 0.08053268010542747, 0.07771645080411294, 0.06940872690417021, 0.07643207850286637, 0.08836077312887558, 0.07667051850514328, 0.07195422265048723, 0.08730612705363694]}, "mutation_prompt": null}
{"id": "ee3b31c0-8ac7-46da-827f-31f9bb506079", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Increased cognitive parameter for better exploration\n        self.c2 = 2.0  # Increased social parameter for better convergence\n        self.w = 0.5  # Adjusted inertia weight for balance\n        self.F = 0.7\n        self.CR = 0.6\n        self.T = 1.0\n        self.T_min = 1e-4\n        self.alpha = 0.95  # Modified cooling rate for nonlinear schedule\n\n    def dynamic_parameters(self, evaluations):\n        # Introduce a nonlinear dynamic adjustment for DE parameters\n        self.F = 0.5 + 0.3 * np.cos(evaluations * np.pi / self.budget) * np.random.rand()\n        self.CR = 0.5 + 0.4 * np.sin(evaluations * np.pi / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha * (1 - evaluations / self.budget)**2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                random_explore = np.random.normal(0, 1, self.dim) * (self.bounds[1] - self.bounds[0]) / 10\n                trial = population[i] + velocities[i] + random_explore\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveMultiStrategyDEPSO", "description": "Enhance the AdaptiveMultiStrategyDEPSO by incorporating a nonlinear dynamic cooling schedule and hybridizing DE/PSO with randomization-based exploration for diverse search capabilities.", "configspace": "", "generation": 85, "fitness": 0.2365950959383063, "feedback": "The algorithm EnhancedAdaptiveMultiStrategyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.5725671231178477, 0.5580646207501045, 0.5803279299901924, 0.5693688379735538, 0.5754609305628939, 0.5848833957391122, 0.5977324703688208, 0.5667585944999598, 0.581336262599262, 0.32633777932176034, 0.3759150053974907, 0.35192439601945336, 0.3630439726553304, 0.3357098990315318, 0.3124484333434354, 0.32980559182106917, 0.3402369782781872, 0.37425238121867055, 0.12718492420188066, 0.11787875246204982, 0.10713084549500218, 0.13848958361929886, 0.12138794833605282, 0.12433184442054457, 0.10543116921288898, 0.13151564591135068, 0.13021550477536437, 0.10211240839525637, 0.10730861877067788, 0.10256438970438009, 0.11096678877274413, 0.12394959571733122, 0.10201222065586368, 0.09955879156353298, 0.10128524270133676, 0.10822007669612355, 0.9875590582025101, 0.9936029212863224, 0.9957017985922904, 0.9716271184474232, 0.9881755900505923, 0.9686855121290033, 0.9882567699738728, 0.9861628193490297, 0.9810815572944256, 0.24540267455810572, 0.2573091073613618, 0.286944640970503, 0.26091012146335857, 0.254537445937584, 0.26255608191537605, 0.27170955011809494, 0.2637099078395897, 0.19925843648534303, 0.28549397000349164, 0.28292385044986845, 0.2992176801793974, 0.42298591523738727, 0.3769659578220429, 0.26932280692902455, 0.514713389786398, 0.2663240886078101, 0.3422053052586639, 0.12832676202872295, 0.15389691370987169, 0.13699113316407252, 0.15551316659338132, 0.16097971729834226, 0.11535664457632289, 0.1614951693153195, 0.1255142578259767, 0.17146448605132303, 0.16468114117852506, 0.12832291450578814, 0.05165030287736461, 0.16208944506730893, 0.14432508696281987, 0.1628967564665318, 0.13368355675101484, 0.13574895272397447, 0.11908648515501041, 0.06601842680471759, 0.02660036212229877, 0.02737833564319736, 0.005716106454711767, 0.017488176584334214, 0.006399216325222001, 0.026231393246024193, 9.999999999998899e-05, 0.019321596958677745, 0.14016238564311212, 0.062202913672285476, 0.0711115464009412, 0.16557063395653326, 0.07733583947191458, 0.049211483004701795, 0.06398531580405975, 0.13912646540693674, 0.11032642272923787, 0.015575653520640498, 0.021573253681625326, 0.031888063190865124, 9.999999999998899e-05, 0.007434306268209179, 0.0028271497978826776, 9.999999999998899e-05, 0.018604298708667866, 0.002254218800014085, 0.10832331959096686, 0.09993638575503083, 0.08567327682687542, 0.14351996471483164, 0.09818844143298244, 0.10017581944683096, 0.08976226909921903, 0.09876020353369352, 0.10650629780931198, 0.46933426293354363, 0.4461606683688306, 0.44146991670933944, 0.44054259153262443, 0.44462141009578804, 0.43868047519039755, 0.4299132706054769, 0.4583533790787313, 0.4473769756007757, 0.08772913536165028, 0.07565059958925391, 0.08546356269941258, 0.08854628575556833, 0.08667600390585306, 0.0844626095519192, 0.08716139963839564, 0.08597291498542103, 0.08223957874623955, 0.1425513950128221, 0.14024711268268675, 0.17543406068635847, 0.17026697133039648, 0.14906416134172373, 0.13530065323799367, 0.19391232447920181, 0.1373901042054958, 0.19577153047550433, 0.30364107162366116, 0.3012421549815847, 0.26866172501559027, 0.305887268525713, 0.28604362687710505, 0.2571738570772143, 0.32061764410592253, 0.3187489152652955, 0.2919628363976692, 0.21731303265170177, 0.18508272972186945, 0.18919520197107143, 0.17756055817396887, 0.20519274758172457, 0.21063148466382975, 0.2369659654536591, 0.2276609905939574, 0.21141755084209213, 0.18506863462076295, 0.20216877662482213, 0.17254029167763785, 0.19584582420149976, 0.18012071393256224, 0.1871779369435661, 0.19507055196310408, 0.17835281746433462, 0.19790739960572346, 0.1954970422207487, 0.18479501128747755, 0.18579532037796964, 0.18214869324084126, 0.1874975339667806, 0.18847169153426713, 0.1796807445644294, 0.1830755400558638, 0.19472306180524135, 0.4230595618142432, 0.16717003295189292, 0.15174286686336358, 0.6138394092842565, 0.19554634021104622, 0.19440534802426557, 0.19672259791251756, 0.1679157698028706, 0.6092380300008859, 0.4806333815482311, 0.1522496234767461, 0.3931885682753735, 0.20261258006487304, 0.4591063337747451, 0.19871913752490122, 0.20892873707634751, 0.15410798338780807, 0.488691314573527, 0.17354301417566198, 0.19295473221913717, 0.1792090712849922, 0.19161957042204247, 0.1939895548040247, 0.18329932245709546, 0.17800761414602817, 0.1931898116369376, 0.1769758796174128, 0.07576117662186133, 0.06834053124543171, 0.07347044214836407, 0.07231639369156895, 0.07445251710001011, 0.07329347270683972, 0.07849340392520521, 0.08011297164242892, 0.07782785984110085]}, "mutation_prompt": null}
{"id": "799cffbf-8d59-4b64-bb5a-d9b2717b3633", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "4801a65a-506c-4c03-afbd-70111cb75a96", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "98679e31-eaa0-4fbf-9477-9f3664948f09", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "b817a7d2-2ec5-41a5-8d13-eab1fff67d6d", "solution": "import numpy as np\n\nclass HybridLevyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.4  # Updated cognitive parameter\n        self.c2 = 1.6  # Updated social parameter\n        self.w = 0.5  # Modified inertia weight\n        self.F = 0.7  # Modified DE Mutation factor\n        self.CR = 0.8  # Modified DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9\n\n    def levy_flight(self, L):\n        # Implement Lévy flight for local search intensification\n        return np.random.normal(size=L) * (1 / np.random.power(1.5, size=L))\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.6 + (0.2 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.6 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                if np.random.rand() < 0.3:  # Perform Levy flight based local search intensification\n                    trial += self.levy_flight(self.dim)\n                    trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridLevyDEPSO", "description": "Hybridize adaptive differential evolution with local search intensification using Lévy flights and dynamic neighborhood-based strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.3397860608702462, "feedback": "The algorithm HybridLevyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.6715275112615937, 0.7319598252995582, 0.7595722146823023, 0.7641386369918896, 0.7111131278929974, 0.6736231648789689, 0.6274377438055323, 0.6249224325675751, 0.6845178346139049, 0.5933163926602116, 0.5862146337725327, 0.6378755156533251, 0.6647603835059797, 0.5776625081512425, 0.6282996244559031, 0.6534754595500526, 0.5127780094573737, 0.5382769953506538, 0.35785414758816725, 0.10985530183889602, 0.15121717658247325, 0.15100443289626053, 0.3881930265621242, 0.34736450408091746, 0.1383870199748971, 0.14741883883824736, 0.5098942541109557, 0.11377130148720371, 0.12308241408948029, 0.12466211522176762, 0.11968406326782788, 0.11242685004123287, 0.13046679584539111, 0.15536341641658924, 0.16607222956310708, 0.10982134926663623, 0.9867354749360543, 0.9812056630522222, 0.9861303478039294, 0.9802946895248045, 0.9808534086544182, 0.968378803385145, 0.9789605636505126, 0.986911260132192, 0.9959127073902044, 0.4109265646600647, 0.440794046111465, 0.44000148760191204, 0.40157208403611455, 0.4111938979755584, 0.39959455841598734, 0.4517800764766958, 0.40400863520480246, 0.34601772266382436, 0.2295837790476023, 0.2239039513859804, 0.8432574210241277, 0.2743171582977483, 0.27971469295341767, 0.1923924077164333, 0.23138458743087142, 0.21336613615961808, 0.8347004711146115, 0.13084538249625877, 0.40604288936711597, 0.5461323377531702, 0.4317627063449828, 0.4161723927792148, 0.359352343313619, 0.41347570974300096, 0.5343422348258, 0.5698658947996479, 0.503780170051065, 0.12921109187800794, 0.5410988962847193, 0.4765939994573455, 0.43520496387230123, 0.4797414832151574, 0.13161847345828337, 0.34599538538786934, 0.39746580587532865, 0.059976407735236714, 0.2291532643611276, 0.06757479774459285, 0.12155553111809603, 0.19236344661362603, 0.150740996783443, 0.5777935051438148, 0.3148886457715073, 0.33937330859067594, 0.574776202004955, 0.11575151295393227, 0.2808757567416619, 0.3081705165540485, 0.48343736076892285, 0.10044700193908263, 0.4207864066179704, 0.13963923215574137, 0.46705767012149735, 0.15140280350568425, 0.10019493178652561, 0.2688018832898932, 0.21591092348400875, 0.20071098226723338, 0.07469052068342685, 0.21619253976397024, 0.12345752033384882, 0.14382531602234339, 0.3114360196946946, 0.26061720012952083, 0.3756683287016843, 0.0065235945120555305, 0.20000643552270903, 0.34329641773882935, 0.17895713952700476, 0.29385836054163506, 0.30879165341124337, 0.576906578722882, 0.5116668777810218, 0.5159259196492046, 0.5534665902391455, 0.5361165605133913, 0.5345694755084314, 0.5391300589080961, 0.5193518642355675, 0.5545727274400141, 0.0703548065873032, 0.12857094275503078, 0.08295300326414412, 0.1337306435530774, 0.13113126426779798, 0.18302877621843094, 0.07584606767043045, 0.09776399944821501, 0.09655514666075105, 0.18829601113643912, 0.15151101675648548, 0.45473785156737934, 0.25678449901841416, 0.1965569631183265, 0.15492068026480976, 0.275758075468325, 0.17628889093719136, 0.20351060271174504, 0.42355360083263316, 0.33889537651383894, 0.4213028103853106, 0.4463197965395612, 0.36028497099629475, 0.40500616425641567, 0.43373940406966316, 0.4957380153264149, 0.3676604935001898, 0.255859484615649, 0.29453523306970986, 0.24273489401582715, 0.22470324519250473, 0.2787235678501554, 0.2635287385712046, 0.39643305192999523, 0.31593890984835293, 0.2613690095825604, 0.2465209599764273, 0.23300790681591232, 0.2015580955565387, 0.21233081691121147, 0.1828349116184348, 0.2546506039172399, 0.22995756022190883, 0.2269668215583991, 0.22137663879061142, 0.19747353796328615, 0.19796373994931282, 0.24940251958094772, 0.22951072436506348, 0.2418254378199428, 0.21038234211030815, 0.1931980954871524, 0.18309539232136673, 0.22033994649909383, 0.1726058787501732, 0.12580427933677807, 0.15368286158619027, 0.1733888954360111, 0.20049538218421648, 0.19870017935128803, 0.09940574107704725, 0.16856088708030892, 0.7667163410036588, 0.807028266140569, 0.15625966117568002, 0.7154010175761227, 0.20700872017500938, 0.5876113004000484, 0.7984285389738935, 0.10444674986007574, 0.15331769594010203, 0.16700642910594743, 0.20493890745098797, 0.19353698929689667, 0.21894441751925742, 0.18197713651096092, 0.20394304168936828, 0.1960633341645368, 0.20998544402901564, 0.1831435843875081, 0.22365726774401917, 0.08462669475269291, 0.07497600754068934, 0.08870145810565755, 0.08986450816095715, 0.10017457677510777, 0.0962293136565846, 0.07575710993990015, 0.1098851696042038, 0.10347650396100239]}, "mutation_prompt": null}
{"id": "896e7c9b-0514-449e-9b9a-894e52a20c13", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5  # Modified cognitive parameter\n        self.c2 = 1.5  # Modified social parameter\n        self.w = 0.6  # Updated inertia weight\n        self.F = 0.8  # Enhanced DE Mutation factor\n        self.CR = 0.7  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Modified cooling rate\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with dynamic parameter adjustment for enhanced global search efficiency.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7788812581129918, 0.66327232868538, 0.7351098101538884, 0.6682634052254023, 0.6758919861281198, 0.6021650671189396, 0.675737529153748, 0.7305594267205865, 0.6400960417169321, 0.6216743530382993, 0.5735989378162831, 9.999999999998899e-05, 0.5821561665269557, 0.5580830683515631, 0.6152869777197725, 0.5937181000577147, 0.5707687475148373, 0.1482207745862213, 0.22952088209026855, 0.16421833365592353, 0.32155074859875743, 0.27346883408056155, 0.3858935705678601, 0.4482042407371416, 0.10618452147245061, 0.24304585469113638, 0.1599841443968899, 0.171728216369596, 0.18900570416440066, 0.1110974114128721, 0.18465147414690686, 0.1457199313722911, 0.21691245934259895, 0.13993629220676007, 0.1305187235611306, 0.15286196062768542, 0.9855317216886283, 0.9889810571624404, 0.9892559108565263, 0.9620421235231948, 0.9723014068001635, 0.9710704942651273, 0.9858984659219806, 0.9791934706077374, 0.9771163566294263, 0.36562836069949667, 0.37680009521607805, 0.3559210526940776, 0.4276350634573879, 0.41219583512972147, 0.41244614113806655, 0.44106857936378296, 0.3809550430619486, 0.24337288802887047, 0.708110438837984, 0.2247186661257914, 0.223392601090879, 0.19398976486993202, 0.21260543032513246, 0.2036391785015318, 0.8212226822512128, 0.7548151088388358, 0.8195479699377823, 0.5264947342745762, 0.4954239780186618, 0.37529789609886255, 0.4890494727992323, 0.5616181780998843, 0.1279695678927525, 0.481484245831986, 0.3932645473072647, 0.5202799918787494, 0.4512824710286646, 0.3186850114461993, 0.2820345258281659, 0.4856948841164569, 0.3700465671833286, 0.13132926329143246, 0.1301313252768317, 0.4890507984720017, 0.3637635482069417, 9.999999999998899e-05, 0.3959701952330502, 0.08808197484607916, 0.05442690849843568, 0.3012683475791137, 0.017623637685056592, 0.26394561389597804, 0.3237967050045707, 9.999999999998899e-05, 0.5559711652619431, 0.5118770954780145, 0.5535607005837723, 0.5116792142170714, 0.48432434016533465, 0.3091855805281627, 0.12072155128670237, 0.6728952459023164, 0.5948126563227913, 0.2815199137026321, 0.03238911155438451, 0.06483530655720693, 0.12602338012174408, 0.08333356882382437, 0.15032785615286015, 0.4222033126513789, 0.08738625500560848, 0.1379529371371998, 0.43296553697194184, 0.37395144510219247, 0.39836349282707517, 0.33716922365034785, 0.0062258996391130195, 0.3647853486655185, 0.31340629416997157, 0.049390833342012774, 0.32656527442850103, 0.5382180779503241, 0.5517324730344417, 0.5140459467783416, 0.514622323614196, 0.5405337936975769, 0.5681684493847405, 0.5245457506414384, 0.4979184273247368, 0.520389598425426, 0.10518015118602164, 0.11037769139419162, 0.07490422239047201, 0.1384324351908217, 0.16578999400991, 0.13252532823602692, 0.11192293265128606, 0.13143265266830972, 0.10235230548891572, 0.19849332866590097, 0.2108830521027265, 0.14844202679292373, 0.21546565304258603, 0.22077983790721367, 0.23727614595555535, 0.3785173957191301, 0.1323533179654638, 0.22457391502997492, 0.32597749198720427, 0.4135721165992424, 0.38920014497176214, 0.4448605902920504, 0.4428362033852502, 0.43455501082049597, 0.45690505257989267, 0.4545950587878522, 0.41215565790097053, 0.2607555275168547, 0.24621967906478603, 0.2391537293262167, 0.26514750674939025, 0.2025299009411251, 0.29882344451470966, 0.3504652385699938, 0.40218455060985325, 0.2584772735387103, 0.24108639857381475, 0.17738086405757125, 0.1796715814884121, 0.19742962652631058, 0.2331776326716104, 0.2433935587451671, 0.19695902970119028, 0.20339531868228533, 0.2205431563735707, 0.6106584521381803, 0.24873796940895865, 0.2026805903456731, 0.24527152133392716, 0.2163361239765612, 0.22521035759339902, 0.5180123726970347, 0.5613401973564367, 0.22661517130107067, 0.1250306862277315, 0.1262215035989781, 0.1542146487771877, 0.1737440756213695, 0.19999097789655007, 0.7430196365808952, 0.09978357407768201, 0.7785025581420805, 0.7698124788209382, 0.863870357094473, 0.15667659927089284, 0.7900017856675209, 0.28542012784321646, 0.16815095445789852, 0.7508052330021034, 0.7238507914717743, 0.10458167462483847, 0.836615662012774, 0.19547357240926833, 0.17725868590916838, 0.18543089453037365, 0.17277660228862401, 0.18687194867292922, 0.18975994777117156, 0.18455940471126275, 0.20303311834883075, 0.18281822517712776, 0.10000289409348484, 0.08896528706822426, 0.08672667476914397, 0.08821319380526571, 0.07390022462038615, 0.0830436049036114, 0.10086150118181925, 0.08489072167646905, 0.08445833980704665]}, "mutation_prompt": null}
{"id": "8eb89b91-2a04-4ff1-bfe3-e5643643086d", "solution": "import numpy as np\n\nclass EnhancedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.2  # Adjusted cognitive parameter\n        self.c2 = 1.8  # Adjusted social parameter\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.7  # DE mutation factor\n        self.CR = 0.6  # DE crossover probability\n\n    def adaptive_weights(self, evaluations):\n        # Linearly decrease inertia weight\n        self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n\n    def chaotic_mutation(self, individual):\n        # Apply chaotic mutation for exploration\n        a = 0.7  # Logistic map parameter\n        chaotic_factor = a * individual * (1 - individual)\n        return np.clip(chaotic_factor, self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.adaptive_weights(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.chaotic_mutation(population[a] + self.F * (population[b] - population[c]))\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedDEPSO", "description": "Enhance exploration and exploitation balance in DEPSO by introducing adaptive learning rates and chaotic mutation for improved convergence.", "configspace": "", "generation": 91, "fitness": 0.1807175063129406, "feedback": "The algorithm EnhancedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.45422986836334545, 0.4654997713746659, 0.4136891573694159, 0.1833921237322066, 0.17911319171173667, 0.3639867272437455, 0.4296806050703105, 0.4339434566237401, 0.47485186429448834, 0.16741885736321094, 9.999999999998899e-05, 9.999999999998899e-05, 0.028819714264449292, 0.030070232841916678, 0.23692513271059923, 0.043645348144911944, 0.025498407131536394, 0.02798696389885358, 0.0628381974647485, 0.06853404340544966, 0.04652146688380876, 0.06913638297955427, 0.07510155756959835, 0.07970992772844543, 0.09369546711287635, 0.08551031651050867, 0.09751743489808273, 0.05757722823818079, 0.04560672619753592, 0.04598166362075351, 0.05778201543574324, 0.036243425762940706, 0.07219365334378158, 0.05782918000579862, 0.05678238570229732, 0.052701361535199664, 0.9880660969367722, 0.9953927892241129, 0.9942472807224714, 0.9718454716752658, 0.9835687465104137, 0.9760294298608321, 0.9854210360607418, 0.9856511573797816, 0.9881604492942435, 0.13107180855965705, 0.10221398225398592, 0.054696209549305985, 0.15900656085418685, 0.07714064308919277, 0.08829603819520893, 0.1058370340262873, 0.10944708331554176, 0.0924779010370177, 0.18636813334765978, 0.17899844877278825, 0.16195873411327555, 0.27247519539878495, 0.2097512674010561, 0.17172811646701824, 0.13317805353794177, 0.1114413481083677, 0.10194187230286755, 0.08859008374541322, 0.18225789528145775, 0.17092417269392735, 0.09834807727719796, 0.07741484218062955, 0.10180695591997924, 0.11176220825159822, 0.06890945757729527, 0.11776247495935954, 0.15272009216440852, 0.19642831645144743, 0.16000037164290404, 0.21015339960126367, 0.20103775406736435, 0.20816007709058082, 0.1469718290715335, 0.2135693648137984, 0.17848348943842085, 9.999999999998899e-05, 9.999999999998899e-05, 0.021050259790912462, 9.999999999998899e-05, 0.02239905967388567, 0.005268722915220625, 0.0326859551458516, 0.07101707662439771, 0.11005888356456761, 0.036377506656709246, 0.09328138826364962, 0.20957910508293576, 0.12510477274964504, 0.004592572406176276, 0.012397483933559994, 0.10910170881643644, 0.10190384223400728, 0.03860196138475336, 0.012843102383964689, 9.999999999998899e-05, 0.030620581850496653, 0.05866341625023286, 0.04936556868349962, 0.028140031588246184, 0.040205679283393914, 0.034301630017692375, 0.04286655997358846, 0.09003512164309646, 0.13268500903209712, 9.999999999998899e-05, 0.0831594090859693, 9.999999999998899e-05, 0.100403154901067, 0.027861724539414157, 0.037413471468354276, 0.05023886966252811, 0.35641003869924537, 0.3164534659192474, 0.4297236331524842, 0.3376644834505734, 0.3281631850570993, 0.3950726438214778, 0.3523892991722304, 0.34895147707831753, 0.3169901589661275, 0.04677885922434255, 0.03873124486989621, 0.08427582959401592, 0.07176605903161637, 0.06545783850678455, 0.08509198825260778, 0.07545698405891599, 0.0643531686024229, 0.07605683776790206, 0.15965076926876465, 0.15256096866485191, 0.15817444728435515, 0.1465119618945635, 0.14570739217661377, 0.12877299865293956, 0.14567740257931672, 0.15260970917177952, 0.14230767740620143, 0.15502388745547013, 0.14048885540991563, 0.22687060451887286, 0.2021080716945729, 0.2374955836405297, 0.2080617520953314, 0.26688305895720954, 0.2558175457332966, 0.17887415547183994, 0.10723206348529934, 0.1287204090752272, 0.13605173403226456, 0.1870879133404889, 0.14653346555914448, 0.11597299271842998, 0.1259838721332488, 0.12062974708203178, 0.15685210327534116, 0.2232821755791562, 0.13964805775050937, 0.21227645267337225, 0.23000182355828436, 0.20469005015936148, 0.17345904897939746, 0.21127147805841007, 0.17361621665565907, 0.21107570115969565, 0.16898042771979194, 0.18959912137023094, 0.19404703970582127, 0.17822388691145474, 0.1683501042008556, 0.17065211662834368, 0.18761994405260118, 0.1746617695654733, 0.1759736695109384, 0.18618080949004523, 0.1991340774599053, 0.11306982737365723, 0.4982498342001995, 0.18526704720846088, 0.18453544834238444, 0.10432544609811045, 0.1335425857385968, 0.5277453333297901, 0.6094531407881619, 0.21011406775681796, 0.35102845710854813, 0.3070039935592759, 0.16226979680515685, 0.15607467758582805, 0.1837165029662371, 0.09944032025341787, 0.1110308718456694, 0.17089511368334498, 0.17735217755809862, 0.17958884789031582, 0.16815551014735142, 0.17250799901316127, 0.17842839765254048, 0.19451340314455057, 0.1833544084930876, 0.19091263216897236, 0.05752230972742478, 0.053352160354372735, 0.07108158298719736, 0.05738827217778486, 0.0593332500747229, 0.07481257235388095, 0.059360393847254445, 0.05812392323081006, 0.06548951257331503]}, "mutation_prompt": null}
{"id": "c78b7859-3d2c-4366-8732-95ec0f5c357a", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5  # Slightly reduced inertia weight\n        self.F = 0.8\n        self.CR = 0.7\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9\n\n    def chaotic_sequence(self, size):\n        # Generate chaotic sequence using the logistic map\n        seq = np.zeros(size)\n        seq[0] = np.random.rand()\n        for i in range(1, size):\n            seq[i] = 4 * seq[i-1] * (1 - seq[i-1])  # Logistic map\n        return seq\n    \n    def dynamic_parameters(self, evaluations, chaos_step):\n        self.F = 0.5 + (0.3 - evaluations / self.budget) * chaos_step\n        self.CR = 0.5 + (0.4 - evaluations / self.budget) * chaos_step\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        chaos_sequence = self.chaotic_sequence(self.budget)\n        \n        while evaluations < self.budget:\n            chaos_step = chaos_sequence[evaluations % self.budget]  # Apply chaotic sequence\n            self.dynamic_parameters(evaluations, chaos_step)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveMultiStrategyDEPSO", "description": "Integrate adaptive multi-strategy differential evolution and particle swarm optimization with chaotic maps for improved global search and robustness.", "configspace": "", "generation": 92, "fitness": 0.35482254796374185, "feedback": "The algorithm AdaptiveMultiStrategyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.8266831583223946, 0.8595317254783826, 0.821449647466008, 0.8321311617713355, 0.7569113054190433, 0.6253582599051233, 0.7320662982181168, 0.8601505021146645, 0.720218425777651, 0.674725525295967, 0.7175050625998725, 9.999999999998899e-05, 0.04680009350480996, 0.0634620643279713, 0.7069428736454875, 0.5847659832683827, 0.7155856224643482, 0.05363146751642367, 0.5377899229663131, 0.14541207334855644, 0.16925501383296504, 0.1542515484895146, 0.17776876105509531, 0.6210213118404393, 0.14631419469080997, 0.5832241018667144, 0.14120478843358253, 0.16896961662459375, 0.14915249355967153, 0.11166029398189403, 0.1105690938477546, 0.16578380973573237, 0.10495491431121085, 0.11906447489461103, 0.1165247288832868, 0.12137553775356269, 0.9794027673411084, 0.992156979957087, 0.9876044303173903, 0.9731335604125849, 0.9592052733121991, 0.9650433602850611, 0.9871062266084089, 0.9706138842725897, 0.9694249225567876, 0.48509942162656217, 0.5198141007858286, 0.5568934988591778, 0.5443928824436367, 0.5553944422055686, 0.5447331373447962, 0.494394153503778, 0.4232300563145024, 0.5307524369670282, 0.8642216682248849, 0.8421060320784773, 0.22604892232483897, 0.2786717332330034, 0.19315509610780435, 0.19334009031092647, 0.23617866957016753, 0.8391241434026838, 0.8234334950758906, 0.6323918163071542, 0.5574426807280407, 0.12854037248192451, 0.5666689652759487, 0.6884068299820367, 0.5422646561778542, 0.5726884714956166, 0.541607513130489, 0.6566340038389223, 0.586267128636303, 0.1280206184244651, 0.13125451599366367, 0.1353592371136625, 0.5918334425633112, 0.42891378346708264, 0.13266931289373862, 0.4132663478756877, 0.12942270792170363, 9.999999999998899e-05, 0.15517936757411732, 0.15363260115401645, 0.09580433006086164, 9.999999999998899e-05, 0.01739687745010865, 0.18815977987068544, 0.3379870263839162, 0.2567021030280072, 0.07579412413347342, 0.1191234259714552, 0.6154938237269454, 0.15318551640082878, 0.16299844126383034, 0.0642245858190259, 0.3936843545416242, 0.5949259430077061, 0.4604522731055467, 0.2958639004541602, 0.467122497366689, 0.04836619084778615, 0.17285790659319755, 0.07727327215880397, 0.12217491103548073, 0.18294572948036025, 0.19150450243316486, 0.07150319408295669, 0.26384358033068, 0.38801413540313356, 0.39828264343812625, 0.3007115474832295, 0.4111478632503752, 0.4586684268574751, 0.329405730715179, 0.04911734911228627, 0.08246683055897597, 0.5508061028535266, 0.5691171461873257, 0.5347449234328299, 0.5430185895424834, 0.5844000220264324, 0.5816873803353084, 0.49749752265687297, 0.488725569048184, 0.47880059136672803, 0.14147445840923323, 0.07977171676642869, 0.08984613764956118, 0.10334620875042366, 0.07911966717546837, 0.14161143519741304, 0.15987293782179712, 0.09549850681583483, 0.12711084633729897, 0.17640106791462462, 0.24492646940021967, 0.18263853634870675, 0.18929147789245004, 0.167060359922669, 0.6879749331910627, 0.45731269051996826, 0.15966705320470753, 0.2088809339668053, 0.2099181704310703, 0.26618767073741834, 0.4178797647454269, 0.368264174618142, 0.42102330979737335, 0.25425158492524624, 0.40888667693300407, 0.28313001834967766, 0.3401989710816946, 0.27564146877264606, 0.2693450751455029, 0.2871622970416855, 0.3772387760423237, 0.19096369302218186, 0.25174264544079195, 0.32452519827421134, 0.35741773020154455, 0.25736875655978897, 0.26136721356418446, 0.23896683991015688, 0.2341372028633092, 0.21847730479980654, 0.20422849084122496, 0.18445099894705785, 0.20115834051667136, 0.21716690924509974, 0.20502043288387706, 0.2510844193721329, 0.24990540263798744, 0.20986691775816946, 0.24848602089751792, 0.22252520433563205, 0.23544350545024706, 0.22816311864782024, 0.20651297842639438, 0.19865662927353234, 0.9043634426769338, 0.1760560269085205, 0.15361413742658803, 0.17377177373512953, 0.2010840853436271, 0.20071092322776363, 0.1001820493325396, 0.8937797998137695, 0.7091514982491676, 0.8164386594519122, 0.1574869444783069, 0.7989552360828991, 0.757799975153953, 0.16886186765911404, 0.8654794935689896, 0.10507906932645561, 0.10518934712993033, 0.6794913766688928, 0.18483379080782703, 0.2426929754430256, 0.19437282185105864, 0.2025434042684371, 0.19577418363892063, 0.1944499371752465, 0.20157513685041262, 0.19025939175799234, 0.2233583075487633, 0.09631510971129154, 0.08964741438401047, 0.08841003614926934, 0.10161703868971217, 0.09876482604511094, 0.07339545787016599, 0.09763431431933, 0.1079062424778997, 0.09639863566347517]}, "mutation_prompt": null}
{"id": "92de34c7-1565-4c2f-b794-92b4c969f1ce", "solution": "import numpy as np\n\nclass AdaptiveLevyGaussianDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0  # Increased cognitive parameter\n        self.c2 = 1.5  # Retained social parameter\n        self.w = 0.5  # Reduced inertia weight for better convergence\n        self.F = 0.9  # Dynamic DE Mutation factor\n        self.CR = 0.6  # Adjusted DE Crossover probability\n        self.sigma = 0.1  # Standard deviation for Gaussian mutation\n\n    def levy_flight(self, lam):\n        u = np.random.normal(0, 1) * (0.6966 / np.abs(np.random.normal(0, 1)) ** (1 / lam))\n        return u\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.5 + (0.3 * (1 - evaluations / self.budget)) * np.random.rand()\n        self.CR = 0.5 + (0.4 * (1 - evaluations / self.budget)) * np.random.rand()\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                if np.random.rand() < 0.5:  # Apply Lévy flights\n                    step = self.levy_flight(1.5) * (population[i] - global_best_position)\n                    trial += step\n\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n                \n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i] + self.sigma * np.random.normal(0, 1, self.dim)\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "AdaptiveLevyGaussianDEPSO", "description": "Enhance convergence by introducing Lévy flights for exploration, Gaussian mutation for local search, and adaptive parameter tuning for balanced exploitation and exploration.", "configspace": "", "generation": 93, "fitness": 0.28554179473787256, "feedback": "The algorithm AdaptiveLevyGaussianDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.735188210337538, 0.7313526061761957, 0.7357713097770776, 0.7335882311446973, 0.7101540690108767, 0.7586113959467103, 0.7140924022856153, 0.7391347210603137, 0.7184489783230372, 0.3550715729687487, 0.35237559168574173, 0.3468142841680344, 0.31837741139801834, 0.3333716088118813, 0.3912138847576191, 0.37580717392909513, 0.34310984424975544, 0.34937338165005927, 0.09938490725568006, 0.17805055419208493, 0.21476041115354327, 0.139191484327024, 0.13739668128338056, 0.14870684841012038, 0.1403078251249592, 0.13037689361000337, 0.09487534595582237, 0.14898090838796196, 0.13575759679651456, 0.11916411371505797, 0.11447050076889953, 0.09581278783906766, 0.11171162927339029, 0.12474147677905711, 0.13418038466690285, 0.1144035926010456, 0.9851508096480467, 0.9879251662451877, 0.9861736871723005, 0.9851662019669006, 0.9935940815133689, 0.9782683638419373, 0.9885009753424059, 0.9889324020409066, 0.9886940940312885, 0.381971654283783, 0.3561385083735511, 0.3688217923137975, 0.34281851120385365, 0.3554048049849874, 0.3638169182796058, 0.33537190621424584, 0.34867023320362855, 0.37561109345092214, 0.6056774404901003, 0.7568341849479109, 0.7404009399687863, 0.5950229583910502, 0.7482146530725038, 0.21213126268828797, 0.6632331123501947, 0.20826860761196442, 0.7436433353205185, 0.24774712232015894, 0.1048084522558611, 0.21786387561550347, 0.21563562191224017, 0.2437866976416031, 0.21370788149021136, 0.2097922733396388, 0.30547891531752136, 0.19032318272491133, 0.2588412964034281, 0.19988030387268618, 0.2148636404859352, 0.13411691176989138, 0.20791796687632946, 0.2035002692087512, 0.12617511725694008, 0.1305349926726722, 0.1296205287115858, 0.09680674647626897, 0.00575488226732801, 0.05681372791645367, 0.026968390722373448, 0.007953184180511164, 0.01838588475689107, 0.009897699334095678, 0.08285296672910769, 0.06454237692194442, 0.1071467287690373, 0.08273444015464915, 0.17826983991976375, 0.10799382514261013, 0.1054707260982577, 0.15765329500894654, 0.2035128890642255, 0.11846949879206403, 0.07924045591549911, 0.012896381145842684, 0.04322642567137969, 0.04095425688105625, 0.04040480446492234, 0.04426652981311585, 0.01161646452543541, 0.03325460027778315, 0.07308731756492592, 0.04930300475497118, 0.16679494705000342, 0.12288979607387862, 0.1409038227642202, 0.14695943400717315, 0.1293683220013141, 0.16762541526338337, 0.1385258721636834, 0.146344081590154, 0.1239939714279531, 0.47453460933590885, 0.49623524904660554, 0.46726561655493914, 0.4829561353744469, 0.4710447262367742, 0.4614560579968733, 0.47876128646603444, 0.514228309187049, 0.5040571449778397, 0.0942372135297328, 0.09176371769820235, 0.10187421431501475, 0.12434205236405449, 0.07252577299313867, 0.13023890997721665, 0.1444216676766169, 0.14932136172011157, 0.08681094997260186, 0.34734661631475294, 0.17799024228437743, 0.18376443373980234, 0.328550615782256, 0.3867225785635272, 0.1759789400663594, 0.32165829528027323, 0.30364139725654893, 0.21664479454078767, 0.3139481427289388, 0.34979417136385516, 0.3493280025451865, 0.3212748660957323, 0.2888258397721214, 0.24251331840901846, 0.3676241646520939, 0.361134085920653, 0.36899611630750784, 0.2288256365451662, 0.1920815353555172, 0.23231230165921168, 0.25823894551808624, 0.2680382106011261, 0.23464237393907939, 0.25340674426250853, 0.3028926326600715, 0.2514339136175152, 0.19206707427768765, 0.21589418660919868, 0.19482044870730908, 0.20747571696817058, 0.1786735280741697, 0.19240559858814987, 0.19509945567309295, 0.1851188892243354, 0.2063841473602479, 0.23548705601471842, 0.2380790095837455, 0.2368564809500162, 0.2137986008556182, 0.20195270643182717, 0.19486983139314107, 0.21944745681042888, 0.1943644240480049, 0.21087026934885844, 0.8453723070661561, 0.18342355169005764, 0.15427649112554442, 0.8651373434378428, 0.2010719093680966, 0.16990868811708137, 0.8061334454863955, 0.16871985517596855, 0.8659453873945887, 0.7788403942622122, 0.15701658817056796, 0.11207594066101845, 0.20860235042659714, 0.1679897220212937, 0.20957842132607107, 0.10511542034049404, 0.2122890773774867, 0.20979177320870046, 0.18645606316833474, 0.18666865189575466, 0.17215370198504565, 0.18933377177285027, 0.20734972593190704, 0.17434376630364423, 0.19088675261874388, 0.18020832871986747, 0.1872260520231086, 0.08504520168502472, 0.08384369780344891, 0.06951437368035751, 0.0888079814005851, 0.0762521226215569, 0.06862319891883129, 0.06932689214492216, 0.07347990465191834, 0.07280364301378561]}, "mutation_prompt": null}
{"id": "83653858-de17-4612-b00b-3b9e64b885f4", "solution": "import numpy as np\n\nclass EnhancedChaoticDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.95\n\n    def chaotic_map(self, x):\n        # Using logistic map for chaotic behaviour\n        r = 3.99\n        return r * x * (1 - x)\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters using chaotic maps for better exploration\n        self.F = self.chaotic_map(self.F)\n        self.CR = self.chaotic_map(self.CR)\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def local_search(self, individual, score, func):\n        # Apply a simple mutation-based local search\n        candidate = individual + np.random.normal(0, 0.1, size=self.dim)\n        candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n        candidate_score = func(candidate)\n        return (candidate, candidate_score) if candidate_score < score else (individual, score)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score, _ = self.local_search(trial, func(trial), func)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedChaoticDEPSO", "description": "Enhance global search capability by integrating chaotic maps for parameter adaptation and implementing a diversity-aware local search strategy.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "63fe8ee6-82fa-4e90-8610-6f03c0f7ddff", "solution": "import numpy as np\n\nclass EnhancedNeighborhoodDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Adjusted population size for better exploration\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Slightly adjusted cognitive parameter\n        self.c2 = 1.3  # Modified social parameter\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.7  # Enhanced DE Mutation factor\n        self.CR = 0.6  # Adjusted DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-4  # Finer cooling adjustment\n        self.alpha = 0.95  # Modified cooling rate for annealing\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust parameters dynamically based on function evaluations\n        self.F = 0.4 + (0.6 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.4 + (0.5 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n        self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n\n    def neighborhood_search(self, individual, eval_func):\n        # Local neighborhood search to enhance exploitation\n        neighbor = np.clip(individual + np.random.normal(0, 0.1, self.dim), self.bounds[0], self.bounds[1])\n        neighbor_score = eval_func(neighbor)\n        return neighbor, neighbor_score\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i])\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                # Apply neighborhood search to further refine solutions\n                if evaluations < self.budget - 1:\n                    neighbor, neighbor_score = self.neighborhood_search(population[i], func)\n                    evaluations += 1\n                    if neighbor_score < personal_best_scores[i]:\n                        personal_best_scores[i] = neighbor_score\n                        personal_best_positions[i] = neighbor\n                        population[i] = neighbor\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedNeighborhoodDEPSO", "description": "Enhance the current DEPSO algorithm by incorporating a global-local neighborhood search strategy and adaptive inertia weight adjustment for improved convergence and robustness.", "configspace": "", "generation": 95, "fitness": 0.25874835465893825, "feedback": "The algorithm EnhancedNeighborhoodDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.5240626670042718, 0.43730794916738325, 0.5163047006603303, 0.46987734515884283, 0.4179483125737359, 0.4393928953229308, 0.5426108481624328, 0.4469438050332334, 0.47449384850882326, 0.29569018571191397, 0.255227217183464, 0.25449354056320206, 0.27976871489579636, 0.29094731945807184, 0.2549725972038017, 0.2808217793976898, 0.2749441544355238, 0.3036713168363432, 0.1554328971830462, 0.1163576683301486, 0.1209956701447592, 0.14012747820653837, 0.13507918914604633, 0.14083304181002188, 0.12439889168654594, 0.16428598267655925, 0.14468425950055175, 0.13176145886575685, 0.1159425235398911, 0.10942901297648155, 0.10883940614331078, 0.11370696946489045, 0.1250643028597187, 0.12206049399561214, 0.11915858076892094, 0.12057482607636516, 0.978701093635899, 0.9810619673446656, 0.9778433539501228, 0.938548970679173, 0.9693857794082764, 0.9626727009941375, 0.9772719890817688, 0.9654536895086715, 0.9673863892265524, 0.26804151796667464, 0.26493781287316953, 0.24315828546349338, 0.3049146347317563, 0.21847640423430392, 0.24921645113600854, 0.252158247650363, 0.23412270933126889, 0.27972638710428055, 0.5361859899361663, 0.45611631173456146, 0.35924782966786484, 0.5004048900670046, 0.31614994964372023, 0.30749958878066286, 0.5234731705627358, 0.3960838389958833, 0.5386848655726713, 0.20585424168543254, 0.205779760491143, 0.18620673554298606, 0.16428776134561462, 0.18462920905782332, 0.21214658024929234, 0.23902266924550963, 0.14391329335538106, 0.20819585597241164, 0.19555801720902122, 0.2582299662270696, 0.23748170495908028, 0.19526652341111772, 0.23289979945379924, 0.22779660281419634, 0.2134488339816103, 0.20391171568413247, 0.21238466609534157, 0.1016214973353583, 0.008110046571064622, 0.06389073978861703, 0.017784547224573233, 0.10693150004285978, 0.045990762834218324, 0.11469181726734934, 0.1164445968045833, 0.12267632607589385, 0.2558732649518132, 0.2075217209031095, 0.2209410419878003, 0.20518307756052367, 0.15983531643106175, 0.16967494139001715, 0.24273535606122454, 0.27604303688677023, 0.26812078363951564, 0.056528063666144934, 0.059914333752452476, 0.07979102750059641, 0.02220634188666082, 0.028321580789897993, 0.044053063325982134, 0.11673853233579379, 0.11910939308126367, 0.07696070046544867, 0.17207883339887065, 0.15248924002811437, 0.18575348887126508, 0.17848244286993464, 0.1869173909265981, 0.1707328438503628, 0.1507386041967348, 0.17328700449342616, 0.14295263796675794, 0.4274769779168538, 0.4113462890066396, 0.4253929622416672, 0.375106778258965, 0.39444289116006725, 0.40201029976610925, 0.414780944866485, 0.3954643370634532, 0.3635765829636828, 0.10565872434521006, 0.08832572554698015, 0.11374699276256617, 0.12336836749507563, 0.11738404891844678, 0.10203531821903178, 0.10036968038568717, 0.115471493724145, 0.1896169761449995, 0.2052339971979088, 0.2550196547221444, 0.17628077485708527, 0.20791923116756117, 0.188607267593787, 0.22625684079612363, 0.24529839179609825, 0.22050316766213296, 0.20256778280790422, 0.2653920517246272, 0.30495489821614874, 0.279843237407011, 0.3011610217448686, 0.26779470256143245, 0.26784504411319987, 0.29924207061040986, 0.2859919612239036, 0.28916452436772344, 0.23792822974927208, 0.19195552273643401, 0.19725913249533367, 0.2504844918627538, 0.20961424866660716, 0.1961583502870633, 0.23935371509271586, 0.2460394112142642, 0.23868732473783116, 0.18870559849466095, 0.20613259991580346, 0.20003288210811543, 0.20275482404002876, 0.18958102737963456, 0.20163983304902533, 0.20368380076866688, 0.21268075985389823, 0.18596097320228178, 0.279738714555012, 0.23813073253063588, 0.2148600344856596, 0.2833255874947904, 0.2595515191915746, 0.21366149359662745, 0.19923524596476905, 0.192559221482002, 0.264252682768477, 0.5078806636858755, 0.28104661667508346, 0.15135441452931975, 0.5335457845447862, 0.19708456860365098, 0.19665355242477256, 0.14318964973726833, 0.1667146655666455, 0.2076558314373289, 0.5728237022948621, 0.20608066861480911, 0.5919841426119526, 0.4687631807767211, 0.16758302990773222, 0.3531596597941311, 0.4472735279023108, 0.15080248049313738, 0.5291932995157835, 0.17999414710723272, 0.17538133401221134, 0.17528267020494082, 0.18457722831108536, 0.19039759229835673, 0.18218979073773, 0.16737923023523782, 0.1854750561019859, 0.18788201056426013, 0.07918730979282951, 0.07547637737512414, 0.07680493975174907, 0.0748832423697795, 0.09318346590245385, 0.07403203093100275, 0.07048165396305317, 0.0666767744103316, 0.09567384018661818]}, "mutation_prompt": null}
{"id": "aa29e0c2-be32-457b-8e63-6256415c369e", "solution": "import numpy as np\n\nclass HybridAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size for diversity\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Enhanced cognitive parameter\n        self.c2 = 1.7  # Enhanced social parameter\n        self.w = 0.5  # Reduced inertia weight for faster convergence\n        self.F = 0.9  # Increased DE Mutation factor for exploration\n        self.CR = 0.6  # Modified DE Crossover probability\n        self.oscillate_freq = 5  # New parameter for oscillation frequency\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.85  # Modified cooling rate for temperature\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        phase = (evaluations // self.oscillate_freq) % 2\n        self.F = 0.6 + 0.3 * phase\n        self.CR = 0.4 + 0.2 * phase\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))  # Zero initialization for velocities\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveDEPSO", "description": "Hybrid Adaptive DE-PSO with Oscillating Strategies (HADOS): Incorporates oscillating strategies with adaptive learning rates to enhance exploration and exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.33870829225753785, "feedback": "The algorithm HybridAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.7729130387747134, 0.7708971409549972, 0.8003629662601706, 0.6131464493452237, 0.7666492379336585, 0.7474262133880516, 0.7804742316008726, 0.7161023583004509, 0.6330998547779514, 0.5752875524511396, 0.6193022001148419, 0.559096953633996, 0.5042719140469709, 0.5773248653972114, 0.5943391062513428, 0.046571558778085276, 0.585020597933394, 0.053952646615195055, 0.23244628687035984, 0.16950041187712883, 0.3014355421259195, 0.38362698764830916, 0.2637593025399725, 0.22230619453789835, 0.27234613399738017, 0.23264305029251375, 0.3146032078974612, 0.14280879910880062, 0.0912093250402719, 0.10910302356909851, 0.18888435391437253, 0.15232563996905935, 0.17706779800085026, 0.15469850820623177, 0.14043481426917281, 0.22495033812765186, 0.9923902961174882, 0.9953303043922357, 0.9907983663015026, 0.9725813371543947, 0.9830755872020482, 0.9615419581286536, 0.9926767069372662, 0.9798392174495575, 0.9687161060514226, 0.44105413416011185, 0.39132210382109556, 0.34169975244104267, 0.4115346619903416, 0.25852129920017464, 0.4185186998513658, 0.376612257240172, 0.34802753778741824, 0.39191847987274964, 0.7970050272125231, 0.771405444083725, 0.3717408414862178, 0.20740770888446436, 0.2087023988608151, 0.8031937721290369, 0.3393021270741525, 0.16533640357001333, 0.24346021152696917, 0.5911873564758978, 0.1311731743355673, 0.4932878932860424, 0.4331284989120212, 0.4059635670759256, 0.5378083113671184, 0.44451895969162336, 0.4965265696642066, 0.5555073013713212, 0.13165541190053232, 0.12951274177756877, 0.5215563798998686, 0.30068489601651427, 0.3759052176745761, 0.51740399384116, 0.4861891415331886, 0.5250265658861126, 0.13100666418993623, 0.10441470473107817, 9.999999999998899e-05, 0.08315697115153775, 0.26982818740094794, 0.3058424236864453, 9.999999999998899e-05, 0.11662677353707951, 9.999999999998899e-05, 0.3192417899783768, 0.107247096958628, 0.11959552237675819, 0.16246899597020859, 0.08281687032053286, 0.21175674140664835, 0.1255949815935492, 0.6169075991565317, 0.3449660139949703, 0.42749062194620746, 0.045593038301214084, 0.2622472792034457, 0.043738273364959834, 0.10761950625454397, 0.2588008705511351, 0.09662587194129812, 0.27687847987846703, 0.08088868554228179, 0.06779401460862933, 0.32874262653948305, 0.26475656848298434, 0.3091460208657191, 0.006059546824091933, 0.4080403396594935, 0.3235621384630618, 0.4305889769943281, 0.08101813494749843, 0.39077962021790713, 0.5437267858953411, 0.5436522978453987, 0.5863656581243907, 0.5455218262643832, 0.558395245828379, 0.5344858349411842, 0.575166190055959, 0.5554883040597407, 0.5572162008835555, 0.09509369188098749, 0.14093388188815625, 0.08015008342209406, 0.08193302419098658, 0.1189198363076912, 0.10157384720415796, 0.1277822028142953, 0.12155443049380643, 0.10877893621790702, 0.1771082077979127, 0.2488326769304614, 0.1770611033890631, 0.18232189293279466, 0.4170394492506071, 0.18474694445759698, 0.25381419429079566, 0.22815217302979618, 0.21091521302893512, 0.1902547096331354, 0.214948041535994, 0.4314893373545019, 0.47256381101816414, 0.34169237716091627, 0.4943664222230183, 0.35295539394677267, 0.47607927825488483, 0.38549768371843973, 0.20864298796515646, 0.21923256875371244, 0.2377467649496029, 0.29193024485633945, 0.2761013279365372, 0.24981379165971185, 0.3001288916559057, 0.22019157428198177, 0.29452910707720814, 0.20033890218170047, 0.20824777449787701, 0.30740879565703294, 0.1970050887563921, 0.18723483025707488, 0.2155750045392617, 0.20867779148818055, 0.21775201584965487, 0.20252353264290623, 0.2291492959692678, 0.22099915519102253, 0.21643412668934237, 0.2477229483421981, 0.21231445589969566, 0.49560335846974857, 0.24127992350775962, 0.19699833373288245, 0.2364051626486665, 0.8319296399489228, 0.18501415409218258, 0.15347260372261462, 0.8506911524062238, 0.19874849067280753, 0.7321201529699405, 0.14209398235156045, 0.16900357725081505, 0.8554620265814816, 0.899788487391679, 0.21244827418543755, 0.15043277152769063, 0.21049298536415995, 0.1677282402245277, 0.7351939219551913, 0.20824859692487185, 0.16821688591440032, 0.8289814049057846, 0.1891694658360158, 0.18973186928271402, 0.18972458000675152, 0.18339196556810844, 0.18287391931874253, 0.21579487261121066, 0.17976052503044193, 0.18844939898407642, 0.2019724070439599, 0.08708276007606042, 0.08494684489483373, 0.08595849375699449, 0.08735473231712299, 0.062204260103658315, 0.09518402126847503, 0.09613024975935691, 0.08808213688833388, 0.09326705553510162]}, "mutation_prompt": null}
{"id": "8f14c5d2-9779-4d60-8d66-9d87fcc4a927", "solution": "import numpy as np\n\nclass EnhancedLevyChaosDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.6  # Slightly increased cognitive parameter\n        self.c2 = 1.4  # Slightly decreased social parameter\n        self.w = 0.5  # Reduced inertia weight\n        self.F = 0.9  # Increased DE Mutation factor\n        self.CR = 0.8  # Increased DE Crossover probability\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.9  # Cooling rate\n\n    def levy_flight(self, lam):\n        sigma1 = np.power((np.gamma(1 + lam) * np.sin(np.pi * lam / 2)) / (np.gamma((1 + lam) / 2) * lam * np.power(2, (lam - 1) / 2)), 1 / lam)\n        u = np.random.normal(0, sigma1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1 / lam)\n        return step\n\n    def chaotic_map(self, x):\n        return (4 * x * (1 - x))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))  # Initialize velocities to zero\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        chaos_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            chaos_factor = self.chaotic_map(chaos_factor)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c]) + chaos_factor * self.levy_flight(1.5)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / self.T) > np.random.rand():\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) + self.c2 * r2 * (global_best_position - population[i]))\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedLevyChaosDEPSO", "description": "Enhance exploration by incorporating Levy flight-based exploration and chaotic maps to improve convergence speed and global search capability.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {}, "mutation_prompt": null}
{"id": "43bfe9cb-b990-4305-9ea4-6bf3b752c5ec", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Adjusted population size\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.7  # Modified cognitive parameter for increased exploration\n        self.c2 = 1.7  # Modified social parameter for increased exploration\n        self.w = 0.5  # Reduced inertia weight for faster convergence\n        self.F = 0.7  # DE Mutation factor adjusted for diversity\n        self.CR = 0.6  # DE Crossover probability adjusted for diversity\n        self.exploration_weight = 0.3  # New parameter to balance exploration\n        self.exploitation_weight = 0.7  # New parameter to balance exploitation\n\n    def dynamic_parameters(self, evaluations):\n        # Adjust DE parameters dynamically based on function evaluations\n        self.F = 0.4 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.4 + (0.3 - evaluations / self.budget) * np.random.rand()\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - population[i]) + \n                                 self.c2 * r2 * (global_best_position - population[i]))\n                velocities[i] *= self.exploration_weight\n                trial = population[i] + velocities[i]\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i] or np.random.rand() < self.exploitation_weight:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    population[i] = trial\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization with Dynamic Exploration-Exploitation Balance", "configspace": "", "generation": 98, "fitness": 0.1747036587536284, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.735470020442783, 0.8692985894081127, 0.8249323816838533, 0.9092796398910011, 0.3406005349196677, 0.31741655295548254, 0.3232872169454719, 0.4024060098545409, 0.403544849413653, 0.016958662478528508, 9.999999999998899e-05, 9.999999999998899e-05, 0.0713697242647795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1262155795403771, 0.13390160298406573, 0.13254381049385788, 0.08598852548086122, 0.12569709329381662, 0.11669793670313555, 0.12431638017683311, 0.11009087058830702, 0.13398369350993822, 0.08150301063816878, 0.09474967256498457, 0.07601271296508183, 0.07405039906993371, 0.14133052061452567, 0.11636795800125987, 0.06651175768031314, 0.141995898939538, 0.06643065156147954, 0.09713751293148176, 0.12734864113538658, 0.07603579314240638, 0.1306156145094014, 0.10388275893843169, 0.10140570283152461, 0.13346291447682923, 0.08544561256899619, 0.10464972542068085, 0.13080224284616648, 0.07612811309630085, 0.062013040420486276, 0.16665964667438815, 0.12279116478031626, 0.13600148522126454, 0.11140407775871286, 0.11486016831245927, 0.08689488032564063, 0.17266082387369075, 0.1417367370450977, 0.21613963189826213, 0.2806311292174164, 0.22138272750822785, 0.24187919092796806, 0.16133555080536388, 0.17484664835932762, 0.1757329969184308, 0.31823692172940676, 0.07555825934255322, 9.999999999998899e-05, 0.09424473302107272, 0.15967970609712268, 0.012379832385457479, 0.24835905650707568, 0.13282038554646347, 0.14465879785808122, 0.15899028972506568, 0.13013155184420788, 0.1467373388753882, 0.17787871427314328, 0.15624355007538993, 0.021121986646933544, 0.1663700669542142, 0.12855778379067928, 0.11935489678490507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1274537619533851, 0.06122298278716187, 0.08378503598666631, 0.05498836339481239, 9.999999999998899e-05, 0.03470733525471459, 0.03627433673119862, 0.12113685997496926, 0.08827019243789058, 9.999999999998899e-05, 0.1359362559071411, 0.1504596692030311, 0.09270689083960171, 0.08371235809085464, 9.999999999998899e-05, 0.13257746206913457, 9.999999999998899e-05, 9.999999999998899e-05, 0.014573791519668755, 0.15301436417302416, 0.15454816065996257, 0.022418229011783808, 0.07421063131508832, 0.09328230665679771, 0.1127924437881147, 0.003952490246735385, 0.07325481824172164, 0.4307213818433039, 0.3637690339606767, 0.4620367402948018, 0.2670290653629829, 0.30198697026934285, 0.3990577601507558, 0.3538764624028271, 0.4596062484869635, 0.3773247217654574, 0.07383058025913558, 0.06470747417527489, 0.036070439759866346, 0.12404231567451895, 0.07678165560050365, 0.14386746511908455, 0.11208683146366416, 0.08690654161978195, 0.11747583787436633, 0.13058319243156058, 0.4332793202549573, 0.19657475130163704, 0.1611306537435646, 0.21869980371764863, 0.13069681160801827, 0.30267181065957105, 0.2661164375791871, 0.19821841189681544, 0.2085764012633855, 0.18761379107647713, 0.1974728313154106, 0.3007114902375907, 0.23130099046641295, 0.3260715616315114, 0.1917039490374527, 0.26942095235451013, 0.14313277540918046, 0.14515824379719544, 0.24496379602907004, 0.24053632666319713, 0.2557853926878578, 0.20675546885361096, 0.20840701915629156, 0.12628442192672207, 0.28202446170845474, 0.22563918781364278, 0.3024596024222119, 0.2413703012793217, 0.2742453204538746, 0.17581667118160094, 0.25676712755406483, 0.21240455093610577, 0.20772592004254953, 0.2604269639396114, 0.22429673676577955, 0.19747851468699162, 0.17297722655002212, 0.16644173127288608, 0.16746484644272464, 0.1764912956037109, 0.19033254314070114, 0.16656215299847876, 0.2029094782664953, 0.16905242394109643, 0.1774251721699076, 0.18810765085726266, 0.1469887712175839, 0.46970278989713976, 0.20010756905164384, 0.19616025999702358, 0.5370045495726661, 0.46490370523866664, 0.5579260996227442, 0.42607691072569565, 0.1554654464318821, 0.42366756244062576, 0.48632110949203244, 0.29039149895274685, 0.3634604380593306, 0.23907733700663014, 0.11179423836971492, 0.2226382429694953, 0.18061849010803976, 0.20068724330367982, 0.23695237654237267, 0.24030938062478213, 0.2443242555081241, 0.20323785425613272, 0.209807963106606, 0.2540393184547849, 0.2349246754255524, 0.09177641730177744, 0.10733509531761287, 0.11166911879708064, 0.10459216609985544, 0.09206936135040866, 0.08243891358403765, 0.060983091388391086, 0.09430497908734747, 0.06712964956225131]}, "mutation_prompt": null}
{"id": "e2e9631d-77ad-4ca0-960e-debf974b15f7", "solution": "import numpy as np\n\nclass EnhancedChaosDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.bounds = [-5.0, 5.0]\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.7\n        self.CR = 0.6\n        self.T = 1.0\n        self.T_min = 1e-3\n        self.alpha = 0.95\n\n    def dynamic_parameters(self, evaluations):\n        self.F = 0.4 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.CR = 0.6 + (0.3 - evaluations / self.budget) * np.random.rand()\n        self.T = max(self.T_min, self.T * self.alpha)\n\n    def chaos_initialization(self):\n        population = np.empty((self.pop_size, self.dim))\n        for i in range(self.pop_size):\n            x = 0.5\n            for _ in range(self.dim):\n                x = 4 * x * (1 - x)\n                population[i, _] = self.bounds[0] + (self.bounds[1] - self.bounds[0]) * x\n        return population\n\n    def __call__(self, func):\n        population = self.chaos_initialization()\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.pop_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_parameters(evaluations)\n            for i in range(self.pop_size):\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                indices = [index for index in range(self.pop_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] + self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.c2 * r2 * (global_best_position - population[i]))\n                trial_velocity = population[i] + velocities[i]\n                trial_velocity = np.clip(trial_velocity, self.bounds[0], self.bounds[1])\n\n                trial_score = func(trial_velocity)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial_velocity\n                    population[i] = trial_velocity\n\n                if trial_score < global_best_score:\n                    global_best_score = trial_score\n                    global_best_position = trial_velocity\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, global_best_score", "name": "EnhancedChaosDEPSO", "description": "Enhance global search efficiency by integrating adaptive multi-strategy differential evolution with particle swarm optimization, using dynamic parameter adjustment and a novel chaos-based initialization to improve convergence and diversity.", "configspace": "", "generation": 99, "fitness": 0.12360477383070233, "feedback": "The algorithm EnhancedChaosDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.20.", "error": "", "parent_id": "47fa4f62-bfe7-4af5-8b32-d43c87fe709c", "metadata": {"aucs": [0.5963108230157308, 0.11976208612746997, 0.0998883681158792, 0.13509222874727234, 0.15112764866601358, 0.11294079400011925, 0.1749298985959702, 0.7741451730582486, 0.16322114357809236, 0.312868763392279, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.34126211084835667, 9.999999999998899e-05, 0.05422683506530379, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02385487526892871, 9.999999999998899e-05, 0.017512715711698545, 0.05986579350567722, 0.03611358013440391, 0.02405113358908917, 0.02200382897988762, 0.020617469365346697, 9.999999999998899e-05, 0.007774849331494305, 9.999999999998899e-05, 0.007807038969641522, 9.999999999998899e-05, 0.0008920762200410604, 0.011018887095841867, 9.999999999998899e-05, 9.999999999998899e-05, 0.9704841838090544, 0.9743847896844305, 0.09862711801251511, 0.9525368895043715, 0.9561287377617514, 0.9748272952230274, 0.07440453138156355, 0.9611059550921092, 0.96365841217856, 0.0454868102250664, 9.999999999998899e-05, 0.034456379757997646, 0.043673379876000396, 0.06685710865055539, 0.045098266150172095, 9.999999999998899e-05, 0.03282270735881321, 9.999999999998899e-05, 9.999999999998899e-05, 0.056231905829785545, 0.05299090882225099, 0.05505920222759997, 0.13622983854419257, 0.11234854104266045, 0.06586104200324605, 0.17104314438235746, 0.08021824884543272, 9.999999999998899e-05, 0.4150883698604283, 9.999999999998899e-05, 9.999999999998899e-05, 0.10140313739190188, 0.09250484090393096, 9.999999999998899e-05, 0.23852118873715678, 9.999999999998899e-05, 9.999999999998899e-05, 0.33441356783087606, 0.021187078578561835, 9.999999999998899e-05, 0.15350738200474712, 0.2093473638426927, 9.999999999998899e-05, 0.20873459511548387, 0.03299434933692935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06577670057154428, 9.999999999998899e-05, 0.04206921995857249, 0.041871068000015166, 0.053226285103685544, 9.999999999998899e-05, 0.1494626707037583, 0.005661760060446275, 0.02786716399012834, 0.4477658251518396, 0.05477098559352367, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05547519672382839, 0.21719807724548124, 0.071959979977962, 9.999999999998899e-05, 0.07912126486668092, 9.999999999998899e-05, 9.999999999998899e-05, 0.1336207329835135, 0.039506775020048734, 9.999999999998899e-05, 0.133721690620473, 9.999999999998899e-05, 0.06978976392703484, 9.999999999998899e-05, 9.999999999998899e-05, 0.13915281979820715, 0.6485969286011493, 0.1388396957671777, 0.13348888749591092, 0.1116931366244549, 0.11753251166825651, 0.399919526652492, 0.2958058549595578, 0.6464709709961606, 0.01955669458969811, 0.019645416754841438, 0.013879363042935466, 0.03969443741342693, 0.03504700963757801, 0.08387406994045032, 0.04207166383965155, 0.07314653469571364, 0.03710759686546572, 0.10826780879017084, 0.110738898357849, 0.1261481574771538, 0.16715934084930195, 0.17364576888874395, 0.18582372034768824, 0.1406982830791983, 0.16595747999144628, 0.15516592544617647, 0.0916170138225405, 0.1354005233180342, 0.1018989877973625, 9.999999999998899e-05, 0.10568247565168565, 0.07829849714553916, 0.0942704972966194, 0.08550859020043666, 0.07751707713706624, 0.028720668319304643, 0.042497368400410074, 0.0170187631331723, 0.018774425392412142, 9.999999999998899e-05, 0.04144821004172572, 0.008681776976009359, 0.042120641935287084, 0.006468627925805048, 0.18748285161073153, 0.08699829688162952, 0.08864299822766009, 0.08442774275124953, 0.14109883251569388, 0.17347220478441028, 0.12480991244942108, 0.18724588484739113, 0.1261823157136972, 0.1714933018103868, 0.18933128683232792, 9.999999999998899e-05, 9.999999999998899e-05, 0.21726422876535967, 9.999999999998899e-05, 9.999999999998899e-05, 0.18413448890757156, 9.999999999998899e-05, 0.14178487400940176, 0.11772606018308585, 0.14106967836318451, 0.11983851659292355, 0.18718015473005956, 0.10561002901436567, 0.15609779947315694, 0.15097645460651166, 0.144102057246282, 0.019884454620446967, 0.15710985025646673, 0.12541325244876156, 0.10321792172892297, 0.15064535432146764, 0.13901844669197094, 0.02412286786491058, 0.5834544926475178, 0.035112775663313944, 0.22257759395574073, 0.2632222577588508, 0.19990622407219638, 0.18713380710876115, 0.1717664020562073, 0.18979000254155398, 0.17630510878154326, 0.1433338227922628, 0.17688475355553224, 0.01580917433017348, 0.07450122471272858, 0.009592637547675253, 0.011652360233294745, 0.10344913975621839, 0.002912441799303944, 0.0372210841607854, 0.07092041547657368, 0.07816011132020662]}, "mutation_prompt": null}
