{"id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.1571755736606365, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "b8a5b2a8-800e-461b-be72-df97b7af6985", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "90d6a3b2-4f01-4450-ab58-cd661158190f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "e9d37cf1-60eb-4de2-846b-ab09af51fc74", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "cda0ee5f-30fc-4b3a-b599-b97d7e0b255a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "c5d26ed8-e579-40d0-aa28-82259e021a92", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "6bfa9642-e396-4840-bb30-9156459d9abf", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        adaptive_factor = self.mutation_factor + 0.5 * (1 - eval_count / self.budget)\n        mutant = self.population[a] + adaptive_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Enhanced HybridGADE with adaptive mutation rate to improve convergence over diverse black box problems.", "configspace": "", "generation": 6, "fitness": 0.14556269857251966, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3472784683804172, 0.3128402810107175, 0.3442551097225999, 0.33755319562459574, 0.32135516893892735, 0.3344188036652168, 0.33140495904977874, 0.32297048332292555, 0.3389186053919626, 0.05565215470558982, 0.0480757743578748, 0.05891056066968725, 0.06861769903452186, 0.05034188783316418, 0.06376351290858351, 0.057666989885625686, 0.0513864925679951, 0.09429196075221713, 0.10401898198870918, 0.10965511343339784, 0.10413317060002758, 0.10885157818965163, 0.11362949342125117, 0.12140022167819386, 0.10531852428698962, 0.0981369622624807, 0.10760263253837687, 0.08005244281576329, 0.08303565940375701, 0.07863158531570169, 0.09088135238073558, 0.0747889891769159, 0.08994999346334676, 0.08468319662243196, 0.08032586192857138, 0.0756595570144033, 0.8981743957054293, 0.9179846556794233, 0.9105775829683588, 0.940353697088126, 0.9282648714227993, 0.8952958403324929, 0.8642090646180286, 0.8806460347800167, 0.8898214333708939, 0.08960258639065455, 0.09924132611405634, 0.09315049381294227, 0.08676048370549394, 0.07535909155690113, 0.11148979485730959, 0.10968113171816585, 0.08311125095214067, 0.0931624432138125, 0.12575313170935554, 0.14576355201826718, 0.10450078338601321, 0.16248515104553662, 0.14439754430821516, 0.1541215877587987, 0.10781668934666777, 0.1510459976461097, 0.13117974542029476, 0.04409852440951967, 0.060632655299179494, 0.04836926466423608, 0.0498353471688866, 0.04394163698674658, 0.06302001667947021, 0.04693178147873045, 0.05229991051801064, 0.05723262999146994, 0.058548252502040876, 0.01820971334796484, 0.03630224141196081, 0.06512395141187521, 0.0445455858573387, 0.05834775063960351, 0.05501294958439629, 0.04958029989277679, 0.040459279659493586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038726917438050235, 0.029307858253258434, 0.04707919477544109, 0.04244489715640121, 0.02307120712673183, 0.015936915451166156, 0.028828575049712146, 0.018621514959657914, 0.06032740512424284, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01589238343432464, 0.008321762630856044, 0.005697999022567846, 0.019183825153627043, 0.010635140336807125, 0.02115877710616665, 0.02345149698194071, 0.02469176486080793, 0.02446049580874532, 0.2398069349854559, 0.24368637777765534, 0.2788107078062064, 0.27756452200901127, 0.2519445249457799, 0.25740636160758124, 0.31496623397742873, 0.2236345566684107, 0.24457584676839073, 0.056666528912000635, 0.061761073315134474, 0.05619601304879651, 0.06403615145057961, 0.053583399156770795, 0.058608468268556146, 0.051629039965536916, 0.05151431583301003, 0.05576085061602931, 0.13441997168043618, 0.13976940045151187, 0.12498060773109887, 0.12661598512531114, 0.14257210774823492, 0.13439153916572455, 0.14118212399958097, 0.14610885630163795, 0.13610991877797718, 0.17997215262771682, 0.14688482108174028, 0.18479959759748754, 0.1939104506419994, 0.16236083572418025, 0.16062123646582893, 0.18723750369905057, 0.18600721168238032, 0.1861007541042804, 0.1008182620108421, 0.10451446867659031, 0.13170281470960565, 0.12825228345931716, 0.10812551431238937, 0.09229977343776141, 0.13011379173414772, 0.12374858935008493, 0.11605753651942974, 0.15715859371449548, 0.15595344657584975, 0.1495427345751701, 0.1826292406811365, 0.15742943935244202, 0.1814163552879995, 0.16756706435680047, 0.15810732874116074, 0.1595285963549129, 0.1748452767106734, 0.17368349198830424, 0.17263316327708067, 0.1658126575024358, 0.16051750681243793, 0.1666041757719131, 0.16386096346317214, 0.15718374765012955, 0.1585637158684201, 0.15673876941359177, 0.1719954978517535, 0.14546030948579414, 0.25315918357258693, 0.20434091290607626, 0.1458280955761727, 0.16596851518693145, 0.1442170442650469, 0.1641794785544164, 0.14141904407868422, 0.13802200650130036, 0.13735451264305032, 0.1335710586181853, 0.1375284928415269, 0.16409712412704447, 0.166082768649918, 0.1597166823130457, 0.16131043923103894, 0.18024682626026134, 0.18477960444576502, 0.1699715028199118, 0.16301895822219503, 0.19301670499999724, 0.1880075961198039, 0.16500626969321674, 0.16152480673161151, 0.18036162388226873, 0.050524388017820776, 0.05414629355684153, 0.06517569400225709, 0.06495975119330488, 0.05405405804661423, 0.05923289671072307, 0.05520095645596268, 0.0619494332643008, 0.047970369368394494]}, "mutation_prompt": null}
{"id": "a9e6edb0-265d-44a9-a1e8-7cef6406e7a0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm and Differential Evolution that dynamically balances exploration and exploitation to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.3845359330804351, 0.34209182444589437, 0.3957337977369081, 0.4102109708766717, 0.36015364403015426, 0.3809642794496161, 0.39033925722902807, 0.37958756194841814, 0.38585682550077016, 0.07613498902196536, 0.06817434555646085, 0.0941130915418309, 0.10145977362877234, 0.09415909067767403, 0.10558722869903936, 0.08447904056240119, 0.11126246132385498, 0.1326773868153197, 0.11723001519876108, 0.11178082108019372, 0.11282727408308979, 0.11458965142090716, 0.12011201804276284, 0.1189839332777376, 0.16894498359568422, 0.12569372862735018, 0.1096577066878015, 0.10840836049354674, 0.09810373802003158, 0.10594901182456817, 0.10807398061948337, 0.09338552056447447, 0.1062538332620101, 0.10535129300575041, 0.09209750714965137, 0.10337129324371597, 0.897186553156591, 0.8727457179796645, 0.8793202147799329, 0.860320537178936, 0.9159657103231474, 0.892324071136835, 0.8596863034895977, 0.9095000096145339, 0.8656714963756822, 0.1028372113714211, 0.11140277145911692, 0.10640946268603713, 0.09288448015404827, 0.09065184239464574, 0.08606036190537547, 0.1183461572953034, 0.09425090529545599, 0.10439896495171475, 0.1337056572620562, 0.14375017511097998, 0.10744490042245869, 0.17033323628472152, 0.1665012812871175, 0.14931983113014757, 0.1792605744241078, 0.12702268709184705, 0.13488873337614182, 0.07190494269256376, 0.07272439401523967, 0.05218713984330425, 0.11243705074547272, 0.08234971286958792, 0.09615748292062343, 0.09195473248297625, 0.08909108046985859, 0.06859540857258617, 0.08614815293058165, 0.038603272522112264, 0.04688321574864163, 0.09109489703042128, 0.07082737095730285, 0.06067816127478709, 0.05670594515786376, 0.05107458533506781, 0.08883810722830898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497445745815042, 0.02239511013387452, 0.029155454556195393, 0.03342415504589302, 0.01677431094420101, 0.0376805163657733, 0.049885051966625404, 0.0700195742211388, 0.05115315143191124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04619427404708254, 0.016680796575941126, 0.026795585229488106, 0.028281832226190073, 0.013491781649890844, 0.01424616552282465, 0.024142331768556846, 0.024686933297923486, 0.0234897994228781, 0.2926799185604847, 0.2686570146918863, 0.29514594867193644, 0.30990042336796064, 0.26266203813655686, 0.29199600100097334, 0.30763404670077177, 0.2438512660592561, 0.27991657565008377, 0.06943176056916656, 0.05531481250746617, 0.06342027910605375, 0.06671080454400458, 0.054607473509827975, 0.06947696439285578, 0.06939761492138818, 0.06422500570049028, 0.059965188290284854, 0.13907140469335322, 0.1408513791198488, 0.13644161951390743, 0.1400179435986889, 0.15776383796789883, 0.13313795937594242, 0.12628878919573672, 0.1275370780228774, 0.1286172468187442, 0.17803768539792741, 0.16181137273937074, 0.17108434867162414, 0.18803963742678909, 0.16455876247826984, 0.17192281000414855, 0.18809364714765675, 0.1936531837110379, 0.16968582085547945, 0.11614210354570709, 0.11379061067914209, 0.12482273286654622, 0.11754181403755903, 0.10745217191070333, 0.11357755125631497, 0.12469056069390028, 0.12377537845768127, 0.12423855977696696, 0.20010586554371357, 0.177562190165916, 0.1792376155579366, 0.19045434162086017, 0.16301144727474315, 0.17327018331568744, 0.1797079303760304, 0.1688402956389522, 0.18179225804434695, 0.1869008885820964, 0.15873373610220698, 0.2027538223882389, 0.17803632201595043, 0.17382712851729354, 0.17172837938407215, 0.18768975911806096, 0.17363733741520193, 0.16866864633666356, 0.15588559741285812, 0.18693168126969062, 0.15116397082728583, 0.3033578518347123, 0.23173291728007994, 0.15397545258963508, 0.1878191085364591, 0.15229403794989504, 0.17982124249841314, 0.1538315911126179, 0.21165122914672596, 0.16083447779559157, 0.15780046422755845, 0.15818949558276985, 0.15174304402024263, 0.14622791010765646, 0.14878863662139574, 0.18093025355147563, 0.18506931964999462, 0.1776064059520397, 0.17942398844202456, 0.18522497268384008, 0.1853296645918766, 0.1730398182021674, 0.1698781129027791, 0.1885817136730139, 0.1741554301874143, 0.062212177661396306, 0.0625874723408919, 0.057507542309383486, 0.06081951344021397, 0.07426603349416583, 0.05663377419492699, 0.06070629266296024, 0.06309979609539329, 0.05315267118250977]}, "mutation_prompt": null}
{"id": "65bdc5c2-48dc-4e13-93f0-08e798f8b659", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adaptive mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Enhanced HybridGADE with adaptive mutation factor for improved convergence.", "configspace": "", "generation": 8, "fitness": 0.1694385680563175, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "375aca99-5888-4a8d-b30b-9b426c61e1fd", "metadata": {"aucs": [0.47733769235628487, 0.43454169517497343, 0.4698839534571633, 0.4772430064812403, 0.4406626409663068, 0.4771953936296408, 0.4587455278943018, 0.4471788831683913, 0.46388295552080894, 0.14827011050739924, 0.18108521349814233, 0.1731884595848413, 0.14789531704231906, 0.1576990493963869, 0.14790718008711523, 0.149772562756871, 0.14496728507324663, 0.1576896892387415, 0.13699386285265247, 0.15560744628666523, 0.13496325348878258, 0.13137141362188265, 0.12364481702362029, 0.13310904650097366, 0.13189746105391298, 0.1340100825174272, 0.13019418325956555, 0.114983613632481, 0.11657202143073264, 0.11315612252869456, 0.13615846416677435, 0.1058115749516273, 0.10191002607945687, 0.1185556698271455, 0.11792985276378498, 0.12782386907570054, 0.8481665528151863, 0.8727382425900239, 0.8789942107979366, 0.8603904745777012, 0.828500196993804, 0.8923931226379953, 0.8598311312193418, 0.8813612801877804, 0.8654311418556978, 0.1096129189152325, 0.12938244582800418, 0.11477540740296444, 0.08719978124226291, 0.08577580281180508, 0.10209491012180716, 0.10793552498515169, 0.10129259653145162, 0.10578797121130812, 0.14563032783587315, 0.1253918633130443, 0.12010618941359785, 0.18859127377395568, 0.1637329159077111, 0.19106685774926202, 0.14472897672066554, 0.13918711934897143, 0.15651817941963309, 0.10479237466717717, 0.09457140129243258, 0.06685205760103996, 0.08811324273853516, 0.09719475785313081, 0.08182978631277182, 0.09738969802623143, 0.08177877410813816, 0.07508884081730272, 0.07873388342101206, 0.05802566456840563, 0.061080836435673524, 0.08454485270693535, 0.09373940707416772, 0.09044026774954705, 0.07691873892628887, 0.0992146119681101, 0.061074053664812666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04490040586509947, 0.0348877636831183, 0.03817676027951766, 0.01792517346928435, 0.031049668340504155, 0.047275633619584756, 0.08740338123213187, 0.09317869652090882, 0.08388382911223347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029084716882710415, 0.01633165670526049, 0.03451444418379601, 0.041133218352517154, 0.03750036053156669, 0.03764466344576156, 0.03630287610461835, 0.027834553142166096, 0.045483806522571335, 0.31787003201384656, 0.29916011240856477, 0.33584081219115747, 0.3279905409387627, 0.30565669166985876, 0.30118294970919113, 0.30471953650496997, 0.2882330173680041, 0.31052128752641006, 0.06596377883758542, 0.08159784946924464, 0.06784163996362347, 0.08721084890307995, 0.05606020091883779, 0.07120029101344494, 0.08108818913884697, 0.07624894067265797, 0.06774114309911494, 0.12592864045999197, 0.1494073705216702, 0.12541705327087616, 0.13830863414925365, 0.1540348439694098, 0.12399605364652566, 0.1237748976657782, 0.151624113362265, 0.12758540453217793, 0.18430022735301166, 0.16538501770539038, 0.18990548590971768, 0.2123434834269452, 0.1774519375550312, 0.18797423732367535, 0.19321882310622418, 0.20074416846329957, 0.19739105659366807, 0.11933847385764784, 0.10635310706706946, 0.1431260758458659, 0.12768351170903736, 0.1339539654247628, 0.11858882815740346, 0.1268826750417429, 0.139676888392271, 0.13428290886907757, 0.20355881170817458, 0.16283956143152878, 0.16349009976571327, 0.17996866370315856, 0.16858475276873464, 0.1811285746904322, 0.1775522295902372, 0.15683536752179805, 0.16316438639952469, 0.16960284453436902, 0.15462063909955104, 0.1967606824523318, 0.1796775901139419, 0.18005928604315102, 0.1779363805262716, 0.18401990882546437, 0.18764798157933416, 0.17891890268864408, 0.21611572275766555, 0.2022662775887899, 0.17119774416390332, 0.41413278055705005, 0.19942550068484444, 0.16946489081267413, 0.15957003521033475, 0.2309253680460236, 0.20369507691624844, 0.21673724491980662, 0.17861798519062544, 0.1609325210995063, 0.15063483614759776, 0.19776074564769808, 0.16248111411424593, 0.16368949623818174, 0.14636821281799717, 0.19023801449023836, 0.1737397673006904, 0.17308431078328979, 0.18936252790802688, 0.1840809410760771, 0.18547375831746382, 0.17016909126057345, 0.17124077067318955, 0.19325399668177867, 0.1655776948922143, 0.05679433360443653, 0.058350822977007, 0.061889031163249064, 0.06559795371207744, 0.06535713372969787, 0.058414960526182, 0.08326708309344577, 0.06005854181925585, 0.053440333043857424]}, "mutation_prompt": null}
{"id": "5b2cea80-f2c1-4518-b618-6bab3c152d23", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adaptive mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Enhanced HybridGADE with adaptive mutation factor for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "65bdc5c2-48dc-4e13-93f0-08e798f8b659", "metadata": {"aucs": [0.47733769235628487, 0.43454169517497343, 0.4698839534571633, 0.4772430064812403, 0.4406626409663068, 0.4771953936296408, 0.4587455278943018, 0.4471788831683913, 0.46388295552080894, 0.14827011050739924, 0.18108521349814233, 0.1731884595848413, 0.14789531704231906, 0.1576990493963869, 0.14790718008711523, 0.149772562756871, 0.14496728507324663, 0.1576896892387415, 0.13699386285265247, 0.15560744628666523, 0.13496325348878258, 0.13137141362188265, 0.12364481702362029, 0.13310904650097366, 0.13189746105391298, 0.1340100825174272, 0.13019418325956555, 0.114983613632481, 0.11657202143073264, 0.11315612252869456, 0.13615846416677435, 0.1058115749516273, 0.10191002607945687, 0.1185556698271455, 0.11792985276378498, 0.12782386907570054, 0.8481665528151863, 0.8727382425900239, 0.8789942107979366, 0.8603904745777012, 0.828500196993804, 0.8923931226379953, 0.8598311312193418, 0.8813612801877804, 0.8654311418556978, 0.1096129189152325, 0.12938244582800418, 0.11477540740296444, 0.08719978124226291, 0.08577580281180508, 0.10209491012180716, 0.10793552498515169, 0.10129259653145162, 0.10578797121130812, 0.14563032783587315, 0.1253918633130443, 0.12010618941359785, 0.18859127377395568, 0.1637329159077111, 0.19106685774926202, 0.14472897672066554, 0.13918711934897143, 0.15651817941963309, 0.10479237466717717, 0.09457140129243258, 0.06685205760103996, 0.08811324273853516, 0.09719475785313081, 0.08182978631277182, 0.09738969802623143, 0.08177877410813816, 0.07508884081730272, 0.07873388342101206, 0.05802566456840563, 0.061080836435673524, 0.08454485270693535, 0.09373940707416772, 0.09044026774954705, 0.07691873892628887, 0.0992146119681101, 0.061074053664812666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04490040586509947, 0.0348877636831183, 0.03817676027951766, 0.01792517346928435, 0.031049668340504155, 0.047275633619584756, 0.08740338123213187, 0.09317869652090882, 0.08388382911223347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029084716882710415, 0.01633165670526049, 0.03451444418379601, 0.041133218352517154, 0.03750036053156669, 0.03764466344576156, 0.03630287610461835, 0.027834553142166096, 0.045483806522571335, 0.31787003201384656, 0.29916011240856477, 0.33584081219115747, 0.3279905409387627, 0.30565669166985876, 0.30118294970919113, 0.30471953650496997, 0.2882330173680041, 0.31052128752641006, 0.06596377883758542, 0.08159784946924464, 0.06784163996362347, 0.08721084890307995, 0.05606020091883779, 0.07120029101344494, 0.08108818913884697, 0.07624894067265797, 0.06774114309911494, 0.12592864045999197, 0.1494073705216702, 0.12541705327087616, 0.13830863414925365, 0.1540348439694098, 0.12399605364652566, 0.1237748976657782, 0.151624113362265, 0.12758540453217793, 0.18430022735301166, 0.16538501770539038, 0.18990548590971768, 0.2123434834269452, 0.1774519375550312, 0.18797423732367535, 0.19321882310622418, 0.20074416846329957, 0.19739105659366807, 0.11933847385764784, 0.10635310706706946, 0.1431260758458659, 0.12768351170903736, 0.1339539654247628, 0.11858882815740346, 0.1268826750417429, 0.139676888392271, 0.13428290886907757, 0.20355881170817458, 0.16283956143152878, 0.16349009976571327, 0.17996866370315856, 0.16858475276873464, 0.1811285746904322, 0.1775522295902372, 0.15683536752179805, 0.16316438639952469, 0.16960284453436902, 0.15462063909955104, 0.1967606824523318, 0.1796775901139419, 0.18005928604315102, 0.1779363805262716, 0.18401990882546437, 0.18764798157933416, 0.17891890268864408, 0.21611572275766555, 0.2022662775887899, 0.17119774416390332, 0.41413278055705005, 0.19942550068484444, 0.16946489081267413, 0.15957003521033475, 0.2309253680460236, 0.20369507691624844, 0.21673724491980662, 0.17861798519062544, 0.1609325210995063, 0.15063483614759776, 0.19776074564769808, 0.16248111411424593, 0.16368949623818174, 0.14636821281799717, 0.19023801449023836, 0.1737397673006904, 0.17308431078328979, 0.18936252790802688, 0.1840809410760771, 0.18547375831746382, 0.17016909126057345, 0.17124077067318955, 0.19325399668177867, 0.1655776948922143, 0.05679433360443653, 0.058350822977007, 0.061889031163249064, 0.06559795371207744, 0.06535713372969787, 0.058414960526182, 0.08326708309344577, 0.06005854181925585, 0.053440333043857424]}, "mutation_prompt": null}
{"id": "9832794c-7ce3-4ffe-a686-2f8a8400bc0e", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adaptive mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Enhanced HybridGADE with adaptive mutation factor for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "65bdc5c2-48dc-4e13-93f0-08e798f8b659", "metadata": {"aucs": [0.47733769235628487, 0.43454169517497343, 0.4698839534571633, 0.4772430064812403, 0.4406626409663068, 0.4771953936296408, 0.4587455278943018, 0.4471788831683913, 0.46388295552080894, 0.14827011050739924, 0.18108521349814233, 0.1731884595848413, 0.14789531704231906, 0.1576990493963869, 0.14790718008711523, 0.149772562756871, 0.14496728507324663, 0.1576896892387415, 0.13699386285265247, 0.15560744628666523, 0.13496325348878258, 0.13137141362188265, 0.12364481702362029, 0.13310904650097366, 0.13189746105391298, 0.1340100825174272, 0.13019418325956555, 0.114983613632481, 0.11657202143073264, 0.11315612252869456, 0.13615846416677435, 0.1058115749516273, 0.10191002607945687, 0.1185556698271455, 0.11792985276378498, 0.12782386907570054, 0.8481665528151863, 0.8727382425900239, 0.8789942107979366, 0.8603904745777012, 0.828500196993804, 0.8923931226379953, 0.8598311312193418, 0.8813612801877804, 0.8654311418556978, 0.1096129189152325, 0.12938244582800418, 0.11477540740296444, 0.08719978124226291, 0.08577580281180508, 0.10209491012180716, 0.10793552498515169, 0.10129259653145162, 0.10578797121130812, 0.14563032783587315, 0.1253918633130443, 0.12010618941359785, 0.18859127377395568, 0.1637329159077111, 0.19106685774926202, 0.14472897672066554, 0.13918711934897143, 0.15651817941963309, 0.10479237466717717, 0.09457140129243258, 0.06685205760103996, 0.08811324273853516, 0.09719475785313081, 0.08182978631277182, 0.09738969802623143, 0.08177877410813816, 0.07508884081730272, 0.07873388342101206, 0.05802566456840563, 0.061080836435673524, 0.08454485270693535, 0.09373940707416772, 0.09044026774954705, 0.07691873892628887, 0.0992146119681101, 0.061074053664812666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04490040586509947, 0.0348877636831183, 0.03817676027951766, 0.01792517346928435, 0.031049668340504155, 0.047275633619584756, 0.08740338123213187, 0.09317869652090882, 0.08388382911223347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029084716882710415, 0.01633165670526049, 0.03451444418379601, 0.041133218352517154, 0.03750036053156669, 0.03764466344576156, 0.03630287610461835, 0.027834553142166096, 0.045483806522571335, 0.31787003201384656, 0.29916011240856477, 0.33584081219115747, 0.3279905409387627, 0.30565669166985876, 0.30118294970919113, 0.30471953650496997, 0.2882330173680041, 0.31052128752641006, 0.06596377883758542, 0.08159784946924464, 0.06784163996362347, 0.08721084890307995, 0.05606020091883779, 0.07120029101344494, 0.08108818913884697, 0.07624894067265797, 0.06774114309911494, 0.12592864045999197, 0.1494073705216702, 0.12541705327087616, 0.13830863414925365, 0.1540348439694098, 0.12399605364652566, 0.1237748976657782, 0.151624113362265, 0.12758540453217793, 0.18430022735301166, 0.16538501770539038, 0.18990548590971768, 0.2123434834269452, 0.1774519375550312, 0.18797423732367535, 0.19321882310622418, 0.20074416846329957, 0.19739105659366807, 0.11933847385764784, 0.10635310706706946, 0.1431260758458659, 0.12768351170903736, 0.1339539654247628, 0.11858882815740346, 0.1268826750417429, 0.139676888392271, 0.13428290886907757, 0.20355881170817458, 0.16283956143152878, 0.16349009976571327, 0.17996866370315856, 0.16858475276873464, 0.1811285746904322, 0.1775522295902372, 0.15683536752179805, 0.16316438639952469, 0.16960284453436902, 0.15462063909955104, 0.1967606824523318, 0.1796775901139419, 0.18005928604315102, 0.1779363805262716, 0.18401990882546437, 0.18764798157933416, 0.17891890268864408, 0.21611572275766555, 0.2022662775887899, 0.17119774416390332, 0.41413278055705005, 0.19942550068484444, 0.16946489081267413, 0.15957003521033475, 0.2309253680460236, 0.20369507691624844, 0.21673724491980662, 0.17861798519062544, 0.1609325210995063, 0.15063483614759776, 0.19776074564769808, 0.16248111411424593, 0.16368949623818174, 0.14636821281799717, 0.19023801449023836, 0.1737397673006904, 0.17308431078328979, 0.18936252790802688, 0.1840809410760771, 0.18547375831746382, 0.17016909126057345, 0.17124077067318955, 0.19325399668177867, 0.1655776948922143, 0.05679433360443653, 0.058350822977007, 0.061889031163249064, 0.06559795371207744, 0.06535713372969787, 0.058414960526182, 0.08326708309344577, 0.06005854181925585, 0.053440333043857424]}, "mutation_prompt": null}
{"id": "4cea7bc0-795b-4058-a897-b1d8fb53d521", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adaptive mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Enhanced HybridGADE with adaptive mutation factor for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "65bdc5c2-48dc-4e13-93f0-08e798f8b659", "metadata": {"aucs": [0.47733769235628487, 0.43454169517497343, 0.4698839534571633, 0.4772430064812403, 0.4406626409663068, 0.4771953936296408, 0.4587455278943018, 0.4471788831683913, 0.46388295552080894, 0.14827011050739924, 0.18108521349814233, 0.1731884595848413, 0.14789531704231906, 0.1576990493963869, 0.14790718008711523, 0.149772562756871, 0.14496728507324663, 0.1576896892387415, 0.13699386285265247, 0.15560744628666523, 0.13496325348878258, 0.13137141362188265, 0.12364481702362029, 0.13310904650097366, 0.13189746105391298, 0.1340100825174272, 0.13019418325956555, 0.114983613632481, 0.11657202143073264, 0.11315612252869456, 0.13615846416677435, 0.1058115749516273, 0.10191002607945687, 0.1185556698271455, 0.11792985276378498, 0.12782386907570054, 0.8481665528151863, 0.8727382425900239, 0.8789942107979366, 0.8603904745777012, 0.828500196993804, 0.8923931226379953, 0.8598311312193418, 0.8813612801877804, 0.8654311418556978, 0.1096129189152325, 0.12938244582800418, 0.11477540740296444, 0.08719978124226291, 0.08577580281180508, 0.10209491012180716, 0.10793552498515169, 0.10129259653145162, 0.10578797121130812, 0.14563032783587315, 0.1253918633130443, 0.12010618941359785, 0.18859127377395568, 0.1637329159077111, 0.19106685774926202, 0.14472897672066554, 0.13918711934897143, 0.15651817941963309, 0.10479237466717717, 0.09457140129243258, 0.06685205760103996, 0.08811324273853516, 0.09719475785313081, 0.08182978631277182, 0.09738969802623143, 0.08177877410813816, 0.07508884081730272, 0.07873388342101206, 0.05802566456840563, 0.061080836435673524, 0.08454485270693535, 0.09373940707416772, 0.09044026774954705, 0.07691873892628887, 0.0992146119681101, 0.061074053664812666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04490040586509947, 0.0348877636831183, 0.03817676027951766, 0.01792517346928435, 0.031049668340504155, 0.047275633619584756, 0.08740338123213187, 0.09317869652090882, 0.08388382911223347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029084716882710415, 0.01633165670526049, 0.03451444418379601, 0.041133218352517154, 0.03750036053156669, 0.03764466344576156, 0.03630287610461835, 0.027834553142166096, 0.045483806522571335, 0.31787003201384656, 0.29916011240856477, 0.33584081219115747, 0.3279905409387627, 0.30565669166985876, 0.30118294970919113, 0.30471953650496997, 0.2882330173680041, 0.31052128752641006, 0.06596377883758542, 0.08159784946924464, 0.06784163996362347, 0.08721084890307995, 0.05606020091883779, 0.07120029101344494, 0.08108818913884697, 0.07624894067265797, 0.06774114309911494, 0.12592864045999197, 0.1494073705216702, 0.12541705327087616, 0.13830863414925365, 0.1540348439694098, 0.12399605364652566, 0.1237748976657782, 0.151624113362265, 0.12758540453217793, 0.18430022735301166, 0.16538501770539038, 0.18990548590971768, 0.2123434834269452, 0.1774519375550312, 0.18797423732367535, 0.19321882310622418, 0.20074416846329957, 0.19739105659366807, 0.11933847385764784, 0.10635310706706946, 0.1431260758458659, 0.12768351170903736, 0.1339539654247628, 0.11858882815740346, 0.1268826750417429, 0.139676888392271, 0.13428290886907757, 0.20355881170817458, 0.16283956143152878, 0.16349009976571327, 0.17996866370315856, 0.16858475276873464, 0.1811285746904322, 0.1775522295902372, 0.15683536752179805, 0.16316438639952469, 0.16960284453436902, 0.15462063909955104, 0.1967606824523318, 0.1796775901139419, 0.18005928604315102, 0.1779363805262716, 0.18401990882546437, 0.18764798157933416, 0.17891890268864408, 0.21611572275766555, 0.2022662775887899, 0.17119774416390332, 0.41413278055705005, 0.19942550068484444, 0.16946489081267413, 0.15957003521033475, 0.2309253680460236, 0.20369507691624844, 0.21673724491980662, 0.17861798519062544, 0.1609325210995063, 0.15063483614759776, 0.19776074564769808, 0.16248111411424593, 0.16368949623818174, 0.14636821281799717, 0.19023801449023836, 0.1737397673006904, 0.17308431078328979, 0.18936252790802688, 0.1840809410760771, 0.18547375831746382, 0.17016909126057345, 0.17124077067318955, 0.19325399668177867, 0.1655776948922143, 0.05679433360443653, 0.058350822977007, 0.061889031163249064, 0.06559795371207744, 0.06535713372969787, 0.058414960526182, 0.08326708309344577, 0.06005854181925585, 0.053440333043857424]}, "mutation_prompt": null}
{"id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 12, "fitness": 0.23949535346728545, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "65bdc5c2-48dc-4e13-93f0-08e798f8b659", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "4d8849a8-b67b-401d-9998-0ddea4cb751f", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            elite_idx = np.argmin(self.fitness)  # Elitism: preserve the best solution\n\n            for i in range(self.population_size):\n                if i == elite_idx:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n                    continue\n\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive elitism for improved selection pressure and faster convergence.", "configspace": "", "generation": 13, "fitness": 0.23854104763578127, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7301083644223191, 0.7043639345093173, 0.6996069851182851, 0.7326729337894711, 0.7252125674172224, 0.7229611800734134, 0.7437921826195274, 0.7230269924442487, 0.7022943217731797, 0.4941575843299493, 0.5034245057811879, 0.5048054732528975, 0.5019520599958536, 0.5210510291739667, 0.516081893672085, 0.5082225630919398, 0.5078804755350919, 0.5015111458242636, 0.30511577541723545, 0.25522354916879897, 0.29789351598449, 0.33958391049210657, 0.3150648525498183, 0.30177102101579834, 0.33419719073887166, 0.25092696118352964, 0.2559282276982553, 0.2427561025995556, 0.1932708673076612, 0.2682329369726545, 0.214801610564758, 0.24253685021285032, 0.21678741670985335, 0.1501245396886528, 0.18766584528147512, 0.2500579350316713, 0.968239680379708, 0.9547002639376297, 0.9423769129592772, 0.9642006899578757, 0.957939784179597, 0.9564212951193355, 0.9609726692087454, 0.9470681131970395, 0.948471018841114, 0.2174600465498061, 0.2239002655196095, 0.20094289312801628, 0.20400039368029022, 0.21159865494426, 0.20170167354540836, 0.19584783681321172, 0.17843157437863244, 0.1940003500714016, 0.20409271559615638, 0.18740862019345195, 0.18189981257372, 0.2388918718518298, 0.2981620740254851, 0.2584895937805688, 0.22456769979109048, 0.2499053301056151, 0.23808619386020435, 0.1494445946841444, 0.1500941302444173, 0.1287146795055112, 0.13533239064583646, 0.1438171119024504, 0.14253194683966797, 0.14422574748664685, 0.12846267397373634, 0.13644189007754992, 0.14141843581251556, 0.11947560529509815, 0.1026878229688436, 0.12612373383917808, 0.1405518091267195, 0.11537887915869705, 0.10598420908451789, 0.09673739474554444, 0.13921684983910088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07441320710144084, 0.042792907588007245, 0.06795358306981203, 0.04975689683485163, 0.03129305639186719, 0.04842847720191945, 0.08844357330130548, 0.07623254004843749, 0.07544046946817251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08693465608016415, 0.07344863901141385, 0.06455737351339685, 0.099304241044049, 0.08385389539152222, 0.09689715576666402, 0.0736771559870909, 0.06838333493335869, 0.07130145440228897, 0.42217267016092563, 0.4073356190466626, 0.4185761345009251, 0.42513629925485785, 0.42521929408233583, 0.4218848771828676, 0.4645854931370016, 0.4196072395199856, 0.4191357884340401, 0.08879928161517259, 0.088056810603657, 0.09262362563578352, 0.09388318701246157, 0.07949996346534371, 0.09160108184329496, 0.09872513065548572, 0.0957249817460708, 0.09973543209715008, 0.1584196214341569, 0.1383818665283878, 0.13196095802908436, 0.1402639355029256, 0.1443962205660937, 0.13390371860812011, 0.14457695274724502, 0.16053148692981634, 0.17783132892568487, 0.24697688466607437, 0.24360569083761652, 0.25652946167550095, 0.22365050939673303, 0.2513396469675212, 0.22670930335973127, 0.27592191311863534, 0.2791747019299209, 0.2656612349928905, 0.179679950315781, 0.19140462219961363, 0.17963648282798872, 0.16747863485645653, 0.14015755501950367, 0.17046205100390854, 0.18695561206094813, 0.18025498280598073, 0.18711317485321788, 0.2017118449309102, 0.1749359096720856, 0.18045538360242352, 0.20254052931319566, 0.18547281583870212, 0.21032522899037753, 0.19900145925412205, 0.18539117300950758, 0.1970998244911566, 0.2123835216891925, 0.20119539258645947, 0.20798675056129634, 0.23008917696186637, 0.20313437298086467, 0.21698249885213128, 0.21513967813444734, 0.20743554291469923, 0.21260529645200854, 0.17365788875685573, 0.27048340111905134, 0.17300178825676282, 0.20922712087274797, 0.19337980953257516, 0.22509356420507454, 0.2384784389653909, 0.23074988990649448, 0.23507860300678607, 0.24498654967079958, 0.18744960716812853, 0.1639926124888057, 0.28652321379523005, 0.183183876717665, 0.17863704432028737, 0.22657980276917833, 0.2315031335544876, 0.20615656073416577, 0.1812275236594707, 0.18591252271651248, 0.19001303532822655, 0.20040232082790677, 0.18630015503018416, 0.17863962851800952, 0.18701253592976397, 0.1980990596861426, 0.18629854038519456, 0.08134035176657706, 0.08474812755385086, 0.08297607920108674, 0.0775499377284592, 0.0730545906025496, 0.07166636079745126, 0.07398549163259482, 0.07401507155134368, 0.0778983861866629]}, "mutation_prompt": null}
{"id": "66c74cae-943d-474e-b0c6-b184f62c8dc3", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "6a1ef41b-95f5-4b09-bc52-2633a9255519", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "97cc7ee8-b74f-477d-841e-a4dafb66e352", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "26ab1910-873c-4b2e-85ee-86ce2ef06810", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "a7fbf0aa-306d-4d33-aa94-6f8ead55bab5", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "798c548c-35c4-412b-9aac-ff6c804f2ab9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "d31950ac-97e3-48a9-b8c8-04ac7f02d50b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "33699460-10c4-422e-81af-3ab1a413dac1", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "90d1b27e-7954-494c-a216-65b8b9016d24", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "1e4e2df3-867e-4ff2-922b-13aacc4955c4", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "6a57b1d2-2913-48c1-9f51-65a42607c4c5", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "e6fe47ca-aa24-41a9-b57f-afe4a61cddfa", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "afbbc09d-c09a-43fc-839c-83a852f5d8eb", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "79acb002-305e-46d0-8c39-0a52c3ca2dbe", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "c85b69d3-6051-44b2-bca9-6aa100095d93", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "e4d2f8b4-2eea-4550-83d1-10aed357a7da", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "503a4d51-341e-40ac-b1c1-fc67453fff06", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        scaling_factor = np.random.uniform(0.5, 1.0)  # Adaptive mutation scaling\n        mutant = mutant + scaling_factor * (self.population[best_idx] - self.population[a])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            fitness_indices = np.argsort(new_fitness)\n            sigma = 0.1\n            ranks = np.arange(1, self.population_size + 1)\n            probabilities = (1 - sigma) / self.population_size + sigma * (1 - ranks / self.population_size) / ranks.sum()\n            selected_indices = np.random.choice(fitness_indices, self.population_size, p=probabilities, replace=False)\n\n            self.population = new_population[selected_indices]\n            self.fitness = new_fitness[selected_indices]\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation scaling and stochastic ranking for better balance between exploration and exploitation.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {}, "mutation_prompt": null}
{"id": "d48af139-f406-4841-994c-87abef9d7cc4", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize fitness of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                # Evaluate offspring\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive crossover rate for diversified exploration and improved convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.7137186471130521, 0.7090673549402433, 0.7034483079740665, 0.7178934884600292, 0.7251305527330967, 0.7224997808654778, 0.7206293035102417, 0.7144564318916632, 0.6901424395841722, 0.5358963480888026, 0.5052294305043603, 0.5321935623234864, 0.474720820562909, 0.5174634198542505, 0.5258839828237081, 0.4934711873747162, 0.5223924237429913, 0.5036429171753922, 0.2645290508556929, 0.25258650205140043, 0.29901381241352176, 0.2859179205754241, 0.23104652051984842, 0.2726715829525205, 0.24850763620126426, 0.3297771289174367, 0.3199320070919407, 0.20354008592831618, 0.2235505447145003, 0.2491631882010078, 0.15820078371765844, 0.23457442265428086, 0.24330668720728676, 0.19809296914466357, 0.2358311505925439, 0.20771106793788274, 0.9406198482256224, 0.9407835173342477, 0.9672644692071104, 0.938964234540513, 0.9538910459342098, 0.9462267895178562, 0.9571169461979181, 0.9612069338248905, 0.9486194256201614, 0.2188470992573922, 0.20784648684463425, 0.2103173492648328, 0.22193488273440176, 0.198691467705706, 0.2381066421521797, 0.1880225954063579, 0.2001680386144471, 0.2076842992315735, 0.21615801909568477, 0.24339043388760795, 0.18974953861689392, 0.2206154486515589, 0.251395761452997, 0.22277128447807337, 0.22594210079711052, 0.23136460810428927, 0.287766017544544, 0.13079549128740642, 0.14446771905741185, 0.1555819087441891, 0.14157298769237858, 0.12689085504553, 0.13052630330961568, 0.146766521562414, 0.1354043439498338, 0.1406681486848489, 0.12713473234114447, 0.09922288036676996, 0.09686470595445684, 0.13598471693510017, 0.11345604779541374, 0.1279503540507263, 0.1317184074053115, 0.11711367744764578, 0.11560800377591474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08613968838754549, 0.0917253684140884, 0.06001564128203141, 0.055606025802546366, 0.04952698280559886, 0.06304828774496618, 0.07453696824153633, 0.06007292629472527, 0.09002685503136632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006038159456043246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07670254496430884, 0.06344815114907976, 0.06595505680127811, 0.08908089575291067, 0.10090752365935551, 0.0932791581194582, 0.08393865090430741, 0.09603539612026557, 0.0916480287352297, 0.4176983847809199, 0.41065094922826195, 0.4183762595588262, 0.4341236490041208, 0.4279230457884835, 0.4326546769988795, 0.4288619911945515, 0.423703227310126, 0.4426068142562285, 0.10556825649923762, 0.10755737622823713, 0.09672063700776778, 0.07947600652564357, 0.10782953255156336, 0.09931330185750287, 0.10177259700605845, 0.10016623178319173, 0.09359319286886325, 0.15167281929779142, 0.1402145117372562, 0.15682867012677593, 0.13154423627849987, 0.15393645158442892, 0.13488650906561594, 0.13114260855705884, 0.14663973488526094, 0.13706721708823788, 0.23650878050505786, 0.2392677779831831, 0.25242931640200583, 0.2612676890885446, 0.2347187590606391, 0.23118772172601287, 0.29011268812881175, 0.29092558252363765, 0.29257814825122497, 0.16522498455989276, 0.16143052451727524, 0.17580137946486152, 0.15507513657507876, 0.1753979294764073, 0.1628478208158738, 0.19454911284314624, 0.20071367687810915, 0.18898193305657474, 0.20821766466836966, 0.18141240321462293, 0.19511503259588614, 0.18797652786958552, 0.19500602433740155, 0.18868260124482594, 0.20149916373032695, 0.1874888555251203, 0.20982880900407586, 0.21060351609254435, 0.23030581418606, 0.20425830046172933, 0.25791765787694076, 0.22552361352191652, 0.22683921881576807, 0.20194429009292802, 0.22007756264424871, 0.19885627683632534, 0.18984297394520921, 0.17380205526947134, 0.23845889046887903, 0.2015318229120896, 0.3244991428366145, 0.23195264275858696, 0.25641210812267046, 0.1945925803834817, 0.23045552219833154, 0.2585761054315583, 0.15934928140681826, 0.22815518199931373, 0.20985078234014376, 0.2171593584772652, 0.2014534885370579, 0.22264277495309626, 0.24857402002856233, 0.20044416939443432, 0.17755077477942582, 0.2041823380939356, 0.17254605830418424, 0.17857887604263578, 0.19106983582358072, 0.18548583930417195, 0.19950523840928858, 0.1945767606176244, 0.16878498819642973, 0.07096572407223756, 0.07657294728110142, 0.07131428906803017, 0.07098275053281689, 0.08786816033317757, 0.07993439256438284, 0.07505628157392052, 0.07577683147468073, 0.07093131683863063]}, "mutation_prompt": null}
{"id": "79517bbf-bbf7-4c47-bbf4-597bf0382c58", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.reinit_probability = 0.05  # New parameter for reinitialization probability\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant = self.population[a] + adaptive_mutation * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            for i in range(self.population_size):\n                best_idx = np.argmin(self.fitness)\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                # Select the better one between parent and offspring\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n                \n                # Reinitialize underperforming individuals\n                if np.random.rand() < self.reinit_probability:\n                    new_population[i] = np.random.uniform(-5, 5, self.dim)\n                    new_fitness[i] = func(new_population[i])\n                    eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Improved diversity and convergence by introducing a probability-based reinitialization for underperforming individuals.", "configspace": "", "generation": 32, "fitness": 0.16380388240801874, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.38518987875109356, 0.33621484439160176, 0.36217907107801073, 0.36586888504606374, 0.3527871710335303, 0.3746647866645665, 0.36725639703873914, 0.32594818923665025, 0.3564295832917682, 0.11389225113722701, 0.05774837853554149, 0.09435004071613551, 0.10446899524188158, 0.06395738698664188, 0.09443596414541167, 0.0772095639301611, 0.053872648126085054, 0.10211096631528949, 0.10580741456241971, 0.09374835842865836, 0.11993729366601669, 0.10477066485128561, 0.11143736952195016, 0.10607673544978913, 0.10674209084022257, 0.11343984291785913, 0.12303518632703059, 0.09766993918098976, 0.08445369188912377, 0.09910114510454038, 0.10134586021808667, 0.08245918173918487, 0.09834456296170668, 0.08663840373021325, 0.08807196463847156, 0.08763037448449396, 0.9554726460517513, 0.9575601979473207, 0.9380935896598631, 0.9257429638800881, 0.9387145581354716, 0.9600336671718791, 0.9505545516824072, 0.9388133380334646, 0.9462498395706225, 0.11764211484540787, 0.10848298351736485, 0.12043931473413938, 0.1076650485910472, 0.09713223504256252, 0.11308511984739433, 0.09917838727674955, 0.11659199886962124, 0.13425982404824355, 0.16572095061330872, 0.13735483941520144, 0.17285840380165174, 0.20236014194216678, 0.17585833020451958, 0.17880454166148507, 0.15724046712943696, 0.1695221429983942, 0.18352862482609522, 0.07566499779870606, 0.07132649500566735, 0.06792301129164557, 0.07569011744476162, 0.053359955007811544, 0.07817816551219203, 0.08764793230651036, 0.07705468383228542, 0.09682560086722602, 0.07876206758930726, 0.0711054936089286, 0.06501814541585427, 0.09697321196229114, 0.08950088755835583, 0.08637420389139494, 0.06645792346305557, 0.0877341899882702, 0.062756730335646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0883794902387286, 0.032629405267600164, 0.05708702951488609, 0.04079366644222204, 0.03489663114911579, 0.11702256668144606, 0.07871081823294024, 0.08065775588933011, 0.050836867359112525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025338753126877944, 0.03817434371010098, 0.029523711628969274, 0.02687293953364478, 0.024175493841319673, 0.035535235667003895, 0.04268543720600959, 0.034666373493276836, 0.03768528381218206, 0.3055437638771332, 0.2678145549982003, 0.29938296378464757, 0.30568656523614535, 0.2846623100426571, 0.3120755895266164, 0.3001729528293595, 0.29196940981576325, 0.2964864706816065, 0.07896222445130152, 0.0721647162946647, 0.07251011842757249, 0.07719026686845443, 0.08682464275301605, 0.07702874398937587, 0.07134259410609278, 0.06625522025684405, 0.07028243551671498, 0.14854321184489905, 0.13037608398063716, 0.13115692862625894, 0.12961604823061412, 0.1417158108990607, 0.14403378983718007, 0.19405948753742097, 0.13111704344908526, 0.13771581142489964, 0.19275340960710574, 0.1868461538793066, 0.20228269420819234, 0.20636900687875315, 0.195263224205943, 0.1969877784431059, 0.19890859957996998, 0.20350342479599481, 0.19594496098591185, 0.13894325210235625, 0.12770349349174126, 0.11822366289236708, 0.12535742750748813, 0.1357978704325169, 0.14025227579308552, 0.135599612395489, 0.1501555093568644, 0.14024280424240476, 0.19410111719988166, 0.16610980180080515, 0.18242085424322563, 0.17932717326964143, 0.20224860283399348, 0.17607220292672576, 0.19291460321498644, 0.16591985174987822, 0.186259303337578, 0.17310490808878187, 0.17586215588943066, 0.18024758187061618, 0.17325971367863913, 0.17368939573937203, 0.18092715938761894, 0.17194153623772912, 0.18619553921328114, 0.17344463687775857, 0.19336963098545434, 0.17133916304731434, 0.19012136577562455, 0.15365148867622158, 0.16199790619454502, 0.19314191087508503, 0.16690649675180935, 0.17753289512497306, 0.20702918074407495, 0.17436683396519803, 0.15798091971185801, 0.1546486905912372, 0.1829058186812511, 0.14592111659321472, 0.14440204627139297, 0.1921717690608291, 0.1735672278401149, 0.18236574450919618, 0.18122261512186344, 0.18449645887996824, 0.18785565006650395, 0.18482008537911365, 0.17786440382833513, 0.18365099792547668, 0.19614009682295097, 0.17344285698337736, 0.18753365475449968, 0.07718726286831024, 0.06655345987539418, 0.07319238659366989, 0.08221767016890591, 0.0662061739997436, 0.06642330892150239, 0.06186450952258837, 0.0615072180996038, 0.06208700792531141]}, "mutation_prompt": null}
{"id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 33, "fitness": 0.3201813384001572, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "d8ee5966-86bc-4c3b-82bc-df7c7b99d5f1", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "8247d61d-f783-4326-a56e-0c153becf57e", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "c0fc3149-e675-42e4-a70c-8b1df52f2196", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "0acdafea-6044-43a6-ba06-4778547fc672", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "f8f0a63a-b8e8-488f-a53c-ada8e151c063", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        scaling_factor = 0.5 + 0.5 * np.random.rand()  # Differential Evolution scaling\n        mutant = self.population[a] + scaling_factor * (self.population[b] - self.population[c]) + adaptive_mutation * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with improved adaptive mutation using differential evolution scaling to enhance exploration.", "configspace": "", "generation": 37, "fitness": 0.28374545307027305, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.716894836189998, 0.7265330168318433, 0.7444495108561262, 0.7217364339021914, 0.7526059794654221, 0.7286824324412358, 0.7460138847131504, 0.7088317939206674, 0.7301052447119503, 0.5109110424928842, 0.522062726954595, 0.5017852498730153, 0.5259640089581836, 0.5419702270308036, 0.4814279943579417, 0.5128262763896312, 0.47351409494609287, 0.5569938648822037, 0.36904591307603496, 0.48134266436927586, 0.3313124366932636, 0.41137347312939476, 0.49404662496112917, 0.463620283675631, 0.401827638988567, 0.523159570555628, 0.1692436630395987, 0.2386777421953854, 0.14594805299814073, 0.16197691554643412, 0.3453934080574256, 0.4983185005781011, 0.324937486491524, 0.42834714777948024, 0.2954785763235038, 0.432320374158378, 0.9835482486916571, 0.9816449220022999, 0.9814842041128804, 0.9765004730115717, 0.9765894594432474, 0.9675201415954678, 0.9831615221329781, 0.9720462105430137, 0.9681194095974905, 0.3253821934165422, 0.31973780981705624, 0.3517421642410262, 0.3305875698585231, 0.33540477606788943, 0.36429232285228896, 0.3066672576202204, 0.26560033690265394, 0.2740074092309285, 0.22497159179661452, 0.2199329530119205, 0.3030580718792617, 0.2018597945347923, 0.2287704041393982, 0.6696447958607092, 0.28656377507003283, 0.5202414401773472, 0.3302885884325608, 0.20352993594797963, 0.1578719827347721, 0.1751745860094992, 0.19662130642806352, 0.11859172877767266, 0.17966254542478888, 0.23254868731582135, 0.17048074698044025, 0.1718061424210824, 0.1800070772330017, 0.1062953467969544, 0.0509643547566726, 0.1373964279235399, 0.17615164170504138, 0.16286844587730953, 0.16010866802769796, 0.14852821110585013, 0.13917088686921686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04702232370769177, 9.999999999998899e-05, 9.999999999998899e-05, 0.0055944497099795765, 9.999999999998899e-05, 0.05966098635512429, 0.04370216504121616, 0.08657749892360134, 0.03406308375614575, 0.08365392453897025, 9.999999999998899e-05, 0.01793119771320084, 0.1911471854504182, 0.09813554902532484, 0.09004483286699883, 0.03557320802490338, 0.09719841617764746, 0.039584236695515584, 0.2399300112102174, 0.0801204891803452, 0.05239024734135311, 0.07138398497633058, 0.10151031838677393, 0.1027671455227408, 0.09185216660831608, 0.14779744057846778, 0.06253595897009656, 0.14026227469156716, 0.13097805331755008, 0.16007598336048146, 0.12658763211966872, 0.1879683650322037, 0.051222955745785614, 0.46149521047646413, 0.4717083990228489, 0.48542287422976294, 0.4769831754020962, 0.4923085181551847, 0.4887054285184037, 0.4509186951333768, 0.4507501742243457, 0.47212616754212666, 0.06648738059203951, 0.10897184901192591, 0.11023199159221408, 0.12896616277006412, 0.11199457865433393, 0.1025177255313402, 0.09282528057837358, 0.09153729825436496, 0.11038866855612217, 0.15203700232125716, 0.151640044096084, 0.14961849054825072, 0.14026886981280073, 0.1829814421467092, 0.15322592789224054, 0.17403888504081733, 0.25501454986329963, 0.19929501457121346, 0.33309613756939294, 0.24052257182550296, 0.34354613157146663, 0.33205281047799695, 0.2408960178683096, 0.30979911505995317, 0.3711290910305244, 0.34405766237381596, 0.3481865400887286, 0.22941835798173837, 0.26691635583093254, 0.30582573308338945, 0.18944107644413077, 0.20027766853721807, 0.1723929230742578, 0.24304351660415136, 0.26193785941700376, 0.28237660078338245, 0.22365225875865158, 0.21645234567958327, 0.1836374342693211, 0.21240215567235077, 0.22038073075238052, 0.2009180273653175, 0.17071880379917947, 0.1910643928703647, 0.21255502800559345, 0.5177537863650972, 0.4701122759308948, 0.22051633345861754, 0.19821566300021054, 0.20729254271098596, 0.20100293355356058, 0.41291035367000195, 0.48798211099027544, 0.21495847246168143, 0.1601659776684502, 0.5015990648255142, 0.15001312879653927, 0.18460289199094082, 0.19140849081115352, 0.16169885335329215, 0.13873348702772148, 0.15169321257596313, 0.7047185047148758, 0.31069063048966605, 0.20401835456652062, 0.17295592249198966, 0.4688064026788267, 0.1520424509116154, 0.19934412950789715, 0.25204304062790184, 0.20686517792208847, 0.2034205395937796, 0.17010915964327689, 0.17771833226786582, 0.16043389910998251, 0.1764652104743114, 0.17312610564881192, 0.1898320007934824, 0.19486398700764707, 0.20145998208654115, 0.20367511944528982, 0.08367767300185203, 0.08015144799371154, 0.08015802812172679, 0.0995060081207857, 0.08374708852394364, 0.05908290299961172, 0.07813173067638202, 0.06298731053421347, 0.07437224776153506]}, "mutation_prompt": null}
{"id": "8520d94d-56e1-4b68-af4c-a28defa6699b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "bca327b0-b0dd-4586-8776-c2b29edc1d82", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "a7554699-b411-44b5-8912-d47f54cf547e", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (1 - np.sin(np.pi * eval_count / (2 * self.budget))))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)**1.5\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with enhanced adaptive crossover and mutation strategies for improved exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.29322570876343546, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.7784554063244207, 0.7527779466035007, 0.7661801862382911, 0.7739202443186124, 0.766046577841599, 0.7852483437520378, 0.7749844554069368, 0.7716256312395204, 0.7692078635940441, 0.6522637399055569, 0.5982609112778706, 0.5987056721199329, 0.6549217307847464, 0.6409230110532376, 0.6018001238163125, 0.6556650850014643, 0.6088964061668065, 0.6410656820818972, 0.5876111084922424, 0.5909532907911108, 0.6182022739834097, 0.16544994312187922, 0.49180628973255247, 0.17209515634977346, 0.5967753757163834, 0.6108492684257755, 0.5828396426004222, 0.532431430409388, 0.5296067066529351, 0.1683789855162855, 0.554276808616968, 0.4708824263707805, 0.5221597012818262, 0.16995970721533216, 0.4803579408670765, 0.16469377799827, 0.9254037259086924, 0.9404614399055506, 0.9355016228956754, 0.9472410347062002, 0.9392798723348879, 0.9543930436839988, 0.9196547565895731, 0.9214623089460023, 0.9529831018806146, 0.34383456915093424, 0.14909216939427083, 0.20442589436562142, 0.2822404765597806, 0.2127899511459963, 0.23015926108741624, 0.2235909955493851, 0.21674246090383242, 0.24115526109566865, 0.17389252452968462, 0.21297856089459377, 0.20924658325474632, 0.2525969622264146, 0.2598615229631489, 0.17738451805396582, 0.21145335585020897, 0.2122599988093541, 0.2127293275461335, 0.15935661545050261, 0.12119576422711231, 0.11967102207599523, 0.15461360218280318, 0.15031626552470423, 0.11651660139437792, 0.22911345731065835, 0.11109381613645053, 0.159913526051931, 0.11441233279331942, 0.1821346661026758, 0.1462302569648587, 0.2289639518134935, 0.10214802262169342, 0.16209807806930598, 0.12186707500098348, 0.1426680079727234, 0.11678589805798001, 9.999999999998899e-05, 0.008373810377004132, 0.004132708494070769, 9.999999999998899e-05, 9.999999999998899e-05, 0.011612415377696195, 0.02571071557604443, 9.999999999998899e-05, 9.999999999998899e-05, 0.04875408892011435, 0.04852355446908063, 0.02842409971508153, 0.061142476208229546, 0.05806394831553641, 0.008191849868179668, 0.11920349124581864, 0.08052390826369138, 0.047361239016987966, 0.07257925554656286, 0.1062941799884427, 0.15027744409661736, 0.07598198927088395, 0.08769861989007621, 0.08003889410083209, 0.05093218679118727, 0.06779538828666987, 0.20433879579051728, 0.19881823368792384, 0.13163211055152457, 0.09864217427480038, 0.07984629413107247, 0.046635848008321434, 0.07763322078073143, 0.28624269869397057, 0.0989028923672789, 0.07740554872326322, 0.527274931630654, 0.4440577836633538, 0.45267675656356243, 0.482952238673351, 0.46623759762641115, 0.470388462141044, 0.5177521418393196, 0.4092320447791622, 0.5012531013155809, 0.10736522890771738, 0.11288393530041685, 0.07709528666264542, 0.12489985067340037, 0.0866384888556091, 0.11238422290894579, 0.09210990805936148, 0.08035558688106426, 0.09394998156316581, 0.19742813030119055, 0.20698208766793336, 0.20774274731527054, 0.2661996866630618, 0.2171292247118336, 0.19452222342050407, 0.19601752661872207, 0.1562809190899097, 0.14674240842027342, 0.3039452079809042, 0.31681408483602713, 0.38038104298813746, 0.37382198444839365, 0.3744974930584535, 0.29394415354456593, 0.36267577141932383, 0.28186312082911114, 0.33483294555046383, 0.18247241097731626, 0.22173444734151104, 0.2989219408010376, 0.22150837684386615, 0.2655543471858155, 0.2800343415565003, 0.26022983387587606, 0.21617757892073564, 0.13687737557904456, 0.16503696608340612, 0.19602797158565277, 0.20216116615514534, 0.1713213107130951, 0.16947756633440025, 0.17178157105492609, 0.21335045737811065, 0.2264296318069906, 0.2079878697777966, 0.21237107528006904, 0.24412675657665894, 0.23294388046191372, 0.19906960126019368, 0.2332407582594881, 0.20969132791110345, 0.21346520826016735, 0.21069413216057398, 0.23122832904589907, 0.6399464101240278, 0.18696319851252885, 0.18971331779986933, 0.18641046427012642, 0.6222597052188628, 0.38701846523081285, 0.1511761595405855, 0.6330147833661286, 0.7842877363815607, 0.4386703148426966, 0.2044015055540137, 0.6080400784355996, 0.5154380996958968, 0.25363504952085814, 0.16359638846357516, 0.15547725187828842, 0.33619419864596156, 0.3950419552476867, 0.1765997908431698, 0.2066278041427333, 0.1653411351747509, 0.19849929630505847, 0.23149289270029194, 0.1687614784402689, 0.19764956877489837, 0.2021208747940102, 0.2133785157402477, 0.09384682108654396, 0.07493938157132729, 0.06376616373121724, 0.09258472272817164, 0.06906574560606005, 0.08592268277191961, 0.07659555779223914, 0.0877112772132832, 0.07091256817932023]}, "mutation_prompt": null}
{"id": "ce860d04-e596-47f1-b307-401239217de1", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            # Adaptive population resizing\n            current_population_size = max(10, int(self.population_size * (1 - eval_count / self.budget)))\n            new_population = np.empty((current_population_size, self.dim))\n            new_fitness = np.empty(current_population_size)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(current_population_size):\n                mutant = self.mutate(i % self.population_size, best_idx, eval_count)\n                offspring = self.crossover(self.population[i % self.population_size], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i % self.population_size]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i % self.population_size]\n                    new_fitness[i] = self.fitness[i % self.population_size]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive population resizing to balance exploration and exploitation across evaluations.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 49').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 49')", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {}, "mutation_prompt": null}
{"id": "896c0929-f971-4e09-81f6-91e15dba4983", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive mutation strategy and elitism to maintain and exploit best solutions.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.827321109054796, 0.8196035122156176, 0.8190209995714746, 0.8241930726779274, 0.8352414302233306, 0.8408288330802557, 0.7982082439694652, 0.8109149496054491, 0.8159255414963749, 0.6980855331334818, 0.6854961464505784, 0.6798669962648259, 0.6974120993476565, 0.673853920041239, 0.6663161728732802, 0.6780867765220222, 0.6638911293021414, 0.6911442330987025, 0.17048418880716631, 0.647333471177945, 0.6432423965035566, 0.6731225849247822, 0.6272576996824921, 0.6133144310230645, 0.5815512582949292, 0.1773187057072979, 0.17305977281969187, 0.519536714442383, 0.16703379082614933, 0.17529956955600134, 0.5762136858129605, 0.168524005645742, 0.17070552883392776, 0.5198910342149331, 0.5639228379350923, 0.5807265600643188, 0.9834460053831875, 0.9496437928325445, 0.9767265005176641, 0.9695508976447049, 0.9485878228009919, 0.9606895401515397, 0.9703555771266251, 0.9630079768508314, 0.9725253324325956, 0.35450983589162754, 0.41407544644992644, 0.4076939514627297, 0.2997766232912996, 0.41809791053829937, 0.4682552997430508, 0.2955493550506778, 0.3278191227259455, 0.3351299542340387, 0.2048626593379318, 0.22285403574458795, 0.3342151672085346, 0.34172627756282314, 0.18840252080251207, 0.2691786332689189, 0.338782280373055, 0.3391791893648062, 0.29667021450729814, 0.18615102231320058, 0.1462392365080818, 0.17289455999554415, 0.11412417059274016, 0.15964392158261598, 0.12693797054072076, 0.4571593884499361, 0.11784058704499256, 0.2189342027611677, 0.14901886283900145, 0.14331261881182622, 0.14992264040453596, 0.12835562958760838, 0.20710476042620707, 0.17311942148878823, 0.14486092104269666, 0.12487991171936408, 0.17797758992768342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059534365472142414, 9.999999999998899e-05, 0.005957575517294034, 0.004453890589278253, 0.05519834172617011, 0.02610807005430671, 0.10308793233152302, 0.08604772974823194, 0.05418132760684402, 0.062028596068353536, 0.02905578337850856, 0.1254058460251365, 0.12398326731447162, 0.12533397332031437, 0.17281740347941998, 0.14361869571721686, 0.09884276721620378, 0.06172401218482648, 0.17949746384133702, 0.10268481427420006, 0.0970115584663368, 0.12239364868934421, 0.14708089171319294, 0.10840189787483345, 0.1261922738830321, 0.08886084610229483, 0.10336514348714676, 0.07985195825677127, 0.1212938551427496, 0.26366637192106923, 0.08215758491211977, 0.05523196626316518, 0.08735775233709686, 0.49357688856809834, 0.5336611214640128, 0.5166940687208379, 0.4620518956001167, 0.4996853657608381, 0.47842226868458737, 0.4837660962456706, 0.5073746322448593, 0.5308889868067896, 0.10819763982742348, 0.09192429073719288, 0.10135525359913333, 0.13473409376883172, 0.08848553630810219, 0.10999704092090856, 0.10528795366283616, 0.14584804740218693, 0.0868146418056942, 0.2691191754128357, 0.18960052862148546, 0.2992481130382858, 0.23959010782186618, 0.19653992191217462, 0.21249095779468674, 0.341954755965745, 0.1491709268818162, 0.25044473844483073, 0.38338629226706655, 0.37502630407498727, 0.38088256367995754, 0.30759646652718653, 0.3909348138813734, 0.4000809202974903, 0.475227282880171, 0.42911033658180553, 0.4418163327513136, 0.18732938029969715, 0.22162001751398097, 0.2861365677568978, 0.33301747890347655, 0.271218345927431, 0.2732867984756828, 0.21452921894918575, 0.2963561078563949, 0.24485677850888632, 0.1755434622999299, 0.2020699402382865, 0.23601718152582474, 0.23613156190433693, 0.20236889406138636, 0.23145956616299623, 0.20549262697416737, 0.1764185836287525, 0.2113343986313012, 0.6493735411859689, 0.2407870776782467, 0.24320636559302944, 0.21752531921018037, 0.21347193087469563, 0.21874725097960623, 0.5462296007749399, 0.5341785112904924, 0.1908683374054172, 0.1844706310297778, 0.18768912341982547, 0.1504070201502583, 0.8241656435556941, 0.19647121640061316, 0.755519090290673, 0.18265675679374338, 0.17256131729212842, 0.8157940385670517, 0.37609444436986283, 0.20723698784022604, 0.1665062679940238, 0.20574380429048456, 0.16497089622081718, 0.16696815673906462, 0.5784356026726574, 0.20823626645486437, 0.4588451718721862, 0.20270574920700102, 0.19079606774886282, 0.25182705593531796, 0.20954213411667477, 0.1802906110782042, 0.20895903927380688, 0.177568817964455, 0.20742254764259327, 0.19974140992075395, 0.09422446606024781, 0.0821150618122719, 0.08123671089597173, 0.09918233851323144, 0.09204437890398043, 0.0743654122816575, 0.1224207407695852, 0.09714645415853307, 0.08768057717101052]}, "mutation_prompt": null}
{"id": "7f5ee3e6-e3c1-4e53-983d-1026eb72e97a", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with dynamic population resizing to adapt exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.326703662872642, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "aeadddc4-1f39-4ec0-b4ed-653dfacb2003", "metadata": {"aucs": [0.8342152777915502, 0.7956803973662161, 0.7936093623399727, 0.816997061684156, 0.8130753600732792, 0.8098007351128244, 0.8180476499031515, 0.8047588817156285, 0.8173487887581996, 0.6564663608995726, 0.6635910798827362, 0.6750015509826774, 0.6582001260336522, 0.6541525341843601, 0.6693871571068365, 0.675949508941834, 0.6346702147707863, 0.6753545791929395, 0.6227799811794272, 0.5598977436280175, 0.6284721524894132, 0.5850101810314092, 0.6278055108250995, 0.5998386261157735, 0.5532119282361064, 0.6488777276338971, 0.5739600934084613, 0.16986140812240935, 0.548569822038486, 0.5188918488033065, 0.5834223016179854, 0.51210446478103, 0.5687945940972852, 0.5755928520351435, 0.17234646472672321, 0.1722289259752734, 0.9734663476399322, 0.9665322473896929, 0.9678241963935238, 0.9649583467354875, 0.966510756475551, 0.9701217966549683, 0.9725077948677381, 0.9670551787756501, 0.9604000122107841, 0.4070151908431401, 0.3521164789619785, 0.3237656395909063, 0.33638779131381036, 0.3949248270493151, 0.37151507618329593, 0.3373280535751584, 0.3939003364451521, 0.3729338056443565, 0.36074899143158323, 0.22329157246916254, 0.20321426749924876, 0.20849808386683222, 0.27349936131468844, 0.26520676231647156, 0.2194767743244591, 0.29595838819536935, 0.23386133293949163, 0.332636273356248, 0.24522900781598844, 0.16861967086637886, 0.12395149683985307, 0.13989885526707113, 0.17085556278994574, 0.21422735540756843, 0.23587680508384012, 0.21228885883878956, 0.12321052182430581, 0.17903637688787088, 0.14817669260681687, 0.1713804256313921, 0.17174859436820367, 0.14070640650175936, 0.1532965486313771, 0.17379842235211762, 0.3828823508527829, 9.999999999998899e-05, 0.09020748035251358, 0.05118547377992877, 0.0011474626345028272, 0.006436995148326297, 9.999999999998899e-05, 0.02626095719622734, 0.046719741392046266, 0.07405572647823833, 0.08157939931652758, 0.14084732359407282, 0.051748846578576924, 0.06749228402106, 0.04627504324084042, 0.041920173211406286, 0.09052676424301376, 0.07120559833677653, 0.04857116891853985, 0.07881894842506187, 0.026721709581688957, 0.05764024396743883, 0.10490169626249712, 0.08058923294912879, 0.17745461399700946, 0.12241210928456292, 0.09275173262555259, 0.13050200059274408, 0.21709234508069808, 0.15075621849170218, 0.20330351560538118, 0.076409780178893, 0.20259029199222278, 0.16555046148426467, 0.1352683871961231, 0.1253128819920799, 0.13595332303287155, 0.5059643235251505, 0.5729531358767675, 0.5134495515268596, 0.5059622929640486, 0.48442936190293484, 0.49030019923856694, 0.5470340237638124, 0.4799364602992018, 0.5175313608561521, 0.14744091527000147, 0.09627012544081459, 0.12471055390039842, 0.10472902325364808, 0.14241401652051955, 0.11908907515985667, 0.14007187049417702, 0.11078307952010857, 0.14476013019658496, 0.24320132949373852, 0.18514915382978014, 0.15631283995869039, 0.21366650582669, 0.19307109851413085, 0.1974691345572115, 0.18225464852307693, 0.1989981554601341, 0.22057340006722737, 0.3024294902233282, 0.39832902773061296, 0.32586951015509236, 0.40655867117064204, 0.41409610553716913, 0.3665275435248162, 0.3824876162503299, 0.3812868460621901, 0.44679462235319, 0.2960129423429243, 0.249694607367682, 0.3044440880475956, 0.22186444801494654, 0.2696799140137709, 0.2863049926839363, 0.2175656491034802, 0.22657149531287257, 0.3288083929214649, 0.22035117617413758, 0.2066351512926421, 0.20535328081339832, 0.2740843034638083, 0.1810232361981846, 0.2319236702736801, 0.2094882983352201, 0.19594334424614623, 0.18235411508849508, 0.5176513191138434, 0.6617600117733977, 0.21630454243571395, 0.21673872139707206, 0.23357914576140315, 0.23581327046623923, 0.23540376947819042, 0.19665868543313159, 0.2182947730089524, 0.8232510920908777, 0.187386196569034, 0.1830017915601282, 0.791345291725199, 0.7410220708493469, 0.19007797538372873, 0.1406543803076482, 0.1776351960912551, 0.7410754868603682, 0.6534598317734885, 0.20527995655336528, 0.20644154813830384, 0.512937549678375, 0.19982236089761996, 0.16445972810303178, 0.2066749051967406, 0.20454488508285829, 0.20326612248934095, 0.1976720601263764, 0.18897925212439282, 0.1790814265879238, 0.21437469498197192, 0.19243939352223738, 0.1972216977816479, 0.18810058531816376, 0.1890877922031966, 0.18752905405626985, 0.08196961968802641, 0.08900088363579928, 0.09389441678197796, 0.08397863055163124, 0.09446302271080276, 0.09457963590457819, 0.08617911912600007, 0.09625395211537602, 0.09841420871541995]}, "mutation_prompt": null}
{"id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 44, "fitness": 0.33033440098850164, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "7f5ee3e6-e3c1-4e53-983d-1026eb72e97a", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "8328aaf6-64f7-4500-86f0-8b7853cdc581", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "d3607b94-e3db-4c1d-a262-24680fe54bf9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adjust mutation factor based on population diversity\n        diversity_factor = np.mean(np.std(self.population, axis=0))\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2) * (1 + diversity_factor)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with dynamic mutation factor adjustment based on population diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.1007960987010037, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.13391624548748438, 0.10504971475517744, 0.12256403416631256, 0.16105114728011627, 0.15540347883668748, 0.1620085742003533, 0.1254309688804065, 0.12145644520028742, 0.11891853406047814, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.015278098086527137, 0.01490604177609689, 0.02652485362592305, 0.027280923205159846, 0.023191770304412107, 0.017835727078353014, 0.03608768437353138, 0.01854587736792579, 0.05163017758226396, 0.013807366466671911, 0.007679175017563877, 0.025215842396152932, 0.022729617157374205, 0.005966325809040995, 0.021696628375517002, 0.026794803823014468, 0.0016947594066001326, 0.0, 0.9790386010944175, 0.9839460863482439, 0.9849435171887965, 0.979428959275908, 0.9875977020512972, 0.9804615353987243, 0.9820668470059432, 0.9704082450799351, 0.9828989523753904, 0.08842729303428509, 0.03908450581129286, 0.03784432045277386, 0.01427300673334908, 0.015194472112097568, 0.03376530388280585, 0.03195219479280531, 0.060466925921960124, 0.06345888725253712, 0.13174614747248525, 0.13544493607838504, 0.05973037536276404, 0.10942277514563015, 0.07275849405211954, 0.08112537230144212, 0.11072657700939381, 0.08420178041144355, 0.08793138754901775, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0037289080134481623, 0.005047779213375181, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.010910074968588424, 0.0, 0.040362776081771856, 0.02620092294146703, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14636605489788712, 0.15748132322755004, 0.1564395648689435, 0.16135542353130383, 0.1312983249522517, 0.12887991814147426, 0.17328560933136872, 0.11367383579032353, 0.13301883623361377, 0.03837410948297171, 0.024335055218311585, 0.023243856384275063, 0.05505568230282476, 0.005815427381073102, 0.021257427020215602, 0.02656923726141558, 0.015137318633523855, 0.0266683362657002, 0.12330735290177586, 0.1002862277249853, 0.11833361437130274, 0.12724742530570843, 0.14267569968019944, 0.1169806631250554, 0.13400466908573505, 0.10543266807908003, 0.10563642708266019, 0.1306703632874664, 0.11897401348363323, 0.16130937881362173, 0.13792052181401226, 0.12518147785460154, 0.12045193574807822, 0.14527594893885398, 0.17369512487615435, 0.13248278937366997, 0.06683013953499506, 0.0810060334876771, 0.08389423256590267, 0.07433434607277467, 0.07790779326686226, 0.0789775809681682, 0.08519744085004621, 0.09968109929816016, 0.09105974249364879, 0.11934558904189485, 0.1060340299228566, 0.13336421106438667, 0.11198840628323359, 0.11351310396098324, 0.12180438583982889, 0.1261223446178117, 0.10958345592485363, 0.1354710144048551, 0.0, 0.13308381955800486, 0.13876245361967599, 0.07030222310393297, 0.0, 0.0, 0.12063235225695568, 0.0, 0.0, 0.1290094106080385, 0.1146959008933447, 0.11069947137309677, 0.1677096930019285, 0.15919484963024078, 0.0978729248288811, 0.10692837481480677, 0.11097301857522202, 0.09366670921837139, 0.11031370369950766, 0.10632440084099748, 0.11277629550621804, 0.0887807530463035, 0.04779395322443891, 0.05893840155281127, 0.16393488929523314, 0.1728978010619514, 0.10396831889055447, 0.16968340808132687, 0.18186850608567917, 0.16566868295092518, 0.1585261852062595, 0.16955549853171537, 0.1763881230562473, 0.19073547546242597, 0.16404628963597245, 0.18252246442922748, 0.030228891285577042, 0.02567533543604872, 0.031296624077933655, 0.037087300888850816, 0.034154360663545824, 0.028790257964131705, 0.034698026629739975, 0.037937353376281346, 0.02233774785050535]}, "mutation_prompt": null}
{"id": "1ea241ec-f966-4fd5-a7e4-4675e13e9aa0", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "9023dca3-7c5e-41be-b564-5cdc5d991bb3", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "5461d069-63a3-4ecd-bc12-d80b5e621739", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "3a34cf29-0ded-4c8b-bb00-dab2ab3226c9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        population_std = np.std(self.population, axis=0).mean()\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2) * (0.5 + 0.5 * population_std / 5)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Improved EnhancedHybridGADE with adaptive mutation scaling by incorporating diversity measurement to maintain exploration and avoid premature convergence.", "configspace": "", "generation": 50, "fitness": 0.11392542397042146, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.2646309996741252, 0.19364327054701236, 0.1554764795809631, 0.20846054604798947, 0.1597836246161447, 0.16071202610181956, 0.15564655642922665, 0.17716224698460414, 0.1723485004337807, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05474531541693339, 0.04840055410120481, 0.03372188337239457, 0.04710897551507931, 0.04629475784323245, 0.03965280232991486, 0.025256948917937394, 0.05151862433615284, 0.05027415559076287, 0.028392367337072955, 0.015410800288497173, 0.034584296508240686, 0.04428344403119877, 0.029756807750070613, 0.021121604571292085, 0.04407994831685391, 0.02324242568924184, 0.003563466499350354, 0.9636391277458852, 0.9612025873793114, 0.9678541938996464, 0.9745625144115073, 0.9643678679910763, 0.9692485454582009, 0.9623690797042046, 0.9704460532976663, 0.9733176873480229, 0.09169633577442382, 0.05417051849268828, 0.017900189785658216, 0.02326775272020254, 0.04321294585691926, 0.018395200770964903, 0.043011662185431176, 0.0474398418222145, 0.11923521689944916, 0.10049963236602422, 0.1374457237288822, 0.07270397566830011, 0.12743218010295898, 0.13809914150539648, 0.11521912255142741, 0.06907134783025215, 0.10789764350304143, 0.08831559581510862, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.023203136517771394, 0.0, 0.0, 0.04015107727559808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.002511580534552915, 0.045179248955271256, 0.040063774230638005, 0.0, 0.03723156490801849, 0.0, 0.027910748411019037, 0.0, 0.051494735561674276, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15671318869187179, 0.17824190009837004, 0.1608552209297024, 0.23330665551343877, 0.17796239695926797, 0.1581452282618322, 0.20276623627272117, 0.1508874288979043, 0.20530330960684984, 0.05241365770363138, 0.04799443520825186, 0.03134367683100858, 0.03746808668260715, 0.0230506142167487, 0.059192714253488155, 0.028544619934217863, 0.03429178375936004, 0.052331131115520346, 0.10131665656368116, 0.11715497305605038, 0.1194834773067116, 0.11783530039586165, 0.11389452543064726, 0.11316576529137379, 0.11421768323590875, 0.10583129216995435, 0.11937483052246511, 0.14834767514880753, 0.1428243601676884, 0.16368966873127844, 0.14954402167772618, 0.12816324333100126, 0.15931820947380615, 0.14782457888784484, 0.18513131207445177, 0.15567889435275206, 0.09791057817255155, 0.12740561219921087, 0.12017916447671328, 0.09347576913575795, 0.0815447277812511, 0.09696003291577349, 0.08633573920496129, 0.101416601647769, 0.09609803220508417, 0.13213346402751736, 0.12729614235807352, 0.1359649197927182, 0.12767941883620348, 0.1056342214301429, 0.1342769968185148, 0.13465667153884986, 0.11588642594533394, 0.12610897469223947, 0.13394369602875045, 0.16124317249543674, 0.14156976991515657, 0.15384662170291807, 0.0, 0.12613013586995026, 0.15028836618970942, 0.0, 0.1429358434062855, 0.13765881675428737, 0.17229541543587779, 0.13071207501013415, 0.22616138551384068, 0.22718538802652344, 0.09953014380110248, 0.11089518656632791, 0.1688197340073968, 0.11001340556153505, 0.11167546053958155, 0.12078415779482077, 0.10585527157062602, 0.1058328085496989, 0.09305047078578377, 0.15498871121751434, 0.18961777272876246, 0.1288130921412678, 0.11200853975358027, 0.20647500907814398, 0.21335018871745504, 0.15774342888754622, 0.1651074366547558, 0.18739918158253932, 0.15431385350227866, 0.1962316818489881, 0.18321287331917901, 0.17152955101403966, 0.04011455245385098, 0.03902053288300067, 0.04139598875389361, 0.04204148697582877, 0.037611644492545726, 0.035272592750430376, 0.03655382960693909, 0.03793735337628146, 0.03311172457249645]}, "mutation_prompt": null}
{"id": "e237e3e1-5572-4bba-9b5d-61aa23dc964b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        diversity_factor = np.std(self.population) / 10  # New diversity-based adjustment\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * (adaptive_mutation + diversity_factor)  # Adjusted mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Improved mutation strategy by adding a dynamic adjustment factor based on population diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.10903701489653354, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.20430725993468513, 0.15436082915728644, 0.1518795093605615, 0.19819948979332125, 0.15338591799296042, 0.1510252062108417, 0.13617893978338758, 0.12188890674511244, 0.15649598572196244, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0519141736860933, 0.024184354692698973, 0.03360059542831151, 0.06388972919418068, 0.024423526066162604, 0.021451896977709883, 0.033710614075970424, 0.04894571001061254, 0.034958927148335706, 0.023325643490881287, 0.00856965944081034, 0.010820528252746042, 0.05033490484504166, 0.01284169847311245, 0.017257525446993216, 0.020309971397415527, 0.020464864073044375, 0.01315110569173139, 0.973878294048157, 0.9699516110895255, 0.9833891555717332, 0.9747399148006075, 0.9739432912981383, 0.9685942300702401, 0.9748915094166978, 0.9745590727055586, 0.9737353673536941, 0.06550472353385117, 0.03173363163249321, 0.023201870409424785, 0.017384790436335784, 0.036413896474429386, 0.08125533896865622, 0.03727345187807407, 0.06247343156376084, 0.06068724401758263, 0.1004153887284861, 0.12843618257449285, 0.08339395954389128, 0.14110852949637043, 0.09520170957419127, 0.09009484739838969, 0.06251343120582065, 0.11460143775960374, 0.08673115394187048, 0.0037922448133429487, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003554127390949513, 0.0, 0.0, 0.0, 0.008063332120895716, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03950778061076432, 0.0, 0.04300391918081459, 0.0, 0.0, 0.008272093802199176, 0.0470983889190244, 0.048444958048856845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1725756963717957, 0.15748132322755004, 0.16918775196873137, 0.17586866846107263, 0.17377091001948974, 0.15101060317450832, 0.16319541396490078, 0.1824796620780238, 0.19865694265512812, 0.041251674890250056, 0.024973788947214803, 0.050347868086804026, 0.03864827747291055, 0.01334125200348335, 0.04663066158870699, 0.031791028613624595, 0.015479457793312723, 0.02860811049791845, 0.12958980715223134, 0.09947121605799569, 0.11833361437130296, 0.1193969076154261, 0.13455952485919365, 0.11698066312505528, 0.13394322824365534, 0.11449398184011039, 0.11087051565620054, 0.13309206731692225, 0.13299731171446838, 0.16130937881362173, 0.13792052181401226, 0.13410656804927734, 0.13473389816765213, 0.1559143154413779, 0.1788306019694308, 0.14014049218832403, 0.07969803800733899, 0.06465969579906372, 0.09806357116416753, 0.09371926045144174, 0.06413245117764832, 0.08262209154825273, 0.09566278181193333, 0.09968109929816016, 0.09103344506249, 0.13462767458636626, 0.12547938283490567, 0.13336421106438645, 0.13151435784586907, 0.11703572374859594, 0.15388120099741065, 0.12237199858757664, 0.14032807014115967, 0.1378479789368725, 0.1550541489014604, 0.13673909702192355, 0.13915281290928816, 0.1367482936979355, 0.0018346909196794714, 0.0, 0.14343192721525122, 0.008496561811167758, 0.14763661706213826, 0.11808488407629081, 0.11804787719787146, 0.11907748006538954, 0.1665848814310652, 0.12070353966556291, 0.11594865864813275, 0.11527953436056249, 0.11097108679667034, 0.103054191478965, 0.18286190315832662, 0.15451874751482286, 0.1415861779662062, 0.1667380193779774, 0.10120384557324125, 0.11949100250474476, 0.12665179783886493, 0.17194651163337893, 0.09564535253353901, 0.1958308625810835, 0.16764953248766123, 0.16016584360112507, 0.1568594343455224, 0.17670360876935687, 0.14994095510957306, 0.20396000902281286, 0.17049650110277947, 0.1696167880149153, 0.05648279907789133, 0.04353765328114789, 0.04739393027457972, 0.03287114750385023, 0.04474609675972807, 0.03375843068195716, 0.034430295359068386, 0.04266294840086826, 0.029970217170651292]}, "mutation_prompt": null}
{"id": "026056f3-bc89-4750-b09d-5051f35506f9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "9918bc17-c935-4bb5-b5cc-aaff82ac6e47", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count, success_rate):\n        # Dynamic mutation based on success rate\n        adaptive_mutation = self.mutation_factor * max(0.2, success_rate)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        improvement_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                success_rate = improvement_count / max(1, eval_count)\n                mutant = self.mutate(i, best_idx, eval_count, success_rate)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                    improvement_count += 1\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with dynamic mutation strategy using success-based adaptation for improved convergence.", "configspace": "", "generation": 53, "fitness": 0.31544248492525073, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8342066439913116, 0.8490453170631355, 0.8420282578434545, 0.8439335354967089, 0.850196984499036, 0.8420556552886214, 0.8433272308962273, 0.832026704957507, 0.8309930541354121, 0.7064243114746385, 0.7013861577929804, 0.698112991165325, 0.717718628351573, 0.7013254171297446, 0.698426449655634, 0.7108119701647589, 0.711716847790457, 0.7332167987299091, 0.7166004970711711, 0.6733877390097918, 0.17865112167940078, 0.6326230580613316, 0.669329323971582, 0.6931549082406246, 0.15266920636660275, 0.18440862451362705, 0.6880787292500559, 0.6201642010111852, 0.6511246469825986, 0.17636356176860357, 0.6627246334196211, 0.17417439858608197, 0.17640234159528978, 0.6442030451798004, 0.1722055137501073, 0.15344616957752732, 0.9521721451394631, 0.9236942601150361, 0.9469818509607701, 0.9441423036732025, 0.9558868754731413, 0.9468184995008454, 0.9362350606292543, 0.9449154007407131, 0.9397204266969401, 0.2295300439167931, 0.25695098175773745, 0.25625624460444996, 0.21474324024676328, 0.24796194875163535, 0.30104104858678193, 0.18051998361886468, 0.1568170004143229, 0.302067272831793, 0.2347007339870395, 0.3216615523213803, 0.15732883322098223, 0.27494088652470516, 0.2671178462262648, 0.34603797783078194, 0.1627415580549647, 0.21586769134517148, 0.3196056236631335, 0.24036354347858924, 0.14652092361712854, 0.17018257444438623, 0.163110684682503, 0.17339526539433714, 0.1423711310012754, 0.1913012389239399, 0.14544861340099846, 0.3354881882511975, 0.15762789940523003, 0.1209339484723112, 0.214764863381821, 0.1291886064195178, 0.1302871790805482, 0.14191716605523363, 0.15024379253130404, 0.1459293225276468, 0.17184914973554188, 0.05999443568057372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06319456617942998, 0.0007993337740612727, 0.1047255354971216, 0.07602225715975364, 0.050060703582280985, 0.06585743465618143, 0.025262558938794255, 0.06346128482039293, 0.12401665818726448, 0.1178953415316597, 0.1093127918006932, 0.03171549895351977, 0.11770804451295458, 0.22454036500902208, 0.1820752267416058, 0.20526740430947776, 0.09661433096339933, 0.23565060471967314, 0.07829140452184258, 0.06085419368506262, 0.26246858258090655, 0.10206057771097843, 0.1558606149035846, 0.11991317063268447, 0.1872804295015772, 0.10548816251904758, 0.16573997612550972, 0.12397112508190189, 0.1342433398440207, 0.4052588371018526, 0.4754086461178576, 0.4677490168942945, 0.5648224082230942, 0.483964366221316, 0.5045429655670843, 0.5238348041340983, 0.4943173416744915, 0.47857532619349397, 0.12130127881484531, 0.15187094257836853, 0.1052344622491117, 0.12626076758036942, 0.13043696248689363, 0.12080801844543165, 0.14265418151550857, 0.15514338261483496, 0.0868144714393404, 0.20217702592837516, 0.24971156341184653, 0.18241676299488108, 0.20356141593213617, 0.31511921627477424, 0.191172137332973, 0.22207073520752874, 0.31575557197214343, 0.19357931620794722, 0.3000582970270589, 0.29291638807352294, 0.3826434175216764, 0.2761832397522779, 0.40525493013695446, 0.31681178925455356, 0.283667758433202, 0.45727732925600406, 0.3668200253403826, 0.23656006372240357, 0.27019220829443213, 0.25973418212876587, 0.24026986343519496, 0.21623162233980342, 0.2702382609261327, 0.22133879095694287, 0.24877774209039805, 0.3689957519670257, 0.24588555536962653, 0.23966778380030007, 0.20287712487919662, 0.22294172332822426, 0.19533470629341565, 0.21496038122844874, 0.22797078751949096, 0.19905590138723805, 0.23234745083504393, 0.21378666333867535, 0.21845819045773018, 0.2105163296067134, 0.23980413144580648, 0.7077179160785239, 0.2242671913837938, 0.6025010569412372, 0.6232050859617151, 0.6638960737812284, 0.18353820699965195, 0.5689205429714137, 0.1494255724668796, 0.6597083603778751, 0.19754839985420047, 0.7905467542683592, 0.16372748463468667, 0.19425714452838305, 0.1653900664626552, 0.43047732929842697, 0.2066137599036757, 0.3290908531800324, 0.31992482533089805, 0.20678159668875973, 0.152193006848099, 0.15911081792946713, 0.2043632139453333, 0.2715030296562353, 0.19678767090003668, 0.2088220607049177, 0.1922000395649277, 0.22496391112894, 0.19153560809490888, 0.20780613124286107, 0.18969636336041762, 0.17581926146842564, 0.21142853151663843, 0.09938807444651998, 0.10396637864417368, 0.09738523200463, 0.08251882776578257, 0.09047247913032974, 0.10311486047246421, 0.08329590084772265, 0.10156728605825849, 0.08296750952627441]}, "mutation_prompt": null}
{"id": "f658ed16-aa88-424c-a204-92da4f10de5f", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def local_search(self, individual, eval_count):\n        step_size = 0.05\n        for _ in range(self.dim):\n            perturb = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(individual + perturb, -5, 5)\n            candidate_fitness = func(candidate)\n            eval_count += 1\n            if candidate_fitness < func(individual):\n                individual = candidate\n            if eval_count >= self.budget:\n                break\n        return individual, eval_count\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))\n                if eval_count % 300 == 0:\n                    for j in range(self.population_size):\n                        self.population[j], eval_count = self.local_search(self.population[j], eval_count)\n        \n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with periodic local search for improved exploitation and adaptive mutation reduction.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {}, "mutation_prompt": null}
{"id": "4049501b-d168-48a1-ac6f-01a1ff7d06d5", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "ace43fb5-2e36-4c6f-987f-2dc53da2b6eb", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "4d3ba3d9-1a14-41d6-8da8-1590b4e4e18b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "3dcf3a39-b19e-4217-a153-43cb94c9afc4", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "61fdd8bc-96fd-402f-863d-181c63ff3088", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "54f4f9f0-e592-4d6f-9202-7f5ee251042b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "7979d492-9d97-4244-9304-cba1bd5f64b4", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "af987eff-06c8-4c01-abe5-7a3988595776", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "08daf258-df0e-4af8-bff7-b754721f6870", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))  # Reduce to balance exploration\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with adaptive exploration control using a non-linear mutation factor decay for improved convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8178534203513232, 0.7736946017355073, 0.7893644993896376, 0.8132553396457355, 0.8178786679107316, 0.802868891981829, 0.817456026671561, 0.8012316470443903, 0.8009030856325028, 0.6429101711936727, 0.6667080825623297, 0.6458199580253984, 0.6374669956806468, 0.6659457040220678, 0.65827737515213, 0.6514734460800453, 0.6604626213626452, 0.6824655876761128, 0.602078822124742, 0.5742278705472941, 0.17039435345557918, 0.6457963648242748, 0.5405276191723074, 0.5554742643645966, 0.530039845468116, 0.6254196103338255, 0.5844208665841684, 0.5558045908296777, 0.5015842019469025, 0.5419100287895089, 0.5348205534211639, 0.49059879247849325, 0.1750043064540101, 0.5526040877823822, 0.5405145955249446, 0.5308263514466152, 0.973473043226363, 0.9666575368993852, 0.9678648268039531, 0.9692936671605968, 0.9665330522656486, 0.9701230054980383, 0.9583339057249912, 0.9615187696560002, 0.9612680721496403, 0.4339196789539377, 0.3031414121474266, 0.3501253481192712, 0.3018721536869411, 0.4289526133486047, 0.3946244355502355, 0.3540009372616191, 0.3752919984364145, 0.3508531707812792, 0.21816502274925154, 0.2235675426520657, 0.34915910303988773, 0.2085042181671496, 0.26839721235366365, 0.26754291196169033, 0.6907952488929701, 0.3244724159475818, 0.6453332146154884, 0.34061095535781827, 0.17127305018332495, 0.17224111374254225, 0.17348565744013522, 0.12235377140943948, 0.16798186451978037, 0.16014533912091722, 0.22973333067399138, 0.1934207615679533, 0.1571682045974958, 0.1213948938405367, 0.13930192361146232, 0.13893114910313287, 0.15236727349017287, 0.148680088951894, 0.17084699406383297, 0.17957907129238904, 0.16222183128590784, 9.999999999998899e-05, 9.999999999998899e-05, 0.019329758314498013, 0.04340015985600987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02193959184468275, 0.06097203241664062, 0.06466222348190276, 0.08524710434233962, 0.10294349014971271, 0.08278669583701159, 0.016343958397232794, 0.02291290934620105, 0.08687000365498931, 0.059435902810325736, 0.1197387267489417, 0.07280840081627016, 0.060303528324864186, 0.14036263477394018, 0.09430036960895705, 0.09284739875861747, 0.06878709686406803, 0.09202643302171454, 0.08066834940860668, 0.11503860118375453, 0.16738340496937176, 0.2044514205935123, 0.0908036725981437, 0.18719017159603668, 0.20447305214923783, 0.15832648613878575, 0.1375515505128989, 0.09435568398824978, 0.17628767596785788, 0.5330563082205624, 0.5401278335027695, 0.5127780479080393, 0.49567571927501375, 0.46727656004635987, 0.5000395841420668, 0.5376963043683455, 0.49644920584155783, 0.5261830486188652, 0.13493510517514185, 0.08679429272473249, 0.0777947157335902, 0.10786240939724212, 0.14729514604777183, 0.10704272236149659, 0.1323792059111396, 0.08751377909306723, 0.11550389752754786, 0.21166766212839616, 0.14857030582991937, 0.15871200659009388, 0.16032219674861536, 0.17481452979661005, 0.2733569837813905, 0.17336480715917146, 0.15824811759759816, 0.20581044214686883, 0.4325890965969067, 0.3293721670048929, 0.4252359078248623, 0.3760243639935362, 0.4712899624340873, 0.3644821443530013, 0.33987747702626214, 0.4006370695418513, 0.337759921496556, 0.30114720788102467, 0.26339636624413065, 0.22874110172944961, 0.21611907271464215, 0.26547116356228506, 0.2681801475609331, 0.27476813850790527, 0.20609450232844506, 0.1723590155431859, 0.21115319779929365, 0.21069324960108593, 0.2160525441332689, 0.1903093725681808, 0.1675752774891478, 0.21132134916317546, 0.19021948215143458, 0.2231518412002389, 0.2003841356727899, 0.5898464154049644, 0.5133087543628247, 0.24350459373089295, 0.21600865635291244, 0.5832830613596274, 0.23413412014253432, 0.19506503740146675, 0.2125008402740175, 0.24163115183659278, 0.7131780326775656, 0.18741726606944697, 0.7382423841910346, 0.8065749047393693, 0.19573947914325507, 0.7841649964635213, 0.7103045962996608, 0.17393666624602688, 0.1684153529674246, 0.6807495231115119, 0.20533895266621516, 0.20357070467676208, 0.4050664654144176, 0.32611302783216467, 0.16324139123257697, 0.20708267564500105, 0.42093988585483666, 0.2041774146512847, 0.1781743321816439, 0.19012324933701463, 0.19296933886595635, 0.18983822130189643, 0.2456131073331449, 0.17722463360935303, 0.18381105390345542, 0.1780843978549025, 0.19192475480845628, 0.09624222206440736, 0.08382921965769696, 0.09436835211040051, 0.08784584597606859, 0.09728943505570697, 0.0945746837272402, 0.0773926919952671, 0.10073763992708662, 0.09432134081714061]}, "mutation_prompt": null}
{"id": "25b431dd-7dff-47ff-8e19-4bc0ebc001e8", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Introduce stochastic dynamic crossover rate\n        adaptive_crossover_rate = np.random.uniform(0.7, 1.0) * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.95))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "EnhancedHybridGADE with stochastic dynamic crossover rate for better diversity maintenance.", "configspace": "", "generation": 64, "fitness": 0.32113115614052085, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8167463585468052, 0.7870201851035122, 0.8093341418690516, 0.8387220646291765, 0.8128128461814417, 0.8184289214367177, 0.8038348397670958, 0.7942472524022695, 0.796451117033026, 0.6434798484214087, 0.6638116235739161, 0.6434926770127372, 0.6690648514676909, 0.6520879349427053, 0.6707450153604186, 0.6730337186757109, 0.6386701104835286, 0.6916421302182665, 0.5336165697943811, 0.5762458060939292, 0.16655648438632709, 0.5349760380179871, 0.564678497455652, 0.17251639642740335, 0.5597483868574284, 0.6168373597068162, 0.5547915305364381, 0.16919779679517355, 0.5474543698927117, 0.5204724802026899, 0.1699007973724549, 0.174774736538865, 0.5157139781197096, 0.540413233716958, 0.5727950740287693, 0.16855996613278945, 0.9649837361186285, 0.9608303983137767, 0.9713658002005517, 0.9706822234563657, 0.9705801815788567, 0.9639855641230021, 0.9568304116465149, 0.9687089844109966, 0.965435331629481, 0.49019578519217644, 0.3399848162016962, 0.3922043220033047, 0.482119326212626, 0.3625130831617559, 0.44337726359612795, 0.3693581100801724, 0.3308210115301192, 0.32619792290634364, 0.2228337327392056, 0.22604936643921436, 0.31404187521519766, 0.3488312949590978, 0.3545787142074137, 0.32556641205346937, 0.31963997356048135, 0.7226314669570463, 0.22476522926866416, 0.24362182119260067, 0.14360056415236944, 0.16571616534182, 0.18027803582116808, 0.29357883286239594, 0.12470593493660764, 0.17911400886115203, 0.15406995043814387, 0.20714938034566777, 0.12188426157300802, 0.12388936847635412, 0.15247886140617029, 0.1205851878747537, 0.18568028311763785, 0.25396570295077203, 0.17919916111869683, 0.10210980122594193, 0.16578977190316202, 9.999999999998899e-05, 0.04071882577101149, 0.07422085973004888, 9.999999999998899e-05, 9.999999999998899e-05, 0.00978501212742744, 0.08297180251300618, 0.0663027279881595, 0.005570100704415326, 0.0858623493103412, 0.0451142385978921, 0.03912235228163974, 0.05752164569451068, 0.05314131950661505, 0.0874886953031011, 0.16798811239442768, 0.09229589863421683, 0.05472418402672119, 0.04005305998059261, 0.1149534481574952, 0.0584140319418428, 0.06118020929668577, 0.06671773077763232, 0.12957989062711006, 0.1865522007263809, 0.11129101332510405, 0.1187564521351323, 0.25972328186545646, 0.11964743769139496, 0.1563172430553994, 0.25967340253188986, 0.1786583989326349, 0.2919835792593468, 0.0809999163350098, 0.09332041915213762, 0.14698225353620742, 0.5302863458283908, 0.4852960487762671, 0.5299796432291983, 0.494811817998406, 0.5017814324878316, 0.5105008805836873, 0.5372191166156564, 0.4918274268133056, 0.49905544644710254, 0.12167648911417983, 0.1330482340305187, 0.10715620634358236, 0.16967870267859686, 0.13689823564568138, 0.12805045362181167, 0.12650317223515162, 0.10481378617837378, 0.10121468416202695, 0.16474080417694714, 0.2485409560876034, 0.23626115375697587, 0.17829645536460448, 0.21047764218691822, 0.1498356415587745, 0.20894301484556665, 0.14910892072119108, 0.26013367560312195, 0.43676257209034874, 0.39934901939429757, 0.3318088842757686, 0.36943519541201253, 0.3731680198036321, 0.3382215318472409, 0.4525218874106419, 0.4677159460548107, 0.41090939949198013, 0.20693878020881817, 0.2675640176722677, 0.24156683950789237, 0.23576702969832009, 0.300815658883003, 0.2637882592606223, 0.334538060418081, 0.3408685780938888, 0.21412458011790036, 0.19568264619913533, 0.1954249857307424, 0.24433506541594374, 0.2582137161657858, 0.18238210895214668, 0.2294408928909164, 0.18859935421882978, 0.19021588091195185, 0.2084244280560943, 0.23671758896054684, 0.21531306051673083, 0.5881280792050925, 0.5999242419245576, 0.2168128075887692, 0.23138418399294036, 0.2425602564443864, 0.2130581941660723, 0.21476238853456575, 0.7868044088681367, 0.18050829397693235, 0.19774056536838025, 0.7552633721774682, 0.1965951587022391, 0.7183821088889193, 0.18202570283614883, 0.16655240163362728, 0.1831859138960752, 0.5253217513777033, 0.20518341512142257, 0.20136745489939956, 0.42295126479940637, 0.4431422962257543, 0.2775347998505162, 0.16612267645544543, 0.20918710182636124, 0.20884952104573318, 0.19806613915292737, 0.18738201931346932, 0.19810501744003373, 0.1903572905534967, 0.164815017944266, 0.16576070735396264, 0.23618402005286043, 0.2004000887125853, 0.16898536175978773, 0.09641097847088731, 0.06914139736976155, 0.07308531735041124, 0.0904495989163262, 0.07615562174686497, 0.09090646585921747, 0.10479067220720917, 0.09243004489081574, 0.07346856822609316]}, "mutation_prompt": null}
{"id": "6e8d8ca4-7c2f-4187-8982-c6bec23d77d7", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Further enhance exploration by introducing adaptive population size and mutation factor reset to avoid premature convergence.", "configspace": "", "generation": 65, "fitness": 0.3566231495927279, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b58f1bd4-d6c9-48f8-a128-1bce58a79325", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.07584932527305244, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "9d848b5b-5002-4acc-88c6-0d4157454e2b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Further enhance exploration by introducing adaptive population size and mutation factor reset to avoid premature convergence.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e8d8ca4-7c2f-4187-8982-c6bec23d77d7", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.07584932527305244, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "1712d2b7-f557-4414-bdb3-c07365ee6637", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n            # Stochastic rank-based selection for adaptive elitism\n            if eval_count % 50 == 0:\n                ranks = np.argsort(np.argsort(self.fitness))\n                probabilities = (self.population_size - ranks) / self.population_size\n                selected_idx = np.random.choice(np.arange(self.population_size), p=probabilities/np.sum(probabilities))\n                self.population[worst_idx] = self.population[selected_idx]\n                self.fitness[worst_idx] = self.fitness[selected_idx]\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce stochastic rank-based selection and adaptive elitism to improve exploration and exploitation balance.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "6e8d8ca4-7c2f-4187-8982-c6bec23d77d7", "metadata": {}, "mutation_prompt": null}
{"id": "dbfa14df-5d21-4331-bcb1-a5390119a6d3", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self):\n        indices = np.random.choice(self.population_size, self.tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Further enhance exploration by introducing adaptive population size and mutation factor reset to avoid premature convergence.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e8d8ca4-7c2f-4187-8982-c6bec23d77d7", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.07584932527305244, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 69, "fitness": 0.3567666847505514, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "6e8d8ca4-7c2f-4187-8982-c6bec23d77d7", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "f6526270-e69d-4f22-b56f-a6858d561135", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Calculate diversity as the average distance between individuals\n        diversity = np.mean([np.linalg.norm(self.population[i] - self.population[j]) \n                             for i in range(self.population_size) for j in range(i)])\n        # Adjust crossover rate based on diversity\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (diversity / 10))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic crossover rate adjustment based on population diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.3500864498352287, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.810211276695447, 0.7907520329414498, 0.816247380761004, 0.5813379582011176, 0.8109316434119064, 0.7783090587278579, 0.8160933943459747, 0.785017930096678, 0.818254298959372, 0.7035103492502335, 0.6778966723663991, 0.6965572316383914, 0.6739155358084308, 0.673666058493585, 0.6820146142512339, 0.6896105624618164, 0.6777847991826045, 0.6595430034932479, 0.6178834083033828, 0.6474901587634818, 0.6310783895777011, 0.19739397837191353, 0.5527190410160548, 0.633611066239162, 0.6260433082209134, 0.6238974907420187, 0.5967827949870953, 0.5003857567174224, 0.12191465637175025, 0.14438588276200082, 0.16810850037892633, 0.575405046533624, 0.5959097309756258, 0.573918359048137, 0.13567284200798735, 0.5771124385078061, 0.9448221145780208, 0.9437653643179248, 0.9624735763753377, 0.9387220284717414, 0.9419053760869275, 0.9530470693238919, 0.9382306479866727, 0.9362062304170317, 0.9386104040230805, 0.4936294401158937, 0.4164037002771672, 0.5562794029698193, 0.46079302107172315, 0.5554866851628294, 0.5685053555712356, 0.45951161954795394, 0.5115940440011928, 0.5055066289622814, 0.7134183656585382, 0.22831758209757425, 0.5533718921380115, 0.18372317977056574, 0.3639593532108988, 0.6966602793153569, 0.6163354165344166, 0.21238971725423827, 0.22783110708469845, 0.15823983162918853, 0.15534494530747156, 0.16362949142632466, 0.22816788405790378, 0.2879441639864886, 0.18826636136319563, 0.19040558099463456, 0.26878849165777896, 0.19505209779254873, 0.1938818621859596, 0.14589849449373993, 0.12379049967340994, 0.13612654747182862, 0.13656969744438774, 0.19233389556951086, 0.15701812950902694, 0.14355593824778679, 0.1647935308669667, 0.02585383865728541, 0.021429562054340212, 0.052029791114727275, 9.999999999998899e-05, 9.999999999998899e-05, 0.047035923217659925, 0.008439463523404855, 9.999999999998899e-05, 0.011825876628297594, 0.07524287620120762, 0.027875874129393963, 0.0571776054148988, 0.10860994386480782, 0.06477196900519666, 0.027275849551784637, 0.06620004476673147, 0.057674938519526764, 0.11036668425377538, 0.19721930206013638, 0.04186070960221022, 0.03251119857322793, 0.048311013834677174, 0.11334212717429859, 0.12665333680024926, 0.19153714322400683, 0.09834042375323437, 0.13276877968446643, 0.14754968203285368, 0.13093232823395884, 0.19239772337398242, 0.2329132416032198, 0.25775644010529297, 0.18563450643211132, 0.09214989527526363, 0.12757060866608316, 0.14667089492889152, 0.5202108305234935, 0.5529992556331607, 0.5287600805606334, 0.5247361352331166, 0.5072288521916387, 0.5268403478419206, 0.46487149796328897, 0.5665873539426538, 0.5839086890779372, 0.15379137206512272, 0.09008750075533267, 0.12996673219912702, 0.13119437703107395, 0.5214442259526711, 0.08395158141836878, 0.12118533594885106, 0.08015809643682059, 0.07756801785582956, 0.16646203761110723, 0.2151113259950752, 0.17835533747324317, 0.17839063891869333, 0.20130749704672923, 0.15291536782085746, 0.1840990349488073, 0.2487059944212896, 0.25966291283265186, 0.3090425843984873, 0.35685567705834953, 0.48619006656360475, 0.28837101317399927, 0.29677142440875715, 0.4138743711004387, 0.3331125223228134, 0.5238219288788751, 0.41843780812429276, 0.25074898142899404, 0.22549046208651724, 0.24382318434017136, 0.20975278246478946, 0.3109000198110954, 0.31385615312260884, 0.2741604062954487, 0.3571738577553283, 0.3636642073986336, 0.1907877943342654, 0.1882055161888221, 0.1926232854656047, 0.24674137799337892, 0.25709600206648797, 0.18975644285572657, 0.21246369944010923, 0.2517506542580852, 0.19247068354235797, 0.6099233197027342, 0.23461772165647288, 0.6887821451925957, 0.22956324618445856, 0.6230393642750321, 0.24283478718000495, 0.237343333394321, 0.2200952713265797, 0.6319413818865363, 0.7541271950490732, 0.18740854436368592, 0.7303595782634676, 0.8000821030635219, 0.19536870965530828, 0.7709463558768849, 0.7210184252674902, 0.6818546815426574, 0.7595817739607083, 0.6602544682515021, 0.32832025540749354, 0.17092306810666613, 0.4440871350196749, 0.19325720471647323, 0.16266320805898338, 0.6659304166401967, 0.16435862474269547, 0.16036307181505705, 0.2368697907873718, 0.1557226958039999, 0.1717379886013387, 0.17966555836541342, 0.1740446346445117, 0.17878871890261583, 0.19151025176416336, 0.18258152923662685, 0.22821708066413526, 0.08242571375398078, 0.09687417069564053, 0.12579721316019699, 0.09624146220205332, 0.08450468092398, 0.08414914099491366, 0.08801112977544912, 0.08959946637380833, 0.08353991770524827]}, "mutation_prompt": null}
{"id": "4aabd505-0059-4a2e-a2f8-210e31ff56a0", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n            \n            if eval_count % 500 == 0:  # Restart mechanism every 500 evaluations\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.fitness = np.full(self.population_size, np.inf)\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce a periodic adaptive restart mechanism to escape local optima by resetting the population after a fixed number of evaluations.", "configspace": "", "generation": 71, "fitness": 0.3042020527742075, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.7860445191280667, 0.7758862710129479, 0.7793381960053767, 0.7996765744754761, 0.786404679084459, 0.7741357917687071, 0.7824450454397559, 0.7916269127240487, 0.7711101823267232, 0.5984351322676758, 0.6418713383110151, 0.6631342664293876, 0.6302347143480096, 0.6342366030116282, 0.6002009256899277, 0.6292991611570439, 0.6105524713489738, 0.6173140250162066, 0.4194579154265584, 0.4756801888920624, 0.6681966344830449, 0.4873979969077823, 0.46214215168098294, 0.4638645916829248, 0.5330815649375125, 0.41010948653085555, 0.5914550628058347, 0.1599989191500294, 0.3645358969852799, 0.4038540161796932, 0.14503802126048393, 0.16084311705479282, 0.4727819228127845, 0.1603780976241551, 0.4400772965726222, 0.37827633664668014, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.3918235504880989, 0.3389450455003835, 0.32839024706770925, 0.42446321769147854, 0.2596630939088663, 0.3113738648339689, 0.2851122311365277, 0.28369753920307517, 0.29463185537876047, 0.21786057670490167, 0.30140354299052863, 0.19402260829604323, 0.25785348655474094, 0.2456636272056646, 0.24903762485058656, 0.21745257150703523, 0.21704401431888587, 0.1966412024775952, 0.21967175512337467, 0.14213538212654042, 0.30445543893643257, 0.11745285687115137, 0.19734016930611464, 0.1778153165058487, 0.11413692454192348, 0.1564899267594565, 0.13560774641026252, 0.12600923770629435, 0.13894723986582225, 0.15108131715318918, 0.11594748008931188, 0.14164412299434515, 0.142591669358762, 0.11510873124281484, 0.1519856709234496, 0.12558570995366536, 0.00711729168422226, 9.999999999998899e-05, 9.999999999998899e-05, 0.025221898804258513, 9.999999999998899e-05, 0.011417822438658187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056467867120706616, 0.048981851961630074, 0.08379113555986206, 0.09351839236112447, 0.0829870699319375, 0.11493357666885462, 0.10334567733189737, 0.06930887879279402, 0.13797513114235826, 0.07662926510412071, 0.07294510961285627, 0.04361694767664026, 0.16029435796421398, 0.061522433146469435, 0.05860915399577549, 0.14418220264179582, 0.07386854075715932, 0.1927101781552698, 0.0816102771861239, 0.16272346451334085, 0.0849871583352344, 0.20636193089441268, 0.13090716424212134, 0.13796107453502515, 0.1346084173007015, 0.10188114358779399, 0.06080662533549408, 0.47720083507687194, 0.5185133001878283, 0.5260695603274749, 0.5142852483041941, 0.4628155327014609, 0.4816750844482631, 0.49136985945955325, 0.5518768571031236, 0.5065577900397147, 0.09679943976258931, 0.09589603263373969, 0.08627339815101842, 0.08883173219739438, 0.11474377411477854, 0.12076082110269948, 0.08472806012167622, 0.10907802424375135, 0.09759466668445071, 0.1991826208593197, 0.20536169191564257, 0.15677841361649458, 0.20441120254234624, 0.2367488095722866, 0.20998677034903124, 0.13292596143570568, 0.22876942932786892, 0.2362621885846372, 0.23916731443052608, 0.24344938950250505, 0.29228017602833467, 0.2764720402643296, 0.26841914293177294, 0.33852947742210016, 0.35734009078951867, 0.3771514910534476, 0.3788175051283511, 0.20029823245107503, 0.24745183750420685, 0.2638423046197296, 0.14466693376030249, 0.17530766148948373, 0.2459504168768636, 0.1896777896527405, 0.23962260870407137, 0.22779376180929012, 0.21803911464972758, 0.17632013381033285, 0.2163152049123961, 0.22674420319294042, 0.22134078915391497, 0.17904551757932408, 0.2078667003218978, 0.2334556733679809, 0.19142299795468953, 0.19704541485772487, 0.23240938981392123, 0.5154458664827397, 0.2293695000696867, 0.20124375723945676, 0.18695661117660523, 0.2149358148256364, 0.23472240526179933, 0.40779467991063, 0.2079211955663094, 0.7263502931739865, 0.7205328544437288, 0.30482131676969526, 0.25645498179388726, 0.7669252537645409, 0.7521267651229584, 0.7327742759899334, 0.699900434201737, 0.18214080610549466, 0.5554332839279867, 0.20385819557734375, 0.20771969322413275, 0.34153797444583756, 0.3121145933065934, 0.19750203003432287, 0.19148469116337663, 0.4219043973705551, 0.18827710369019246, 0.17952661586313046, 0.21436591857011766, 0.17130019642608862, 0.18396684471335656, 0.17524220100122034, 0.18777441796244032, 0.18999817772384153, 0.1718347925082111, 0.09006914621769924, 0.07284403935545603, 0.16363402330358034, 0.08351885467112863, 0.08005590395604578, 0.08208175318395483, 0.08530767037273057, 0.08162364903219566, 0.08590036628504771]}, "mutation_prompt": null}
{"id": "43f0ecff-5a28-4e7c-852e-0e98dae9d11b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Introduce oscillation in mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2) * np.sin(2 * np.pi * eval_count / self.budget)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Enhance diversity and convergence by introducing adaptive mutation factor oscillation and modified selection.", "configspace": "", "generation": 72, "fitness": 0.3328216835507124, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8224753066906715, 0.8333852695276991, 0.8324413971631228, 0.8508628504921436, 0.8359799416304426, 0.839932691582349, 0.826893046037965, 0.8196736577228295, 0.8411708110961231, 0.7279692636630027, 0.7283501039304956, 0.7094046972180246, 0.7143253699245508, 0.7286566784049755, 0.7111013810368964, 0.7269489238728484, 0.7340943630289536, 0.7482705371341886, 0.5060515452475389, 0.645006375476357, 0.6480931018399013, 0.5567496040974141, 0.6681754296665398, 0.6827959301870816, 0.660758895748912, 0.5811809480881922, 0.654837721367024, 0.5322257015591141, 0.1783195975674391, 0.1777934971049353, 0.182481234258148, 0.17354317633906813, 0.1813655804407327, 0.15358845114750241, 0.5883652904715491, 0.41513975099562384, 0.9087721675437328, 0.9238524156813394, 0.943740230385653, 0.9283892106943272, 0.9310976601271415, 0.9192799266988985, 0.9325025647009297, 0.9218846620274942, 0.9524277890555811, 0.35808844282844443, 0.41568593601446446, 0.3304426824551763, 0.3489511430951402, 0.3761685953881766, 0.374784130411437, 0.3100111817130673, 0.2233689613894454, 0.4456244317035791, 0.22112318377286921, 0.640502550687883, 0.21547265372615254, 0.21663241019366164, 0.2783662468135716, 0.770474076683871, 0.22002267703146372, 0.7969536180920815, 0.3567950951343576, 0.16086879645653696, 0.15666818921118653, 0.11729452434201981, 0.18023743352648747, 0.1929230077694808, 0.1787099291024169, 0.2186410955643504, 0.2680694633747246, 0.15608845951232908, 0.12879362440575948, 0.12138078364486027, 0.1363315034077388, 0.14994918896355958, 0.23142180342431662, 0.18935859034829838, 0.1366983253266244, 0.15266374566687624, 0.20340261046158525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007071164525060514, 0.02653602311909653, 0.01481987473903823, 9.999999999998899e-05, 9.999999999998899e-05, 0.07203316080024702, 0.08434513792686227, 0.05612456229923557, 0.08275069247712108, 0.056300226683654864, 0.12375519997451301, 0.11458323011598026, 0.16784534256390415, 0.12633419465265128, 0.1661017941971591, 0.0626947647314835, 0.10113092234425403, 0.18916255900229362, 0.07463413715698675, 0.093078088728894, 0.12066714228028863, 0.0967475204492193, 0.09620622217381913, 0.07749005679674592, 0.2938502892709096, 0.14903492163737897, 0.19466297995866988, 0.19590582385340727, 0.17330588381123002, 0.2196273721588652, 0.10678319541736114, 0.14256736122637625, 0.1632616734644522, 0.5160767918239866, 0.5342686701545609, 0.5819278942193313, 0.5345571216726133, 0.5495106491454187, 0.5167220076150771, 0.5332632820413601, 0.4830147242194135, 0.5616017211598071, 0.10924589278680485, 0.10205551606730201, 0.10643271963919398, 0.12120570143623899, 0.10608057456671527, 0.13755895008112418, 0.12558387129256898, 0.102779201380091, 0.13482764659455426, 0.15691179436585045, 0.4147547629823226, 0.2397620824630421, 0.24083577103845077, 0.185566548704044, 0.312664457025725, 0.2691340449391145, 0.1516547078809739, 0.18463904500807393, 0.3799640332630988, 0.28988703277769234, 0.4250021812957492, 0.32202945235018643, 0.34510419131071557, 0.33749926923928164, 0.4032672795752287, 0.4358964480090526, 0.40099957922023477, 0.26541385387772476, 0.34078895789058794, 0.2667948065569288, 0.2222043903464589, 0.22744909258869872, 0.27742484513608523, 0.28485535569515286, 0.28506057994049616, 0.32196496465990265, 0.20812024689134623, 0.2088360066794489, 0.24051293684243125, 0.22742939256609251, 0.22405457164066878, 0.20725580116592368, 0.25146319644107185, 0.2596600880243818, 0.22108206606091751, 0.2148534085399909, 0.24247340684212548, 0.657746974815282, 0.24271727880048066, 0.24095899376123808, 0.3205936311642227, 0.22300204979512828, 0.2457363927652284, 0.2217450700448076, 0.1877973370178857, 0.21064717830277024, 0.19351961715713384, 0.7845468805299671, 0.1971893398265313, 0.8224738293337797, 0.1562899823104421, 0.1400658162857915, 0.7705671871408608, 0.5976146325150182, 0.20767975793048177, 0.26759036398685854, 0.6466798720339376, 0.20726945073736158, 0.16644049250320403, 0.16160169772073318, 0.46832523184259056, 0.3667243785632246, 0.17327804361398813, 0.1800024249689115, 0.1781497624063062, 0.22834307276092636, 0.24892604922776185, 0.18629399202110364, 0.1811867059826867, 0.2164241551805165, 0.1759959383025449, 0.08344680098196311, 0.10682798040271846, 0.08367200495633986, 0.09930744864149743, 0.09788107102046739, 0.14534640329012016, 0.07045666912074089, 0.09747412536657318, 0.07172861723571555]}, "mutation_prompt": null}
{"id": "68fdfd38-5a7d-4045-8286-634231e0758d", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "8f77590b-1ab2-49bf-a819-3c2a47947f04", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Adaptive elitism: replicate best individual based on diversity\n            diversity = np.std(self.population, axis=0).mean()\n            if diversity < 0.1:  # Threshold for diversity\n                replicate_count = int(self.population_size * 0.1)\n                new_population[:replicate_count] = best_individual\n                new_fitness[:replicate_count] = best_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive elitism where the best individual is replicated based on the current diversity.", "configspace": "", "generation": 74, "fitness": 0.32888995145209815, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.4944794694615521, 0.7984403983665924, 0.2883499465035583, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.7227654802481461, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.47360396070510014, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.2698743793228956, 0.5928959455140467, 0.2868623865410287, 0.621099008774864, 0.1490284323755361, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.08114078929767055, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.23815454225754962, 0.283200635571479, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.31761598862939533, 0.29163698642025826, 0.3605135132267727, 0.11130399277547753, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.20810792872042305, 0.326083060788924, 0.23085719004691363, 0.2779311435652303, 0.17534226023891297, 0.1548497036951405, 0.18032316609706378, 0.15216441638000744, 0.05678622270983846, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0, 9.999999999998899e-05, 0.0002652920293571004, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.0, 0.09799001891140036, 0.08428239346108513, 0.06430297077186153, 0.06686484812432847, 0.07263779761083078, 0.07705348050803329, 0.08600242142198022, 0.11359374347198825, 0.04394364298013864, 0.22805994308709254, 0.18612590343417978, 0.13298615357262988, 0.1417708441202844, 0.09427395145151973, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5334415450925443, 0.3712404150651972, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.2787106543260527, 0.4951606744825875, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12358635921240968, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.3172527808782596, 0.3309159778647004, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.2667562535193557, 0.39950359571800564, 0.18857283295916982, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.26074273517782554, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.18567481740791958, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.2635822882058736, 0.22989862126588867, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.6519417526515945, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7072858686883181, 0.8251857596977885, 0.19410839572258953, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.6113960687812661, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.45141089429207737, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18963009101811634, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.06645508630937946, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "c6559bf6-d4e7-46fd-837b-4bebcc6db2e9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "b885b44b-4add-416a-b723-68c784aa376e", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.learning_rate = 0.1  # Introduced adaptive learning rate\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adjust learning rate for adaptive selection pressure\n            if eval_count % 50 == 0:\n                improvement = (np.min(self.fitness) - best_fitness) / best_fitness if best_fitness != 0 else 0\n                self.learning_rate = max(0.01, self.learning_rate * (1 + improvement))  # Adaptive adjustment\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Integrate adaptive selection pressure via learning rate adjustment to improve convergence speed.", "configspace": "", "generation": 76, "fitness": 0.33067917620300724, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8083712351711084, 0.8182380251547863, 0.8231586788122074, 0.809564899981578, 0.807361648096982, 0.8198021889170413, 0.8118330710659936, 0.8136985983450354, 0.8201857301622426, 0.6744192445090149, 0.6650632724343915, 0.6809759686387007, 0.6487237099972074, 0.6453732846465796, 0.646735537219512, 0.6769317265808126, 0.6712381175443916, 0.665723916385772, 0.5215980216163891, 0.541976212571438, 0.5914041531923457, 0.6138427947641745, 0.5649644897525328, 0.17604712580151372, 0.5247075758789015, 0.5596212916304546, 0.6111188311583768, 0.1777184497853268, 0.5270345842986468, 0.5418540739443807, 0.5139558713169227, 0.15102840879436286, 0.17185232418998386, 0.5428118173595141, 0.16988519725099505, 0.48531679970403463, 0.9834461991022765, 0.9488099519162142, 0.9767278978831311, 0.9696693513993266, 0.9631694588720863, 0.963662662571245, 0.9759428266536226, 0.9605265159526313, 0.9725510686327447, 0.3926218616011855, 0.4622426804812596, 0.3405688528296742, 0.37845481092329736, 0.358940008970419, 0.3205117331802235, 0.318756659330625, 0.3058955586811535, 0.3460910490321928, 0.3088648703871414, 0.7127773295552633, 0.5837351000621884, 0.34561639449912607, 0.19108513941795424, 0.20524422867141467, 0.30510482512087056, 0.2930770091016387, 0.7242652175573008, 0.19309441118008508, 0.1664798221371091, 0.11824591417695907, 0.14569402216942362, 0.1735431264456161, 0.18580572990487398, 0.38895179358084386, 0.11431091912740599, 0.2216289857696806, 0.1583715575564405, 0.12989033711346742, 0.18135873354017007, 0.19012721592471593, 0.16165758630400728, 0.15262873508040398, 0.12238944587851897, 0.17945572572188206, 0.18125674412433435, 0.12507452822201737, 0.031215753059383178, 0.017503549911459193, 0.023987796233819414, 9.999999999998899e-05, 0.019018845622551073, 9.999999999998899e-05, 0.05098222573318267, 0.04125754706346141, 0.18716754552786274, 0.15687294514050842, 0.0782216118815362, 0.07659755839034055, 0.0701524850009495, 0.005665978398038396, 0.10019848724797686, 0.1913238318001872, 0.0642801165426019, 0.04137615683519236, 0.18743602154442784, 0.06053718960722765, 0.1877606312493303, 0.09569387261575335, 0.12496801136135216, 0.1505136822442762, 0.11808586364324836, 0.06012900769110452, 0.0678690580452489, 0.07219245214068504, 0.18840475392901868, 0.11398265976603728, 0.20038012511774672, 0.1313262974574595, 0.09357197887179647, 0.07375772102217926, 0.08297743613928377, 0.5288791593439618, 0.4724222626793678, 0.5773226094951005, 0.5168049671588896, 0.4787528131536424, 0.5030459672204877, 0.5480923110854041, 0.4972568431123755, 0.5549924689664959, 0.12825524623797846, 0.16481714526528923, 0.11388186426046265, 0.11762584795365127, 0.12183596549044828, 0.13250260008087866, 0.13213952195088619, 0.10205596992024402, 0.10267203700194061, 0.3878096013272633, 0.20628623153519388, 0.2372665958856015, 0.19586568630851697, 0.19146769607093084, 0.16854835906669485, 0.280705685199229, 0.15497538419725443, 0.22622158698055617, 0.2433061307887191, 0.29018651166618414, 0.4376845520036613, 0.24101657623043404, 0.3229180965942835, 0.3147157253853954, 0.4047694482887697, 0.46140811488017486, 0.4047069160232448, 0.25230398602091786, 0.2612522891534058, 0.27734490518997823, 0.2898606816982833, 0.22623712845521482, 0.27861482799107873, 0.23283869995374085, 0.30046109302933033, 0.22695988643158316, 0.19706032058749146, 0.18338880030418725, 0.24810156372885628, 0.1784671899877861, 0.1833896231729445, 0.21657758980278663, 0.18386145998901182, 0.20611693607142123, 0.2205089063497898, 0.6878409871943937, 0.18986592738436314, 0.2168021343140708, 0.24210587748708334, 0.5813314693428483, 0.23771077387101547, 0.6834317813157857, 0.21245038121913817, 0.2005834788701203, 0.18342632385970659, 0.18770668239060073, 0.7358148360531913, 0.8129011493334223, 0.7913332125056385, 0.7359173008335504, 0.18008463893132665, 0.1725355276859888, 0.8039387124789108, 0.35226286634822246, 0.2058160787362815, 0.16673176343793494, 0.20121334162176863, 0.16490031661903326, 0.3711648625429045, 0.33337961752868894, 0.2495210739226874, 0.4257604930190503, 0.17767957828386804, 0.21230800770333125, 0.1796644657652574, 0.18451230782661476, 0.1867917770990153, 0.23261735137733153, 0.176340415971186, 0.22603139083249946, 0.19149138945063282, 0.08528018093207701, 0.0988614860743855, 0.08016388363587079, 0.08267897290743476, 0.0909014066880649, 0.08782089832157347, 0.1390887801235926, 0.08727125927739376, 0.09603584215124628]}, "mutation_prompt": null}
{"id": "63500e7c-6904-4233-8a40-40568ecd4ed3", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget)) * (1 + 0.1 * diversity)\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_mutation *= (1 + 0.1 * diversity)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Incorporate adaptive learning rates for crossover and mutation factors based on population diversity.", "configspace": "", "generation": 77, "fitness": 0.06328958479901044, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.13236226626589087, 0.1455078109441612, 0.12539658043984558, 0.14308654967713352, 0.15327605089824048, 0.13313222443628658, 0.1290418686631407, 0.10705011248077267, 0.10875639063899512, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02404797262555125, 0.025485730312331145, 0.03245610169896462, 0.01610081946596731, 0.020397477169264544, 0.02172113628082184, 0.038574593231916365, 0.029501107717770703, 0.027134539936182644, 0.010644605625853898, 0.0, 0.014416520607511085, 0.027334459943050393, 0.017409744904372526, 0.0224038822401742, 0.014664865741569666, 0.006821537888840212, 0.01634791750007658, 0.12254681735353878, 0.10578061018659124, 0.12337587081662149, 0.13131973948786657, 0.11337195357866914, 0.11960358033656593, 0.08950844113406964, 0.14244877230206132, 0.08520482717940159, 0.06265423285317973, 0.03933697804841263, 0.038673634393430634, 0.061092778447170204, 0.007499887017012208, 0.023777237917829153, 0.03583729273801606, 0.06244669121545521, 0.03722497806450498, 0.10018685869141841, 0.13783763317124798, 0.0614309876144975, 0.10169404500362966, 0.07275849405212009, 0.05334665313993414, 0.10394045076805014, 0.0991554937340472, 0.06509411787789976, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0012671669157109378, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00018763772669228018, 0.030973796618720018, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1468353845360716, 0.17169913101419465, 0.16357353806638308, 0.16924313908867594, 0.12965044165601536, 0.175432248821066, 0.1637797739147463, 0.12936882338194533, 0.17855035493893556, 0.026677404598695054, 0.013531502499946724, 0.03018049527032396, 0.03257212990950753, 0.0, 0.026313276314440026, 0.017928314187784733, 0.010637298208577173, 0.0266683362657002, 0.09293443785789479, 0.0860023147635125, 0.11833361437130263, 0.10580220346382396, 0.1084405743401412, 0.10789794917811146, 0.1222365596005971, 0.09350909053647338, 0.12204040489801737, 0.12922706352095958, 0.16146888405366133, 0.16130937881362173, 0.14628476455825656, 0.14244460023685768, 0.11591546234500094, 0.14414774466339608, 0.17369512487615446, 0.1342463591049733, 0.08467971256255091, 0.08671054431720626, 0.08389423256590267, 0.0661214001518281, 0.08146520147870329, 0.08451431346188965, 0.08364015581209738, 0.09968109929816016, 0.07949866285605045, 0.15395410280791944, 0.1202404933393949, 0.13336421106438645, 0.12216023297951584, 0.13098531781870948, 0.11392406634206731, 0.1509827105695336, 0.1277166974464451, 0.163711158567587, 0.02668862839971442, 0.0, 0.13319466414883396, 0.0, 0.0, 0.07815807834050048, 0.0, 0.0, 0.05648875686025745, 0.08967293271303367, 0.11453234831881764, 0.16671091434322483, 0.11389882679598706, 0.12070353966556291, 0.11131439149470479, 0.11096722181545216, 0.11093042479035009, 0.11283894027162134, 0.11031370369950544, 0.1025819267227327, 0.06922728298844627, 0.11011685299292606, 0.0531217358405498, 0.09157755271106582, 0.055654099182795846, 0.18121589601858867, 0.09847891747185278, 0.16552623455942161, 0.13978801335554292, 0.15692612865399702, 0.15321187087288712, 0.1858514079891439, 0.17406658993035673, 0.14961211855402323, 0.17926838539942036, 0.15813720312032198, 0.03573442253995507, 0.05446165115964685, 0.043424620421021576, 0.039764419246875904, 0.041937814160595055, 0.058896856387102514, 0.02215035741317828, 0.03793735337628146, 0.0369942708451938]}, "mutation_prompt": null}
{"id": "81226211-1978-4bd0-97ec-828b024ff91e", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        elitism_frequency = 50  # Initial frequency of applying elitism\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Adaptive elitism: carry the best individual to the next generation at a dynamic frequency\n            if eval_count % elitism_frequency == 0:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = best_individual\n                self.fitness[worst_idx] = best_fitness\n                elitism_frequency = max(20, int(elitism_frequency * 0.9))  # Make elitism more frequent over time\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive elitism retention by dynamically adjusting the elitism frequency based on evaluation count to balance exploration and exploitation.", "configspace": "", "generation": 78, "fitness": 0.32463522720305005, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8153224881457841, 0.8022466982812282, 0.8162750157324993, 0.8131512923793158, 0.8092343864330238, 0.8153131280192244, 0.8082859813346643, 0.8121551087976373, 0.8140833506358474, 0.6813831739624857, 0.6809182265317533, 0.6755730767780146, 0.66682269021922, 0.695190148243622, 0.6872285720605658, 0.687121163463937, 0.6656621134231737, 0.6845831099632285, 0.5679510729817387, 0.4955466244873783, 0.5536643564850889, 0.5896555918054356, 0.5397788374400689, 0.5358595485530899, 0.5350849168423365, 0.5739749988278875, 0.5702195436793953, 0.4835851089710025, 0.48785793747713135, 0.46775400620120267, 0.5101332887321488, 0.4620184995223727, 0.4688163871469443, 0.45847519260075453, 0.4904310861114698, 0.5045704085548386, 0.9862762792325471, 0.9571468376270695, 0.9591154109616409, 0.9683076762441304, 0.9677947996962578, 0.970597532830508, 0.9700014478086123, 0.9692259976948134, 0.9517421456842592, 0.3554727785779035, 0.3419203359457891, 0.40387896073353036, 0.3186232390897745, 0.3755405903610137, 0.32688472517355893, 0.31469513149305606, 0.2775660632817565, 0.31203480428352126, 0.2648323799697794, 0.26648608756035863, 0.28226673703296623, 0.4517966388371023, 0.5378470349798519, 0.30728722639466755, 0.26049805078957344, 0.2049124636285775, 0.3035702877717241, 0.1639193423914812, 0.14361778361633426, 0.15097915342977353, 0.16308039160421428, 0.17314699397483013, 0.20916544748033894, 0.1437624271273129, 0.20112971046871242, 0.14975691544712977, 0.1439833617488241, 0.15329276076000276, 0.13198045050318274, 0.1633997649241581, 0.14348734930311602, 0.13203479389131056, 0.15524928687854933, 0.16771438434430186, 0.14974357513350278, 9.999999999998899e-05, 0.001447435132446162, 0.014257322924174143, 0.0012756044741562, 0.007151541100077541, 9.999999999998899e-05, 0.01677810518869849, 9.999999999998899e-05, 9.999999999998899e-05, 0.04835585159198619, 0.05863978845306628, 0.10650765145587271, 0.05664630438864171, 0.07875282990899923, 0.06963450348004774, 0.1112941801594779, 0.12038518773484708, 0.09630510231007938, 0.05458618606048182, 0.09675655784028714, 0.04332447099495551, 0.05880479108554859, 0.1433440717296498, 0.1052458688888337, 0.0723483520902497, 0.08733700464326521, 0.05533382505264728, 0.11302615736761268, 0.09062780937556325, 0.15798146048056028, 0.1618992386140944, 0.20652671593339667, 0.16657862259219036, 0.14590899571173033, 0.1415930233597259, 0.11996883258994095, 0.44321655966120665, 0.48807316797869094, 0.4938807076202558, 0.48580833717566074, 0.4723821732371899, 0.4836606691914148, 0.4904775950329324, 0.4874527883574582, 0.4882896975171911, 0.11326681099680869, 0.10927589174491459, 0.11923753947668192, 0.0984125676521197, 0.11586102490502748, 0.20808373464973628, 0.11179077496381229, 0.0971592060559513, 0.11582130031642501, 0.15956835782090728, 0.15778007874547806, 0.14620882209421504, 0.20355064341280094, 0.16835000800351207, 0.1412281928489043, 0.16671313132625398, 0.14396543649418636, 0.1465514575439011, 0.3855151657719117, 0.3082510285983049, 0.35984031529582894, 0.2977769650940534, 0.2941491062523194, 0.3231289202733587, 0.389012165594282, 0.39592990322074995, 0.37245822023815933, 0.20756310818359291, 0.21915353415066685, 0.23752662203996577, 0.23843095603033948, 0.24704118097937788, 0.2623882280102048, 0.24821774181319922, 0.26946545052759285, 0.23840617846157963, 0.2108532248018803, 0.20272906263373924, 0.1691962366545311, 0.17927006524212452, 0.19413875991078156, 0.21332853736299784, 0.2202297112818664, 0.2203310423419269, 0.1881746083552892, 0.4807289661802908, 0.43333231365032665, 0.47900225278806885, 0.4161992148093625, 0.44484044090387975, 0.4875700620182327, 0.42172825058933183, 0.4641326779892696, 0.47177341554041974, 0.6695697711854052, 0.3713923721710205, 0.490406568623706, 0.6584143280515723, 0.46387569796342254, 0.5025084124966138, 0.17027568506733426, 0.42380037547041816, 0.5583957071077855, 0.19824503275261718, 0.17367892704131138, 0.19442716461077292, 0.2005904177542167, 0.33448618313435496, 0.19614457582003375, 0.3062769428251335, 0.416189440631455, 0.34367514319875614, 0.18991909722403033, 0.1798340065495666, 0.19195383640853902, 0.18312799081907738, 0.18086840598498855, 0.1837402950378333, 0.19097230230467455, 0.17183993146314225, 0.18970001651350443, 0.08773063173330342, 0.08493816086882833, 0.07899466053151194, 0.08594189415922415, 0.08346593300353355, 0.08281099063165598, 0.09041039607049828, 0.08590445685726678, 0.07810693512803568]}, "mutation_prompt": null}
{"id": "d87eb940-28d3-4f00-8735-1f8ff8d5d928", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "dd2ea15d-66be-478b-a110-ba83dac89c7d", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "155ed5c1-73d1-4333-93cf-c0f948248e84", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def local_search(self, best_individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_solution = best_individual + perturbation\n        return np.clip(new_solution, -5, 5)\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 50 == 0:\n                refined_solution = self.local_search(self.population[best_idx])\n                refined_fitness = func(refined_solution)\n                eval_count += 1\n                if refined_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = refined_solution\n                    self.fitness[best_idx] = refined_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Integrate adaptive local search within elitism to enhance convergence rate by fine-tuning the best individual periodically.", "configspace": "", "generation": 81, "fitness": 0.3342713958962857, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8274356158860876, 0.7925773919000577, 0.8129994539068373, 0.8186738084321858, 0.8063357349049458, 0.8260382502405239, 0.8101168712161209, 0.814324915176522, 0.8196073067845222, 0.6692174029372371, 0.674036446414498, 0.6569132719183391, 0.6296766683947728, 0.6726924256096638, 0.6824423962333147, 0.6728291863184261, 0.6339580670471741, 0.6822794288845804, 0.6164524449802653, 0.5419185422003914, 0.5419426092991833, 0.6008626827011074, 0.5275207771673993, 0.544378154469719, 0.5427071359103213, 0.5932322675689599, 0.5938002444279946, 0.5872928704985608, 0.5162818307384835, 0.17349012601053693, 0.5631211642190403, 0.15101080179461335, 0.16878981432289997, 0.5328292354348954, 0.16584381427249595, 0.5366755471406942, 0.9685967896443632, 0.9683950421650964, 0.9546003163841077, 0.9767776460230075, 0.9469370330114699, 0.9626063374040034, 0.9534298201715019, 0.9682589142384436, 0.9673608252381702, 0.49247455221485037, 0.39625196461565126, 0.32464357949086664, 0.42401870884677506, 0.36796409611139647, 0.40476101974300405, 0.37098181134899055, 0.3455722181404186, 0.3693966377187272, 0.7126368791825062, 0.22045143261760214, 0.22025603122517967, 0.21143619202801966, 0.26482303668590335, 0.19963461562141893, 0.3426542610925031, 0.2101971176064259, 0.2268364824940019, 0.21520998210847386, 0.3191007560552924, 0.20550323803388737, 0.16618981100965302, 0.16096773417447052, 0.12763679884399504, 0.15812105413876776, 0.15702050681960866, 0.17545356987655647, 0.13735886203299708, 0.1440969045575744, 0.16721111595345428, 0.14727337919464667, 0.16885884076467628, 0.16706842719634518, 0.167426603964152, 0.18099446513089257, 0.1254275549671222, 9.999999999998899e-05, 0.04189800538582089, 9.999999999998899e-05, 0.04509940896752629, 0.06612584289154055, 0.03221356917455653, 0.004651933142016285, 0.024438602527166897, 0.07223097592012473, 0.07418933592448596, 0.07088037778273193, 0.05674291521728447, 0.044217751129049465, 0.04957295903220804, 0.02513453765200835, 0.1203502686263811, 0.1457768705172926, 0.05948960440065543, 0.04248220665925506, 0.06466047259238805, 0.12023032371010345, 0.1703164551746681, 0.12336776327013599, 0.10618686842093938, 0.20579028766196084, 0.12047614412379293, 0.08522251053456364, 0.12175448488333607, 0.15506029774740382, 0.09991529937454613, 0.22613631398932144, 0.15036931025680222, 0.183355195247201, 0.17519476395911493, 0.07374853165141981, 0.07816351062741356, 0.4945847866005455, 0.5048128085241921, 0.4870134634960739, 0.5096293566707206, 0.5014690027190878, 0.48464381623518193, 0.5296905400038432, 0.5022401168879125, 0.5184434637558548, 0.14743578537381963, 0.16471611306295086, 0.12022183120516783, 0.11095913174930427, 0.14159452959975627, 0.12162270760667793, 0.12134206842820217, 0.10237669483169087, 0.06945740719413296, 0.20672754540291094, 0.2033579739267195, 0.17038166207291727, 0.27945552944839847, 0.3207734682208394, 0.1576993315146037, 0.1763276840236605, 0.15691587576408805, 0.19684371096023145, 0.31437448238641696, 0.36743524444513076, 0.4237009298166834, 0.3731646693966354, 0.34850764711446314, 0.3234909720235555, 0.357232149227941, 0.3530375440555287, 0.32226456887914967, 0.2805573103650917, 0.25152836722679606, 0.28661131998836975, 0.1950428081129656, 0.2610416583120565, 0.2721455448402378, 0.22703590274224983, 0.2731754272030186, 0.24318100490943007, 0.18969545688668055, 0.24086560980711302, 0.2255177792147871, 0.202220882690344, 0.19019355411715388, 0.2053239557449834, 0.21242665238001646, 0.2427757177249601, 0.21321891787750913, 0.578814817467205, 0.19929907536268143, 0.22393033822226438, 0.23659032037595684, 0.6251377415962658, 0.24023646804181542, 0.6082288653486007, 0.6243506395744437, 0.2372361831510249, 0.15788695916260787, 0.7823385100464433, 0.15504014170120317, 0.7978098447854194, 0.7620617673004054, 0.588950215838387, 0.7509220802536314, 0.17242872084007754, 0.8128298040610892, 0.6597452409788689, 0.16868910977100804, 0.5387147916995374, 0.20003432907505292, 0.16488698745183117, 0.19563757227349243, 0.20094336171086558, 0.5394532484553913, 0.7363105188864746, 0.1727068206012784, 0.21308778559181218, 0.17433171735444053, 0.19812049207275162, 0.18430199082830356, 0.1814202015641011, 0.17962323953253367, 0.2098147253505971, 0.20064674981964914, 0.08037744402772373, 0.09199724666261277, 0.08847996896735277, 0.07949170099748626, 0.0910954051299121, 0.08187356021830383, 0.06800423035251879, 0.06790662171388318, 0.08551010718609864]}, "mutation_prompt": null}
{"id": "7e4c3dbf-270d-4c2b-b2b9-c726bc81730a", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Adaptive elitism frequency reduction\n            if eval_count % int(100 * (1 + (self.budget - eval_count) / self.budget)) == 0:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = best_individual\n                self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive elitism frequency based on progress, dynamically reducing elitism pressure when the budget is low.", "configspace": "", "generation": 82, "fitness": 0.30760106253629765, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8104415037911028, 0.7999997440765638, 0.8164760975084373, 0.8122529350744527, 0.7979974461532715, 0.8145639827733262, 0.8082859813346643, 0.8011645540185011, 0.8061751303447322, 0.6720207199857202, 0.6876330124125227, 0.6732608271174825, 0.657344467043582, 0.6784207022415114, 0.682682040581438, 0.6859352523872044, 0.6933283868912683, 0.7009827041334036, 0.551029051340017, 0.5551988281215867, 0.5375539013951844, 0.5523141073691702, 0.5581661836985989, 0.5894098476240599, 0.5226316606827671, 0.5019482546060003, 0.5547891176196016, 0.5033716925709155, 0.5028114553417897, 0.478420144492236, 0.47140397238368736, 0.4892838618823703, 0.46153537498466923, 0.4732104297952562, 0.4705573187949741, 0.4441052893315701, 0.9862762792325471, 0.9619886996200807, 0.9601616362781304, 0.9693778398781969, 0.9652670137868793, 0.970672439432247, 0.9699445475810915, 0.9708835244393155, 0.9570757194520463, 0.29979716208694906, 0.2872823163666227, 0.31624657464101236, 0.28637707548581415, 0.3431119263037363, 0.33098108622024014, 0.23009432753707393, 0.25492668610677705, 0.2684452012267373, 0.43960419697039765, 0.287394558168632, 0.288395479730306, 0.5142818123344827, 0.3462480934695933, 0.21967214995726092, 0.4816651828493993, 0.2659908573152413, 0.2876216831928867, 0.18347823427056775, 0.1910314622372744, 0.15545809376892317, 0.16303073507299193, 0.16206275102735435, 0.1708278469510367, 0.1437821406983929, 0.1719426432921638, 0.1608797734355878, 0.1822925539271969, 0.1491250166555146, 0.12818760506287286, 0.16118528624455064, 0.15893047666846838, 0.1483926349005653, 0.1869357258048867, 0.16444174188872407, 0.14078967073611293, 9.999999999998899e-05, 9.999999999998899e-05, 0.014867899014164854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008310259008712406, 0.004156170631916978, 0.0007704262379872873, 0.07814446005330267, 0.06687281088340769, 0.049490953519735204, 0.05154511713714072, 0.08309378272165135, 0.026113844252430463, 0.14285149036801326, 0.08673620174199548, 0.05721628857663452, 0.021246448800620654, 0.03922498847276512, 0.03890097154485117, 0.007229105065515662, 0.013237060262883626, 0.003268936241816456, 0.011196235093104634, 0.027372894929748703, 0.005380235101091979, 0.11662826120150804, 0.09362694543510497, 0.09808972168188934, 0.12754085266458481, 0.11027913133411826, 0.13124532206223682, 0.11876326267700366, 0.10126462490643584, 0.0922621232454045, 0.5006222176296979, 0.47205344862722365, 0.46478418165806323, 0.44536381091026656, 0.47422551147281067, 0.48166618525756133, 0.48766716461071025, 0.5063540048715034, 0.4834948067680963, 0.11846467963010998, 0.0984266073933393, 0.10863963758625161, 0.08713046951324577, 0.09796666669240095, 0.10725614708999787, 0.11587058387697102, 0.1009425229358758, 0.10842552114021886, 0.14937876177168674, 0.13917735544894716, 0.14298045612467847, 0.16189221474984028, 0.15324378294859764, 0.158778123677354, 0.1276664675809056, 0.1508946912211543, 0.1532146674570133, 0.29284881974670074, 0.28956781627417094, 0.34560601757715426, 0.3203481611191702, 0.25392801636339024, 0.3413207153038146, 0.4444864450389049, 0.37610317295978135, 0.40714195937245845, 0.18495172563016682, 0.24053083882695392, 0.2229598900058205, 0.22020564331226333, 0.21017233128918578, 0.2164180525877858, 0.225450035036303, 0.2557638415300355, 0.20146347845145585, 0.18662877139395395, 0.18718128262593847, 0.20274038742270784, 0.19171527911810982, 0.17606186315628225, 0.19256127934881828, 0.2202297112818664, 0.1743265531118745, 0.20018575111677162, 0.2639418341175045, 0.2813316994234708, 0.4901856830245017, 0.26143910772374845, 0.322285029533101, 0.25656977216281174, 0.28416866098510085, 0.32757152981655147, 0.3160219849337814, 0.6499484348011315, 0.2903525025931045, 0.37686181530542895, 0.6075791012014458, 0.4995413501120449, 0.6205208390303382, 0.48922114688749097, 0.1728490405678007, 0.36591292045128765, 0.1943032954994678, 0.202218245086479, 0.19869619922712634, 0.21414324039042998, 0.1777124794840087, 0.19499651329498124, 0.2858715142363304, 0.23986425422861568, 0.2926387735901087, 0.18537855682022897, 0.17423712528117252, 0.1811567734085997, 0.18340348535430862, 0.20223603721468042, 0.1837402950378333, 0.19020201504766965, 0.17054261085714773, 0.18560514324746868, 0.0818112566950856, 0.0758275744871868, 0.07636748938937543, 0.08011800126028334, 0.0735755793137911, 0.07288004118086577, 0.08465317960511998, 0.0761955279277905, 0.08298205327884367]}, "mutation_prompt": null}
{"id": "5963ea49-4d76-4d1c-baca-49a1f7facab3", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "06c8606a-3257-4927-bffc-dc8dd2ceeac6", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Enhanced adaptive crossover rate to balance exploration and exploitation\n        adaptive_crossover_rate = self.base_crossover_rate * (0.3 + 0.7 * np.cos(np.pi * eval_count / (2 * self.budget)))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic crossover rates to balance exploration and exploitation based on budget usage.", "configspace": "", "generation": 84, "fitness": 0.2906064203624208, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.7459402688379791, 0.7230586434778862, 0.7189854586739395, 0.7386298175334931, 0.7276680412923571, 0.7460817487282414, 0.7265357142448348, 0.7459814991631653, 0.7397272679515519, 0.6121881689154992, 0.5684340628331217, 0.5734899856263082, 0.5955957664719695, 0.6093422753238614, 0.5975415136394111, 0.6057327296444894, 0.5858820212551981, 0.5901055508491633, 0.5746283840176101, 0.5698495120315161, 0.5962512692471051, 0.5786439345934178, 0.5943375001579846, 0.5576497404145573, 0.5568861102039419, 0.5322422375214266, 0.5489707881539575, 0.4967583375937642, 0.5291998600871384, 0.5413913007428017, 0.5059394431044957, 0.1629269068954321, 0.5252064459816679, 0.16233044464008506, 0.4857069877194722, 0.4791811967325893, 0.9256225272612588, 0.9174978608183052, 0.890373567704899, 0.9119922324016212, 0.9174939963781434, 0.9346554269561463, 0.9134109041058359, 0.9103063748653063, 0.9317020710673106, 0.1994042039941042, 0.30221171277719905, 0.3091500661469455, 0.381909641581372, 0.3245278256571066, 0.3191437552124816, 0.2292997056734345, 0.21951531589054307, 0.26762846420462105, 0.18332789764472013, 0.22228839451055205, 0.14756205175455894, 0.18147733638030528, 0.20610616758400302, 0.22218442272663708, 0.22262470605550955, 0.2070952710850501, 0.10972725923963311, 0.2727859383616915, 0.12265547930487342, 0.10913439414744774, 0.2514570456628632, 0.14020738218952988, 0.18484660590917934, 0.1871936803843819, 0.1579111588800315, 0.14795419275966903, 0.1353996098843412, 0.16480823904139963, 0.12042714511600205, 0.22114497283533807, 0.13902406139560186, 0.17893179609733267, 0.16008776796355162, 0.13783286772857972, 0.148102499546927, 9.999999999998899e-05, 0.08380470025972098, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017487257620696584, 0.0443390231495836, 0.0637045940173755, 0.06106980956419161, 0.05835544562716566, 0.0600266423289646, 0.020164418481353086, 0.10483081624149293, 0.048204441484561156, 0.11870847377855442, 0.05972322702703203, 0.04987011284898635, 0.1420671470906737, 0.07161735716459028, 0.05562319187931375, 0.07747711995465834, 0.08063264756291444, 0.07014565745638779, 0.07548895455333127, 0.15409791788059557, 0.11555376770266734, 0.12213305902354243, 0.22139822564063827, 0.12224686563313858, 0.08938032361570258, 0.18049598442162929, 0.06695284919087985, 0.07682265148627354, 0.43369446251931687, 0.469124107935341, 0.4525997421586465, 0.4281787165392188, 0.45375620706730235, 0.49380631065025393, 0.5041093519191069, 0.4522454825674229, 0.46761951404148216, 0.10052320984021612, 0.09342705142531704, 0.0980775703646164, 0.11076036928626998, 0.11441698228746577, 0.1031291295545732, 0.10403787555739508, 0.09147430088391972, 0.07598720214771215, 0.318958136741497, 0.19899810257573658, 0.1522701357594538, 0.13544313795190233, 0.2529404591319496, 0.19921695078130486, 0.2072201164663976, 0.17480414076176276, 0.22586088924460523, 0.26293558386271876, 0.31069526306595474, 0.2465676468023822, 0.31370763295031623, 0.25924612748367937, 0.23341068580610003, 0.4191335847790958, 0.347799020215405, 0.29082604080677243, 0.16187762718692178, 0.2059999964617304, 0.1788587941503058, 0.27464728041222575, 0.1330931810905922, 0.17247803111618287, 0.14756865547938325, 0.16239624441276157, 0.1593870388697849, 0.2146507762740555, 0.18898351643388756, 0.1725880180443493, 0.18816975540711978, 0.18685343406154875, 0.21989036951863938, 0.18663987480161137, 0.20040149174418775, 0.2052146684755336, 0.2096247275551092, 0.20563495648064145, 0.20771619899929628, 0.19015980840932334, 0.6001988758117022, 0.20287445331218545, 0.22933702966481828, 0.20613899922612222, 0.20418538447874868, 0.5552188477686695, 0.1867744630519722, 0.6325882463548091, 0.7702839555829797, 0.19123429015583648, 0.674535550906569, 0.14895152322904992, 0.7447961780074756, 0.15917902935039563, 0.38951986453450504, 0.19477885849344523, 0.19597085669555203, 0.18279412498002667, 0.23203383860822835, 0.16120148521567157, 0.38854375877168357, 0.1464232388395671, 0.2814367855068798, 0.22183788821149253, 0.19101937282932535, 0.1717751790296146, 0.16696495054816318, 0.1709022048026141, 0.18684907416209473, 0.19365721289755478, 0.1799287918013317, 0.18390506343607216, 0.08790222610175025, 0.07178507172020532, 0.09104030869141733, 0.08035946499559232, 0.08009235584547081, 0.08795170570713162, 0.06239562911874197, 0.06156446067647592, 0.08193289796875436]}, "mutation_prompt": null}
{"id": "8bbc6cf2-7e07-4eab-a647-22798abe0259", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "4b8d87a9-f6c2-42cc-bd06-86d598ce8cad", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        stochastic_component = np.random.normal(0, 0.1, self.dim)  # Stochastic element\n        offspring = np.where(mask, parent1, parent2) + stochastic_component  # Introduce stochastic component\n        return np.clip(offspring, -5, 5)  # Ensure bounds\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce a stochastic component in crossover to further enhance exploration abilities with minimal code changes.", "configspace": "", "generation": 86, "fitness": 0.24460626936876545, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.43002503261611513, 0.4339290579877183, 0.4651977758884652, 0.4552632619349818, 0.4271450827608645, 0.4568064770862592, 0.45938943957502465, 0.49228192817980254, 0.4387489036735256, 0.03227918251030093, 0.07566659855178148, 0.029512881436746685, 0.047428140291394416, 0.04996612926412147, 0.08823653242852747, 0.050417828862354686, 0.038628619792955066, 0.11750278619258536, 0.1545531306661394, 0.1447834351828149, 0.14976060075829523, 0.13281623386702812, 0.14108132994819678, 0.12428143110613221, 0.1235582166578082, 0.14336202703133605, 0.13591934457617139, 0.10320092489207455, 0.129008564566371, 0.1346109966923812, 0.12264574948734552, 0.11587047218231405, 0.12565319443158174, 0.11263150390053356, 0.0884304148609959, 0.11957108084385071, 0.9404537834551575, 0.9127843439432349, 0.9249060881141125, 0.9133782388547507, 0.924895318297701, 0.9498294278575556, 0.9396334660521297, 0.9267242864268121, 0.9378157318978123, 0.2921969343813826, 0.2775778566488407, 0.29336249602397435, 0.3027793762496144, 0.2833607044475248, 0.29122539873313336, 0.27756035981341554, 0.28344239880793853, 0.28815190691709136, 0.38210517001410094, 0.5751878496233398, 0.577136308605769, 0.36357126226303893, 0.430622058533045, 0.6675251493517724, 0.3950192383871223, 0.5510282286994781, 0.6865366164519439, 0.16136727247922245, 0.1483691033743949, 0.1659259720064592, 0.11680244200999645, 0.15293196950463372, 0.16256648498463144, 0.17295077505332213, 0.2049672763308893, 0.1698476612085138, 0.16712406486194253, 0.1429632757394136, 0.1477343188350918, 0.2134372169361981, 0.15998743028926454, 0.20116399326964762, 0.12856319084987067, 0.08633836374984605, 0.18278603428625761, 9.999999999998899e-05, 9.999999999998899e-05, 0.03384626541082947, 9.999999999998899e-05, 0.013329476220871217, 9.999999999998899e-05, 0.0242039821702138, 0.11509605606267692, 9.999999999998899e-05, 0.03602396914536421, 0.08556992407448649, 0.10354839079043154, 0.11155956116764842, 0.21270473415647517, 0.06538377417936025, 0.05755222185167663, 0.10699222694326438, 0.07359346209064188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09929322203278912, 0.10234923500981874, 0.10836385444682639, 0.09666871740305083, 0.10784863593030347, 0.11375274165680271, 0.07234391000370832, 0.0605981175137289, 0.09391842756298918, 0.41201204755341936, 0.4326556364888974, 0.40422638852310444, 0.41732754731419197, 0.419254543685188, 0.4064289038464698, 0.45187401990977794, 0.42005623753968124, 0.4019378710749617, 0.08884291535108657, 0.11114046100644026, 0.10487593800622508, 0.13627043809053974, 0.1268888824391874, 0.128664867652592, 0.1040163433157053, 0.13116032800560484, 0.10379913532477691, 0.23468668130054748, 0.2584405771351984, 0.1778033943429671, 0.2435979231976677, 0.2559119753144349, 0.21394971169380284, 0.2524107084657027, 0.22725176213277842, 0.23732401280584003, 0.2966053915102107, 0.2924127777205312, 0.28993119131065437, 0.2864011539561627, 0.2756571004324675, 0.2875513196006989, 0.28876542062366783, 0.29589527610337496, 0.2867879651932411, 0.23240947529416223, 0.2073423680973998, 0.20304779584957744, 0.2287492048960278, 0.19557170100006727, 0.2190497047807155, 0.24619119066838135, 0.24312444572488234, 0.21776236840200702, 0.2194039654835146, 0.1990294930255917, 0.20134540307243565, 0.19906913670276927, 0.19919139162932709, 0.2183222004480092, 0.18454927076808314, 0.1995915949153031, 0.21530940748794591, 0.27670545922580747, 0.2076619295528339, 0.21327241324308732, 0.2093547363658358, 0.21127322598532372, 0.26332361468740406, 0.19342563066479668, 0.2107534074244376, 0.21094599491145904, 0.5950197808810898, 0.1675041851047523, 0.6008826239506864, 0.6348381849219605, 0.6830826889887358, 0.6064754617949966, 0.5741622692189146, 0.6881452607959533, 0.20246462454379566, 0.5859834713149387, 0.20553074180717423, 0.34408505682482393, 0.4399948469324362, 0.5123341663617053, 0.1492226790705763, 0.4005516169838854, 0.21175029261501976, 0.2056457744494099, 0.191192066767921, 0.19065757950917994, 0.18846012147134183, 0.20143653963407837, 0.20104460190271833, 0.17946880544382582, 0.19966940071975414, 0.1753055357918618, 0.17963672181830914, 0.08559754786156915, 0.08359791062741184, 0.08861162317189997, 0.0833739037271809, 0.07965033983571324, 0.07406460669198, 0.08819316435992552, 0.0682244453639047, 0.07976010298868619]}, "mutation_prompt": null}
{"id": "7b80ce15-1393-443f-8606-9cfe7fad0931", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "3012d92f-87fd-4542-93a7-84468e4cb87f", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "e7161701-60be-4c64-a23e-34fad026b817", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            if eval_count % (100 + int(100 * (eval_count / self.budget))) == 0:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = best_individual\n                self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive elitism frequency to dynamically control elitism based on convergence rate.", "configspace": "", "generation": 89, "fitness": 0.3079811581022498, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8104415037911028, 0.7999997440765638, 0.8164760975084373, 0.8122529350744527, 0.7979974461532715, 0.8145639827733262, 0.8082859813346643, 0.8011645540185011, 0.8061751303447322, 0.6720207199857202, 0.6876330124125227, 0.6732608271174825, 0.657344467043582, 0.6780239191997093, 0.682682040581438, 0.6859352523872044, 0.6933283868912683, 0.7009827041334036, 0.551029051340017, 0.5551988281215867, 0.5375539013951844, 0.5523141073691702, 0.5581661836985989, 0.5894098476240599, 0.5226316606827671, 0.5019482546060003, 0.5547891176196016, 0.5033716925709155, 0.5028114553417897, 0.478420144492236, 0.47140397238368736, 0.4892838618823703, 0.46153537498466923, 0.4732104297952562, 0.4705573187949741, 0.4441052893315701, 0.9862762792325471, 0.9619886996200807, 0.9601616362781304, 0.9693778398781969, 0.9652670137868793, 0.970672439432247, 0.9699445475810915, 0.9708835244393155, 0.9570757194520463, 0.29979716208694906, 0.2872823163666227, 0.31624657464101236, 0.28637707548581415, 0.3431119263037363, 0.33098108622024014, 0.23009432753707393, 0.25492668610677705, 0.2684452012267373, 0.43960419697039765, 0.287394558168632, 0.288395479730306, 0.5142818123344827, 0.3462480934695933, 0.21967214995726092, 0.4816651828493993, 0.2659908573152413, 0.2876216831928867, 0.18347823427056775, 0.1910314622372744, 0.15545809376892317, 0.16303073507299193, 0.16206275102735435, 0.1708278469510367, 0.1437821406983929, 0.16582750998195295, 0.1608797734355878, 0.15806026264722728, 0.1491250166555146, 0.12818760506287286, 0.16118528624455064, 0.15893047666846838, 0.1483926349005653, 0.1869357258048867, 0.16444174188872407, 0.14078967073611293, 9.999999999998899e-05, 9.999999999998899e-05, 0.014867899014164854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008310259008712406, 9.999999999998899e-05, 0.0007704262379872873, 0.07814446005330267, 0.06687281088340769, 0.049490953519735204, 0.05154511713714072, 0.08309378272165135, 0.026113844252430463, 0.14285149036801326, 0.08673620174199548, 0.05721628857663452, 0.021246448800620654, 0.03922498847276512, 0.03890097154485117, 0.007229105065515662, 0.013237060262883626, 0.003268936241816456, 0.011196235093104634, 0.027372894929748703, 0.005380235101091979, 0.11662826120150804, 0.09362694543510497, 0.09808972168188934, 0.12754085266458481, 0.11027913133411826, 0.13124532206223682, 0.11876326267700366, 0.10126462490643584, 0.0922621232454045, 0.5006222176296979, 0.48571716503231, 0.46478418165806323, 0.44536381091026656, 0.47422551147281067, 0.48166618525756133, 0.48766716461071025, 0.5063540048715034, 0.4834948067680963, 0.11846467963010998, 0.0984266073933393, 0.10863963758625161, 0.08713046951324577, 0.09796666669240095, 0.10725614708999787, 0.11587058387697102, 0.1009425229358758, 0.10842552114021886, 0.14937876177168674, 0.13917735544894716, 0.14298045612467847, 0.16189221474984028, 0.15324378294859764, 0.13830829831605007, 0.1276664675809056, 0.1508946912211543, 0.1532146674570133, 0.29284881974670074, 0.28956781627417094, 0.34560601757715426, 0.3321494563690318, 0.25392801636339024, 0.3413207153038146, 0.4444864450389049, 0.37610317295978135, 0.40714195937245845, 0.20583616135468008, 0.24053083882695392, 0.2229598900058205, 0.22020564331226333, 0.21017233128918578, 0.2164180525877858, 0.225450035036303, 0.2557638415300355, 0.20146347845145585, 0.18662877139395395, 0.18718128262593847, 0.20274038742270784, 0.19171527911810982, 0.17606186315628225, 0.19256127934881828, 0.2202297112818664, 0.1743265531118745, 0.20018575111677162, 0.32209022964826894, 0.2813316994234708, 0.4901856830245017, 0.26143910772374845, 0.322285029533101, 0.25656977216281174, 0.28416866098510085, 0.32757152981655147, 0.35043168396643765, 0.6499484348011315, 0.2903525025931045, 0.37686181530542895, 0.6075791012014458, 0.4995413501120449, 0.6205208390303382, 0.48922114688749097, 0.1754113701316432, 0.36591292045128765, 0.1943032954994678, 0.202218245086479, 0.19869619922712634, 0.21414324039042998, 0.1777124794840087, 0.19499651329498124, 0.2858715142363304, 0.23986425422861568, 0.2926387735901087, 0.18537855682022897, 0.17423712528117252, 0.1811567734085997, 0.18340348535430862, 0.20223603721468042, 0.1837402950378333, 0.19020201504766965, 0.17054261085714773, 0.18560514324746868, 0.0818112566950856, 0.0758275744871868, 0.07636748938937543, 0.08011800126028334, 0.0735755793137911, 0.07288004118086577, 0.08055415396926269, 0.0761955279277905, 0.08298205327884367]}, "mutation_prompt": null}
{"id": "7f6a622e-518f-40c7-80ec-bcbcf807ee97", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        # Adaptive crossover rate based on diversity\n        diversity_factor = np.std(self.population, axis=0).mean()\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget)) * (1 + diversity_factor)\n        adaptive_crossover_rate = min(1.0, max(0.6, adaptive_crossover_rate))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Adaptive mutation based on fitness improvements\n        best_fitness = min(self.fitness)\n        current_fitness = self.fitness[target_idx]\n        improvement_factor = max(0.1, (best_fitness / (current_fitness + 1e-6))**0.5)\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2) * improvement_factor\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive learning rates for mutation and crossover to better accommodate varying search landscapes.", "configspace": "", "generation": 90, "fitness": 0.2753223002857906, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.760012541860615, 0.7473553204760588, 0.7618721150576319, 0.7639618624143892, 0.7654145239295884, 0.5034822236553858, 0.6226618232334582, 0.6482288664627123, 0.750567175234795, 0.09231054604722233, 0.11607612770851261, 0.0, 0.6535462780257615, 0.6427054061447106, 0.659818799693526, 0.6504779554519511, 0.6564827580313638, 0.6908408983562662, 0.09844596590795684, 0.5975098932203664, 0.5703475058449083, 0.19483835082639067, 0.5904960308929299, 0.2223110485225308, 0.20881213502173246, 0.17895179545195938, 0.09913532584772766, 0.5329134806365885, 0.5347751177855731, 0.5304043722904861, 0.10055592640360467, 0.5396672028776781, 0.5547362830243046, 0.5749126639780582, 0.4807757252365402, 0.5838446035173099, 0.8776701963922052, 0.873601737837463, 0.8660262326816157, 0.878692842818019, 0.8966280048852266, 0.8835607645185328, 0.8828427023066476, 0.8912374421351843, 0.8793366797924395, 0.47120256196464094, 0.17468217281280818, 0.19404586132317514, 0.464350001148775, 0.04618404293438072, 0.24706491467002867, 0.37589313047969586, 0.311258466236235, 0.4284811154106757, 0.6331142227489314, 0.21614788859807488, 0.6877823552297381, 0.25590932400715005, 0.25271474357351076, 0.24627487515275714, 0.29164108486158935, 0.6725543995252999, 0.08056549229687737, 0.23259578768504086, 0.15563432706599267, 0.0, 0.09871563125199156, 0.10411529585113766, 0.09653527774327308, 0.25291419525217884, 0.10701401959626022, 0.15206183855342348, 0.11867276036486796, 0.10806225707537798, 0.16262787916643773, 0.13685406060889016, 0.13263061996502634, 0.12357011123859263, 0.16882390885355658, 0.05187683110528707, 0.15196473435535662, 0.0, 0.06169712921206172, 0.0, 0.005006773385935803, 9.999999999998899e-05, 9.999999999998899e-05, 0.03200354677884565, 9.999999999998899e-05, 0.025788799446244015, 0.0737322219573946, 0.050906945046575114, 0.07677279733861653, 0.06029660616700583, 0.0296755823415904, 0.021759772427118018, 0.04658298425322249, 0.08636476113232183, 0.042714305282413934, 0.12318286488679697, 0.047295048951964236, 0.012219995287994223, 0.0, 0.0, 0.10567940434984524, 0.3952046870877508, 0.12065841063765892, 0.05486547624719873, 0.21516200969442112, 0.13082649762516507, 0.0, 0.0, 0.057125104300068785, 0.10121107147205399, 0.1704287688583065, 0.12146505471246838, 0.014273300628671493, 0.33414805644335066, 0.46646420176683745, 0.4867497696984079, 0.47640937747127987, 0.4317873314420123, 0.45154913229033444, 0.5041323240566413, 0.26214159057975517, 0.45761809224757377, 0.11361480025607873, 0.06962446056274363, 0.09519898391644677, 0.13964413770066408, 0.14130225157391885, 0.1214938547413481, 0.09756872160964469, 0.1103184306022078, 0.08658503358380476, 0.1831814404170341, 0.22362561779513357, 0.16266286403508823, 0.25261433727155014, 0.16554415774940823, 0.19479231559332677, 0.16437755018813438, 0.29695240925477095, 0.15749771819346026, 0.32051870873875454, 0.2739160580208808, 0.37171201304345325, 0.2647601731391952, 0.2706471776766095, 0.30441058830906387, 0.24371903314908372, 0.44348610916067355, 0.2936894137110585, 0.2478506370106266, 0.3070429043978692, 0.21160581808352585, 0.1778779388489753, 0.22608744364027666, 0.2122567238446249, 0.23600522243405597, 0.2614838274352991, 0.23511956532752998, 0.22580855541787437, 0.18748706729991615, 0.23759549640842592, 0.2063798871092778, 0.21020709055293008, 0.19664916798405863, 0.19248115000311772, 0.1771311924177057, 0.22305373035521936, 0.22039495292747124, 0.20013915837437857, 0.2229382806978799, 0.19167820521560153, 0.581932717356137, 0.2215291697915438, 0.2205704512262825, 0.21002859619824144, 0.220507980491484, 0.7215463393649564, 0.16144881790297172, 0.1472178075899726, 0.7807048927474964, 0.19266853206624068, 0.15388194171525338, 0.11776179509066409, 0.1524301390203242, 0.5576560855431576, 0.4133782632285975, 0.19669234716347384, 0.19153428823905339, 0.18744479319228036, 0.15523459534367245, 0.1861751713055091, 0.0984486992993232, 0.18103156167283707, 0.44689350386098736, 0.17279051614425878, 0.1806291543404741, 0.19680343134131717, 0.18144148672514782, 0.19076421430039614, 0.19634304189002427, 0.1789291188135772, 0.2021057899960611, 0.18350607729720014, 0.0660799505899824, 0.09202821483391599, 0.061277161379162504, 0.08462410598766967, 0.08969298420936611, 0.0914611205071445, 0.07830852096582874, 0.08906026977511772, 0.09873960079261523]}, "mutation_prompt": null}
{"id": "de642178-8bf1-4bac-8a5f-5878325e9f14", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.learning_rate = 0.1  # New learning rate for adaptive mutation\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        population_diversity = np.std(self.population, axis=0).mean()  # Measure diversity\n        adaptive_mutation += self.learning_rate * population_diversity  # Incorporate diversity into mutation\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce a learning rate for mutation factor to adapt based on diversity metrics and improve solution exploration.", "configspace": "", "generation": 91, "fitness": 0.10804417498773809, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.18042974661962563, 0.13581645778688112, 0.145793583263781, 0.14938000635803417, 0.15793213173737786, 0.1583513121674197, 0.14636954118797807, 0.1653889978859031, 0.1701428364833233, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028010293802678277, 0.03478553865129963, 0.039111380103696525, 0.04623005935896074, 0.03400123673388844, 0.03726034121698718, 0.040276912708238743, 0.03921471186266556, 0.024647927264359493, 0.024417882349097253, 0.013442055627125082, 0.007847054962219935, 0.05399837526013185, 0.007601482475042776, 0.03416252955994281, 0.030588406256950473, 0.001894920146646606, 0.0127910647196815, 0.9862762792325471, 0.9755125668286269, 0.9725884975116709, 0.9742966336331846, 0.9777531052196377, 0.9756121279013821, 0.975446412072579, 0.9778941877589941, 0.9722678697900292, 0.07574793432598148, 0.05411683487622554, 0.062079792866432615, 0.05942174202759121, 0.017482198960947826, 0.021693713313249874, 0.06197307678884567, 0.037188152419692755, 0.10846879195258041, 0.10410820664031584, 0.17243461800002424, 0.09050416359810354, 0.07852499579020533, 0.07275849405212009, 0.08127452331403351, 0.060324580444960474, 0.10507347437352366, 0.08009417001874464, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006342422790120983, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03893717514153017, 0.0, 0.10939349773610063, 0.001750370212760588, 0.042020716511798506, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14682251664438828, 0.17111772572187767, 0.19942897394268522, 0.162589308207429, 0.15102349362788425, 0.16345931899829302, 0.16104568613219783, 0.18251491003877018, 0.1870278365482987, 0.022283614306131905, 0.057909655409248306, 0.03464297685370088, 0.03257212990950753, 0.015057729269691844, 0.03696876524702819, 0.028483011435710637, 0.0227648163258255, 0.028576794696683616, 0.14605001206796042, 0.11516961524552649, 0.11833361437130263, 0.12606812287757507, 0.12693418839631487, 0.11669114348798071, 0.18828736437245874, 0.10056326172838015, 0.1454577607000832, 0.1422266201362974, 0.1316370990829533, 0.16130937881362184, 0.1393035907991138, 0.1450054668139097, 0.1254737652180311, 0.1501864190355735, 0.17369512487615446, 0.13884851455337488, 0.0729613391110453, 0.05610854694813039, 0.08389423256590267, 0.07847917842483998, 0.07221451832200276, 0.09739863123582615, 0.1197670333192844, 0.09968109929816038, 0.0852010740709106, 0.1225880289423189, 0.1097899586319494, 0.13410625672562926, 0.1580950929629018, 0.11290596183040358, 0.2007874524317972, 0.1231871161632001, 0.12445844997568456, 0.1452966909389496, 0.027936160362237783, 0.047830422799572614, 0.14592442036974895, 0.18246237649358987, 0.0, 0.09768192840303946, 0.13076940982516594, 0.0, 0.1549577063758779, 0.10909944085601275, 0.11454113037350577, 0.13883688994794907, 0.12632985139143893, 0.12070353966556291, 0.1095850588033136, 0.11198578988758012, 0.10803111644057639, 0.11473242395308736, 0.12771924712873317, 0.15725857945896915, 0.09728627516426114, 0.09380864066164007, 0.10408555057918634, 0.1094345070792635, 0.09601528349656363, 0.11407511004477533, 0.1107674482881632, 0.16340018698801373, 0.17399641628307727, 0.17319526230630022, 0.1935354793690579, 0.1941031615063119, 0.16467114787041937, 0.17396967358498605, 0.17728126270972755, 0.1814951510571755, 0.05615866532456948, 0.024127663836227997, 0.0448052961248937, 0.054835240522210005, 0.034154360663545824, 0.036879068783024604, 0.03534470776764609, 0.03793735337628146, 0.02980247149387505]}, "mutation_prompt": null}
{"id": "eb159e46-23ba-4aec-a7f0-ef6ffb135b66", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "e5cc74f7-af5a-4a25-91b3-00720c3ac927", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        resize_phase = True\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                if resize_phase:\n                    self.population_size = max(20, int(self.population_size * 0.9))\n                else:\n                    self.population_size = min(50, int(self.population_size * 1.1))\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n                resize_phase = not resize_phase\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive population size by alternating between reduction and expansion phases to maintain diversity and convergence balance.", "configspace": "", "generation": 93, "fitness": 0.3390171638890495, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8129856342817635, 0.8225541974799588, 0.8312331897908403, 0.8367488055512066, 0.8410995460963098, 0.8321652372922935, 0.8245924349059365, 0.8219134840460128, 0.8189458581690344, 0.6739829149297853, 0.6572412104074663, 0.6902205216977033, 0.6454104701661318, 0.6732837292551821, 0.6857858368566605, 0.6563800320417412, 0.6854906515546512, 0.6994103177135433, 0.5985603598283677, 0.55859404339232, 0.5830069873165624, 0.5907019006818391, 0.6525513807414416, 0.5914822401789347, 0.5219036789742025, 0.6401337114319158, 0.18080725695061528, 0.588619664149446, 0.5678838360840908, 0.1504309597957788, 0.17010750854629952, 0.1742446805914466, 0.5856055493063216, 0.1505467753530756, 0.5117764780393673, 0.5733765202614363, 0.9862762792325471, 0.9646993471487447, 0.9654728756580556, 0.9683122786706776, 0.968120325749447, 0.971266588756534, 0.9697143924489936, 0.9766220196703049, 0.9655293053747924, 0.44244408248193423, 0.49911406487380505, 0.5197687880196165, 0.4189417689909306, 0.32891707924979896, 0.3809352422347453, 0.25222618947518494, 0.42144408818785484, 0.4242839783243968, 0.22239962102108135, 0.7418258870825452, 0.31925614613629516, 0.33493959398169104, 0.3508820596019283, 0.2662880144742592, 0.22737824419388586, 0.5043796339396122, 0.2283035204337469, 0.18835806119914367, 0.15923194275909647, 0.21992387107385092, 0.12727910128991515, 0.12425959628419059, 0.1893483153238803, 0.31271596631338083, 0.17008489980274066, 0.17047044141188894, 0.22582033413006974, 0.20492081656034766, 0.17206575238154853, 0.13297546556230844, 0.12639326012386431, 0.19272555551254444, 0.16309687534349382, 0.0950820452095481, 0.1829395778685472, 0.04814454026685111, 0.06396317179729116, 0.025672766817579795, 9.999999999998899e-05, 0.0008060524505637545, 9.999999999998899e-05, 0.0057343865714146736, 9.999999999998899e-05, 0.07684091162776008, 0.12677507207823513, 0.0583826496212152, 0.10804318002860036, 0.11352420783986472, 0.12211593105374918, 0.06861095643183157, 0.10440745833268461, 0.07919456572335437, 0.06227058069150171, 0.110187582438665, 0.03233129097093457, 0.10018880420344689, 0.19181955816974183, 0.06691347107731549, 0.10163693367951687, 0.07085515318675717, 0.1161548144710487, 0.1652813361368468, 0.20644578021101, 0.1702452214249861, 0.17450334372347442, 0.14534250687899308, 0.09501938882205196, 0.1406357828161443, 0.10196977725934553, 0.11331438734026666, 0.10640720031149908, 0.5157469258009194, 0.4847738880027046, 0.5261540040953174, 0.5190762858950635, 0.48893921026853904, 0.48635755994269125, 0.553570627924072, 0.49198555952944434, 0.5004400786104242, 0.10283415699649723, 0.10731776874839383, 0.10468798147534142, 0.10404055562116155, 0.12788734755755593, 0.17163742533058501, 0.10309816345031741, 0.11071088014516595, 0.08784197453686848, 0.18366626573300104, 0.3400555715339407, 0.19516415380619623, 0.33061568969312116, 0.18934493640728256, 0.13754482940368484, 0.2880741692161666, 0.23724826569375523, 0.21965875438754567, 0.2792150245779007, 0.3001240901519937, 0.45493335124308565, 0.3335038895933171, 0.3932124101459642, 0.35057788413408364, 0.4206255602465958, 0.48437639489655304, 0.3424134522650737, 0.2209427030241019, 0.22949488545552577, 0.36577191001624376, 0.2635340482140741, 0.18381657274555796, 0.2579529834239316, 0.3318840266475003, 0.30155610571046076, 0.1807268744365016, 0.19947432174419932, 0.18191147623624504, 0.23041075707506642, 0.2514566497351751, 0.21283697806561963, 0.24058755550288446, 0.24906554171136874, 0.26239449507713875, 0.20074073837373063, 0.23810226435880844, 0.23931723099676105, 0.19963139510962513, 0.2363284796320737, 0.22032943353937795, 0.6318672130778172, 0.23069739073144613, 0.6199081692489878, 0.2332430533460932, 0.7771913500419994, 0.18825147872412584, 0.8109789323969658, 0.8364968726971327, 0.7773105000359635, 0.8401994139741049, 0.16974774186730024, 0.8052630955337625, 0.8181127578283394, 0.4386705343947708, 0.20697447895750554, 0.20236737590931975, 0.4809736626802027, 0.16116707848266543, 0.1645575536803997, 0.15193889154127704, 0.4883839892515811, 0.20773585431438768, 0.22411425167382193, 0.1813950774614791, 0.1719136422268408, 0.17473560742418193, 0.16815726166482836, 0.19469730504249405, 0.19251711667286375, 0.17124377768346255, 0.17598114464194026, 0.09762434725815905, 0.09219618786795358, 0.09048981295928626, 0.08601023448363376, 0.08318067774408411, 0.09753484835675408, 0.08785974996405543, 0.09452370545759992, 0.08452308696480337]}, "mutation_prompt": null}
{"id": "ca25f0ae-e503-46fd-bed4-8278b43c1ea9", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 100 == 0:\n                self.mutation_factor = 0.8 if eval_count % 300 == 0 else self.mutation_factor * 0.95\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive population scaling and periodic mutation factor adjustment to improve solution diversity and convergence speed.", "configspace": "", "generation": 94, "fitness": 0.35263858723658953, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8201499614966292, 0.81523246868564, 0.8129264565303036, 0.8238694203496817, 0.8149653463115436, 0.8144147101624409, 0.8132292684927906, 0.814015020088827, 0.83360856133255, 0.695432865003439, 0.6896260831775507, 0.7032391142086589, 0.6946634539508383, 0.6835057454815487, 0.6898829022783017, 0.6853085452042449, 0.6905313579785276, 0.7043686140716866, 0.6632183736859409, 0.6291088706152865, 0.6233994072583879, 0.6231263768528481, 0.582293966574086, 0.6132844984032357, 0.6380431490166629, 0.6630079343010467, 0.685545677619344, 0.6087216328604672, 0.5702467057632623, 0.5481663897183664, 0.5699534153117531, 0.564717802071441, 0.5575878550294209, 0.58902608713399, 0.5663677120681414, 0.58045621880225, 0.9862762792325471, 0.9660270693973727, 0.9703494496296208, 0.9681085269196235, 0.9742442163263925, 0.9714965734816262, 0.9637652232314688, 0.9691556679655318, 0.9668003502026786, 0.48245895725186716, 0.39945379143163595, 0.4459853704224177, 0.47481221822040287, 0.38833199654701467, 0.4552091269027473, 0.3750018501234016, 0.4346465800068171, 0.1977930925563952, 0.3496415787652093, 0.21974923020975534, 0.21662746318976156, 0.21039291140127403, 0.2685377893495017, 0.2061654334445988, 0.31195009952150454, 0.34162971744309933, 0.22689224426669163, 0.2596485752173402, 0.1611473646486027, 0.15574131558822157, 0.14399495703963971, 0.1559546432192177, 0.1211513840403764, 0.22093010837231664, 0.15614815828710393, 0.16367720199964353, 0.18922693331856733, 0.4091541163021244, 0.15629557047971954, 0.1830873285501382, 0.31962023004127016, 0.2061862353060886, 0.15581538242608406, 0.1988233382120681, 0.17038680871431244, 0.011913097864904909, 9.999999999998899e-05, 0.05728658815141641, 0.04040650023836567, 9.999999999998899e-05, 0.00012972434785096798, 0.041405711503139875, 0.04107779723246241, 0.05398245225448173, 0.08087941763481721, 0.10082985286507318, 0.07635086220368537, 0.08065147675839868, 0.012520086510578787, 0.03544008351599992, 0.10380712981382645, 0.11392957738327569, 0.049210367199842175, 0.0386752490223744, 0.029790695954130197, 0.039537167020246344, 0.06626797332554635, 0.06420336297281104, 0.09059883627064758, 0.08862997394419325, 0.0686253072137657, 0.19736669616404257, 0.13256060320866514, 0.15913255487468247, 0.1665844786362315, 0.2689648691834473, 0.17590557313899102, 0.16452218002859043, 0.07755849047459251, 0.11288390694758854, 0.10559918487763276, 0.5576268549289516, 0.5430494371654702, 0.4957917888635276, 0.4925093439285251, 0.47602644250889214, 0.5103464136157527, 0.5166397591791865, 0.49445723481517845, 0.537379706838825, 0.10398245370348691, 0.11010235814530134, 0.11218225975778073, 0.12388883651060556, 0.07109471967800984, 0.1700412949717145, 0.1112291303866908, 0.09874495621901391, 0.17199088311455613, 0.18255858682514592, 0.31509056041045047, 0.1654953906362865, 0.23371064988246992, 0.19788972266352844, 0.22496043940823707, 0.22370544488237287, 0.19156959001521034, 0.18621150449160806, 0.361586682925253, 0.32336558272109817, 0.3348758217372455, 0.41338708330558727, 0.3443412932419351, 0.37063658675537114, 0.44105851439436616, 0.4658008996641454, 0.43136831613201954, 0.3022453820312402, 0.16508973741455812, 0.27858356683623264, 0.18822503259169732, 0.20778364776833325, 0.27091911317853934, 0.264868749220199, 0.3192943506950935, 0.31950876431266384, 0.1856863475293491, 0.1960604714023687, 0.24140756796185192, 0.21637714750900272, 0.18422412214376216, 0.19042407994376098, 0.22759439737782927, 0.186662798542654, 0.21758596500981742, 0.6060092609112384, 0.680570173837618, 0.6419834488520059, 0.23395853366609987, 0.23707164483543008, 0.21504328905317005, 0.23706660694352633, 0.6654381331655003, 0.681822861707289, 0.7520619324002069, 0.1870303877565591, 0.36830463749623965, 0.8173897700201783, 0.7638579306888489, 0.7363970840806793, 0.16922653353769745, 0.7636800848038584, 0.7785754727249146, 0.5640647877340186, 0.20417217646405283, 0.16575285996674283, 0.4246381589805698, 0.1974756601146327, 0.29171012427449783, 0.20126210081315776, 0.5633290350956435, 0.4934055552733615, 0.1880092699312298, 0.19821971670697358, 0.21807987965920894, 0.16339559020193906, 0.17354836661733275, 0.19681917614567013, 0.29573235596477776, 0.19220276732066222, 0.17775004260241034, 0.07939479745066425, 0.09067098777052085, 0.0815477256041528, 0.08403724451078054, 0.0810704995515047, 0.08582558595912193, 0.0969748875365618, 0.08124548758418826, 0.08571217506393136]}, "mutation_prompt": null}
{"id": "acb1a662-53b2-4330-b48b-b670e6d57c6f", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "58e79d89-313e-4704-bd67-6bed9e47356a", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "7d8ad31b-1846-46d2-ad08-0a181d23905f", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        # Make tournament size dynamic based on the remaining budget\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        # Apply a non-linear decay function for the mutation factor\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c]) + beta * (self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)  # Ensure within bounds\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            # Elitism: carry the best individual to the next generation\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            # Adaptive mutation factor reset every 200 evaluations to maintain diversity\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8  # Reset mutation factor\n\n            # Dynamic population resizing\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))  # Slightly more aggressive reduction\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce dynamic tournament size to enhance selection pressure adaptively based on remaining budget.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569096145, 0.7984403983665924, 0.8087274775059203, 0.8186144498949841, 0.8175309786672088, 0.8159724799078152, 0.8174018055861988, 0.8165791455360556, 0.8060201676619985, 0.7068283542922884, 0.6929675274863816, 0.6888912907888936, 0.6830052150557676, 0.6936057412361063, 0.688494479325977, 0.695891192489962, 0.6853871478248994, 0.7158736332786023, 0.6306779102289133, 0.6451804994559587, 0.6391491490054163, 0.6105552790243949, 0.6172992639896285, 0.5928959455140467, 0.6733739572614977, 0.621099008774864, 0.6087509894054052, 0.590416726455236, 0.5434430400519532, 0.5870340571051111, 0.589358059261836, 0.5592034015080918, 0.5891854653933577, 0.574771047632415, 0.573070701977475, 0.5905200297852653, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742374484, 0.502581180069076, 0.47079977968585396, 0.3889495932199434, 0.4321102998715012, 0.3783293496533412, 0.38695628630138024, 0.3422669091767748, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298545, 0.26144869038217167, 0.326083060788924, 0.24402001349242475, 0.2779311435652303, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.03163169613327643, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.10643355743085581, 0.07507519949885755, 0.08437038742472591, 0.16837464865652396, 0.14799462459745172, 0.18801781827307784, 0.07226124500352693, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078539, 0.12138273833035906, 0.08600242142198022, 0.11359374347198825, 0.17308848979750657, 0.22805994308709254, 0.18612590343417978, 0.16087217749482552, 0.1417708441202844, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.17524476288980773, 0.4857945038965117, 0.5248926090698411, 0.5399466937533474, 0.5394622387763294, 0.5707160035338876, 0.5131446807241025, 0.505187873648542, 0.47380054920308035, 0.5275352362112034, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742256685, 0.28017881379228216, 0.22588560610719222, 0.2784639603099005, 0.2850323171628987, 0.16308904093188048, 0.15087721594216763, 0.1765529032645523, 0.16970128600324785, 0.41083308368385574, 0.3125014144634555, 0.40318285425212197, 0.3613176721453728, 0.2552410861630219, 0.4544057950868192, 0.4138958721978958, 0.4779033343885233, 0.39950359571800564, 0.2842824364378238, 0.24147733379194125, 0.3738094419163722, 0.2900983757647566, 0.17661102203641021, 0.374937558837674, 0.27534194146187885, 0.30354159465005426, 0.32584466696625425, 0.19933049791575363, 0.1934972300795179, 0.23993948084774308, 0.19828547572150346, 0.22084073686100514, 0.19363066361863446, 0.20605576916892432, 0.1676259927468433, 0.18813705351493815, 0.6276792037129382, 0.6292358239168552, 0.5902855682565118, 0.23871513950289358, 0.2325631984526091, 0.5760091375940116, 0.3097509312533596, 0.7042017898671625, 0.22892972287660385, 0.7982411181149072, 0.40381283826113723, 0.7819228638177533, 0.8251857596977885, 0.194199839091581, 0.6919342621507738, 0.7390021495218847, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848471, 0.19247153009910212, 0.19991549439251266, 0.19128721342739852, 0.2449700442193563, 0.17768502651396922, 0.18777441796244032, 0.18658436029011016, 0.18971531325599145, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10685291936292907, 0.09282415227885887, 0.07426223837486812]}, "mutation_prompt": null}
{"id": "94fceb1c-9dc1-4f13-a565-d6d5eb0c3e9b", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c] + self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce adaptive learning rate for differential evolution to balance exploration and exploitation.", "configspace": "", "generation": 98, "fitness": 0.3568664212329743, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "f470a7a4-269b-4fdd-bfa8-04f39b7b9946", "metadata": {"aucs": [0.8241446569094651, 0.7984403983667092, 0.8087274775059572, 0.8186144498950468, 0.8175309786673672, 0.8159724799077662, 0.8174018055862124, 0.8165791455360292, 0.8060201676619537, 0.7068283541709832, 0.6929675273889983, 0.6888912907867886, 0.6830052150668771, 0.693605741173087, 0.6884944790618426, 0.6958911924632236, 0.6853871478372766, 0.715873633283975, 0.6306779102286557, 0.6451804994559619, 0.6391491490054135, 0.6105552790243978, 0.6172992639896716, 0.5928959455140397, 0.6733739572614974, 0.6210990087753744, 0.6087509894053327, 0.5904167264532835, 0.543443040051337, 0.5870340571058138, 0.589358059261883, 0.5592034015059124, 0.589185465393331, 0.5747710476324149, 0.5730707019774697, 0.5905200297844273, 0.9862762792325471, 0.9571468376270695, 0.9703615652657676, 0.9683076762441304, 0.9677947996962578, 0.9712672642820722, 0.9700014478086123, 0.9692259976948134, 0.9661331047487427, 0.46360055742353146, 0.5025811800685835, 0.47079977968588005, 0.388949593220009, 0.43211029987136074, 0.3783293496533443, 0.38695628630135104, 0.3422669091767331, 0.3853534777206731, 0.33517763226959274, 0.3605135132267727, 0.20104023475660893, 0.19082463221894308, 0.259382772911382, 0.2550649788386187, 0.22086733202551867, 0.20113831520302405, 0.22753512053275704, 0.20263595435084303, 0.15307155893339042, 0.15556481801227706, 0.16389612504298223, 0.26144869038216745, 0.3260830607889419, 0.24402001349242686, 0.2779311435652355, 0.17534226023891297, 0.18043249329864752, 0.18032316609706378, 0.17844638353215614, 0.13875924967709574, 0.15025642739449008, 0.13089383769243124, 0.17848615622128583, 0.18282302065662293, 0.19448572704479627, 9.999999999998899e-05, 0.0007237435112706914, 9.999999999998899e-05, 0.031631696133286424, 9.999999999998899e-05, 9.999999999998899e-05, 0.0161155261753525, 0.03076853269706903, 0.08345629163175217, 0.12273372226552581, 0.052557809692404756, 0.10270100074327526, 0.1064335574308568, 0.07507519949885755, 0.08437038742472591, 0.16837464865652596, 0.14799462459745283, 0.1880178182730785, 0.07226124500350795, 0.09799001891140036, 0.08428239346108513, 0.06440279081327349, 0.06686484812432847, 0.14564528031078772, 0.12138273833035906, 0.08600242142199244, 0.11359374347199758, 0.17308848979750713, 0.22805994308771027, 0.18612590343417956, 0.16087217749482552, 0.14177084412027274, 0.09800850771605274, 0.09365510492531337, 0.07397262201590982, 0.1752447628898155, 0.4857945038965179, 0.52489260906984, 0.5399466937532731, 0.5394622387764916, 0.5707160035340891, 0.5131446807240923, 0.5051878736485311, 0.47380054920308945, 0.5275352362112251, 0.11886838292055169, 0.10311107838330558, 0.13102613960007314, 0.09296643565404883, 0.16289460388462662, 0.1265974135967166, 0.10525333394563519, 0.12658698641501598, 0.1251820476712986, 0.18365004742255342, 0.2801788137922949, 0.22588560610718067, 0.27846396030990395, 0.29152968789668954, 0.16308904093188759, 0.15087721594219872, 0.1727758297191112, 0.16970128600322765, 0.4108330836841001, 0.31250141446346713, 0.40318285425215483, 0.36131767214541755, 0.2552410861630219, 0.4544057950859909, 0.4138958721984102, 0.47790333439927224, 0.39950359571818894, 0.2842824364377181, 0.24147733379199865, 0.3738094419163781, 0.2900983757647705, 0.17661102203639933, 0.3749375588374957, 0.275341941461857, 0.3035415946497466, 0.32584466696643444, 0.23885622191684264, 0.20170777438215115, 0.23993948084774308, 0.19828547572150623, 0.22084073686100514, 0.19398064451275, 0.20605576916892632, 0.16762599274682666, 0.18813705351493815, 0.6276792037024974, 0.629235823916809, 0.5902855682471562, 0.23871513950289358, 0.2325631984526091, 0.57600913759411, 0.3097509312533736, 0.7042017898665623, 0.22892972287660385, 0.7982411181148762, 0.40381283826114034, 0.7819228638177533, 0.8251857596977994, 0.194199839091581, 0.6919342621507738, 0.7390021495218841, 0.7867816114671534, 0.8009387777188319, 0.3701210704730763, 0.20508220416750966, 0.20172472971935518, 0.531823296830977, 0.19991648331081235, 0.16432877065505014, 0.15037523652137874, 0.44811883282020515, 0.42028586601736784, 0.1893699953848509, 0.1924715300990969, 0.19991549439253542, 0.19128721342734256, 0.21777218175959856, 0.17768502651396922, 0.18777441796244065, 0.18658436029011016, 0.18971531325599822, 0.0923365179128075, 0.08506981567880245, 0.09606795363122278, 0.09040157278201733, 0.0899552010290341, 0.08557783963591303, 0.10482693921393416, 0.09282415227886065, 0.07422261536079022]}, "mutation_prompt": null}
{"id": "4375a315-5b95-432d-96bd-1c27aaa6db45", "solution": "import numpy as np\n\nclass EnhancedHybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.tournament_size = 3\n        self.survival_pressure = 0.45\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def select_parents(self, eval_count):\n        dynamic_tournament_size = max(2, int(3 * (1 - eval_count / self.budget)))\n        indices = np.random.choice(self.population_size, dynamic_tournament_size, replace=False)\n        return indices[np.argmin(self.fitness[indices])]\n\n    def crossover(self, parent1, parent2, eval_count):\n        adaptive_crossover_rate = self.base_crossover_rate * (0.5 + 0.5 * (eval_count / self.budget))\n        mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, target_idx, best_idx, eval_count):\n        adaptive_mutation = self.mutation_factor * (1 - (eval_count / self.budget)**2)\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        beta = np.random.rand() * adaptive_mutation\n        mutant = self.population[a] + beta * (self.population[b] - self.population[c] + self.population[best_idx] - self.population[target_idx])\n        mutant = np.clip(mutant, -5, 5)\n        return mutant\n\n    def stochastic_ranking(self):\n        ranks = np.argsort(self.fitness)\n        for i in range(self.population_size):\n            if np.random.rand() < self.survival_pressure:\n                ranks[i] = i\n        return ranks\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.get_best_solution()\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness = np.empty_like(self.fitness)\n            \n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n            best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx, eval_count)\n                offspring = self.crossover(self.population[i], mutant, eval_count)\n\n                offspring_fitness = func(offspring)\n                eval_count += 1\n\n                if offspring_fitness < self.fitness[i]:\n                    new_population[i] = offspring\n                    new_fitness[i] = offspring_fitness\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness[i] = self.fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.fitness = new_fitness\n\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = best_individual\n            self.fitness[worst_idx] = best_fitness\n\n            if eval_count % 200 == 0:\n                self.mutation_factor = 0.8\n\n            if eval_count % 100 == 0:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n            # Apply stochastic ranking\n            ranked_indices = self.stochastic_ranking()\n            self.population = self.population[ranked_indices]\n            self.fitness = self.fitness[ranked_indices]\n\n        return self.get_best_solution()\n\n    def get_best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridGADE", "description": "Introduce stochastic ranking to balance exploration-exploitation trade-off by varying survival criteria based on rank and fitness.", "configspace": "", "generation": 99, "fitness": 0.09937737872094293, "feedback": "The algorithm EnhancedHybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.09.", "error": "", "parent_id": "94fceb1c-9dc1-4f13-a565-d6d5eb0c3e9b", "metadata": {"aucs": [0.1776393258481619, 0.13282194159271998, 0.1900238587285431, 0.16670363649780906, 0.14721806573242757, 0.19166579116897442, 0.8299826019184255, 0.18222026700545124, 0.18365849648199184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18203093883141497, 0.06965392093723388, 0.0618456416845754, 0.0406452722590257, 0.02968890819295744, 0.05168528192997346, 0.0575959099083857, 0.027000631442355205, 0.04981752857215538, 0.03654586445277841, 0.05467308941194382, 0.03530520046881702, 0.03945349562701883, 0.027375327264293814, 0.050229334788157054, 0.025895623575220794, 0.048948570967672134, 0.0691242027954535, 0.11868365095481803, 0.09441604955611671, 0.11938680823479919, 0.1125153894210762, 0.14752488619418513, 0.09856686218264221, 0.09591779365670572, 0.11739475339760141, 0.12679128966704245, 0.06274794416174423, 0.018242211707804046, 0.0692759229430765, 0.06042896184900892, 0.040370649925764335, 0.04127564687735252, 0.29274508053092707, 0.35721619646790626, 0.04578050169486869, 0.12721534845013172, 0.13759398923974553, 0.1554141118054413, 0.13360800797927386, 0.12061314303779291, 0.1550695752882757, 0.12706464926124916, 0.11024240817093689, 0.21991657605322867, 9.999999999998899e-05, 0.006085951957412128, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03378940050374435, 9.999999999998899e-05, 9.999999999998899e-05, 0.14883340053562166, 0.05213781700036668, 9.999999999998899e-05, 0.10745136151102885, 0.09335456765050965, 0.04279701684207471, 0.07248924216579322, 0.07587084492180607, 0.03503301064016995, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026321596227423805, 0.05778505769499043, 0.08932406774157409, 0.0393628803375663, 0.00997792454084101, 0.05470191585957984, 0.026577624455458526, 9.999999999998899e-05, 0.05239646946491283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019841917607166026, 9.999999999998899e-05, 0.0016169974617359362, 9.999999999998899e-05, 9.999999999998899e-05, 0.006836556940950866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22586070741419118, 0.20877758549998138, 0.22656342831328524, 0.25603663391040843, 0.21146754117019262, 0.22878532293951026, 0.20132571550736023, 0.1958956563162927, 0.23675725500321132, 0.030001019042314003, 0.03184123612500711, 0.04179063274712802, 0.06647531845739507, 0.054556489724175816, 0.06758735306925989, 0.03542213888757506, 0.027185647738791285, 0.04272760500292627, 0.11694639723199418, 0.1318542859663112, 0.12128356360943782, 0.14443426990395947, 0.15141180310742808, 0.15358451674837237, 0.14532574470028792, 0.1462941367998737, 0.144890037628581, 0.1545507927329145, 0.1476186343888387, 0.19802379311373175, 0.17702358883151081, 0.1830883176490271, 0.1677296329918625, 0.1793405868667185, 0.17377774300845283, 0.15370448363924116, 0.11074364506180268, 0.09440380564565276, 0.11706582806014243, 0.11937631480653965, 0.11835613810136458, 0.13228201154975305, 0.10814051969989669, 0.11212173194674757, 0.12611633258217103, 0.1741459717070456, 0.20998068418865545, 0.16944935478603562, 0.25733884750628033, 0.2272144369649597, 0.17201294567355963, 0.25683976422276533, 0.2281023480406804, 0.17839352858884971, 0.14986556130253814, 0.15836665999493527, 0.1643492573068741, 0.14326595374860185, 0.15268925194113347, 0.16726203729466216, 0.14507270710130138, 0.13825660138065976, 0.1589092095704484, 0.10997555405689396, 0.16930959472292328, 0.13524031682205118, 0.11833093159672647, 0.1227957555481155, 0.11699140244677086, 0.1739282954189577, 0.13709739844418678, 0.16681294884277997, 0.11244464561419532, 0.14130870078968272, 0.10659496661307455, 0.11522548631899665, 0.10153665218891306, 0.1318928099959179, 0.11753109624147595, 0.1769333016749075, 0.09355458454875953, 0.1610600453618245, 0.1871557732241056, 0.1842304374274195, 0.18036330594384165, 0.18161595966087074, 0.17469284133790552, 0.18745962757104884, 0.1887976406411187, 0.16833655157670113, 0.05425716110094525, 0.05448287629269366, 0.062469454292250925, 0.053224703968677956, 0.04315707045777184, 0.05677648677588931, 0.0665483899995476, 0.06270247995022893, 0.058364732839716105]}, "mutation_prompt": null}
