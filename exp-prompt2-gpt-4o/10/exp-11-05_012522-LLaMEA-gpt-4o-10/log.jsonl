{"id": "760d8511-16ae-4534-91ec-9d00188ed38d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.3256685061243838, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "58f38630-a0fb-4ec1-ae1e-eb6c07f31d32", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "0a0a4d36-ecbe-4d3d-a42d-0c2662254d48", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "d15c672d-81df-4364-948c-4e9e6887a708", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "7222e7f4-f33a-4e53-8d3c-b51f4c1450fe", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "b275cb4f-9378-42a3-aae8-87d2b9541617", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "a7bda29b-1d8e-4aa9-8f84-d325848b3b81", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "812d4c72-6d98-4465-80a4-cb6a9b1e7e31", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "c09e1fa9-88a4-47f6-b296-8997b182efe4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f75faad0-5536-4594-b1a7-c9667d9b8345", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "9c733182-bb02-4dcc-bf97-1003aea8062e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "be279277-a294-4a0d-9e49-5e634ef62480", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            adaptive_F = self.F + np.random.uniform(-0.1, 0.1)  # Adaptive parameter adjustment\n            mutant = np.clip(a + adaptive_F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            adaptive_w = self.w * (1 - (current_eval / self.budget))  # Adaptive inertia weight\n            self.velocities[i] = (adaptive_w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Incremental refinement of HybridDEPSO by introducing adaptive parameter control to improve convergence efficiency.", "configspace": "", "generation": 11, "fitness": 0.31342855023617605, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9359966332311772, 0.9255223273581092, 0.9289197653140377, 0.9281627776948962, 0.9294977301663241, 0.9326748590821324, 0.9289709773029472, 0.9301849742857536, 0.9271163669250503, 0.8676640141049388, 0.8598882783819147, 0.8431152191170503, 0.8659326156336803, 0.847523991744511, 0.8728140665893893, 0.8605245814784862, 0.843482220783458, 0.8571344331665139, 0.16247287801076093, 0.1125367186805819, 0.09705514079252153, 0.14471367116890177, 0.10707511878911735, 0.8511241930366681, 0.11167862562660869, 0.08963398293442482, 0.06276817687753355, 0.11249814920068324, 0.07516486948513268, 0.10532825539803237, 0.07984162170842102, 0.09627507494003873, 0.08927248348201844, 0.11787794661324968, 0.08568606898537978, 0.11276709234499704, 0.9700424452035675, 0.968467709639327, 0.9426839191464449, 0.9566163342460058, 0.9727570120289187, 0.9763053897603272, 0.9434830237936804, 0.9627094641334186, 0.9848230310120601, 0.8656793545220491, 0.8365526105377585, 0.8048754887547384, 0.1521499028373542, 0.6163860299518685, 0.8571270008478664, 0.7995382040068331, 0.08599085310768928, 0.05010677748322323, 0.14048607464895535, 0.11940363731511172, 0.39900010509351547, 0.2801033966563008, 0.9305975513038843, 0.2787087346312703, 0.17826877974839284, 0.4021848805799695, 0.23600670817665337, 0.11639633766931778, 0.16018195112034117, 0.20563084275713095, 0.12820694653829956, 0.2936965177490567, 0.13330447312341143, 0.19971751416902717, 0.3274325728715133, 0.1856518443661045, 0.21971262595388263, 0.201737309606834, 0.234674601547198, 0.20186465301552403, 0.21046573649047084, 0.13660544043852407, 0.13654943621874882, 0.2764404079445668, 0.25269146084691296, 0.0786704206803317, 0.011172119504681888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0666614813856502, 0.09065342264375287, 0.02871866940464185, 0.10066688021461179, 0.12446039421682742, 0.011446364907356066, 0.057168586796371934, 0.06648663301421642, 0.0736034913263155, 0.033195993837995985, 0.1359830615067853, 0.1163987852273618, 0.038022554122483454, 0.12810658697847244, 0.23604348251951102, 0.08243311626106664, 0.0835735359779739, 0.3063552967921611, 0.21705159829579346, 0.19577118093000523, 0.05190283280087915, 0.02180358185111486, 0.19376086074836174, 0.03975029913056971, 0.03990916457549998, 0.08386553544289055, 0.08317306595554341, 0.05866031479190137, 0.5923303251876353, 0.5548412948030519, 0.583991377509461, 0.6076680294741312, 0.5592422304451362, 0.6168927244967832, 0.5942618132029354, 0.5996792127833899, 0.6269829252771904, 0.07663065619613496, 0.07938946841820893, 0.10951342526776298, 0.11866496595790121, 0.11753073158991156, 0.1162454461585195, 0.14504244430508495, 0.11179518587035842, 0.14478839843630742, 0.2150002923447455, 0.2729915022565259, 0.34611116049841095, 0.27672980765191213, 0.25179792209192575, 0.23714799227854566, 0.17936667463289468, 0.16284531226953536, 0.17510047549558216, 0.28001190420808864, 0.505589951359631, 0.34653722075783333, 0.4656261893775201, 0.2583099208664176, 0.4855499303919455, 0.42649429801131655, 0.472258640315797, 0.5894770090368626, 0.23532357280917882, 0.22618244454873504, 0.13600062785400147, 0.19855178526621975, 0.20624524086077467, 0.19108912714700665, 0.2349345664381819, 0.23592372388179528, 0.20312275143883562, 0.21148745125304347, 0.24745670838809952, 0.21994281972056684, 0.2192409543380981, 0.23628872981855853, 0.21181430753253971, 0.19699488340126148, 0.2555608996869533, 0.23956522217105602, 0.21232994100330016, 0.21247910597855812, 0.2557814494856714, 0.2010383451591632, 0.21261768115048274, 0.22723785512452355, 0.18586241682069926, 0.20994089038505503, 0.20969563481568676, 0.14870803700985036, 0.15903942803241622, 0.21408596248624512, 0.1705897308502472, 0.16966483943461486, 0.1585492897540175, 0.13683928922557131, 0.13693728281574058, 0.9330326240512246, 0.5850145077642872, 0.2126665249696581, 0.21115897172749287, 0.4493154416705377, 0.1693278160985836, 0.10815396629047014, 0.8471030999254598, 0.15672590217538596, 0.16929101932306057, 0.20570824039526336, 0.19875279314190253, 0.191853799256949, 0.19096260175664614, 0.1890915144926194, 0.18531954570776943, 0.177608695942293, 0.2013928096235511, 0.18220952160252823, 0.10106550280448223, 0.08005798393735353, 0.07744758589717804, 0.08125196688859282, 0.09186720655692315, 0.09536968226349873, 0.09016619265443748, 0.10582225035760673, 0.09628892455552118]}, "mutation_prompt": null}
{"id": "8179d3de-c01f-4c2a-8f42-a7b46672865f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "11fd50fa-e02b-4c38-bf60-ccfe97cbe07b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "c1449a8f-bb24-432b-815f-4e4f50ede990", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "1159baf4-91f4-4ef7-a4ca-8cdc4014d4a0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "b6378b76-2cf2-4da9-8f53-289c65a4b634", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "538b066e-96ab-4264-b58e-2723c6a68273", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "2bd702d4-8e2d-49a0-baca-298181dde323", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "45a33a11-cdc1-47a9-bf27-a3494dd8f435", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "ade669cb-e782-4a44-92ec-5304f3fa7c65", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F_base = 0.8  # Differential evolution base parameter\n        self.CR_base = 0.9  # Crossover base probability\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        F = self.F_base * (1 - current_eval / self.budget)\n        CR = self.CR_base * (1 - current_eval / self.budget)\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.where(np.random.rand(self.dim) < CR, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            w = self.w_max - (self.w_max - self.w_min) * (current_eval / self.budget)\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Introduce adaptive parameters for more dynamic exploration-exploitation balance in the HybridDEPSO algorithm.", "configspace": "", "generation": 20, "fitness": 0.290681635096694, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.7771192764307462, 0.782817268049568, 0.7778977225975411, 0.7926462072443501, 0.7790418354366333, 0.7790890146373632, 0.7593887567332962, 0.7725143008141482, 0.786643614394424, 0.5770991032740165, 0.06730879605999018, 9.999999999998899e-05, 0.5766804673853737, 0.5824003890741936, 0.5390976308462301, 0.5861360646428303, 0.5554486967440608, 0.5823722309902938, 0.12751413871989503, 0.10968572814799826, 0.4866395553121544, 0.11573478869690768, 0.12883768427915876, 0.11729096905046787, 0.4093807334277314, 0.16953350511953158, 0.1379840408299029, 0.12617531942895255, 0.11395424910179985, 0.1288307134864617, 0.11387624022029286, 0.11133990731451227, 0.12558374819644835, 0.1387487497438762, 0.16314103698955318, 0.10141782903057062, 0.9765961185325123, 0.9747711893933603, 0.9806772595030301, 0.9772595477096431, 0.9804932014760751, 0.9752845046099374, 0.986497026435613, 0.9752173904272906, 0.9876674072115856, 0.5912200825871496, 0.05979157882596797, 0.6075441125200844, 0.6137927590534157, 0.6104381151108504, 0.6248245140776721, 0.5738176219763103, 0.6018066325444471, 0.6146774601620923, 0.22436882793284163, 0.22555998734341431, 0.22803717074371532, 0.1943223230687119, 0.2034469160276291, 0.26661173788717574, 0.3544062133468958, 0.23461636818677745, 0.7122588895997259, 0.20612738590608504, 0.20952872367839104, 0.22997064272789636, 0.20518439436788494, 0.2035084746129211, 0.21066728959556869, 0.2157623623117586, 0.2008140638824456, 0.18883767695508857, 0.20502574701450305, 0.20554782322796716, 0.20954839858382368, 0.27205971161754683, 0.19470810596527355, 0.20795303297368617, 0.12869463320752217, 0.23347083913863298, 0.28538815982923815, 0.007561906347559266, 0.04819777663794722, 0.08377213758579471, 0.0004359834121845374, 9.999999999998899e-05, 9.999999999998899e-05, 0.06390221588772671, 0.0712207544702349, 0.00332054972478113, 0.04726290364177854, 0.09043674988482509, 0.08551262073411048, 0.006587140263825342, 0.04236250693645538, 0.09741372997379927, 0.0800947149076614, 0.11395901670418751, 0.0672306421723815, 0.05200507925934106, 0.07857731055011241, 0.02880608950398378, 0.12477212254095216, 0.21372584334954958, 0.08176016156794685, 0.11535943449560215, 0.07300868219537293, 0.0970392906515184, 0.17993104471995225, 0.18939270196402636, 0.2010663852785476, 9.999999999998899e-05, 0.09197054314563335, 0.10716923805569445, 0.275165686649393, 0.22009366186509616, 0.07909584045611773, 0.5429913111442355, 0.4891942036399105, 0.49795223628925667, 0.5548997893974168, 0.49401328344089046, 0.5461742289815861, 0.5190766760507509, 0.524179745958222, 0.5354766812597054, 0.12050213109678076, 0.13124902285258955, 0.08479013469282703, 0.14265084642161951, 0.14784607228132485, 0.12335745040176826, 0.12380097150948166, 0.10657010006797407, 0.10990353648249418, 0.23052861818170478, 0.18265679582462835, 0.2854863747897731, 0.17305259649266536, 0.20360450040876865, 0.2954977188933221, 0.38009924407875717, 0.27645644220508103, 0.22166539641389293, 0.4028797215840211, 0.29412991522830767, 0.3581522569150287, 0.23084120213700998, 0.20270569961164542, 0.42193630958149164, 0.4359461523012824, 0.34895982712663853, 0.3930494663621801, 0.20997393459139702, 0.2824365939882034, 0.3119694884030224, 0.2148814301279791, 0.22152288244351181, 0.23131640494064254, 0.2641239460746786, 0.25127974339068004, 0.3372407779406539, 0.23991424525449867, 0.21095968261083986, 0.22644012979737815, 0.2433806589781452, 0.20990079836187092, 0.20139226668037213, 0.23503652548486753, 0.2579608350999196, 0.22544009887532301, 0.23746274283884306, 0.20119042087504624, 0.1957628774788801, 0.2371671804714579, 0.24045105427586866, 0.2158483993218978, 0.21686249162132532, 0.23736720956343327, 0.22236790963805475, 0.19709477466042968, 0.18763025659480448, 0.15429487965872035, 0.16859463580672185, 0.18770384226058867, 0.15161033406792446, 0.17582016668907852, 0.8416320994162456, 0.14732044990634663, 0.1267371392640262, 0.1275688425514161, 0.11000165734283995, 0.7873816354903425, 0.16856778037225195, 0.8160485807185485, 0.09447969901923503, 0.7491492108406854, 0.16870593792031974, 0.190625831564032, 0.19617445550310264, 0.17058644074380902, 0.2026557072108497, 0.19466908926907833, 0.19608545793374277, 0.19184011929480616, 0.19710118761603113, 0.18633562471187193, 0.12663223219409925, 0.09971874587189777, 0.08977793276401425, 0.08944104986493318, 0.10529704136053664, 0.10503810042650452, 0.09783777379091785, 0.0899645055543229, 0.09839937352147421]}, "mutation_prompt": null}
{"id": "7f585c10-7742-4746-bcd6-5b297daf04de", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "6b5f9f26-facb-44d3-9bbe-a9c271b80bf5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f3925b68-75fc-4a5f-8994-7a5d768e2052", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f706cb40-e4f1-4b7e-9acb-94dfbcfaacc1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f6d99f6d-58e4-4eb3-88bb-3ea6e2c1ea1f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "2161be66-f3c5-4dde-adc0-6cf7ccece43f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "824c58bb-9be8-417c-a1e3-5fbee601e60c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "b4ae92cd-2d07-4945-92d4-3f50d945f694", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        diversity = np.std(self.populations, axis=0).mean()  # Check population diversity\n        if diversity < 0.1:  # Adapt F if diversity is low\n            self.F = np.random.uniform(0.5, 1.0)\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Optimized HybridDEPSO with adaptive parameters and diversity checks to enhance convergence and prevent premature stagnation.", "configspace": "", "generation": 28, "fitness": 0.3238368286529923, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9282599084085916, 0.922664820741283, 0.927569483228387, 0.931129584143216, 0.9212247128126007, 0.9307533837701473, 0.9258584795829148, 0.9201921451009252, 0.909970235031819, 0.8489566729116345, 0.8391070619645589, 0.8283271907045519, 0.8275822259944343, 0.8434700318163921, 0.8519454326065998, 0.8323615161056181, 0.058640040770834956, 0.8378949804897105, 0.10641697322958932, 0.1329212363199327, 0.18934752940172117, 0.10429206400130375, 0.11131877214607155, 0.1332717427359692, 0.11795759987018906, 0.18839102635716953, 0.14760446486997203, 0.10898502741247629, 0.1449063267609505, 0.13314671826121594, 0.0926651041497546, 0.1361241330654097, 0.11816348041558067, 0.07171328532507448, 0.06580605430037267, 0.08561382622335145, 0.967011577142136, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8156367483113203, 0.796953734825796, 0.8140072532001814, 0.8451505273793336, 0.8396896858696181, 0.7927571477756584, 0.8435687164396861, 0.7842507857385027, 0.8219700668206619, 0.15992726009559122, 0.22902586485663035, 0.24388927073779676, 0.2807531549355563, 0.20753726336187184, 0.2797984036828747, 0.2252458462516247, 0.2347888285651949, 0.17885496573740678, 0.25053039425288026, 0.2715365307001105, 0.2583341833077597, 0.29036334497240335, 0.26355346390730006, 0.2891954281034915, 0.2450009786238454, 0.2608796272836287, 0.2209126099607739, 0.42534448756945953, 0.2437582463610254, 0.2572153196899728, 0.13597086446978102, 0.13217384139567057, 0.28590392896336103, 0.288697438267732, 0.28152409768279263, 0.28447643014853674, 0.015942411704333193, 0.001955566933898978, 0.004770129889595465, 0.0006197129653091604, 0.09213435656908675, 0.0015792339751451445, 0.042918616273751486, 0.010681335265337988, 0.07687918823547024, 0.09730780658507043, 0.11138586261485162, 0.0973256016798898, 0.0468255996482827, 0.040199243819752484, 0.12673123553300192, 0.07440546038463058, 0.07173372142705758, 0.01532134639442262, 0.15499400613731162, 0.052652707533701326, 0.038784031380888484, 0.22667114685515855, 0.09948674683786807, 0.11474180858707494, 0.20125548843472885, 0.11445413579981323, 0.139373407066941, 0.15923384116962702, 0.11613786831775363, 0.08909183572528712, 0.1316455302818682, 0.172026395997532, 0.1014718798801949, 0.049863425599294575, 0.17918336362824572, 0.08405415193516586, 0.5940501714900805, 0.5727250062186848, 0.5583393521574315, 0.5660556011103751, 0.5863948278163132, 0.5902766963193925, 0.6082202908359906, 0.603708505629603, 0.5947127354539349, 0.14472223263092487, 0.1246455993940413, 0.08805098595596117, 0.12190618806809383, 0.09614781028810016, 0.09817481006173256, 0.11699777401850897, 0.09544933885647133, 0.08003465558511558, 0.30726669718632416, 0.22381199261404683, 0.4213905834586201, 0.21972291230711372, 0.25277013942177684, 0.2848424853616417, 0.17569877877971363, 0.2765178736920454, 0.3519117070273109, 0.2047245486096384, 0.3159276001506549, 0.26154921245545604, 0.20129969307610485, 0.27214541911835044, 0.6646177011393947, 0.37055682945739643, 0.24946823773459004, 0.2237782193789678, 0.26199821887139196, 0.18449674381849723, 0.3549057476290691, 0.30261494778055276, 0.1538680155582659, 0.23196019131480083, 0.1990217488758067, 0.3629458770465923, 0.24548719771881244, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.2366811114994003, 0.22471452421278593, 0.20313447243521643, 0.27814178828288094, 0.18831832461357534, 0.19351553661845577, 0.1892771885694975, 0.18719165385225667, 0.2005057038563326, 0.1791028353068228, 0.18860029385538113, 0.22720713846454577, 0.2040175462802748, 0.1723698699351125, 0.18777640984787036, 0.15445108722606382, 0.9159297291353405, 0.18877820468177609, 0.14834662840769164, 0.1631329020683081, 0.9431318893973809, 0.17715669584383598, 0.12750558919705612, 0.12852042491214033, 0.11013994524582449, 0.8742179445330076, 0.1696208929458367, 0.7596699688315665, 0.09484947309355485, 0.21173263926606656, 0.8834060920685518, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.08922906684465992, 0.09676535914821693, 0.08532077483295797, 0.09533365089449086, 0.08561679322792537, 0.09769992017753071, 0.09292768100178705, 0.0967436556478255, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "ed3a05dd-a1e6-4711-bb7e-e678cf903d5c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "42695320-4d24-44c1-a2f4-40f4c4f4dadb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "640860cb-813a-47c2-ae2b-948b5834c434", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f43d60d4-b07e-4467-aeba-b7e0b72ddcae", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "8750ff3b-4a6e-41c8-b558-6706446c88a4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "ce9ff62e-ef5e-4f2f-bc08-f62f294778eb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "f95b255e-aeb7-40e1-a3cd-6c2efbde273b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm leveraging Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9276713590282591, 0.9244462531088892, 0.9240867890219917, 0.9226908313430616, 0.9191219669150479, 0.9349769866110155, 0.9200753586523764, 0.9199696077735162, 0.9136722155092389, 0.8468243899343771, 0.8433858300063575, 0.822253466680428, 0.834361177531413, 0.8402144383012068, 0.837172178134311, 0.8206737481785613, 0.0586986604945503, 0.8293396459061279, 0.10642106688951558, 0.12457122078771754, 0.18934675239430276, 0.10428215517236805, 0.11132055812628283, 0.13327010153409358, 0.1179570835085193, 0.18838912354037507, 0.14760471784117057, 0.10897440427344085, 0.1449534732733715, 0.13314325760775414, 0.09266507394233559, 0.13612360041960003, 0.11816768871236927, 0.07170609910806325, 0.06578903553928539, 0.08561476823287661, 0.9670234858400754, 0.9678948580174127, 0.9663004783058734, 0.9716114634268519, 0.9717406781237552, 0.9659040796788948, 0.9806757327389053, 0.9736802321197762, 0.9812073958464728, 0.8137515060751219, 0.785697690007888, 0.8257787086473267, 0.8181080008007431, 0.8207983004875097, 0.8235778870525288, 0.8354937530428483, 0.8272903788728471, 0.8279816998333165, 0.14095617393444337, 0.22902586485663035, 0.2436011757653016, 0.2812667238236226, 0.20751489526509537, 0.2804973078171895, 0.22492173357234424, 0.23478961363245376, 0.17885496573740678, 0.2729723803372498, 0.31261354888175497, 0.25241801677269704, 0.310975844618231, 0.2672791480435075, 0.3292272962526024, 0.25522059648140627, 0.2678563635683432, 0.24048900769181936, 0.4045363269045642, 0.2344025668533536, 0.25948575219708936, 0.1358181767527158, 0.1322819842099907, 0.29705932092461906, 0.298729223873876, 0.30231869072841966, 0.30433862290120417, 0.03686010990895228, 0.008676019520795109, 0.014202898495272342, 0.002541005781325434, 0.09524694214513074, 0.003728230421818468, 0.03888313962199952, 0.012395099188151293, 0.07937379826775326, 0.09762946482439328, 0.11138586261485162, 0.1200696514416082, 0.04661161766161004, 0.03919909124444787, 0.1320448950196318, 0.07266973491519091, 0.07173372142705758, 0.012073653246400529, 0.15530958559507124, 0.05217334143563179, 0.037343134024304336, 0.21746698641439244, 0.09898253721682593, 0.11518631426645498, 0.1915684061800068, 0.1116550911334574, 0.13196722983042442, 0.15961652244051816, 0.11954801042386731, 0.09541122654116607, 0.1328048769454856, 0.17069686843622967, 0.12259792950504456, 0.04988024581034112, 0.18496584955073558, 0.0841719245496122, 0.5563053307611728, 0.5665664829313602, 0.5500431273035162, 0.5637786935394382, 0.6409266677097673, 0.623357477354324, 0.6018115965164674, 0.6068789235043037, 0.6214960908024743, 0.14471807535115822, 0.12464634212320436, 0.08804336943532565, 0.10071536614033472, 0.09614474498016934, 0.09817509588333073, 0.11699728885494864, 0.09544388683282068, 0.08003472592448069, 0.3029405594599346, 0.22548776695001993, 0.31319294341217363, 0.22041496928661053, 0.2578766758678559, 0.26243524115248806, 0.18167120338261034, 0.27709890567021234, 0.3564178428513065, 0.20177900550759098, 0.3142419527070408, 0.26252003335608143, 0.20161990812133956, 0.2666309427084361, 0.6766954554921272, 0.4318302635202286, 0.252834619599431, 0.25052816700697556, 0.2644451356526961, 0.18522521962903837, 0.3832226487403587, 0.2809724056866958, 0.1634432044289531, 0.23565500034307785, 0.19367161637884212, 0.4273245394554053, 0.25602284891594995, 0.2259716377801666, 0.20745970607917785, 0.21776039941124103, 0.24301936111363243, 0.23178579198685656, 0.23668007295451243, 0.22471452421278593, 0.20313447243521643, 0.27813834005719884, 0.18831811754436267, 0.1935158359606095, 0.18926672036682046, 0.2094062149366005, 0.20050494596818458, 0.1791016466534726, 0.18859923335059592, 0.22722144958485724, 0.20400982297861137, 0.172369686332269, 0.1877747617394825, 0.1544502244599849, 0.9144518376287656, 0.1887782003611166, 0.14834711074365592, 0.1631326804478418, 0.942862509493579, 0.17715488199957907, 0.127507822871202, 0.12852012357130138, 0.11013970925917815, 0.882570077046867, 0.16962099767664263, 0.8022610431238739, 0.0948490960712064, 0.2117320097500366, 0.8840618472827707, 0.20623790154147814, 0.19633155695769566, 0.20206313248109808, 0.21574436774112815, 0.19646176145379035, 0.19372905867213341, 0.1987188730650561, 0.19951387398649179, 0.20440806563767833, 0.0892271679626716, 0.09676535914821693, 0.08532146829436182, 0.09532370691782222, 0.08561663894645188, 0.09769997426996702, 0.09295496888734056, 0.09696893537933537, 0.08926148566163228]}, "mutation_prompt": null}
{"id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 36, "fitness": 0.34826998711388507, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.31.", "error": "", "parent_id": "760d8511-16ae-4534-91ec-9d00188ed38d", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "5a774c36-27ec-45ab-bd89-90848bd1ea51", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "8e4a30d6-8d11-4dde-beeb-d19107661c50", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.w = 0.9 - 0.4 * (self.budget - current_eval) / self.budget\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def random_restart(self):\n        worst_idx = np.argmax(self.personal_best_scores)\n        self.populations[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.velocities[worst_idx] = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, self.dim)\n        self.personal_best_scores[worst_idx] = np.inf\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n            if np.random.rand() < 0.1:  # Random restart with 10% probability\n                self.random_restart()\n\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "EnhancedHybridDEPSO", "description": "Integrate a random restart mechanism with adaptive inertia weight and crossover to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 38, "fitness": 0.33130541753534914, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9268523261593258, 0.9197637254809059, 0.9196447243119679, 0.9236786954616804, 0.9196942037014015, 0.9189681064574755, 0.9177114412176869, 0.9104284764513528, 0.9066908007587482, 0.8232961989065861, 0.8243287971694269, 0.8152787250230544, 0.8134816671297842, 0.8303458352295604, 0.8425202870455891, 0.7726106386481871, 0.8109507381865654, 0.8330639598490553, 0.16786451528646884, 0.134230672447611, 0.16888916297518353, 0.11322612105151875, 0.10750631198642935, 0.12771744488847703, 0.12357565307198726, 0.12956531691104778, 0.16148319829211555, 0.14642331775358775, 0.11067883749874163, 0.10905462779234709, 0.118721434961237, 0.11092683135115222, 0.11607261277762604, 0.07189521462303694, 0.12432969257369064, 0.11794263235916147, 0.970465448785618, 0.9634168997761445, 0.963026995547372, 0.9669549427536248, 0.9821566256043407, 0.9562071854943658, 0.9683127458731293, 0.9809663178860896, 0.9650097233027864, 0.7732892948986608, 0.7747366189478679, 0.7922691437174804, 0.8154802317508593, 0.790172499371308, 0.8022625479983221, 0.8288527738648679, 0.6536647035302185, 0.8223867418265014, 0.2443994295410883, 0.2095453851830641, 0.171460706532095, 0.2831424507385514, 0.21423668417585207, 0.16148699376197784, 0.1316971674834877, 0.6575692385836711, 0.5772577200389033, 0.13018797974726581, 0.25131171923771967, 0.3207769710169758, 0.2585351656613123, 0.23695734335392027, 0.1341239545592804, 0.2656970276788787, 0.2684752930921911, 0.25554307887767824, 0.2580126210510576, 0.2512137546844744, 0.25558388819931754, 0.27810188756355625, 0.13522435109151631, 0.13543851127546802, 0.135051883820402, 0.2979699731402773, 0.26176000816468026, 0.04393803525794704, 0.05468368271770707, 0.0015985893962197073, 0.11944265547914346, 0.011913921366083935, 0.01220750491272915, 0.0815011500406837, 0.047356557906993446, 0.0012700813002407552, 0.12838681835401822, 0.1646766644112606, 0.0937579659646075, 0.08377582749068602, 0.027638013365370306, 0.0923416321373135, 0.1158911767465497, 0.10781590155558884, 0.06510748728691229, 0.16002328154893963, 0.05246971619357488, 0.052309502702311494, 0.1840464680301055, 0.08157408040659098, 0.20659823518307785, 0.1790669323512628, 0.10574079880877885, 0.07738035890344164, 0.10845580341067029, 0.09573646577704198, 0.09198580538198164, 0.1791464480842767, 0.17385947600731155, 0.14110440791522194, 0.12883100291591143, 0.11249465394472768, 0.19164444191954566, 0.5593104440422813, 0.5668927176924916, 0.5472801356531797, 0.6102989652541512, 0.585300207667254, 0.5871064890506921, 0.5875022386366919, 0.598070056955893, 0.6046315501931399, 0.12241468532795696, 0.11748233409913722, 0.12064395163779296, 0.14642716908124986, 0.06844487617929973, 0.14303598501020642, 0.11757592387171933, 0.09265804706539604, 0.1302481244405721, 0.16527373236644793, 0.20339126865004686, 0.5363771968498379, 0.2683855182761906, 0.32662697711053046, 0.21514408613876157, 0.20350576960041467, 0.18114984571963755, 0.16122704636828744, 0.4698732938040501, 0.4165563882904888, 0.5306087575828717, 0.6270005445622342, 0.5447213982103453, 0.4183580447388172, 0.3868022457042388, 0.6460116687995319, 0.4469099284880673, 0.11563150905664354, 0.38575847174183575, 0.22950910892205867, 0.14009692456202538, 0.2441114195462214, 0.1744949682764465, 0.15978738244458723, 0.3042834290363513, 0.3343316466261641, 0.224637369789637, 0.2460466111281716, 0.22534670011478353, 0.22241842393400435, 0.2006880509478699, 0.24786541859372768, 0.24817420318832017, 0.21603953038335355, 0.2168280626735959, 0.188355926230939, 0.2538206496420933, 0.19344706832184122, 0.1842126250404491, 0.1899343325487851, 0.19154775063483487, 0.18917995865173776, 0.18193319343719538, 0.1994422640651755, 0.17876718089516586, 0.16796925113673333, 0.17224241853580002, 0.17286214176837333, 0.169462325651344, 0.9359592973732718, 0.9266558048801314, 0.12291049547622879, 0.10835574542819537, 0.6249285218401166, 0.7988063709253588, 0.15584587762601187, 0.1047035752534986, 0.12816603902052426, 0.16913823141480244, 0.2138360682364706, 0.15671336228388844, 0.5913266301769302, 0.2414481636676038, 0.19718674209455667, 0.18845281295416894, 0.20496141601364193, 0.20339043581089022, 0.19439083374503763, 0.19831728129442072, 0.20553780566885027, 0.18641661874877513, 0.11748556306011415, 0.09791103086252173, 0.08506807070234335, 0.07721899037030422, 0.10194904841191421, 0.09847086029956187, 0.09059339236723607, 0.08836202877229493, 0.10941202206075318]}, "mutation_prompt": null}
{"id": "384eac08-561d-491a-b65f-213639683b6a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "02da7443-7363-4066-80ee-845a2c6c3bfa", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "90729af4-c318-432a-ad3a-721f31f83fac", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "77ccc0c3-3c71-487e-8716-7b2f1fe297c8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        diversity = np.std(self.personal_best_scores)  # Measure fitness diversity\n        if diversity < 1e-5:  # Adjust population size based on diversity\n            self.population_size = max(10, self.population_size // 2)\n        else:\n            self.population_size = min(20, self.population_size * 2)\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with dynamic population size adjustment based on fitness diversity to improve convergence.", "configspace": "", "generation": 42, "fitness": 0.34739605402857743, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.31.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9307492342515693, 0.9329504562304654, 0.9267762707654655, 0.9269918153890768, 0.9224080065320709, 0.9361535800883228, 0.9293844893189225, 0.9218845916183597, 0.9154595650002427, 0.8393983002032988, 0.8330268673711181, 0.8448848956235384, 0.8493499607523102, 0.8592278986283767, 0.856532579168253, 0.8559802271270988, 0.8527820415353753, 0.8336429872805615, 0.07806135548708848, 0.1603937324016279, 0.1473686522483313, 0.796624024727442, 0.14789726916443902, 0.1261653643864683, 0.12738937348331203, 0.1612990305592813, 0.10248375332890425, 0.12625840060890003, 0.11781702482455347, 0.11205713150657193, 0.09694965658414167, 0.10101402404519977, 0.1331743680789076, 0.11390599566833137, 0.09682098663840621, 0.1433328321072579, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.816282566246845, 0.8173576329443084, 0.8299065372070218, 0.7199608915433192, 0.8272203251546377, 0.824439568355775, 0.8263487429989405, 0.8224292209876511, 0.8115533644666302, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2871674141237345, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.16623176053804856, 0.17155588105713593, 0.19377231103645354, 0.11794448938354563, 0.11141524946447223, 0.15759326452146838, 0.1964550649940633, 0.04337022091324161, 0.1657870893358533, 0.08138260306140854, 0.20535365087191615, 0.16630438655391422, 0.21187904720313577, 0.10936185546796728, 0.6001274210943401, 0.591398807239377, 0.5731656870666633, 0.5808660595741622, 0.590517406887872, 0.18270576213251577, 0.5852477116270646, 0.6407713518085149, 0.6344845045393289, 0.07655743858456221, 0.08398713595405549, 0.11141028113364371, 0.12622705627930186, 0.08266542770016272, 0.1611707198822876, 0.0962304840201672, 0.1610445873047327, 0.11682004870476737, 0.21454449541237386, 0.2660992786798173, 0.274167152462914, 0.20227085241910425, 0.26435678809126206, 0.2554956799226148, 0.26736400115635506, 0.24671201625244765, 0.17272020691983248, 0.48329318418002853, 0.26015102137419976, 0.28966091623558043, 0.3990846974061748, 0.34505418247596886, 0.30837322225690345, 0.4874258302114436, 0.41463563897205724, 0.22171234659907357, 0.17439774753322612, 0.2909968523684211, 0.23467298237180967, 0.1714597578100906, 0.22868862595381656, 0.24066527867708487, 0.15003307275895716, 0.2910833159238224, 0.3247385365644814, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.20902485986595798, 0.872174502051621, 0.18539732859318814, 0.1841936854616394, 0.20969494421813328, 0.19410188271014484, 0.210056214797114, 0.21014164138269265, 0.20001593278438723, 0.17875148349340364, 0.19888762226798695, 0.17087497584878142, 0.17302814023784907, 0.1698020321204473, 0.9455749752144912, 0.9318211725067301, 0.939015658403769, 0.10825865673686641, 0.2126146771962112, 0.7719986196537805, 0.7708296589316622, 0.20880828301225363, 0.1282922953003639, 0.9318156840645533, 0.10490500297543004, 0.15677262201712072, 0.12836049093501, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159653532342, 0.09305940233370369, 0.09455552177043758, 0.1358212334257205, 0.09847368771857712, 0.10075110007831933, 0.10517386121998062, 0.09985930374806795, 0.09472453207503262]}, "mutation_prompt": null}
{"id": "69a4d83f-223c-4451-b922-17117a424bf7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "21dd740a-9c9e-48c7-acb3-0af88749f422", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_max = 0.9  # Maximum inertia weight for PSO\n        self.w_min = 0.4  # Minimum inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n    \n    def update_inertia_weight(self, current_eval):\n        self.w = self.w_max - ((self.w_max - self.w_min) * (current_eval / self.budget))\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            self.update_inertia_weight(current_eval)\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n    \n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced Adaptive HybridDEPSO with dynamic adjustment of inertia weight and population diversity maintenance to improve exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.30688675047980746, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7721672265779254, 0.7755438958792221, 0.7656757002154669, 0.7788313886743142, 0.18968639844076474, 0.7873781544630033, 0.7669066427113893, 0.7761915659898326, 0.7658653850773527, 0.5884059944286715, 0.5603972489392084, 0.5660794844641622, 0.5490550359979061, 0.505362740090438, 0.5520306892354847, 0.5451528865246902, 0.5361227275921181, 0.5690118270570257, 0.14688035653720888, 0.14062783479248464, 0.17243697659510404, 0.13228636178606812, 0.17092485822681303, 0.15593846510884346, 0.12820304490137513, 0.17552398973283578, 0.1235111217430529, 0.13677871721354895, 0.13866205529468845, 0.13345367732297286, 0.1112761831085034, 0.10771426861429645, 0.10675381390114613, 0.10764471933012465, 0.1261924810760624, 0.11168024698264611, 0.9734063814047696, 0.9729111496193619, 0.9627978327160303, 0.9707634721215408, 0.9839463164761837, 0.9818076451905209, 0.9711397521703365, 0.985310451154208, 0.9806538825417721, 0.5833444005636843, 0.05930769620764276, 0.6198275989246635, 0.6013354186347333, 0.6083613004454853, 0.5616306125161863, 0.5862903848370087, 0.08863553829912818, 0.5498904899275723, 0.22453533575369755, 0.3795174313929647, 0.6427058925580151, 0.36688672200147865, 0.21249212784473648, 0.26743193088924233, 0.23068410897946, 0.7853619517931992, 0.8226109057427531, 0.205776835604631, 0.22222828537558503, 0.22160552655017574, 0.13246910344865004, 0.2166453048365774, 0.10466464166404854, 0.19882783882288513, 0.2066722342194356, 0.1984666506588092, 0.2213475042162204, 0.22779182711598733, 0.13179267855417898, 0.2384070458176626, 0.2301241085097807, 0.21580466281348376, 0.2279444538348534, 0.24593129589037876, 0.2383651183558534, 0.05340801557555552, 0.05948344499256686, 0.06226884331721194, 0.03326699908329267, 0.15511501701582653, 0.0004802901273780469, 0.05875771986265077, 0.049565332481185775, 0.018290209613734287, 0.08981066835050278, 0.1541363050176655, 0.1130918925557215, 0.07061789735296065, 0.06507658684490503, 0.1103931531761222, 0.16470763007890143, 0.07817589653286194, 0.10788691789636307, 0.038771702535424946, 0.14208005786208955, 0.03879101472832247, 0.06169658869591188, 0.1534957423242742, 0.1415112924159303, 0.18824464331154345, 0.07856027552702505, 0.18193765300277775, 0.28409296532310613, 0.09871295617042719, 0.09692221305710313, 0.11415268425226299, 0.16023701387196454, 0.037474993581392835, 0.08066396499070683, 0.13480757269733856, 0.14620780569508807, 0.4956558078147043, 0.5308217489784062, 0.5121111277577017, 0.5410926167241217, 0.5125789559292752, 0.5096903614165802, 0.5370362234757706, 0.5615759934087545, 0.5271822234174441, 0.11182249375488351, 0.11584551090724893, 0.11422228703115977, 0.1378742032863034, 0.1361161789284333, 0.13835672566086465, 0.09508388543415836, 0.09331833176323268, 0.17116347414393296, 0.3890878782735411, 0.3056982266499215, 0.5587755128093863, 0.21291084581630193, 0.24077283070612976, 0.18844561590771347, 0.17529377665999002, 0.22398969203618624, 0.22505206281917267, 0.3948639556439786, 0.31040679569051466, 0.5393013082427838, 0.4220454613603559, 0.4604009011638627, 0.39166367466397556, 0.479056051199208, 0.5042456709903758, 0.222266020388052, 0.29655155148917167, 0.17057589682537289, 0.1959608129251531, 0.19553246762429177, 0.338432744668256, 0.30326409331544646, 0.1850038591937484, 0.3762782841726291, 0.19034242349108965, 0.22973405272751957, 0.18785021738172514, 0.24472503775010668, 0.22975953372905855, 0.23244680133103957, 0.2088738478164771, 0.21091428394703937, 0.2086020522500457, 0.21069458935156815, 0.1868972397038159, 0.19324857545625018, 0.19719351696521503, 0.23920324407189397, 0.2001894816535521, 0.20623803862715973, 0.21606777975216895, 0.20304596525887553, 0.20703806444235584, 0.17757441079194336, 0.19754609982312898, 0.17235753955091038, 0.199978364757177, 0.8441935818491646, 0.1786481529067403, 0.8620687170356008, 0.8457325570421799, 0.17225374252774384, 0.20972003125919814, 0.7464037256555089, 0.6249141456359829, 0.20941365073348084, 0.12711615274642862, 0.7981950821253639, 0.22157206068911295, 0.15575416810406317, 0.6919927426094816, 0.19410172655500724, 0.1867411037869765, 0.1823531585095186, 0.19963339687788073, 0.20885372759130938, 0.20199479861796377, 0.1806535892158483, 0.19587583979628564, 0.17734320474414766, 0.11354053736506609, 0.1013445133631905, 0.09791673129321388, 0.12926708699941936, 0.10277341762381453, 0.10103610516781025, 0.09008668878475523, 0.09690372599222141, 0.08349496719489613]}, "mutation_prompt": null}
{"id": "3ecb2c2a-be7f-4d9a-85e2-5c15fb0a0786", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "3cb7a1ad-94aa-484f-aff4-9e87f9c79aae", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "a955f853-2817-4f1e-b78e-0e2aee6b3724", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "e4753c10-2b9e-48c1-9917-f54e66427e7c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "96e8697c-0ca6-4aba-82fd-c0ce8b1f7764", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "514317cd-8954-4887-a13d-303644b34dda", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "fa81bef3-37d5-4926-850d-41ee07301b75", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "b52bdd0c-25a7-4212-958c-11c7328915df", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "230b1716-0f09-4292-a2b7-8d753c2e3b53", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(20 + (dim * 0.1))  # Dynamic population size\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            # Adaptive inertia weight (linearly decreases over iterations)\n            self.w = 0.9 - (0.5 * (current_eval / self.budget))\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive inertia weight for PSO and dynamic population size for improved convergence.", "configspace": "", "generation": 53, "fitness": 0.30688675047980746, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7721672265779254, 0.7755438958792221, 0.7656757002154669, 0.7788313886743142, 0.18968639844076474, 0.7873781544630033, 0.7669066427113893, 0.7761915659898326, 0.7658653850773527, 0.5884059944286715, 0.5603972489392084, 0.5660794844641622, 0.5490550359979061, 0.505362740090438, 0.5520306892354847, 0.5451528865246902, 0.5361227275921181, 0.5690118270570257, 0.14688035653720888, 0.14062783479248464, 0.17243697659510404, 0.13228636178606812, 0.17092485822681303, 0.15593846510884346, 0.12820304490137513, 0.17552398973283578, 0.1235111217430529, 0.13677871721354895, 0.13866205529468845, 0.13345367732297286, 0.1112761831085034, 0.10771426861429645, 0.10675381390114613, 0.10764471933012465, 0.1261924810760624, 0.11168024698264611, 0.9734063814047696, 0.9729111496193619, 0.9627978327160303, 0.9707634721215408, 0.9839463164761837, 0.9818076451905209, 0.9711397521703365, 0.985310451154208, 0.9806538825417721, 0.5833444005636843, 0.05930769620764276, 0.6198275989246635, 0.6013354186347333, 0.6083613004454853, 0.5616306125161863, 0.5862903848370087, 0.08863553829912818, 0.5498904899275723, 0.22453533575369755, 0.3795174313929647, 0.6427058925580151, 0.36688672200147865, 0.21249212784473648, 0.26743193088924233, 0.23068410897946, 0.7853619517931992, 0.8226109057427531, 0.205776835604631, 0.22222828537558503, 0.22160552655017574, 0.13246910344865004, 0.2166453048365774, 0.10466464166404854, 0.19882783882288513, 0.2066722342194356, 0.1984666506588092, 0.2213475042162204, 0.22779182711598733, 0.13179267855417898, 0.2384070458176626, 0.2301241085097807, 0.21580466281348376, 0.2279444538348534, 0.24593129589037876, 0.2383651183558534, 0.05340801557555552, 0.05948344499256686, 0.06226884331721194, 0.03326699908329267, 0.15511501701582653, 0.0004802901273780469, 0.05875771986265077, 0.049565332481185775, 0.018290209613734287, 0.08981066835050278, 0.1541363050176655, 0.1130918925557215, 0.07061789735296065, 0.06507658684490503, 0.1103931531761222, 0.16470763007890143, 0.07817589653286194, 0.10788691789636307, 0.038771702535424946, 0.14208005786208955, 0.03879101472832247, 0.06169658869591188, 0.1534957423242742, 0.1415112924159303, 0.18824464331154345, 0.07856027552702505, 0.18193765300277775, 0.28409296532310613, 0.09871295617042719, 0.09692221305710313, 0.11415268425226299, 0.16023701387196454, 0.037474993581392835, 0.08066396499070683, 0.13480757269733856, 0.14620780569508807, 0.4956558078147043, 0.5308217489784062, 0.5121111277577017, 0.5410926167241217, 0.5125789559292752, 0.5096903614165802, 0.5370362234757706, 0.5615759934087545, 0.5271822234174441, 0.11182249375488351, 0.11584551090724893, 0.11422228703115977, 0.1378742032863034, 0.1361161789284333, 0.13835672566086465, 0.09508388543415836, 0.09331833176323268, 0.17116347414393296, 0.3890878782735411, 0.3056982266499215, 0.5587755128093863, 0.21291084581630193, 0.24077283070612976, 0.18844561590771347, 0.17529377665999002, 0.22398969203618624, 0.22505206281917267, 0.3948639556439786, 0.31040679569051466, 0.5393013082427838, 0.4220454613603559, 0.4604009011638627, 0.39166367466397556, 0.479056051199208, 0.5042456709903758, 0.222266020388052, 0.29655155148917167, 0.17057589682537289, 0.1959608129251531, 0.19553246762429177, 0.338432744668256, 0.30326409331544646, 0.1850038591937484, 0.3762782841726291, 0.19034242349108965, 0.22973405272751957, 0.18785021738172514, 0.24472503775010668, 0.22975953372905855, 0.23244680133103957, 0.2088738478164771, 0.21091428394703937, 0.2086020522500457, 0.21069458935156815, 0.1868972397038159, 0.19324857545625018, 0.19719351696521503, 0.23920324407189397, 0.2001894816535521, 0.20623803862715973, 0.21606777975216895, 0.20304596525887553, 0.20703806444235584, 0.17757441079194336, 0.19754609982312898, 0.17235753955091038, 0.199978364757177, 0.8441935818491646, 0.1786481529067403, 0.8620687170356008, 0.8457325570421799, 0.17225374252774384, 0.20972003125919814, 0.7464037256555089, 0.6249141456359829, 0.20941365073348084, 0.12711615274642862, 0.7981950821253639, 0.22157206068911295, 0.15575416810406317, 0.6919927426094816, 0.19410172655500724, 0.1867411037869765, 0.1823531585095186, 0.19963339687788073, 0.20885372759130938, 0.20199479861796377, 0.1806535892158483, 0.19587583979628564, 0.17734320474414766, 0.11354053736506609, 0.1013445133631905, 0.09791673129321388, 0.12926708699941936, 0.10277341762381453, 0.10103610516781025, 0.09008668878475523, 0.09690372599222141, 0.08349496719489613]}, "mutation_prompt": null}
{"id": "0463125f-d2e3-4351-877a-7c431dc80d64", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "bcfa3ad1-fd34-43a0-98e3-de1690d33a82", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "c6f87236-c022-43a6-9073-2b0309ff0371", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "259f2f03-3616-4a2e-a83d-f7c3d0ca85b6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "53cf2f1c-021e-4c26-837d-f6e360e62450", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_min = 0.4  # Min inertia weight\n        self.w_max = 0.9  # Max inertia weight\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Dynamic Crossover\n            CR_dynamic = self.CR * (1 - current_eval / self.budget)  # Decreasing CR\n            trial = np.where(np.random.rand(self.dim) < CR_dynamic, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w_adaptive = self.w_max - (self.w_max - self.w_min) * (current_eval / self.budget)  # Adaptive w\n            self.velocities[i] = (w_adaptive * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO by introducing adaptive inertia weight in PSO and dynamic crossover rate in DE for better balance between exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.2933912354228387, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.786406610720789, 0.7905778226196088, 0.77449689339528, 0.7725000387009086, 0.7978526421157965, 0.7651506038161039, 0.7828116575212837, 0.8127696003573494, 0.7682752926144147, 0.58756253988433, 0.5460186459958691, 0.5824785012926292, 0.5461375886454934, 0.5596946393669164, 0.532030777821782, 0.5894177929867175, 0.5648130296509791, 0.5570070750476713, 0.1659956887014199, 0.17215857496408427, 0.11920316317412138, 0.1729395509464251, 0.14440759526810198, 0.11362896188922367, 0.14418061098689172, 0.4685662551011539, 0.16337834921724204, 0.138261848806426, 0.09460268739651168, 0.14198888861798475, 0.10788142751067331, 0.11399970181544938, 0.11223625765761902, 0.14360776094630479, 0.13580365680683304, 0.1126370344763149, 0.9758448446271012, 0.9714949590626883, 0.9607155632532788, 0.9653478672666364, 0.9798407082763019, 0.9794307286861106, 0.9634255548054695, 0.9749980577885361, 0.9816177523450014, 0.6410415289315923, 0.5962989843052153, 0.6025896383132812, 0.6054185163555461, 0.5992335536170126, 0.5550034855594607, 0.08910436953084322, 9.999999999998899e-05, 0.050709523669330125, 0.737465741868988, 0.33575414478886545, 0.22494345985783104, 0.27517341826627406, 0.368871957009938, 0.11534602969798857, 0.33091901064057283, 0.6853254619809785, 0.718693111470261, 0.1598566763696515, 0.17909903676588823, 0.1996787793966679, 0.10426907438269939, 0.20234145165647355, 0.11594783852862545, 0.25184898279491363, 0.11248375537203936, 0.1951634630236565, 0.22585042772577102, 0.21591434700129253, 0.18968277182184268, 0.22048632203151786, 0.12971068397125873, 0.18597372566548642, 0.2040783282977764, 0.24593750939092307, 0.11333125116162013, 0.036644550296902945, 0.01487076296316614, 0.07999552960988876, 0.037874738535907504, 9.999999999998899e-05, 0.012114075148838666, 0.07367447347843703, 9.999999999998899e-05, 0.0674547027653245, 0.06606660604201675, 0.02182591530628064, 0.07131261429270597, 0.05770886300617928, 0.039249469230751455, 0.12454144965349112, 0.11422997999730633, 0.1692830289281575, 0.03194203835348852, 0.037073071593378915, 9.999999999998899e-05, 0.058617260027785445, 0.14626062451826305, 0.10465119361034325, 0.08666889492662322, 0.05845555419140436, 0.1251928060838643, 0.0783279201547552, 0.1321314121196896, 0.119984586915305, 0.1427102259155899, 0.10367856945089848, 0.0377439556077539, 0.10985471698564919, 0.13552148061565805, 0.07919933464135265, 0.049050921040191486, 0.5375371643711699, 0.50689837452799, 0.525502671441493, 0.5126873454423775, 0.5086885917552741, 0.5101658775577875, 0.5388598737951364, 0.5017237156282683, 0.5030157048515741, 0.15100681700638086, 0.09347470176571915, 0.11523954482334886, 0.11453203888985086, 0.1313909491153159, 0.11654680760054559, 0.12373894652828277, 0.14732079592596892, 0.11668958360027826, 0.21548861068088776, 0.20972875579570327, 0.16458973535253385, 0.3764916346777163, 0.29885797961672655, 0.2669489592150104, 0.514071343881527, 0.3593914322007157, 0.2553680989426569, 0.3574537822266728, 0.338872326791841, 0.26558292408295825, 0.42126687613232583, 0.34097317554315665, 0.38421071695846154, 0.4842281653311299, 0.44570637424926307, 0.47266384875313294, 0.27614680170671657, 0.2072661140951838, 0.33169569959052847, 0.32545134503786566, 0.2929772059972885, 0.21959822985314903, 0.30368229248758605, 0.20019244294417782, 0.21188635975715553, 0.25409195533311735, 0.21830163109038248, 0.2155745461608789, 0.20943325371767507, 0.27477680957650086, 0.22854187401840131, 0.25026332232719095, 0.21535508837644035, 0.2050907073612831, 0.2355622024002525, 0.2207967107733988, 0.19848593324259334, 0.18673692846842938, 0.18947658817925328, 0.6742520896046613, 0.23873932328241998, 0.2435688059688268, 0.21724718836993462, 0.143443970411693, 0.17027066202698882, 0.21179578640174324, 0.16991398860510942, 0.18754082392803173, 0.20997808577108723, 0.13595249010507338, 0.8345419111056763, 0.8249891966265577, 0.12662767655654972, 0.1687763795016679, 0.2111906251810548, 0.1283623556669412, 0.16858815143400463, 0.12776455156199829, 0.8461347037871478, 0.16835934111746664, 0.10397518773204761, 0.23150858561715248, 0.18783103933354184, 0.18581759830610767, 0.18215515235740665, 0.1904742607211931, 0.21520455232233027, 0.20741213232032685, 0.18998005447441124, 0.1862028983009104, 0.09214210724379757, 0.10572706866015813, 0.09761396532437516, 0.09954022316310729, 0.10132243503263616, 0.08741353453920075, 0.08807175286920921, 0.08340988348939993, 0.0883145347793074]}, "mutation_prompt": null}
{"id": "616aab77-31be-49d5-bac3-fa25504211d3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "eabf4158-ff4d-4f03-9a36-5a0cef172a86", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "2a022364-b472-4588-a96b-ddf8bd123d4f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "c034cf87-36b9-448f-9e28-4732d17079ab", "solution": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased initial population size for better diversity\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.9  # Initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.w = 0.9 - 0.5 * (current_eval / self.budget)  # Dynamic inertia weight\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "RefinedHybridDEPSO", "description": "Refined HybridDEPSO with dynamic population resizing and inertia weight adaptation to enhance exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.2930449988510333, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7282502002221793, 0.7168291058032319, 0.7333986125632339, 0.7419461014420103, 0.723595273833598, 0.7423010678231365, 0.7444280392903528, 0.7269213191873564, 0.7425853326599837, 0.4964032653261964, 0.03237793584882398, 0.47418591291674195, 0.46647207308209904, 0.4826898978949351, 0.4556839720687964, 0.48158410803119545, 0.4471893901236059, 0.490062069372742, 0.15033774877080108, 0.4454152620000379, 0.15691764290033883, 0.13354426777791528, 0.10297064874487549, 0.11610053438113122, 0.13172062186036693, 0.14107069886222057, 0.4033376845694784, 0.11473035969477752, 0.11732932325262468, 0.10350759580074242, 0.12415896333722498, 0.0940543473154205, 0.12415337949739491, 0.09622001178766493, 0.09839190229915706, 0.13450262906937838, 0.9619980168378025, 0.9636103680061086, 0.9546717941124063, 0.9726517637591885, 0.9688848762069706, 0.967522078310138, 0.9845219186901775, 0.9810875928352606, 0.9775780565854029, 0.5233850552653991, 0.5267766756118384, 0.058300803583303806, 0.151699398916865, 0.5009640268274361, 0.5178863652988257, 0.08807134283478701, 0.5162541030039911, 0.525589082581997, 0.7345504402546048, 0.358805536749668, 0.5820140158149936, 0.8806131685489531, 0.3564854136625967, 0.19183542627716843, 0.8049862297627046, 0.6896956387577076, 0.3431300092657764, 0.2641334028818273, 0.19114506325376412, 0.2073239158367317, 0.20621809201119112, 0.11759333651777537, 0.18594196360326143, 0.18726487237292044, 0.20523311065375782, 0.15128344404610694, 0.19948192224811834, 0.1271686554947662, 0.20544035192814258, 0.14151601237440392, 0.21570579477413188, 0.13697904818458206, 0.2394556823513292, 0.2200224199312204, 0.21751649389838412, 0.015862817857385747, 0.006956336745307268, 0.032138156719912714, 9.999999999998899e-05, 0.05955634894683026, 0.06713310247911342, 9.999999999998899e-05, 0.003650174791714589, 0.05564894832465184, 0.11871212773277073, 0.13675125783144326, 0.08257312272349393, 0.03383132431602409, 0.01519191427827371, 0.16142408387239138, 0.132062643602884, 0.09692755805210329, 0.080436640679733, 0.0267137661087834, 0.12454827451729511, 0.037247756970345436, 0.12724494596900293, 0.061005053381739116, 0.05817825934077314, 0.14701450082548584, 0.07525537294237528, 0.18382652817376888, 0.10153433045776639, 0.14731606535977482, 0.0887866315188649, 0.16785226342078863, 0.12794288296360123, 0.1271815119599614, 0.11888108532600394, 0.07047991827116018, 0.07674043132656205, 0.5242500280753686, 0.4949643252373349, 0.48886146980484957, 0.49603033989901135, 0.507323593897698, 0.4807948019776299, 0.5089916592186968, 0.5239283422710559, 0.5326881888969008, 0.1300964613779383, 0.10949510810512908, 0.09856404064353208, 0.1516919623457641, 0.12164984638066745, 0.12512074665124784, 0.14735870110530236, 0.08210797251425761, 0.11156341149031468, 0.1654939216544764, 0.2809638233282603, 0.24039768682687268, 0.3616677162950779, 0.274184163201571, 0.23678660271563035, 0.19048837534655094, 0.515355938005484, 0.28826838852135483, 0.3147505189128754, 0.393726146691861, 0.30416989221153123, 0.2996116335265142, 0.22169698106119629, 0.4403741919735533, 0.2558978958042968, 0.4349601120724952, 0.40508495724591564, 0.27584216065144795, 0.2344499973796651, 0.2573320722447474, 0.21210155517360707, 0.21200844585534828, 0.2699826143218077, 0.21104790985513588, 0.21645384705926496, 0.2860041027540827, 0.23887070079418815, 0.24518745651749174, 0.2187923432269141, 0.240835926034628, 0.24004179657512992, 0.21764058230799732, 0.23542147210801356, 0.20463545468447086, 0.20472461990980662, 0.1926551945394891, 0.23236050689451038, 0.24130250009499443, 0.2111413007888906, 0.1922642499156788, 0.2143524193011037, 0.23359853846284317, 0.18605972085019662, 0.2086912453496167, 0.1689280243599598, 0.1856994197573666, 0.16372698909935512, 0.17813884967546934, 0.16682540868511753, 0.1518686923405287, 0.19587636045623635, 0.8154209984957741, 0.8182898924790112, 0.7783332682342232, 0.1675460052752089, 0.11279182098876284, 0.16784870133355967, 0.6939958078930294, 0.2076862265276883, 0.7539730414145187, 0.15606197105753294, 0.6816088152983169, 0.19472958234929183, 0.20551377874820287, 0.18870080672418788, 0.1942013245849411, 0.18165714264785926, 0.18967856250167703, 0.21512357616237332, 0.20846639816727486, 0.2079405651020796, 0.0862978806364586, 0.10861207332892786, 0.09711321745278456, 0.09421103283392529, 0.09281207272712366, 0.11562037679227488, 0.08859542878469129, 0.09340396778656923, 0.09209677425726492]}, "mutation_prompt": null}
{"id": "f28c65d7-58eb-4d9f-9d79-d92b75d43b0e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "51d510a4-72e3-4f5c-a908-00381917772d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "5f57c7e8-1946-49d4-8b18-7cb7ec967150", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "263c4b2a-442e-4b7a-b66f-1f86d40c33b6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "ba78378d-db39-48a1-b6c6-f5af22ac6e77", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "3665611f-9b76-493d-abdb-5f133875348c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_initial = 0.9  # Initial inertia weight for PSO\n        self.w_final = 0.4  # Final inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n\n        w = self.w_initial - (self.w_initial - self.w_final) * (current_eval / self.budget)\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n            # Local search\n            if np.random.rand() < 0.1:  # 10% probability of local search\n                local_step = np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(self.populations[i] + local_step, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                current_eval += 1\n                if local_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = local_score\n                    self.personal_best[i] = np.copy(local_candidate)\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhance HybridDEPSO with dynamic inertia weight adaptation and local search to boost convergence speed.", "configspace": "", "generation": 68, "fitness": 0.30659980186771235, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7689177626738928, 0.7862038236565259, 0.7696284407368162, 0.782858692839514, 0.7551558047670938, 0.7508371362092694, 0.7708005911109923, 0.790254785406493, 0.7703593109694526, 0.5816473281426182, 0.5579315164656095, 0.0365579554499087, 0.5332195164089581, 0.5266648207771595, 0.5484146437837725, 0.5645548967354201, 0.569375964603259, 0.5227843679407684, 0.14083202423947827, 0.11254213004739977, 0.16544001524424, 0.11560508027694372, 0.14582252575873922, 0.13301323443289925, 0.1538554986573254, 0.1422957506630822, 0.07221924264569357, 0.14741621497513246, 0.10630200720198679, 0.11168405859810826, 0.09978198777135716, 0.10575527026859277, 0.1091847422219755, 0.13970565693032388, 0.1029780282072843, 0.13249988676360203, 0.9836768404201748, 0.9557860222057261, 0.9745592809044229, 0.98033735093262, 0.9877759895330911, 0.9773008654844519, 0.9799807027743104, 0.9765263795841225, 0.982380152852255, 0.5884761979962707, 0.5918095742149567, 0.5657736709069363, 0.5448942298428523, 0.5625076593954021, 0.589076954903236, 0.5753735656891603, 0.5800412594616993, 0.581446696614873, 0.7027456044363152, 0.3575554239059666, 0.33924915381573806, 0.2736315976740883, 0.7139600298369664, 0.16078511308725374, 0.12476368180466502, 0.23569155100717298, 0.6628102298004721, 0.21581270475655656, 0.13028457728664744, 0.21478387599686133, 0.1275572812927689, 0.20775813273689314, 0.1035716122710213, 0.22436485880585555, 0.2122294759063329, 0.13051316619173992, 0.21818110841437333, 0.22032492469490794, 0.21091581145016702, 0.2202664662974415, 0.23300904716241666, 0.2107239668665617, 0.21100368881787868, 0.24527959741685568, 0.29467083827205365, 0.06234811267100682, 0.05295173327671032, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050845515537027874, 0.006841918832904081, 0.08433070630552142, 0.1370850607768196, 0.09534998626976299, 0.13146369565245986, 0.007123781711692256, 0.15543658871627453, 0.1842564008598433, 0.03167231486341848, 0.08794393264106781, 0.16498669360682583, 0.09511717001738107, 0.03908343372231704, 0.06131513193577576, 0.08461507831170789, 0.15914447246034447, 0.1568685383630729, 0.07004269829174503, 0.11293794118285028, 0.18402980561535753, 0.17692626465128758, 0.14035300553846153, 0.13700500008663652, 0.03951270125508888, 0.0403589744287306, 0.07912090592088661, 0.1589966251072361, 0.07870127667657001, 0.5294972832231291, 0.5012216144794629, 0.5449809047834442, 0.5257607115316236, 0.550681949131994, 0.5031131113786738, 0.5086464910605079, 0.5237285921355468, 0.5167787860425659, 0.12188756034611137, 0.10515009619115101, 0.06573892333029385, 0.10106176489625651, 0.0958445638719948, 0.14428622963910342, 0.13569108445138334, 0.12983564176780915, 0.13275268794864237, 0.2879560991352751, 0.32805120970204027, 0.40672682414415295, 0.28959123161769573, 0.36413395092241685, 0.3691984980210361, 0.44018548456175377, 0.19068701936824695, 0.17966174346504482, 0.35696135502074056, 0.28279053126731235, 0.4059487862479557, 0.2519372793773237, 0.4168149928510928, 0.46569370462170856, 0.24502625977603165, 0.484710369102892, 0.2205272342339356, 0.26383301131675985, 0.39148787154976394, 0.2485529741032454, 0.29237776097557777, 0.2073663177423346, 0.29717861255629185, 0.20525482451181565, 0.24179922320001535, 0.25100609094406545, 0.22716407715211973, 0.2960135183025552, 0.22431495963376014, 0.1976690463628531, 0.20162198922706365, 0.18975080066934913, 0.24419868297511915, 0.21685505451268405, 0.2535623440867214, 0.19373263798257034, 0.6562679898541729, 0.24006760087977042, 0.21930280999880714, 0.2288510368002551, 0.20368298009876873, 0.20839047945297684, 0.604690270246392, 0.22313679233621297, 0.17638123338252676, 0.20000248162755419, 0.1536010502448022, 0.17257451396181422, 0.8501761660312701, 0.8606182147182702, 0.162942925326791, 0.820811120654016, 0.8558473271292653, 0.11202840120766688, 0.21153988194302498, 0.8076494471370046, 0.712195452795148, 0.15407118531277209, 0.1690485696879901, 0.10480939575960457, 0.16763243390767657, 0.12626241822220252, 0.19876676696413975, 0.18401644754085444, 0.19896866404301294, 0.18824342768955737, 0.17714316751537085, 0.1908594659125652, 0.18247127936306295, 0.219349260856318, 0.18310872260629163, 0.10536094296750742, 0.0897566506285451, 0.1013169674791281, 0.09082980296749044, 0.09668572767916117, 0.10011942007240249, 0.0982322635755456, 0.09178625023799292, 0.08842633656814702]}, "mutation_prompt": null}
{"id": "515c06db-2ffe-431a-9684-021a4078dcd8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.population_size = self.initial_population_size\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w_dynamic = self.w_max - (self.w_max - self.w_min) * (current_eval / self.budget)  # Dynamic inertia weight\n            self.velocities[i] = (w_dynamic * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive population size and dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.30688675047980746, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7721672265779254, 0.7755438958792221, 0.7656757002154669, 0.7788313886743142, 0.18968639844076474, 0.7873781544630033, 0.7669066427113893, 0.7761915659898326, 0.7658653850773527, 0.5884059944286715, 0.5603972489392084, 0.5660794844641622, 0.5490550359979061, 0.505362740090438, 0.5520306892354847, 0.5451528865246902, 0.5361227275921181, 0.5690118270570257, 0.14688035653720888, 0.14062783479248464, 0.17243697659510404, 0.13228636178606812, 0.17092485822681303, 0.15593846510884346, 0.12820304490137513, 0.17552398973283578, 0.1235111217430529, 0.13677871721354895, 0.13866205529468845, 0.13345367732297286, 0.1112761831085034, 0.10771426861429645, 0.10675381390114613, 0.10764471933012465, 0.1261924810760624, 0.11168024698264611, 0.9734063814047696, 0.9729111496193619, 0.9627978327160303, 0.9707634721215408, 0.9839463164761837, 0.9818076451905209, 0.9711397521703365, 0.985310451154208, 0.9806538825417721, 0.5833444005636843, 0.05930769620764276, 0.6198275989246635, 0.6013354186347333, 0.6083613004454853, 0.5616306125161863, 0.5862903848370087, 0.08863553829912818, 0.5498904899275723, 0.22453533575369755, 0.3795174313929647, 0.6427058925580151, 0.36688672200147865, 0.21249212784473648, 0.26743193088924233, 0.23068410897946, 0.7853619517931992, 0.8226109057427531, 0.205776835604631, 0.22222828537558503, 0.22160552655017574, 0.13246910344865004, 0.2166453048365774, 0.10466464166404854, 0.19882783882288513, 0.2066722342194356, 0.1984666506588092, 0.2213475042162204, 0.22779182711598733, 0.13179267855417898, 0.2384070458176626, 0.2301241085097807, 0.21580466281348376, 0.2279444538348534, 0.24593129589037876, 0.2383651183558534, 0.05340801557555552, 0.05948344499256686, 0.06226884331721194, 0.03326699908329267, 0.15511501701582653, 0.0004802901273780469, 0.05875771986265077, 0.049565332481185775, 0.018290209613734287, 0.08981066835050278, 0.1541363050176655, 0.1130918925557215, 0.07061789735296065, 0.06507658684490503, 0.1103931531761222, 0.16470763007890143, 0.07817589653286194, 0.10788691789636307, 0.038771702535424946, 0.14208005786208955, 0.03879101472832247, 0.06169658869591188, 0.1534957423242742, 0.1415112924159303, 0.18824464331154345, 0.07856027552702505, 0.18193765300277775, 0.28409296532310613, 0.09871295617042719, 0.09692221305710313, 0.11415268425226299, 0.16023701387196454, 0.037474993581392835, 0.08066396499070683, 0.13480757269733856, 0.14620780569508807, 0.4956558078147043, 0.5308217489784062, 0.5121111277577017, 0.5410926167241217, 0.5125789559292752, 0.5096903614165802, 0.5370362234757706, 0.5615759934087545, 0.5271822234174441, 0.11182249375488351, 0.11584551090724893, 0.11422228703115977, 0.1378742032863034, 0.1361161789284333, 0.13835672566086465, 0.09508388543415836, 0.09331833176323268, 0.17116347414393296, 0.3890878782735411, 0.3056982266499215, 0.5587755128093863, 0.21291084581630193, 0.24077283070612976, 0.18844561590771347, 0.17529377665999002, 0.22398969203618624, 0.22505206281917267, 0.3948639556439786, 0.31040679569051466, 0.5393013082427838, 0.4220454613603559, 0.4604009011638627, 0.39166367466397556, 0.479056051199208, 0.5042456709903758, 0.222266020388052, 0.29655155148917167, 0.17057589682537289, 0.1959608129251531, 0.19553246762429177, 0.338432744668256, 0.30326409331544646, 0.1850038591937484, 0.3762782841726291, 0.19034242349108965, 0.22973405272751957, 0.18785021738172514, 0.24472503775010668, 0.22975953372905855, 0.23244680133103957, 0.2088738478164771, 0.21091428394703937, 0.2086020522500457, 0.21069458935156815, 0.1868972397038159, 0.19324857545625018, 0.19719351696521503, 0.23920324407189397, 0.2001894816535521, 0.20623803862715973, 0.21606777975216895, 0.20304596525887553, 0.20703806444235584, 0.17757441079194336, 0.19754609982312898, 0.17235753955091038, 0.199978364757177, 0.8441935818491646, 0.1786481529067403, 0.8620687170356008, 0.8457325570421799, 0.17225374252774384, 0.20972003125919814, 0.7464037256555089, 0.6249141456359829, 0.20941365073348084, 0.12711615274642862, 0.7981950821253639, 0.22157206068911295, 0.15575416810406317, 0.6919927426094816, 0.19410172655500724, 0.1867411037869765, 0.1823531585095186, 0.19963339687788073, 0.20885372759130938, 0.20199479861796377, 0.1806535892158483, 0.19587583979628564, 0.17734320474414766, 0.11354053736506609, 0.1013445133631905, 0.09791673129321388, 0.12926708699941936, 0.10277341762381453, 0.10103610516781025, 0.09008668878475523, 0.09690372599222141, 0.08349496719489613]}, "mutation_prompt": null}
{"id": "65fa33c7-6be2-4b6d-b18a-4e8af377e6d4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def compute_diversity(self):\n        centroid = np.mean(self.populations, axis=0)\n        diversity = np.mean(np.linalg.norm(self.populations - centroid, axis=1))\n        return diversity\n    \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            diversity = self.compute_diversity()\n            CR_adaptive = max(0.1, min(0.9, self.CR + (0.9 - CR_adaptive) * diversity))\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            diversity = self.compute_diversity()\n            w_adaptive = max(0.1, min(0.9, self.w * (1 - diversity)))\n            self.velocities[i] = (w_adaptive * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO using adaptive inertia and crossover rates based on diversity metrics for enhanced global-local search balance.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'CR_adaptive' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'CR_adaptive' referenced before assignment\")", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {}, "mutation_prompt": null}
{"id": "825a8288-b5c5-4885-928e-682c9976efcb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.3 * np.random.rand() - 0.15)  # More adaptive F range\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.15 * np.random.rand() - 0.075)  # More adaptive CR range\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection with Elitism\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n            elif trial_score < self.personal_best_scores[np.argmax(self.personal_best_scores)]:  # Elitism\n                worst_idx = np.argmax(self.personal_best_scores)\n                self.populations[worst_idx] = trial\n                self.personal_best_scores[worst_idx] = trial_score\n                self.personal_best[worst_idx] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "A refined HybridDEPSO with dynamic parameter adaptation and elitism to enhance convergence stability and efficiency.", "configspace": "", "generation": 71, "fitness": 0.32480011299554307, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.30.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9318008643210722, 0.9302720955521345, 0.9325334130752921, 0.92663618506656, 0.9346546951060679, 0.9361228707317695, 0.935944164700543, 0.9279496157494126, 0.9262132441368924, 0.8463626282943694, 0.8603350834229601, 0.04410699959430209, 0.8532964385737056, 0.86594070962469, 0.8618690718174502, 0.857772797033235, 0.8732029758434081, 0.8601856338507639, 0.09299669207584826, 0.14504511790713537, 0.16276248040512187, 0.15982342871012511, 0.11172707187877151, 0.11714055065549744, 0.14812575619875512, 0.1462951558296791, 0.1606024174782258, 0.16186742036978596, 0.11183670973130466, 0.09133017420939193, 0.11147884516871365, 0.1334361943463871, 0.09320162364342088, 0.07021496511753977, 0.11102354804226655, 0.09552953479826953, 0.9761524019619445, 0.9485823728296592, 0.976094388079919, 0.9694681782254583, 0.9760017288144646, 0.9743348281014699, 0.9683713895032314, 0.9811448740544503, 0.9701544620471568, 0.8485383324561065, 0.05945397657251417, 0.8283858593187133, 0.8291325773887669, 0.15326667074573397, 0.8474581047719071, 0.8615909642072819, 0.0867354817502013, 0.8537720582478614, 0.22935648186257018, 0.22832301420702472, 0.896586847842319, 0.28271222343942903, 0.15904076642821563, 0.19388000587702459, 0.22315788275298587, 0.23521884258096137, 0.24876629610683232, 0.22504523983567704, 0.2556024318662673, 0.24899297827524902, 0.31937696918947533, 0.13222625591046622, 0.27066906816562664, 0.2317507066111213, 0.298510574405752, 0.13440950445136146, 0.13399727197747158, 0.13500233879195167, 0.27480617427054455, 0.3529104634576914, 0.27318352564969106, 0.2406431665321176, 0.13601496950864367, 0.13662378055251667, 0.2656167094457599, 0.0113086272559767, 0.018718606880786193, 0.0045295460245222685, 0.0012650537413512186, 0.060928426079999376, 0.001007964699542896, 0.010902173749740895, 0.010954082400369547, 0.028252608340263552, 0.11788835904967676, 0.18570711041556454, 0.04881383445583776, 0.07125429522262217, 0.09102339190983222, 0.0684201269243988, 0.11673584401147341, 0.10448565481639649, 0.10028967233387209, 0.3060688709006909, 0.12821882821807562, 0.21859657331024251, 0.08297093234637709, 0.10465622155765708, 0.17575438934138332, 0.181642523854587, 0.10617987401007778, 0.092831572063929, 0.1799160266505394, 0.2134602800092954, 0.03863001793515142, 0.03971672288799566, 0.1287511600888812, 0.15411146266056042, 0.2139043393213621, 0.1863252142947579, 0.04909850141073935, 0.63702398199639, 0.6185636651823383, 0.5437236473964425, 0.5969746607127118, 0.5650400457004447, 0.6155170961741204, 0.6560103621872773, 0.6028464096817615, 0.6166511885125763, 0.06340119843732117, 0.13369787514903486, 0.10266895765284623, 0.10177520521252625, 0.06846793853613964, 0.1245442589566148, 0.11851735711288747, 0.13478430737696034, 0.11096761446228998, 0.2183541490921318, 0.259535555825396, 0.2850279476885049, 0.1960585069856885, 0.2219990203803519, 0.8115923397719389, 0.15098299208134935, 0.241131832056107, 0.32993099522453817, 0.2114579680530947, 0.3917392269982787, 0.2035874808762057, 0.35595024856542745, 0.3497730227580166, 0.29712838623891824, 0.6321966683409375, 0.5661928275958372, 0.5511412541648671, 0.13142811277167343, 0.21827947121022517, 0.2970261497310538, 0.29053168940361196, 0.16468165447425565, 0.23314953673324845, 0.11869900401588362, 0.3499566480523284, 0.25732777395202266, 0.2764181297366787, 0.25755148906112535, 0.2893431225750598, 0.24307283129489266, 0.22157302022299696, 0.22601082227054725, 0.24643190415164307, 0.2810688962890717, 0.22934374686706105, 0.18508880603352929, 0.18692973945107183, 0.17991046860359072, 0.17036634964558584, 0.1909111192735451, 0.2252804681396554, 0.22624937266015155, 0.2042398017745911, 0.17930453879561448, 0.1786530336050971, 0.1887796446892629, 0.1543978780948292, 0.16967100678784752, 0.1589412975502129, 0.16724963870916165, 0.9344658502894354, 0.9395005813107901, 0.9373249782661033, 0.9268150928895119, 0.12885076040567656, 0.21157212280120963, 0.1265777908462653, 0.1285105905635996, 0.8568048521526828, 0.2130676718443122, 0.15653791031168007, 0.11702627677814015, 0.19563798621580264, 0.19590721754609852, 0.2046489358217819, 0.20804163090543715, 0.18300521348537702, 0.20362221056983065, 0.20096119043314542, 0.19882089316039409, 0.20262489416729446, 0.09537481622220279, 0.09408413996098353, 0.08895845941874281, 0.09927185512834891, 0.09180140379778678, 0.10621379714219259, 0.10121382604720297, 0.08926730964799756, 0.08347158783490793]}, "mutation_prompt": null}
{"id": "0fe66d10-0150-4333-a89b-92d73ce62160", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w_adaptive = 0.4 + 0.5 * (self.budget - current_eval) / self.budget\n            self.velocities[i] = (w_adaptive * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            if current_eval > self.budget / 2:\n                self.population_size = int(self.initial_population_size * 0.8)  # Dynamic size\n                self.populations = self.populations[:self.population_size]\n                self.velocities = self.velocities[:self.population_size]\n                self.personal_best = self.personal_best[:self.population_size]\n                self.personal_best_scores = self.personal_best_scores[:self.population_size]\n\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO with dynamic population size and adaptive inertia weight to enhance exploration and exploitation.", "configspace": "", "generation": 72, "fitness": 0.3076060047212889, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7721672265777593, 0.775540637270683, 0.7656757002154766, 0.7788313886742497, 0.18968639844078927, 0.7873781544629082, 0.7669066427115363, 0.7761915659898234, 0.7657086421348426, 0.5930364875540621, 0.5627713636230922, 0.5690984068624351, 0.5545050519407455, 0.5128596016784215, 0.5540747089900504, 0.5491870732053878, 0.5522929053121106, 0.5759729893649381, 0.14688035605604144, 0.14062780920484108, 0.17243706851190832, 0.13228623651318316, 0.17092510128896665, 0.15593846959008717, 0.12822412102414527, 0.17552399440401845, 0.12351508015600521, 0.1366934559850559, 0.13864230331368144, 0.13345396007083787, 0.11127639774086351, 0.10771002051000356, 0.10675381369799619, 0.10764470328513731, 0.126214034748252, 0.11167699614407733, 0.9734063814047696, 0.9729111496193619, 0.9627978327160303, 0.9707634721215407, 0.9839463164761837, 0.9818076451905209, 0.9711397521703365, 0.985310451154208, 0.9806538825417721, 0.5875860462014993, 0.0593076961441924, 0.6241007386716939, 0.620475460187741, 0.612689219866557, 0.5767829323384146, 0.6003153877774563, 0.0886354951012217, 0.5692454590372651, 0.22453533575369755, 0.3795174313929647, 0.6427058925580151, 0.36688672200147865, 0.21249212784473648, 0.26743193088924233, 0.23068410897946, 0.7853619517931992, 0.8226109057427531, 0.20641503483770374, 0.21609364257372776, 0.21393643088469882, 0.1325380536234516, 0.21108802069131394, 0.10466870699534425, 0.2070394489340318, 0.21326433454221272, 0.19877084921884558, 0.22148594559955204, 0.22723517441601881, 0.131793812927822, 0.24528238248442735, 0.2266292516574605, 0.20508665583818386, 0.2319751807874736, 0.2476286963848472, 0.24045356618989644, 0.05311711253693774, 0.059654420278372866, 0.050255189072453854, 0.033314780424589796, 0.1468036033932001, 0.00033249335026352966, 0.06002347412656961, 0.04905738108444546, 0.016500179082143074, 0.09125346673802925, 0.15822899383770617, 0.116451231708261, 0.06026041004188787, 0.06952655444791256, 0.10763085085083457, 0.16398947376935247, 0.0764269055186374, 0.1035851154803078, 0.03877173575680404, 0.1420756340423992, 0.03879102424747993, 0.06169887645385219, 0.15351479770727006, 0.14151110481766715, 0.18365119776115657, 0.07856043491021769, 0.18195442368856407, 0.2843578651078946, 0.09871174955217088, 0.09692786961967781, 0.11415193033280902, 0.16023495149464484, 0.03747504787667455, 0.08066390558034287, 0.1348135942651204, 0.14621061297121285, 0.4906764288619999, 0.5282887125081985, 0.5057717143807542, 0.5391423395582174, 0.49833811647313775, 0.4983733409845903, 0.5358359530925193, 0.5546116913144077, 0.5361880904003344, 0.11182385596696387, 0.11541409320517648, 0.11422240646332027, 0.13787443301194469, 0.13611370846633075, 0.1383567358670338, 0.09508392981625602, 0.09331838786748448, 0.1711646196797476, 0.4111983088733089, 0.3050521664537853, 0.5861692773558114, 0.2108920537669262, 0.24114614125631217, 0.1874274940010745, 0.17491966670948966, 0.22335275210503625, 0.21185116365043555, 0.46246978159412455, 0.3103873721226298, 0.49556861911822037, 0.4791234993997565, 0.4550226186233832, 0.3906159324079371, 0.4832596411239335, 0.5128719406961998, 0.22220367734600754, 0.2985283049262839, 0.17059215724751453, 0.19596838594146015, 0.1957074051812011, 0.350731791039662, 0.3039006805117509, 0.18500263183652443, 0.3531676155993172, 0.19060260224088854, 0.24353911803210349, 0.19666200297420378, 0.27948758022403586, 0.19764807394135986, 0.21739433233174954, 0.21383091023792555, 0.21090706662319814, 0.20313591759660288, 0.20892851797431122, 0.18689723987766715, 0.19324856968920456, 0.19719351741105828, 0.23920319484317754, 0.20018949950622145, 0.20685697590633667, 0.21606777075845618, 0.2030459691097406, 0.20723733105818387, 0.17757435107841935, 0.19754609982666094, 0.1723575395521013, 0.19997836474000485, 0.8441935818491606, 0.17864815291126235, 0.8620687170356008, 0.8457325570421799, 0.17225374252853565, 0.20972003126793326, 0.7465774723605578, 0.6140619956888915, 0.2094136506438713, 0.12711615274825272, 0.7981950821253967, 0.2215720606889804, 0.15575416810428944, 0.6994572303815416, 0.19351567244704715, 0.18194531382008194, 0.1825081572374192, 0.19980554242842563, 0.20884765753332746, 0.20195176633471912, 0.18168536228304888, 0.1959231516527319, 0.18003085421193332, 0.11250324611008822, 0.1020614896275367, 0.09780158437583464, 0.11898274463987912, 0.09848170776019727, 0.10092654137373447, 0.09131041382745775, 0.0977927149255351, 0.08051214804722773]}, "mutation_prompt": null}
{"id": "605227ed-d319-48e2-9859-2490b9ba0350", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        w = self.w_max - ((self.w_max - self.w_min) * (current_eval / self.budget))\n\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        \n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive inertia weight in PSO and dynamic population resizing for improved exploration-exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.3117036011782883, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7702745940680027, 0.777324197905728, 0.7811038624645738, 0.7618596280583196, 0.18968210093169668, 0.773837936454685, 0.7922080480889213, 0.7875116791411709, 0.7754130705043155, 0.5478847990165454, 0.5616759061824522, 0.5236133115474506, 0.5358080325201733, 0.5056478015394805, 0.5263213587101256, 0.5237086752235772, 0.04884245439077839, 0.5418240907629706, 0.15967493710938307, 0.5284828006661955, 0.1698859271420814, 0.10966219558183699, 0.15188876711168164, 0.14462701525834432, 0.11810993752776955, 0.17182383027838188, 0.1124355775070075, 0.15309805294557355, 0.13803660488365643, 0.12423070984200713, 0.13595678360733632, 0.10301063995898274, 0.11683349683598843, 0.1503469081260892, 0.11271234313852851, 0.1239755628197885, 0.9734064814313762, 0.9729102098121695, 0.9627977407763562, 0.9707582979761065, 0.9839440929231262, 0.9818076759174925, 0.97113932189983, 0.9853104759542017, 0.9806524657188371, 0.6058826328768465, 0.05930612729542295, 0.5906793634332816, 0.6268637934500696, 0.60421915984083, 0.5935281913435689, 0.5701095930254776, 0.08864266652916153, 0.5847119410887942, 0.711242559401128, 0.7767289634862968, 0.22578483399902782, 0.856247139248291, 0.269568437413541, 0.7501306292836176, 0.232235700339681, 0.3879173787768341, 0.7353282676552393, 0.2001226161183749, 0.21297189138041062, 0.20904251485389125, 0.21208921224695843, 0.2062712360369542, 0.10530946703760113, 0.21802227414633923, 0.21164745106059757, 0.24899828944307478, 0.22486070787489998, 0.22039648353864327, 0.1322089893123235, 0.2496144718004396, 0.23987840695969853, 0.2118418828246188, 0.23218101014516102, 0.23706193505884865, 0.23270784403857325, 0.05761302879916186, 0.01445558691129123, 0.043141698364467684, 0.03994005917717991, 0.07439235510243525, 9.999999999998899e-05, 0.10200618339667, 0.01725057424607257, 0.03823971135631887, 0.10827319588419759, 0.12352071331643888, 0.14006125558166405, 0.06530003394116979, 0.11246747329956575, 0.13087240396680444, 0.15297085228920604, 0.039251718133058056, 0.14996863612018407, 0.04081068389200482, 0.10176331198875921, 0.0405228863845819, 0.06467935945726533, 0.25989997904321516, 0.13519153419301655, 0.16326354784214003, 0.08582815446686021, 0.4335239264877455, 0.18157802137652646, 0.2166790555653686, 0.12902633378166117, 0.150996106958041, 0.2152546743365894, 0.037501584666217114, 0.08114821951811302, 0.1320815810099899, 0.13917248746314603, 0.48871853869729853, 0.5123306046382473, 0.49104755465524463, 0.5142698662230556, 0.58864739099512, 0.5102919887972445, 0.53054389054499, 0.5396866852566593, 0.548008372215748, 0.0967581736565104, 0.16483070635717156, 0.13251678437019454, 0.1069799020321911, 0.16977893462368043, 0.13605053396719158, 0.09520175608639692, 0.09452053422460216, 0.13489895707798438, 0.19825456746036318, 0.40101068564994624, 0.1804304700143422, 0.18428965800677577, 0.5414999861666883, 0.1692872189525344, 0.19554950165281015, 0.2194582267548958, 0.24542174650792592, 0.3833257768182332, 0.29567064557768385, 0.4279205742197638, 0.48703888946560026, 0.4131772608266503, 0.5111768299948052, 0.4760558642251954, 0.44311988129205326, 0.22560840512950253, 0.2676194125813727, 0.23207816468086007, 0.28381694097925614, 0.132994254970641, 0.3141353550928132, 0.18444853996665878, 0.2152483401552554, 0.291826423126501, 0.20530634324089092, 0.22357180815160405, 0.23046066169185875, 0.20742935610949098, 0.21149173161407964, 0.2290968291083041, 0.2194372600158666, 0.22258108876032756, 0.22061857644490002, 0.2513936519566894, 0.18753782484718162, 0.1914400981030474, 0.1971450442763717, 0.21813800600464994, 0.2155208575434201, 0.21382611246998295, 0.21610063788809053, 0.2083019275691459, 0.2118029528217218, 0.178076492184014, 0.19752706872729986, 0.17234702568902904, 0.19997264369345313, 0.8397129047516836, 0.17864790416421727, 0.8378626447643854, 0.8418496226714638, 0.17226655153502757, 0.21096198307626335, 0.7077754171174793, 0.6353503442519908, 0.20942669444500528, 0.12711758030507647, 0.8254035387995631, 0.22169018463559997, 0.15576192393615018, 0.7340183291316352, 0.17963300712649888, 0.1899999341194636, 0.20603273699242808, 0.1917932580768108, 0.1886597072757783, 0.1845169430753857, 0.17204916102779844, 0.19546168270560837, 0.21099558586567957, 0.08995172319471167, 0.0955269061948153, 0.10147254263040195, 0.10050675293803502, 0.09722249032042363, 0.10121306296904453, 0.09954261939931963, 0.11300021119871961, 0.08272372127099592]}, "mutation_prompt": null}
{"id": "93ede133-86ef-4776-b833-c6dc5bde2a19", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "bfcb7d1e-e12b-46ae-9cba-9f726f0043d4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Local Search with Simulated Annealing\n            temperature = 1.0  # Simulated Annealing Temperature\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            trial_local = np.clip(trial + perturbation, self.lower_bound, self.upper_bound)\n            trial_score = func(trial)\n            trial_local_score = func(trial_local)\n            current_eval += 2\n            \n            if trial_local_score < trial_score or np.exp((trial_score - trial_local_score) / temperature) > np.random.rand():\n                trial, trial_score = trial_local, trial_local_score\n            \n            # Selection\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced adaptability by introducing local search exploitation with simulated annealing within HybridDEPSO's DE phase.", "configspace": "", "generation": 75, "fitness": 0.32532093650667815, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.8950147729653614, 0.8882487148989855, 0.8812097497118548, 0.8869769431355181, 0.8652894755381348, 0.8877665366692298, 0.8862273352926792, 0.8732331767896365, 0.8882596050166932, 0.7250337372158282, 0.778513603839702, 0.7508248002674458, 0.7549257147781062, 0.7691572202831573, 0.7690221169554057, 0.750531726216662, 0.7672532146160634, 0.7703156830699257, 0.15482264444023675, 0.15412748634135476, 0.1474059455568506, 0.15100691717135284, 0.14336417262240098, 0.11507547473869983, 0.11743459360736286, 0.1406627553375729, 0.18272774903524636, 0.07132138238903685, 0.10317634209757964, 0.08384951850652012, 0.09157674511292535, 0.09384505987691427, 0.10065528444316296, 0.10475651444147338, 0.10894812845508184, 0.13043352017638976, 0.9614133825194207, 0.9540793394587741, 0.9358297256660495, 0.8996498547502002, 0.9734773454263658, 0.9646051970634029, 0.9544644508781294, 0.9755397874359322, 0.9593555936270007, 0.7420997946485774, 0.7277027107437521, 0.638817973201633, 0.7338550063105875, 0.6489124267075003, 0.7404443567818946, 0.7292745505836832, 0.7460287023457637, 0.7106636736041175, 0.22666469938531597, 0.2253852284633746, 0.23014954180589786, 0.8868555965191772, 0.21244080752666106, 0.21145771654611567, 0.22441640302507426, 0.1724113268832188, 0.7024897800611506, 0.13239223286688628, 0.23332489882581608, 0.23214196106692575, 0.23381409676236187, 0.34468107672877335, 0.15468522362503523, 0.1332987752635859, 0.24357265633988978, 0.25393494620288415, 0.2370978638314456, 0.12547862864778603, 0.24591127682293012, 0.2727013016596531, 0.13247979744665173, 0.24047840729771153, 0.2766983762982954, 0.2741019202163184, 0.2607758049267832, 0.00471860324259199, 0.08117351189149846, 0.05108237059888765, 0.1333141903827031, 0.01872795543478567, 0.10285372879246402, 0.009301248241952664, 9.999999999998899e-05, 0.011581592352125303, 0.17911155668152845, 0.07853132612026625, 0.08791531482865589, 0.031152416912271996, 0.07786650582052246, 0.02773772581757672, 0.044073966726614566, 0.0828503627892, 0.16248219955000165, 0.10264121079029376, 0.09332745512017737, 0.09626343928432557, 0.26254420918726984, 0.12908692698147006, 0.19559260952188473, 0.208910818853436, 0.14219833987789332, 0.16577339627224208, 0.23516160698215094, 0.07537664133257627, 0.11597463187474621, 0.08528692609770383, 0.04235375006813846, 0.12799228607265067, 0.08260824522828847, 0.12893396832516102, 0.09283960104021405, 0.517037051321438, 0.5479344180151695, 0.5267298680298023, 0.5755569983199694, 0.501685088396862, 0.5196735612160215, 0.5719801048454822, 0.5566769561488065, 0.5740983259170074, 0.10656187545910456, 0.10299687323226647, 0.10500537919865405, 0.1440556723412656, 0.11432435490232562, 0.11136871254938219, 0.14461623967418347, 0.13759874374316927, 0.09058419630674996, 0.2738073308802238, 0.22168306904849644, 0.5195735727533741, 0.3036345705728154, 0.29689882945792856, 0.27071407935162084, 0.2075488084910545, 0.15483315897929095, 0.2005230511977677, 0.21898419745506503, 0.3153054774075845, 0.4761874543768143, 0.2591051499724938, 0.2043351164446079, 0.32084279970667584, 0.4284203188151111, 0.4525146969775766, 0.20753058402584768, 0.20727300215638744, 0.37630741168554926, 0.2099506877107059, 0.2426013117318706, 0.19736211054130404, 0.31256686526546695, 0.2408782404733345, 0.21787248785987057, 0.1516822771890587, 0.24635992180191602, 0.22495693946735684, 0.2025903733405583, 0.20520036345422732, 0.18527506095220392, 0.19999870640119366, 0.21991017268095225, 0.22892346940449193, 0.26792223668941473, 0.18692614190344858, 0.19955873776544575, 0.22593734436026014, 0.2225498897675534, 0.7932784012269266, 0.20654128249618087, 0.1951403731369834, 0.7598099052076536, 0.18969448298316138, 0.9238573150150329, 0.17661864820073936, 0.16176951924968597, 0.1994868261135656, 0.21038627916579977, 0.9270831599892481, 0.16092758970968057, 0.1577157560914506, 0.9004298361287351, 0.12665111852249178, 0.21105616781514946, 0.7332794714860662, 0.1274585906486262, 0.21170904710568805, 0.15483356361765377, 0.15443401607674256, 0.12650729042176612, 0.8610229379442566, 0.1966259643932624, 0.2019122841831269, 0.19211149826418905, 0.2100333140418209, 0.21238133591664532, 0.22201195856843337, 0.20335546813887928, 0.18538681088574027, 0.20466882692483102, 0.09046631496198076, 0.08770687870426097, 0.10431444642166277, 0.09862609898287233, 0.09262531245883276, 0.09150765939048666, 0.10315286650276945, 0.08412381810116965, 0.09860019461032876]}, "mutation_prompt": null}
{"id": "5f3d6ef3-7f68-4e14-b56c-3764e1cfcb80", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "1c141d76-23ca-4de8-8b28-ae94dc903c82", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "454ea9d4-ff5d-4a21-8ff9-493504138de7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "abb139ff-363c-412a-96c4-b425497c5db2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.initial_population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n\n    def adjust_population_size(self, current_eval):\n        max_size = self.initial_population_size\n        min_size = 4\n        new_size = min_size + int(((self.budget - current_eval) / self.budget) * (max_size - min_size))\n        if new_size < self.populations.shape[0]:\n            indices_to_keep = np.argsort(self.personal_best_scores)[:new_size]\n            self.populations = self.populations[indices_to_keep]\n            self.velocities = self.velocities[indices_to_keep]\n            self.personal_best = self.personal_best[indices_to_keep]\n            self.personal_best_scores = self.personal_best_scores[indices_to_keep]\n\n    def differential_evolution(self, func, current_eval):\n        for i in range(self.populations.shape[0]):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.populations.shape[0]) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        w_dynamic = self.w_max - (self.w_max - self.w_min) * (current_eval / self.budget)\n        \n        for i in range(self.populations.shape[0]):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w_dynamic * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            self.adjust_population_size(current_eval)\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Introduce a dynamic inertia weight and adaptive population size strategy to improve exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.31696066805152046, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7884530315196239, 0.8069331721582174, 0.7877961634771299, 0.8140899057609928, 0.7980534176917191, 0.7936615200583527, 0.7804746795527723, 0.8074078790525342, 0.7876500973241554, 0.5997910445231447, 0.6059442345170682, 0.6127200613364028, 0.6266304830268388, 0.5942943425520697, 0.616276231817048, 0.6061801659987933, 0.5854799770559265, 0.6169371972556925, 0.08343383707299923, 0.16243843708431793, 0.15915069281903738, 0.11182942033711152, 0.13287485185203263, 0.11543423617804749, 0.13850582823738766, 0.14460606531872888, 0.14784309471519697, 0.14522347563943072, 0.13068997350282696, 0.10270546917396839, 0.14133946210619075, 0.11362266545297028, 0.1266872666063955, 0.05331506394342178, 0.10260148244409595, 0.13453192039106965, 0.9824620267811159, 0.9772062591760083, 0.9729391994307345, 0.9613452946685959, 0.9779280560691206, 0.9728324246923186, 0.9811976857815786, 0.9840128198502719, 0.9762669452649778, 0.6453503308111288, 0.05945210363777964, 0.6542201101261482, 0.6690079899530625, 0.64466873334032, 0.6406716877389333, 0.6303053983754164, 0.08801939367213651, 0.6699932225917035, 0.7406537101306692, 0.3697753065496667, 0.6981688769200793, 0.2708181084900543, 0.27420988105821076, 0.2665842937416548, 0.3917830063988237, 0.15915490329341797, 0.17753326894688604, 0.12462875743623614, 0.22042740762398783, 0.22028754372528903, 0.20674605404491864, 0.11510484166779078, 0.11365796151865948, 0.23081447639192487, 0.2321050807139462, 0.23713718066877254, 0.20274475066633924, 0.21365971280845053, 0.13195569339441937, 0.2121998892621536, 0.2441187498405739, 0.2398230921543052, 0.24309636026243575, 0.2596391663711166, 0.24001299827420342, 0.0033268012740689246, 0.02484509118025402, 0.04405145625670903, 0.0342223197012923, 0.04011503199873967, 9.999999999998899e-05, 9.999999999998899e-05, 0.04643281576157987, 0.03353062969580045, 0.09799102298558482, 0.12283195267012159, 0.11907319551939566, 0.050757716965362354, 0.050482231593940385, 0.11402853888581321, 0.09750120095943149, 0.09130519849023189, 0.08404518837650599, 0.04310202019447151, 0.09628917512542245, 0.2540820509767595, 0.22808554881623866, 0.13908313211405898, 0.06481760771749145, 0.0830257870389205, 0.4033146948165778, 0.11326693257608589, 0.2341815722714291, 0.11271606195755735, 0.07741348459503294, 0.1118466289297414, 0.006218298620820462, 0.07921088993867798, 0.12378267358359285, 0.1580750575434191, 0.08118357259427889, 0.5412480719793701, 0.5438814706543023, 0.4802437085981274, 0.6099474074879649, 0.5494107586538426, 0.5163080358762069, 0.5481691394966539, 0.5843261397119988, 0.5480285032468657, 0.16822208293737606, 0.11374394968337331, 0.1089668104608893, 0.1619089635014006, 0.10028584817233188, 0.16315373741050976, 0.13712561951269076, 0.11945207954798465, 0.13888719702257235, 0.4451242427167864, 0.1576345180193075, 0.14935253096056444, 0.1963324859429294, 0.44094708975598373, 0.2072802990838869, 0.21551365609772066, 0.2653182012065285, 0.23861020059978144, 0.5043741368542924, 0.379315331215612, 0.48567777223801556, 0.3553009658700903, 0.3758614906855321, 0.3768035766481407, 0.5622221462968142, 0.44337620142288026, 0.43422618286963954, 0.2323566488819453, 0.2318704750402465, 0.36295480058314644, 0.20419302475805645, 0.33913559606599497, 0.23047181616188672, 0.20616411988543637, 0.23558590233714116, 0.2548521511413413, 0.22223105921516162, 0.229135446337973, 0.24207726579501587, 0.2411904298532973, 0.21285157945619382, 0.2157312950169289, 0.210875310400351, 0.23173704261912176, 0.24262655172908365, 0.22030394693783706, 0.700482599327986, 0.20546734739078554, 0.1837038309107002, 0.17703057467846517, 0.1963464192501737, 0.23669497856924893, 0.669327912778066, 0.21897363699266537, 0.8660265809202892, 0.19819203365412263, 0.15392801905455722, 0.16167706819228078, 0.1585376864567154, 0.1775751637421148, 0.13073158128379891, 0.8509592523948575, 0.8755743430391488, 0.8023985376663697, 0.7984874129583294, 0.6442116543941573, 0.20969040957008078, 0.12709116429313527, 0.7343177397668659, 0.1982329811255108, 0.1560668374134182, 0.1280347199223042, 0.19836501369861548, 0.18714206506638598, 0.203925870595827, 0.2168443917915912, 0.19536851864280425, 0.19937948403548766, 0.21984369126521686, 0.18286629254914288, 0.2077211026480702, 0.10252198537714341, 0.0985347328899594, 0.11088317216379906, 0.0899449888823689, 0.09530405159900746, 0.10450726968765944, 0.09634041099357293, 0.09303540417407274, 0.10352716907096005]}, "mutation_prompt": null}
{"id": "575ae882-227e-4e1b-97ae-a0f43b6f7ac9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "f54004b9-0290-4417-b066-df41e77831a9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.population_size = self.initial_population_size\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n    \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F * (1 + 0.1 * np.sin(current_eval / self.budget * np.pi))\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR * (1 + 0.05 * np.cos(current_eval / self.budget * np.pi))\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def resize_population(self, current_eval):\n        if current_eval >= self.budget / 2:\n            self.population_size = max(10, self.population_size // 2)\n            self.populations = self.populations[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.personal_best = self.personal_best[:self.population_size]\n            self.personal_best_scores = self.personal_best_scores[:self.population_size]\n    \n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            self.resize_population(current_eval)\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO with dynamic population resizing and adaptive parameter adjustments to enhance exploration and exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.32670861121764794, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9220438381000821, 0.92772943911839, 0.920408885667072, 0.9254023958696163, 0.9288076645189931, 0.9283564364582452, 0.9171758389795422, 0.9167342759170704, 0.9217591975495956, 0.8466272365879834, 0.8502060901704965, 0.7883163516574635, 0.8239362751859866, 0.84392375098401, 0.852907418096857, 0.8403777103080889, 0.8438950296225598, 0.8464185810819361, 0.125485281916068, 0.1579177398251821, 0.14498652139320822, 0.12417507855871901, 0.16280562018123856, 0.13372974830034223, 0.14633465400566092, 0.18756890606284482, 0.11075662559664345, 0.11053286166328802, 0.0790067080303607, 0.07618623551306192, 0.06635380942948232, 0.11048299315051335, 0.09767261688562467, 0.041940361031365336, 0.11561241506725528, 0.11707027734507769, 0.9739132667467015, 0.9896066576550454, 0.9596674492756572, 0.9627355695326617, 0.9739199338659739, 0.9704566047785235, 0.9841514791297963, 0.9844021487132233, 0.9868709019945985, 0.816538989921061, 0.8390914662721454, 0.8171982605004147, 0.8500178032432832, 0.15325510847745338, 0.8425451860018736, 0.7966946208376541, 0.8312081855161093, 0.8201642570064513, 0.2286412426450234, 0.16986074939843054, 0.22783859161233344, 0.2121893237458765, 0.21383452767118938, 0.28239690501048664, 0.2060148846230635, 0.9192351572427533, 0.2401866774848146, 0.45094361613139855, 0.2635705288326624, 0.2498321047466029, 0.2635438985012961, 0.1339524199162524, 0.12694002541278204, 0.2524918745905851, 0.13506416707645386, 0.18244911399164443, 0.25915122643978916, 0.1274065753513982, 0.24192918306616673, 0.26475878773440753, 0.2550590501987471, 0.2906382054905555, 0.28853726251355005, 0.2816122859794965, 0.16098864884253794, 0.06684369984988625, 0.005887875736630521, 0.03870186569382672, 9.999999999998899e-05, 0.02342396280385961, 0.026531196113867894, 0.0027739809320893594, 0.04145792183959207, 0.05533872525601258, 0.10650757766688113, 0.09291620131536804, 0.05206483128501682, 0.12817539970453729, 0.0888254328023741, 0.02264379956411211, 0.04547444430612979, 0.05112645224064216, 0.05074683269748148, 0.24572864347526235, 0.20551124778989394, 0.0377342239182048, 0.0875673874078502, 0.09877363144215401, 0.1437353984782469, 0.10797374548753613, 0.13304747625249713, 0.07755517854638805, 0.2232594588743796, 0.0117470851742828, 0.3235670113757926, 0.19330796671531092, 0.08575254459232651, 0.17579017110379824, 0.05774994585987059, 0.04916830914408732, 0.08503358619486867, 0.5613829780665645, 0.6521624212742998, 0.7688306915759966, 0.6082647833042892, 0.5525144954184331, 0.6154756189828727, 0.6236938186473118, 0.5961000143637967, 0.6015845869555584, 0.1107782407844492, 0.14454248656343194, 0.10098355925484415, 0.13468516494726468, 0.07196665135344338, 0.11125003339453265, 0.09710871839638746, 0.09292742052501068, 0.12608101867166477, 0.21306092454380077, 0.668033250039672, 0.1923598570408389, 0.20322564255159536, 0.5408527682106449, 0.17896996312624958, 0.23747881330037612, 0.34009808529465313, 0.23746964777495028, 0.6044633387450795, 0.3418875204606344, 0.2931085494542305, 0.3795455115030423, 0.21374816445651612, 0.3024601518208416, 0.32726466856932024, 0.2684363996886846, 0.5834140025631851, 0.21713476652624408, 0.42833046973316, 0.33133884645184697, 0.36176309104982185, 0.24621543933029766, 0.4429844209471899, 0.2733322484355042, 0.23320931071416384, 0.2372323949478098, 0.22436006218589577, 0.23375131750672373, 0.19264335570487856, 0.3576411731890725, 0.20881888595814413, 0.20471460320159918, 0.20197795874955327, 0.2077240568702775, 0.22819491638663303, 0.22682273829354804, 0.20546035031057985, 0.18455107293923534, 0.18521324945548645, 0.17796915283354464, 0.2131637890951824, 0.1771634964067187, 0.1862602642656871, 0.17964667107834598, 0.17287593773387888, 0.20094397528990238, 0.14888752477881717, 0.1688418674396891, 0.188454851346326, 0.11953119311399918, 0.16836508457275723, 0.12682894271631862, 0.12566053803202826, 0.8686436421269264, 0.12807408203690174, 0.11224818408989357, 0.1614124984312606, 0.1696271082187919, 0.7959679879364291, 0.2128274856881064, 0.884212589806366, 0.1694271314580741, 0.18060609236525138, 0.18957546559024563, 0.2087810931272115, 0.20512985633233027, 0.17813705894686682, 0.1922161644031437, 0.2081098951353162, 0.20794669976999247, 0.19713907135336173, 0.10540331177049267, 0.15567324893027923, 0.1036301878459237, 0.09040459214839358, 0.09964872177747641, 0.09397064772975405, 0.1046089064136777, 0.09547135588474998, 0.08825595928950947]}, "mutation_prompt": null}
{"id": "5f6cbc74-b9f6-4c07-b951-42eb246bd83f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        # Dynamic population size adjustment\n        self.initial_population_size = 20\n        self.final_population_size = 10\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        # Nonlinear inertia weight decay\n        self.w_initial = 0.9\n        self.w_final = 0.4\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.population_size = self.initial_population_size\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        # Calculate dynamic inertia weight\n        w = self.w_initial - ((self.w_initial - self.w_final) * (current_eval / self.budget))\n\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            # Adjust population size dynamically\n            self.population_size = max(self.final_population_size, \n                                       int(self.initial_population_size - (self.initial_population_size - self.final_population_size) * (current_eval / self.budget)))\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Introduced dynamic population size adjustment and nonlinear inertia weight decay to enhance exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.3227940672484173, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7811620000083297, 0.7935500251782766, 0.7981173551002371, 0.7917555080483817, 0.8139871754954823, 0.7910316315161651, 0.7969478089277592, 0.7988237007052722, 0.7878191956888121, 0.6097790452431924, 0.6170416249262299, 0.6006857006524922, 0.5693157874585668, 0.5935038467344995, 0.6162886022823332, 0.5875900246061015, 0.6105576906897459, 0.5666520682168156, 0.14358245990435348, 0.08928740788099587, 0.5218335263519531, 0.1072559569445315, 0.13218810628270372, 0.12536644003276087, 0.13965341357060823, 0.13519099352461494, 0.1194010001537863, 0.13427191989283305, 0.1110829133412653, 0.10551197846622995, 0.12279975806295329, 0.14536262216563045, 0.14139221771754107, 0.11123396023314058, 0.1473299220419212, 0.1535741355838669, 0.9841927870274966, 0.9673180177122911, 0.9753325270205851, 0.9773243474555948, 0.9775582033090082, 0.9781975404696778, 0.9723611511788836, 0.9814988068508916, 0.9871688490282444, 0.6286913320301157, 0.059398326395605716, 0.6263101084294103, 0.6313605175152777, 0.6323669764263562, 0.6374389128694202, 0.12604024327752794, 0.08840610757656209, 0.6437436145025797, 0.3867680748552986, 0.7309461665783628, 0.784481937537246, 0.2766236940963668, 0.21086046000748915, 0.28032095483833397, 0.12659566645644138, 0.8313436118492807, 0.1509698584778555, 0.22127207153354456, 0.21257693640518605, 0.22676728458277307, 0.22131078299261076, 0.20458274862563508, 0.11914051702541106, 0.2119711854166254, 0.20478515744611725, 0.20028585929831544, 0.22094535226023915, 0.22840365957711384, 0.21363486316370794, 0.2518682589872163, 0.23916645928565838, 0.2407072740002364, 0.2626976673838394, 0.13107917358565735, 0.23602473602592966, 0.010917965692828324, 0.034549039240350576, 0.024784985278283655, 0.03230934586355483, 0.07377138145833961, 0.012697158360382876, 0.0029885301199281677, 9.999999999998899e-05, 9.999999999998899e-05, 0.08618728812250942, 0.08647546135251583, 0.08962385632031833, 0.080561451662573, 0.05032932017930236, 0.05347277992284305, 0.13921221550760532, 0.057271244110170816, 0.07674097002288272, 0.062049088415625064, 0.04139511029032217, 0.18976231190800263, 0.06461803663252852, 0.1798317951537709, 0.0650693737539132, 0.08738341491503399, 0.08354047976245582, 0.06193749728888631, 0.058341899335310865, 0.22675115918403144, 0.10496785660981744, 0.13588124203948082, 0.005954897641358592, 0.1455876535875943, 0.21684736267321425, 0.19128298706289915, 0.07997107696176464, 0.5458369097935228, 0.5457830277065622, 0.5124064185073294, 0.536079645118764, 0.5226939121152522, 0.5368388166642524, 0.5640650072789426, 0.560221476642585, 0.5725603940365028, 0.07608266013333764, 0.10782533927407456, 0.1520093490566924, 0.568784769022016, 0.1042299336607212, 0.52518446683255, 0.13351349818740288, 0.13922648277847416, 0.10973662460493705, 0.27710105755524417, 0.17597560793489264, 0.184784265931352, 0.3208385957178924, 0.1544259672030598, 0.27291777134853423, 0.4499613559253848, 0.14675559452131326, 0.4947792215341743, 0.4836996743808256, 0.3552670192565184, 0.4684190211438498, 0.33948188457220896, 0.3748112150408536, 0.527618312951365, 0.4134087273145328, 0.44796504435291773, 0.5625718083706649, 0.238095724347965, 0.2529932533407123, 0.22477883067859383, 0.2914544724762963, 0.2521147293784768, 0.2814136305541165, 0.16793614868019957, 0.23672916649595344, 0.29845586532158985, 0.251657753563974, 0.21665329208063422, 0.2490910586007743, 0.252349984907399, 0.2208688532153954, 0.22571774257537258, 0.21477761616102298, 0.24267365068426294, 0.23035351461175047, 0.22064575260509944, 0.1931605461362763, 0.19711932198966986, 0.19182845853859032, 0.20372925437138678, 0.23805949794170134, 0.23364470632710732, 0.19417907395523304, 0.1984758413848111, 0.1476690282813824, 0.1756835447141344, 0.17040476842534968, 0.8546266882804558, 0.8562641959931852, 0.8632843710731275, 0.12275321488402191, 0.8631832024117043, 0.16745661172554427, 0.7368033052476604, 0.7280139389914762, 0.6178006005997515, 0.2087795229238678, 0.12685447318768817, 0.7429710755275314, 0.7542417832494313, 0.11302405206332711, 0.7991256990334498, 0.20451953882836216, 0.19643868629030103, 0.1740848410272705, 0.1999884235234375, 0.18564351231217013, 0.19526872217149993, 0.1829791766681943, 0.20234980874851172, 0.19155422576490233, 0.09615818372725571, 0.0893389954619872, 0.09499844044567507, 0.09397362327355563, 0.09116607010023492, 0.09818346963123181, 0.08216536788328721, 0.097301506764091, 0.09061469760041041]}, "mutation_prompt": null}
{"id": "8ac31fc7-5896-4cb5-928c-fbb8e0be7ed6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "2360a8bc-e51f-4c54-911f-8bd73f3d6739", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.w_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n\n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive inertia weight\n            self.w = self.w_min + (0.9 - self.w_min) * ((self.budget - current_eval) / self.budget)\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        \n        # Dynamic population size\n        if current_eval < self.budget // 2:\n            self.population_size = min(self.initial_population_size * 2, self.population_size + 1)\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO using adaptive inertia weight and a dynamic population size to enhance exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {}, "mutation_prompt": null}
{"id": "301ca4ac-5725-4c64-b417-46fa4611a2a2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, int(dim * 2))  # Dynamic population size based on dimensionality\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved Adaptive HybridDEPSO with dynamic population size adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.30464154633530566, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.30.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9603018481878188, 0.9520993767816497, 0.9543640165667306, 0.9547706417269379, 0.954653129482991, 0.9558525280272201, 0.9518847204423613, 0.9535460879052581, 0.9623377807506067, 0.8144002652866269, 0.8319995374463989, 0.916407926718698, 0.8899249084111056, 0.9091323514035945, 0.8963905702702023, 0.9052388921386564, 0.916058403039286, 0.8342256189377977, 0.11378481197378565, 0.1500172037320745, 0.05640907809078377, 0.1363265020526363, 0.1670027942933815, 0.13704521873151776, 0.03617636822765413, 0.11299015379086508, 0.056089318236031804, 0.0815062775261225, 0.09368026427115872, 0.10832742211330637, 0.09797835916525965, 0.07311216484117633, 0.07604392039630203, 0.10291951140733147, 0.0487584049835188, 0.10326470960740064, 0.9697253965107875, 0.9569982291320194, 0.9737130116530517, 0.9897340910515966, 0.9785914661100703, 0.9673510521076852, 0.09989869109110483, 0.09910507911565636, 0.9775397585656581, 0.82107439645243, 0.8546747073459341, 0.7456090283846617, 0.8778218503641588, 0.25372536209337004, 0.3171247904421264, 0.08865685054186123, 0.8651245669563824, 0.6912510630541071, 0.23100690754608377, 0.13570393252693325, 0.17268862484535707, 0.9672179596283873, 0.14829017690006585, 0.14976995284729833, 0.2384503575291611, 0.11711297343561222, 0.1477480151990156, 0.18433737784147564, 0.13285591927600748, 0.1810174311578444, 0.12132807017409653, 0.21635503924398358, 0.19435866599120177, 0.18513661325013075, 0.1674030737644685, 0.22043861577362756, 0.227878781776103, 0.2085995442985149, 0.18557712362672152, 0.13130079788523108, 0.2364756999471006, 0.21764226935169295, 0.22127577146643218, 0.13745700316586484, 0.30401774803103887, 0.0011001200659315202, 0.01515847661822356, 0.01873027277910244, 9.999999999998899e-05, 9.999999999998899e-05, 0.14184031433191524, 0.0779623829124585, 9.999999999998899e-05, 0.013879171067443519, 0.06836840729227422, 0.10987281339329769, 0.030610465279502064, 0.0028417980712834856, 0.04346007354378578, 0.058071229055808415, 0.0729780043779571, 0.09933159247887413, 0.017621956245464587, 0.12787728899175654, 0.054966395402273105, 0.19773322346255495, 0.14982739640905984, 0.1825569671908771, 0.08685282884000467, 0.12144693286465369, 0.10941181289483304, 0.08111259391297043, 0.10315120780740017, 0.0448806650507424, 0.19098037820801517, 0.008968808732392808, 0.19698047817544895, 0.2530407181736696, 0.0862411205057666, 0.08668805452808648, 0.08670532803986275, 0.5559627254915426, 0.565398717213316, 0.5616739602080152, 0.6237252337186758, 0.5929396250503848, 0.6620186088814146, 0.5996096163111796, 0.6301208379540351, 0.6243588755673787, 0.13496487308955207, 0.02477091302875123, 0.11738575996918121, 0.0733296230853615, 0.10804244780818739, 0.04469367850392825, 0.06505502396335483, 0.09428283889549238, 0.04911879659518503, 0.19844769334090917, 0.2440215868968697, 0.22138942561716024, 0.300536805500089, 0.22221804070232565, 0.4237473271800475, 0.28886193342330757, 0.15559140378065783, 0.2287765793279456, 0.2581818531399459, 0.2296816456140619, 0.24914868876374252, 0.46997686912290426, 0.4795417464382402, 0.19821921155185196, 0.160388879679918, 0.15910701931051008, 0.18495630652784179, 0.1231693444197326, 0.21442212308514264, 0.21783379686653292, 0.36464900442734094, 0.315020080813052, 0.2780020509183776, 0.07703546105957282, 0.2103939793639762, 0.1707424121995944, 0.21603169407836387, 0.25545029021786236, 0.25818035136066164, 0.244538795081102, 0.2334140261777865, 0.24086948548172926, 0.20951563845551224, 0.1749885617887459, 0.24728034367262597, 0.1726567047105223, 0.20588407465904246, 0.19499093388080935, 0.2013787045762626, 0.20589458806751848, 0.2004026773268348, 0.20160187805610386, 0.18248725272416277, 0.19504295749668887, 0.9697838096700355, 0.18910211324261883, 0.11475171752789703, 0.9723491680939058, 0.15408779977640474, 0.202073873464507, 0.15958123929402535, 0.9590432173121594, 0.9648850032852964, 0.16974508085357232, 0.1703074047816674, 0.17846279511097185, 0.14163837761116627, 0.21441339829237271, 0.1553963134447326, 0.1309473933360461, 0.16961323615066382, 0.9331446334536214, 0.19997722530673545, 0.18291477635336695, 0.20487708758611822, 0.20247863832107504, 0.19967588547414272, 0.19983120982011293, 0.2155644371016271, 0.22237876697559744, 0.21217679576115356, 0.08711611500574634, 0.07954329880192434, 0.08687445969144392, 0.0877397492240567, 0.11003450128616155, 0.13754022915773056, 0.06930045742860258, 0.10560634360839483, 0.12176087348138975]}, "mutation_prompt": null}
{"id": "16e00137-5e75-44bb-821f-dd549d2534b8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F_base = 0.8  # Base Differential evolution parameter\n        self.CR_base = 0.9  # Base Crossover probability\n        self.w_base = 0.5  # Base Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F_base * (1 + (np.random.rand() - 0.5))  # Dynamic F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            CR_adaptive = self.CR_base * (0.9 + 0.1 * np.cos(np.pi * current_eval / self.budget))  # Dynamic CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w_dynamic = self.w_base * (0.5 + 0.5 * (1 - current_eval / self.budget))  # Dynamic inertia weight\n            self.velocities[i] = (w_dynamic * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Adaptive HybridDEPSO with dynamic weight adjustment mechanisms for both DE and PSO to enhance exploitation and exploration balance.", "configspace": "", "generation": 86, "fitness": 0.3007792888163891, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9290932944586423, 0.9361250813300991, 0.9319258777495318, 0.9271426301694677, 0.926877443068039, 0.926609953311694, 0.9250746770823751, 0.9293347741391864, 0.9343055310869981, 0.8412477252790485, 0.044147112489741236, 0.8415903537493121, 0.8687369493143621, 0.6393127753648149, 0.8549889947543331, 0.8329498006257722, 0.770475267037174, 0.8454310282364785, 0.14535630233424457, 0.11781174017047358, 0.1017254146558183, 0.11788474246169245, 0.06674542058493038, 0.13662163407270234, 0.08629852626610723, 0.11186805457003535, 0.14451225224914255, 0.11136346734934854, 0.05086070913950769, 0.08208127848455005, 0.09731015315544589, 0.14344779950431763, 0.11846529313589749, 0.13374825367482046, 0.11974389908290539, 0.1129322726432429, 0.9800299287764448, 0.9689692843103576, 0.944247319286665, 0.9484631128662269, 0.9817830686409857, 0.9824899998584342, 0.9661826382415274, 0.972325663936577, 0.9862763247617689, 0.8329441762757888, 0.11433737460088234, 0.7705181713023727, 0.8286772906152372, 0.15416717619452558, 0.8482626051135453, 0.05134411857070176, 9.999999999998899e-05, 0.835812707019676, 0.2293088786284566, 0.15580242791878718, 0.22898976244582958, 0.3805415407208136, 0.9325637592429593, 0.15931937447227829, 0.15184396827826951, 0.29285340934442394, 0.22369743895555794, 0.12762728443100402, 0.2306341112087401, 0.2034993652763214, 0.1982205870375573, 0.21186833032282826, 0.19697801979861373, 0.1345182793776788, 0.16594178071934018, 0.22050369835381445, 0.22591268353023997, 0.22071454005461089, 0.1757921133319421, 0.26698842561930036, 0.2265353371477382, 0.25434804885689233, 0.18080686564379023, 0.1328500257625186, 0.26770881015537795, 0.042822236410138936, 0.014553043425482026, 0.016673898832313405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044835637040663845, 0.0726293788660145, 0.06291267824744295, 0.021183520794157085, 0.0709452925640639, 0.03681389621412179, 0.18340407065585274, 0.012859095754950256, 0.11689063343540185, 0.1029953546870589, 0.08370522116950885, 0.07400390352990127, 0.1694166951712699, 0.08711850376654529, 0.08225623358730516, 0.1967194062047115, 0.20727952308284003, 0.07756956193009046, 0.4623916896309975, 0.1335911342647481, 0.15012618554536117, 0.060514663611698216, 0.0491576145342173, 0.1220088347518744, 0.2347341236138244, 0.006819000440609679, 0.049836109282954344, 0.3084885869239916, 0.09150845565700583, 0.5756633121529754, 0.5574096396593944, 0.5584858210104555, 0.6222018989165894, 0.5466067052675672, 0.6632940560095879, 0.6531220255880151, 0.599205575613225, 0.6060105745018318, 0.09658451431113557, 0.11716311137970481, 0.11126387075194655, 0.09691357855348437, 0.06556046440675256, 0.08263168953235367, 0.14338244874328465, 0.18327875367268687, 0.07956520908905163, 0.18361401960086954, 0.2155389927397351, 0.1628856094887704, 0.19267542591436881, 0.2934043988750873, 0.2715581826848976, 0.23597200727542145, 0.2738739860448688, 0.15858977515833717, 0.2799629472194559, 0.4176740241399952, 0.41651737573662206, 0.4936777351486821, 0.5648939826507346, 0.2622508752275401, 0.31598386919633126, 0.24019736248690438, 0.24707104966927695, 0.24826287807835978, 0.25470631667829946, 0.2813923778128482, 0.23801129951999345, 0.20456266493330244, 0.2863697902422092, 0.169957363329171, 0.33208019966561275, 0.2071471191818689, 0.24857797174971707, 0.20748237646904444, 0.22717351168711664, 0.23622753832689536, 0.2731073138679553, 0.32526173134324876, 0.21941490121842555, 0.23136633450856026, 0.2089620020583811, 0.1992148055683528, 0.2115691987463897, 0.186519628751311, 0.1982211015865335, 0.2544369504615204, 0.8826325258900884, 0.21295825062538543, 0.2027087154242757, 0.21262863633542728, 0.16924741114824904, 0.15955223462996304, 0.18241047448129943, 0.16991190359859998, 0.1681650392977705, 0.16342817664316278, 0.13195987071185866, 0.13570862867345934, 0.17738750333084374, 0.6233284006668881, 0.21359734303493372, 0.21093470222530852, 0.6086681270966687, 0.1693703285315996, 0.12713029494062356, 0.1563709883269101, 0.15647784840858658, 0.16967533062681994, 0.178530310880596, 0.20114058522842637, 0.2351260369395618, 0.18319940895369824, 0.18354072709182845, 0.18348313028912766, 0.1966739651048972, 0.189202978521673, 0.20532724707448546, 0.09952619480192448, 0.08181758600236932, 0.09118902617209401, 0.08889037177658887, 0.10351939388450371, 0.09759979317279177, 0.12327991711887354, 0.07776436115187046, 0.09494187790618003]}, "mutation_prompt": null}
{"id": "fd3b629e-1c71-4b98-a7ec-eaf516980ac0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "0b04b499-6eab-4b30-ac09-f4a119d058d6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "7677eeae-90e9-4b68-9456-70563089e6c6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "2cad35db-c26a-4435-9976-b0d447953e62", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "3f94c039-d46a-4d7c-82f1-39fc3660c03c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        # Adaptive inertia weight\n        self.w = 0.9  # Initial inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        \n        # Update inertia weight dynamically\n        self.w = self.w_min + (0.9 - self.w_min) * (1 - (current_eval / self.budget))\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "HybridDEPSO with adaptive inertia weight and dynamic population sizing to enhance exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.31183773924634, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.7829807324982142, 0.8050767491030899, 0.7773759773577142, 0.7623076058614986, 0.18962577178176443, 0.7903505049719912, 0.7639141371804576, 0.7875245009606855, 0.7963499796592926, 0.5245883230117979, 0.5320566765343178, 0.5473861011270037, 0.5384966060245606, 0.5462467190411981, 0.5514107737164973, 0.5382235586340354, 0.545803433511608, 0.5645765677222223, 0.16514292476216053, 0.4757547431819671, 0.16385561630015055, 0.105001420269482, 0.16815902311043152, 0.13832423541278327, 0.16888307439024064, 0.1418804062694078, 0.11082146402002546, 0.1345606241511771, 0.13530792314754725, 0.1460613682957972, 0.1294949122382716, 0.14004308483091676, 0.17040382363729167, 0.1318846302583967, 0.0954577133586546, 0.12122351243316898, 0.9734066747079145, 0.9729102305192103, 0.9627977244725558, 0.970750200233589, 0.9839370071306197, 0.9818077284750736, 0.9711394343735978, 0.9853104735043469, 0.9806485252460149, 0.6196638076812246, 0.05930542842989728, 0.5793584868767765, 0.5981035899570566, 0.5813899705376588, 0.598350889096952, 0.5902664845988175, 0.08864492221941744, 0.5711105746724638, 0.3614212898651705, 0.7600479748686295, 0.22505997250797238, 0.6828644113229452, 0.27784994894524384, 0.7726584188045069, 0.2350387171747188, 0.7499254999282328, 0.23438342066611373, 0.20793231867459694, 0.21721211637046767, 0.20888225355308154, 0.19111126548571478, 0.2198711149300021, 0.11702220940267594, 0.20323672542053361, 0.2116312331955127, 0.23401874607596362, 0.22123127559645406, 0.21757054677292642, 0.21344126093095528, 0.25092345648497216, 0.23275225166572477, 0.2156243655179143, 0.2285388294925529, 0.24038526499411328, 0.2339172165333404, 0.06046246819210277, 0.04072396699532477, 0.0519367005346687, 0.03376391807895629, 0.048081341337150696, 0.004404046509726367, 0.047054036006354716, 0.019900655904551368, 0.10032609886691368, 0.11159995623407226, 0.1748192272489021, 0.1392519384629941, 0.06338269652893547, 0.08807881376160731, 0.1583826594351334, 0.1351961467035302, 0.04371473030741346, 0.1244321605007983, 0.0649813624661727, 0.1429840899577417, 0.04093197600747567, 0.06429139127259476, 0.13144471446195327, 0.19403181367009603, 0.20969589675856826, 0.08182059758712235, 0.19670303859041993, 0.20864750756935657, 0.1508390532940801, 0.12151005080371324, 0.14984821805448023, 0.21741572738836246, 0.037230501762546164, 0.07922998871138531, 0.14835445899218425, 0.1541250481195957, 0.48978295819860274, 0.4992141336223329, 0.5017033687231107, 0.5189146415372916, 0.5128292210194489, 0.5202270696772591, 0.5460576941703597, 0.5287401556273119, 0.541881581097591, 0.10453543180020519, 0.11129110491962124, 0.1270078579244278, 0.13910867937853144, 0.1469024821495668, 0.13738844002869122, 0.13155116744590978, 0.1353300337432194, 0.14315323549533165, 0.19456321150150502, 0.48349163410957285, 0.47935144187120304, 0.2412942994815327, 0.3466059521632229, 0.19334958966085747, 0.1840388099931488, 0.19841991167997908, 0.34693369443706024, 0.30585978255212753, 0.4051502677715848, 0.46445307679482406, 0.47231133012724447, 0.3688504945935459, 0.5138425188279439, 0.5275104542985078, 0.5433513192227338, 0.22258486841244662, 0.28577549707899075, 0.21245429263216098, 0.21512844966067635, 0.25421722329401486, 0.21454133477251802, 0.19356576902345024, 0.20267150781256382, 0.2744369646384789, 0.20304687077791395, 0.22647436788467123, 0.20732361153424328, 0.2027984065584979, 0.20694120379793146, 0.22431158507825188, 0.2170532521194235, 0.201342443726083, 0.22334484386621922, 0.20896918217253913, 0.20708045230624972, 0.21146431570411028, 0.24186945532091464, 0.21470815397915244, 0.23408026470399923, 0.21697471180602057, 0.22828391689587446, 0.24105308751971422, 0.23672053415681438, 0.1778416447896347, 0.19743551104172274, 0.1723491153536021, 0.19996740985605255, 0.17234023178291114, 0.1786275440543592, 0.8354965795069553, 0.8503603313721149, 0.17231744766623236, 0.21101683275114647, 0.6937747674936948, 0.6671983613094502, 0.2093199998854478, 0.128224935761867, 0.8097989004153379, 0.667221275934349, 0.15579963577706635, 0.7299032063547328, 0.18838526917561782, 0.18488222320370773, 0.18722698124201143, 0.20201433606184738, 0.1856899065221197, 0.18700129249395026, 0.17487551920655164, 0.1772374591942225, 0.17789614138291687, 0.09853322645446938, 0.0862537787432911, 0.08724466069129355, 0.1247754138732955, 0.10434298861651892, 0.09688222860704265, 0.09901808963725012, 0.07928914776072526, 0.09258919659956555]}, "mutation_prompt": null}
{"id": "eb170e0f-1a25-4302-9837-4d5e7b58ed0f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "90752ce1-0a43-41dc-8f0f-1a0d095c3ec7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "ae8c424d-c6a8-4e10-9f5a-6aca59bc8e4c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "d695c789-765d-443f-a750-b4d02e200f25", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "edbda706-cdbd-4b8a-a58b-962f94c6a189", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "529958ae-c2ab-4dc9-b489-2610973fb5e2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution parameter\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive (personal) component\n        self.c2 = 1.5  # Social (global) component\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            # Adaptive Mutation\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)  # Adaptive F\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Adaptive Crossover\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)  # Adaptive CR\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            \n            # Selection\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(self.population_size):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            # Clamp velocities\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            \n            # Update position\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate new position\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        # Alternate between Differential Evolution and PSO\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        # Return the best found solution\n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive parameters for F and CR in Differential Evolution to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.9299934048841042, 0.9310831737204878, 0.9247509540855561, 0.9244370235878488, 0.9187912277322237, 0.9327017798081225, 0.9291413689466588, 0.9217214776782021, 0.9148093366049381, 0.838425831007928, 0.8297704239253944, 0.8428798053688396, 0.8488509114353667, 0.8571741554547914, 0.8540790469587463, 0.854048801361069, 0.8519698706886215, 0.8312541600752047, 0.07806135543407633, 0.1603937322961152, 0.14736865197502047, 0.7947294653598067, 0.1478972697329176, 0.12616536435147718, 0.1273893734649062, 0.16129903072419838, 0.1024837532914542, 0.1262584005762858, 0.1178170247719138, 0.11205713147289376, 0.09694965656657872, 0.10101402403492388, 0.1331743680771872, 0.11390599562955772, 0.09682098666155947, 0.14333283202724345, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.8129983970006956, 0.8220868086308666, 0.8299559301092551, 0.8234299972643927, 0.8303509465913386, 0.8229930980382794, 0.8259542808643318, 0.8179767734079455, 0.806171168295396, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.9192007918343507, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.12936110972002846, 0.29208753590491976, 0.27285198080761897, 0.2632269764031775, 0.13106341771879304, 0.23379596464860708, 0.26450292798127717, 0.255261883380281, 0.24505868738711556, 0.27120486005420175, 0.2791808116605796, 0.2591979318099412, 0.29899997740806006, 0.22997010755007652, 0.2875086908472907, 0.134443355767616, 0.13614270785749483, 0.2842976130867414, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0659388497279284, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.09088688660090316, 0.055118012259919635, 0.09855500625827407, 0.09753603774757524, 0.1662390270755495, 0.17154052860267022, 0.19377239350940234, 0.11794448938354563, 0.11141524946447223, 0.15759327473507567, 0.19645505251605277, 0.0433702221327783, 0.16578708786045682, 0.08138260372316053, 0.20535364675838497, 0.16630438113958357, 0.21187902716141893, 0.10936185694829714, 0.6019893959109841, 0.5916420458419862, 0.572736915585512, 0.5799545708508298, 0.5858061184060739, 0.18270576221850954, 0.5959239709552941, 0.6338939894652755, 0.6347162667620785, 0.07655743857856445, 0.08398713592857199, 0.1114102811376233, 0.126227056218836, 0.08266542767798546, 0.1611707195907569, 0.0962304840861109, 0.1610445870692998, 0.11682004847748795, 0.2145446329191082, 0.2660992785930105, 0.27416714989814306, 0.20227085230943975, 0.2643567929350392, 0.25549582508830526, 0.26736398996230715, 0.24671202527279634, 0.17272020691098167, 0.4832663954792702, 0.2601509895362101, 0.28966083184776636, 0.3990835795039348, 0.3450538285090017, 0.30837305422453276, 0.4873879218108159, 0.41463842348218627, 0.22171233671557766, 0.17439774705222078, 0.2909967616250456, 0.23467298468480735, 0.17145975744263853, 0.22868862308280113, 0.24066522492682785, 0.15003307275895716, 0.2910833051430842, 0.32473842649894213, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.2090248594761569, 0.8709908683459674, 0.18539732866341097, 0.1841936853077193, 0.20969494497788443, 0.1941018825059, 0.2100562140150659, 0.21014164159145698, 0.2000159327426373, 0.17875148814576713, 0.19888762217041833, 0.1708749758548238, 0.17302813967336517, 0.16980203200690813, 0.9455749752144912, 0.932572015931127, 0.9388248624851367, 0.1082586567521765, 0.2126146765192024, 0.8233065329363647, 0.845949280605288, 0.20880828090287296, 0.12829229533811726, 0.9316044013871199, 0.10490500295996719, 0.15677262188094088, 0.1283604910954993, 0.20416114971191646, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355159644354406, 0.09305940226553355, 0.09455552177043758, 0.1358212332343941, 0.09847368764017683, 0.10075109927608705, 0.10517386108985283, 0.09985930374806795, 0.09472453203938402]}, "mutation_prompt": null}
{"id": "e637c7eb-cd10-4f5d-974b-860f62b2a620", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.max_population_size = 30  # Adjusted maximum population size\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.initial_population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        population_size = len(self.populations)\n        for i in range(population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(len(self.populations)):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        \n        # Adjust population size based on convergence\n        if np.std(self.personal_best_scores) < 0.01 and len(self.populations) < self.max_population_size:\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n            self.populations = np.vstack([self.populations, new_individuals])\n            new_velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (5, self.dim))\n            self.velocities = np.vstack([self.velocities, new_velocities])\n            self.personal_best_scores = np.append(self.personal_best_scores, [np.inf]*5)\n            self.personal_best = np.vstack([self.personal_best, new_individuals])\n        \n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO by incorporating a dynamic population size and velocity adjustment based on convergence rate to enhance exploration and exploitation.", "configspace": "", "generation": 98, "fitness": 0.34939201381517426, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "d939ae39-4bf6-4367-824c-b7e2b6a9d658", "metadata": {"aucs": [0.914640610412153, 0.9164814118425771, 0.9126632014701082, 0.9015765269126946, 0.9130401269787658, 0.9209112434001742, 0.9169477131122268, 0.9009561106609125, 0.8981725474029661, 0.8292073510621318, 0.8148294671540928, 0.8353001160610257, 0.8306516952439396, 0.8467949265017047, 0.8229597424767912, 0.8370396385147866, 0.8445154069321464, 0.817213883907936, 0.08041130907054594, 0.16039354706056252, 0.14736854886268425, 0.7884144494486514, 0.1478969794693148, 0.12616532396472502, 0.12738934528946488, 0.16129908852256813, 0.1024837601341464, 0.1262582154723083, 0.11781684539605197, 0.112057185075915, 0.09694966512057768, 0.10101405111876138, 0.13317430167016941, 0.11390588532987511, 0.09682098692499752, 0.14333261827690402, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.7503452762124396, 0.7945046166235054, 0.8107186830460651, 0.8219785220868511, 0.7695865480494122, 0.7798608953552367, 0.7669020267836403, 0.7997651239624919, 0.787587189920731, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.922959044819144, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.1282982613380027, 0.2736932931678745, 0.25220780774482077, 0.24795651894527615, 0.13031494365898577, 0.24965368963017254, 0.2450100909139996, 0.26251196558079815, 0.2681295112188544, 0.26510936219572145, 0.2695010119502814, 0.26471278985005176, 0.28155358443536616, 0.22620812191936246, 0.255250383792079, 0.1336337076895595, 0.13614314495273538, 0.2860168664095034, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0657696939592326, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.0908602934035363, 0.05510432140519805, 0.09856059505822723, 0.0975257294759233, 0.16620306699294418, 0.17152934918089557, 0.19373594504802016, 0.11792748174645096, 0.11139927443530573, 0.15761554701931635, 0.19645599286659488, 0.04336547084284503, 0.1657855228431363, 0.08138287087263962, 0.20536321276006442, 0.16630214697164136, 0.2118820692983322, 0.10936529055779776, 0.5588785940179384, 0.6087024730604194, 0.5798633097441008, 0.5849206994324014, 0.5786491123333173, 0.5231299599428273, 0.6060005316980994, 0.6720895841170486, 0.6105857661644445, 0.07655735205228609, 0.08398712793343566, 0.11141028096969985, 0.1262270419605025, 0.08266533636423012, 0.16117084445895258, 0.09623048350009433, 0.1610443313171529, 0.11682001600353287, 0.2136833993745617, 0.26646637907180504, 0.2741558526204345, 0.2022240215183453, 0.2590374951558291, 0.2545747748840508, 0.2670463696904196, 0.24670452600882498, 0.17285468282050187, 0.5632335283036375, 0.25953909796008734, 0.28954672539176596, 0.4136250670585703, 0.34525478629754647, 0.3077168344346243, 0.36334328981312647, 0.4618274757928402, 0.22054048336014365, 0.1743975490734878, 0.2922305314406364, 0.23468223705241253, 0.17144298088169085, 0.22998100956225587, 0.2400652653348586, 0.15002734509289561, 0.2934628075806258, 0.3247458081904566, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.20902490137850227, 0.8608888690504322, 0.18539722048926055, 0.1841935736486101, 0.20969477579168083, 0.1941017829363052, 0.2100545106261077, 0.2101415612026506, 0.2000162728103101, 0.17874983217497087, 0.19888756509052086, 0.170874864575993, 0.17302730358499063, 0.16980202147219592, 0.944038473775332, 0.9261853104166348, 0.9350620976687954, 0.10838229347346606, 0.21261455907213844, 0.8450431653076602, 0.8084025775044077, 0.20880563302039168, 0.1282920553892134, 0.9167777404863446, 0.7089281393516109, 0.15677234106033033, 0.12836018495144086, 0.2041611473967705, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355127757731186, 0.09305390851950746, 0.09455552177043758, 0.13582130983233198, 0.0984731150687328, 0.10075100133590498, 0.10516606149358954, 0.09985930374806795, 0.0947245074312234]}, "mutation_prompt": null}
{"id": "1dd54c8b-5822-4939-b8cf-7a3a596b7b81", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.max_population_size = 30  # Adjusted maximum population size\n        self.F = 0.8\n        self.CR = 0.9\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.populations = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_scores = None\n    \n    def initialize(self):\n        self.populations = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.initial_population_size, self.dim))\n        self.personal_best = np.copy(self.populations)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        \n    def differential_evolution(self, func, current_eval):\n        population_size = len(self.populations)\n        for i in range(population_size):\n            if current_eval >= self.budget:\n                break\n            indices = [idx for idx in range(population_size) if idx != i]\n            a, b, c = self.populations[np.random.choice(indices, 3, replace=False)]\n            F_adaptive = self.F + (0.2 * np.random.rand() - 0.1)\n            mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n            CR_adaptive = self.CR + (0.1 * np.random.rand() - 0.05)\n            trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, self.populations[i])\n            trial_score = func(trial)\n            current_eval += 1\n            if trial_score < self.personal_best_scores[i]:\n                self.populations[i] = trial\n                self.personal_best_scores[i] = trial_score\n                self.personal_best[i] = trial\n        return current_eval\n    \n    def particle_swarm_optimization(self, func, current_eval):\n        global_best_idx = np.argmin(self.personal_best_scores)\n        global_best = self.personal_best[global_best_idx]\n        \n        for i in range(len(self.populations)):\n            if current_eval >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] + \n                                  self.c1 * r1 * (self.personal_best[i] - self.populations[i]) + \n                                  self.c2 * r2 * (global_best - self.populations[i]))\n            \n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n            self.populations[i] = np.clip(self.populations[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            score = func(self.populations[i])\n            current_eval += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best[i] = np.copy(self.populations[i])\n        \n        # Adjust population size based on convergence\n        if np.std(self.personal_best_scores) < 0.01 and len(self.populations) < self.max_population_size:\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n            self.populations = np.vstack([self.populations, new_individuals])\n            new_velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (5, self.dim))\n            self.velocities = np.vstack([self.velocities, new_velocities])\n            self.personal_best_scores = np.append(self.personal_best_scores, [np.inf]*5)\n            self.personal_best = np.vstack([self.personal_best, new_individuals])\n        \n        return current_eval\n\n    def __call__(self, func):\n        self.initialize()\n        current_eval = 0\n\n        while current_eval < self.budget:\n            current_eval = self.differential_evolution(func, current_eval)\n            if current_eval < self.budget:\n                current_eval = self.particle_swarm_optimization(func, current_eval)\n        \n        best_idx = np.argmin(self.personal_best_scores)\n        return self.personal_best[best_idx], self.personal_best_scores[best_idx]", "name": "HybridDEPSO", "description": "Improved HybridDEPSO by incorporating a dynamic population size and velocity adjustment based on convergence rate to enhance exploration and exploitation.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e637c7eb-cd10-4f5d-974b-860f62b2a620", "metadata": {"aucs": [0.914640610412153, 0.9164814118425771, 0.9126632014701082, 0.9015765269126946, 0.9130401269787658, 0.9209112434001742, 0.9169477131122268, 0.9009561106609125, 0.8981725474029661, 0.8292073510621318, 0.8148294671540928, 0.8353001160610257, 0.8306516952439396, 0.8467949265017047, 0.8229597424767912, 0.8370396385147866, 0.8445154069321464, 0.817213883907936, 0.08041130907054594, 0.16039354706056252, 0.14736854886268425, 0.7884144494486514, 0.1478969794693148, 0.12616532396472502, 0.12738934528946488, 0.16129908852256813, 0.1024837601341464, 0.1262582154723083, 0.11781684539605197, 0.112057185075915, 0.09694966512057768, 0.10101405111876138, 0.13317430167016941, 0.11390588532987511, 0.09682098692499752, 0.14333261827690402, 0.9655881093739518, 0.9528378855362162, 0.9733022910170798, 0.9617506803949503, 0.9816981266253013, 0.9805813645895374, 0.9746131324444955, 0.9858694531242541, 0.9791907532803211, 0.7503452762124396, 0.7945046166235054, 0.8107186830460651, 0.8219785220868511, 0.7695865480494122, 0.7798608953552367, 0.7669020267836403, 0.7997651239624919, 0.787587189920731, 0.1397304799895306, 0.2290510458973758, 0.14048174115888956, 0.9057665055492468, 0.28126467001993427, 0.922959044819144, 0.23657404206689137, 0.8626528780398892, 0.22643811347911558, 0.1282982613380027, 0.2736932931678745, 0.25220780774482077, 0.24795651894527615, 0.13031494365898577, 0.24965368963017254, 0.2450100909139996, 0.26251196558079815, 0.2681295112188544, 0.26510936219572145, 0.2695010119502814, 0.26471278985005176, 0.28155358443536616, 0.22620812191936246, 0.255250383792079, 0.1336337076895595, 0.13614314495273538, 0.2860168664095034, 0.05126707180663448, 0.045307663684329924, 0.008828330168630827, 0.04479127644312941, 0.13623560232299825, 9.999999999998899e-05, 0.11367038786216221, 0.05671131545111452, 0.0657696939592326, 0.09577457611018492, 0.07274148184478813, 0.12616105768010888, 0.09817445808206593, 0.08732759207181129, 0.07702325053152204, 0.1401100383468178, 0.10918954909012968, 0.19374546581569385, 0.0908602934035363, 0.05510432140519805, 0.09856059505822723, 0.0975257294759233, 0.16620306699294418, 0.17152934918089557, 0.19373594504802016, 0.11792748174645096, 0.11139927443530573, 0.15761554701931635, 0.19645599286659488, 0.04336547084284503, 0.1657855228431363, 0.08138287087263962, 0.20536321276006442, 0.16630214697164136, 0.2118820692983322, 0.10936529055779776, 0.5588785940179384, 0.6087024730604194, 0.5798633097441008, 0.5849206994324014, 0.5786491123333173, 0.5231299599428273, 0.6060005316980994, 0.6720895841170486, 0.6105857661644445, 0.07655735205228609, 0.08398712793343566, 0.11141028096969985, 0.1262270419605025, 0.08266533636423012, 0.16117084445895258, 0.09623048350009433, 0.1610443313171529, 0.11682001600353287, 0.2136833993745617, 0.26646637907180504, 0.2741558526204345, 0.2022240215183453, 0.2590374951558291, 0.2545747748840508, 0.2670463696904196, 0.24670452600882498, 0.17285468282050187, 0.5632335283036375, 0.25953909796008734, 0.28954672539176596, 0.4136250670585703, 0.34525478629754647, 0.3077168344346243, 0.36334328981312647, 0.4618274757928402, 0.22054048336014365, 0.1743975490734878, 0.2922305314406364, 0.23468223705241253, 0.17144298088169085, 0.22998100956225587, 0.2400652653348586, 0.15002734509289561, 0.2934628075806258, 0.3247458081904566, 0.2292344745439805, 0.19811734196861952, 0.2085948435919991, 0.21867587753325268, 0.22725527037891757, 0.23580639321894992, 0.21560095095830378, 0.22405540390708756, 0.26179893755386396, 0.20902490137850227, 0.8608888690504322, 0.18539722048926055, 0.1841935736486101, 0.20969477579168083, 0.1941017829363052, 0.2100545106261077, 0.2101415612026506, 0.2000162728103101, 0.17874983217497087, 0.19888756509052086, 0.170874864575993, 0.17302730358499063, 0.16980202147219592, 0.944038473775332, 0.9261853104166348, 0.9350620976687954, 0.10838229347346606, 0.21261455907213844, 0.8450431653076602, 0.8084025775044077, 0.20880563302039168, 0.1282920553892134, 0.9167777404863446, 0.7089281393516109, 0.15677234106033033, 0.12836018495144086, 0.2041611473967705, 0.19433604668693782, 0.1933058114488464, 0.18825093992665254, 0.23130538919093047, 0.20814315890075108, 0.19904794607978493, 0.21301991738717396, 0.20029525833496187, 0.10355127757731186, 0.09305390851950746, 0.09455552177043758, 0.13582130983233198, 0.0984731150687328, 0.10075100133590498, 0.10516606149358954, 0.09985930374806795, 0.0947245074312234]}, "mutation_prompt": null}
