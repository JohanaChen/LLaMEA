{"id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.26129299788939, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "faaef321-4431-4d85-b573-b1fb9d2e633a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "798722bb-05d7-4311-bb81-01514e8aad58", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "3b16f2be-d52e-425a-947d-7feae17e0705", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "ec26ba17-88bf-403d-a6ef-b4c0faed8809", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.5  # Initial crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < (self.cr + 0.1 * np.random.rand())  # Dynamic CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection with elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial.copy()\n                        best_fitness = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        return best_solution, best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "The algorithm enhances diversity by dynamically adjusting crossover probability and integrates elitism to retain the best solutions, improving convergence.", "configspace": "", "generation": 4, "fitness": 0.22214658062450407, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6720402115801267, 0.6660479049807, 0.696718808836721, 0.6744411674592397, 0.6827987776616329, 0.6837900401745017, 0.6721231117416908, 0.6666079116441357, 0.6739778560921308, 0.44681066743350883, 0.4205947541497158, 0.45790299149223523, 0.42025585207993277, 0.4077614810037715, 0.4205163996398391, 0.4401442641338529, 0.4118653168232298, 0.44231360352634597, 0.17073248247449269, 0.16155292235179763, 0.17271532556630587, 0.15175399913069454, 0.16711204079741726, 0.16734539010729754, 0.18934994652763304, 0.13796357803974135, 0.14081881343547398, 0.1475292532243928, 0.14584401237473066, 0.16942292803878467, 0.15086499562533773, 0.14517899795964062, 0.1589243500463, 0.1369775340512177, 0.13869071971136526, 0.1358941866325909, 0.9664115137440741, 0.9472104363884929, 0.9314847982427809, 0.9442254977856822, 0.965791345576035, 0.9724753340864545, 0.9537519898875968, 0.955654160681064, 0.9728769296038399, 0.2399759880028698, 0.21193721811196498, 0.25092870143413404, 0.23445679582627754, 0.22915727048599766, 0.26015464468773064, 0.21827502585546332, 0.20377557348021968, 0.21452345428908626, 0.23629162981095764, 0.19816692225565957, 0.2106393295479677, 0.2382927893749871, 0.24479900047945735, 0.2520988302031979, 0.21059365837436994, 0.22913614877897082, 0.2236644265066131, 0.1379576618541276, 0.13560066330077736, 0.12353893318421338, 0.12668157713312667, 0.13894152523079506, 0.14534410318211943, 0.1442481009906431, 0.13950869713470204, 0.13692616404344504, 0.09786142391790142, 0.07557605510190657, 0.11216628168335885, 0.15181377800731666, 0.13502787085279944, 0.13739168405859892, 0.12238305261161209, 0.1106538311328521, 0.11085587624175464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010612693179123944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0493056832280927, 0.08132216380303303, 0.06600760408178152, 0.06411803591294396, 0.04806152208062864, 0.06824657244662358, 0.08574367100184532, 0.10087156348211501, 0.07357043827987164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07641208461690185, 0.06510261415229046, 0.07098390306089986, 0.0735540480766993, 0.10413155150751796, 0.08212193875943796, 0.07448868752464588, 0.07649124553931252, 0.08115039424664361, 0.40490019720489745, 0.4303857582357189, 0.44400939337929834, 0.41989527681784455, 0.4253023501416785, 0.4277333725423156, 0.421050855906674, 0.3963909310932763, 0.4349998728219321, 0.10611843630682993, 0.11248724264973076, 0.09231643829959779, 0.07802717831242445, 0.08024811478235838, 0.08561159062984591, 0.08152022665927305, 0.07879949390198038, 0.10509512882375494, 0.15196402621639504, 0.1478139704733309, 0.13212656388856814, 0.13411717741322282, 0.14419572338783004, 0.15014418982664424, 0.13284632571272836, 0.12556459672164533, 0.1403571026972179, 0.23026389480698595, 0.23877490264964174, 0.23906074108199316, 0.21373576496207802, 0.23046192892001105, 0.2398498855098744, 0.2710963950014148, 0.27745808015356743, 0.25710874512304827, 0.16846545142965774, 0.16506265855296864, 0.17104340324653167, 0.16434253510840335, 0.1645771033471598, 0.16311541269474206, 0.18335114681536668, 0.1694164961716057, 0.17132051989890207, 0.18743786852984334, 0.18676255955242016, 0.19514318335049174, 0.16723047851628248, 0.1710094881811478, 0.19000907598684014, 0.19094263660609856, 0.19013765134391158, 0.21951490184305233, 0.17429039308781336, 0.1882816726851958, 0.1876135962672174, 0.17929985460927111, 0.19908814476222325, 0.20364477207543918, 0.18641838265257893, 0.19702928850828272, 0.19382459775221506, 0.2149604973136755, 0.16038889076052587, 0.20141877775168482, 0.17068888524542325, 0.1853819736017579, 0.16501591413631977, 0.15777256791694394, 0.17350120145399872, 0.25125798401976085, 0.1592747956957019, 0.22809410813086395, 0.17025203331504768, 0.22022890395784378, 0.16130990678860857, 0.13609960055029846, 0.25022906543534873, 0.25102859381203346, 0.27065836150426525, 0.19106677638595027, 0.1865843764769305, 0.2025441321788467, 0.20136666243182, 0.1750815272960795, 0.18616468850099432, 0.20131423579751073, 0.19122863958752956, 0.1878767964010638, 0.06767342323331416, 0.06556178680424274, 0.06905337660041477, 0.07094855678456513, 0.0706453221784692, 0.07023398780033507, 0.0693930809069121, 0.07643066256783115, 0.07462703649307256]}, "mutation_prompt": null}
{"id": "e6e04f66-4d8a-4e7e-adc4-14730b9d8530", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "6aa739c5-8c37-4c4c-bbd0-fa44eeadc53c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "d4551880-72d7-4b6d-a10c-c9752f57879f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive step sizes and local exploitation to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "a1fc70eb-6ec5-48fa-814a-3f27336b23ff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Initial crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        dynamic_pop_size = self.pop_size\n\n        while evals < self.budget:\n            for i in range(dynamic_pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(dynamic_pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                dynamic_cr = self.cr * (1 - (evals / self.budget))  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < dynamic_cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population resizing\n            if evals % (self.budget // 10) == 0 and dynamic_pop_size > 4 * self.dim:\n                dynamic_pop_size = int(dynamic_pop_size * 0.9)\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolutionPlus", "description": "AdaptiveDifferentialEvolutionPlus introduces a dynamic population resizing strategy and adaptive crossover probabilities to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.23773273728563443, "feedback": "The algorithm AdaptiveDifferentialEvolutionPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6682307935271664, 0.6418039428183802, 0.6916279327802624, 0.7004963883587736, 0.7079458865094175, 0.7152895381449091, 0.7006209680475579, 0.7124038466359055, 0.6953164269246064, 0.5017124506578269, 0.4807053098484688, 0.5126708542850174, 0.4883626052964869, 0.48764101645564606, 0.4500806855104258, 0.49773451388965495, 0.506316940252342, 0.50914596397443, 0.23250997504162974, 0.22019318800980048, 0.2033840099249412, 0.20386191212681903, 0.22150181429559312, 0.20373950379828432, 0.2010284709743413, 0.21394847175829523, 0.2448917750909534, 0.18366242212341066, 0.17126251780186064, 0.18254880777433213, 0.2196327137551961, 0.1589846873556684, 0.19070255827529048, 0.16670632233817828, 0.18512597148456922, 0.18569505095489347, 0.9806164642140757, 0.9109763499743496, 0.9440303445508962, 0.9539777565392153, 0.9671427154562356, 0.9427630927185668, 0.9715132985611343, 0.9526787924348913, 0.9689147118055341, 0.23719418871790143, 0.24341768006943965, 0.22132427263267773, 0.2485769267491934, 0.2336908712340462, 0.24730830892401878, 0.2580672464161069, 0.2276509067654825, 0.23892829524454196, 0.2857375190785245, 0.23754631037827922, 0.24227544698864556, 0.23509123502242324, 0.24469577769654594, 0.2763997518613627, 0.23252520378228847, 0.2987619342975213, 0.265688448359101, 0.14298810259918193, 0.15009204147787258, 0.14109018677681684, 0.148644881779871, 0.14661820951806492, 0.14480370665171394, 0.1539448005262637, 0.14800996187664062, 0.12473496980990495, 0.09439395641854842, 0.10578550272959697, 0.12915544038749738, 0.1337729668980635, 0.12221826605639852, 0.13346557777592993, 0.11237178253817204, 0.1180515182579076, 0.16395264374652996, 9.999999999998899e-05, 9.999999999998899e-05, 0.021503349872176836, 0.00038117799555170695, 9.999999999998899e-05, 0.0017048715957777016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08438595328609189, 0.06563543880798317, 0.10115986746782835, 0.07015123768279996, 0.058680768055906496, 0.05489864351004403, 0.09294773845523618, 0.08305865183485384, 0.09455627752176066, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0883617921552513, 0.08408097891776911, 0.09640436638046135, 0.11426875014918092, 0.10208711447219831, 0.11024454671923811, 0.07915963163580142, 0.07236855041839951, 0.10659911942799594, 0.4119081046866109, 0.42695734233513805, 0.44723569600596746, 0.4056758230299832, 0.4404749941899355, 0.4281725911690263, 0.4348627555685671, 0.4394500591540744, 0.455189478976349, 0.09698482787797802, 0.08837988084064541, 0.09768515403960987, 0.08653832401262496, 0.09834546949316625, 0.08413371586522644, 0.0885938791261236, 0.09012787344262074, 0.09161742457446342, 0.1494514510170999, 0.15524607479889985, 0.15189715381626212, 0.20397860845477434, 0.1607077720504232, 0.1562286142732754, 0.139300830356903, 0.15044014701202557, 0.13989444952926733, 0.26301052523903135, 0.25688413116238784, 0.2657579864305627, 0.22725461156967197, 0.23799994429073446, 0.24652207139428395, 0.27677351742460243, 0.28181269711458823, 0.2806698262501862, 0.1905473388640142, 0.1735574698727087, 0.18827109065094338, 0.16913510402147292, 0.17774693809690711, 0.17849668683901, 0.21055687245965204, 0.2063624939000107, 0.19262034677059803, 0.2026046047807899, 0.17179761450721598, 0.19203727956822725, 0.21426731510817554, 0.17188034425596777, 0.18867857921162823, 0.17700708699962542, 0.19454244248394392, 0.19549369582493015, 0.18940564797065151, 0.21462991372281415, 0.20882471062611496, 0.20657640091892382, 0.19831559282332278, 0.1925326459288611, 0.18290931504980612, 0.18210751077071452, 0.19649948835823583, 0.166270205124034, 0.296012766076732, 0.20913597520203575, 0.28742171373105263, 0.3269977411499799, 0.18481796502120762, 0.3334615697292672, 0.17493394054760103, 0.1541720859086183, 0.2691143255190104, 0.19485175076555095, 0.20876829679373987, 0.17247417486081562, 0.17982343036719017, 0.22211251085476935, 0.2906368783057466, 0.2165565123534554, 0.2108047894719488, 0.18049661157588393, 0.19378919173319853, 0.18652326271669895, 0.17463998220266697, 0.1879410631649463, 0.17259549235944904, 0.18723016743866672, 0.18931156738799182, 0.18089387703466708, 0.06792127546640403, 0.07518629550133515, 0.07259617723025003, 0.07490964738067907, 0.0764348823243175, 0.0705041235767192, 0.06973011825916364, 0.07047948118244263, 0.07393963895883537]}, "mutation_prompt": null}
{"id": "876121a8-5a00-495e-85e3-436940dfa165", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.2637548869759283, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "7305ee6c-6490-4821-a42f-8ec24a1e9eb0", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "f840d5e8-b0da-4db5-b04d-a97ed3ac660f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "12a4f466-8aee-41ab-8727-16afdc2cf6d0", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "008a6e84-4f67-4f54-85ed-23d2ce738930", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "34f9f2e6-13e5-4f98-926a-030d81539514", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "de95ca6a-25dc-48a4-872b-4c89507eb0db", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "f1ab6199-115d-4fa9-95fc-9c8c3892cc6e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "bc47782f-712f-4fc1-be1f-613573edd416", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "dd60509b-635c-46b0-a527-64203e564b36", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def chaos_mutation(self, x):\n        # Logistic map for chaos-based mutation\n        a = 4.0  # Logistic map parameter\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * a * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                \n                # Chaos-based mutation\n                chaotic_ratio = np.random.rand()\n                mutant = np.clip(a + self.f * (b - c) + chaotic_ratio * (self.chaos_mutation(a) - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                top_percentage = 0.2\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Introducing chaos-based mutation to improve exploration and enhance diversity within Enhanced Differential Evolution.", "configspace": "", "generation": 17, "fitness": 0.07252607442100761, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.12081867603285679, 0.09570004465541948, 0.12733535305302723, 0.1483488009992734, 0.14115755933196505, 0.13429864142893422, 0.11536080278703897, 0.11518648378254326, 0.114373801788626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018824351954200957, 0.01467079663371329, 0.0171071285540767, 0.011645116130313493, 0.020714497384025865, 0.011380176082762206, 0.024869833558874732, 0.019452614381714195, 0.02634647231075682, 0.03096284637072222, 0.001030260954374862, 0.009320027519431617, 0.01959972157639278, 0.0004952459975243739, 0.01765274852801335, 0.014763392921912755, 0.0017501413375672348, 0.002500597422236739, 0.08547795702039007, 0.07158977667834077, 0.11967835277509908, 0.3385801208700765, 0.14383047135267657, 0.49768756366845535, 0.9912098702994772, 0.9707771908763907, 0.9838192707764315, 0.06274794416174423, 9.999999999998899e-05, 0.0011194551091633365, 0.023939319306083395, 0.00031549654350837564, 0.004815521844883541, 9.999999999998899e-05, 0.013290834975899779, 0.003919114536732327, 0.10027683525177622, 0.08224659834595494, 0.059824388882108726, 0.0667108215001172, 0.11538763761379245, 0.0573742607273221, 0.0674847445823138, 0.05931056463008866, 0.01748323993917078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001492556804543188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001045374982522107, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006797872905566327, 0.022295823306718976, 0.030459561116882083, 0.027096057119615713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012236489977555332, 0.026147090398907835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12304899666800229, 0.15756555760738078, 0.14838054695461433, 0.1701180104344714, 0.17642170343772956, 0.13187754306178945, 0.16112956940342849, 0.13315559699383572, 0.12444681967160909, 0.027535452994640552, 0.009933792931027141, 0.02198412468535549, 0.03266886175302153, 0.00039976264592844757, 0.024400641967945003, 0.016112506400694282, 0.009760334442059815, 0.0267656688986897, 0.10461002747055659, 0.11542644445740391, 0.11842175776965747, 0.10034396034463722, 0.11482905219369333, 0.10965221383641655, 0.13855715448506745, 0.13192656134114145, 0.14526383159255452, 0.11321584420080888, 0.13797643370598378, 0.1613932299901244, 0.13800672315110074, 0.11452801297456061, 0.1348681734471322, 0.1226334026189263, 0.17377774300845283, 0.12240355604632513, 0.06257851341278875, 0.08012871276296463, 0.08398582550377798, 0.07512865198459129, 0.06406947898089654, 0.08448695711758925, 0.08708797521242873, 0.0997711199450243, 0.07727656198159438, 0.11943364695601921, 0.10588223250505757, 0.13345086981233123, 0.1198376419202225, 0.11411817260332413, 0.11243075905366773, 0.12245976138762271, 0.11360356106235814, 0.1261963614278906, 9.999999999998899e-05, 0.012588943473545111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010428841029557212, 9.999999999998899e-05, 9.999999999998899e-05, 0.07493167043936777, 0.11324026891951577, 0.08278882657492437, 0.10210506958808563, 0.1207914665021157, 0.10817372740509801, 0.13663850367916985, 0.11721049636960912, 0.07647171702040834, 0.14632290771167644, 0.10554925887960076, 0.07923214574717219, 0.07463140198267815, 0.09575414026586859, 0.11741895419711113, 0.07414387496393227, 0.07946702797603744, 0.10774734062399638, 0.16032839695670298, 0.15178108293935944, 0.1577447150975808, 0.1895827595096341, 0.1599416220335057, 0.19111906740237927, 0.2097427210788011, 0.1647558417299535, 0.15772171574475846, 0.02280187408703116, 0.029172622655375346, 0.031393493129599714, 0.030448876296113703, 0.03839481591030924, 0.02170940079901429, 0.02821578065096131, 0.03803354422653826, 0.02444973288912311]}, "mutation_prompt": null}
{"id": "7f3dcd32-2648-41f8-83b0-23b76dd362eb", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "71a1c5d1-0215-4038-95c2-df88b8e86cbc", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "5e2ca353-bb26-46cb-b974-c340ed0dfc66", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution by integrating a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6286489363147207, 0.6290365237141007, 0.5964469572926852, 0.6182841941283234, 0.6544852049296725, 0.6387787771507701, 0.6130120172777018, 0.6482390274308126, 0.6045275712444859, 0.39252861530765504, 0.3915458109064436, 0.363709028424696, 0.3645185250310118, 0.36528760655576886, 0.3887488340948738, 0.3971353786630838, 0.3770245093925859, 0.3986989381201038, 0.08936634161534662, 0.10558570694894842, 0.09571873987214785, 0.12567550980579434, 0.0907044032717369, 0.0859512681098269, 0.08707325063877325, 0.10447868455701159, 0.08639030777324552, 0.08377115095262033, 0.08936490055441759, 0.08098557548544028, 0.08748758940539847, 0.09739566935252719, 0.10233034246204153, 0.0965063418452411, 0.08187875892024077, 0.08619387157065017, 0.9487281291430295, 0.9646831406868377, 0.8953589570500481, 0.9320127842513342, 0.9692281508624123, 0.9188300358511868, 0.9131555483409508, 0.9549405126165614, 0.9446632710437164, 0.3005381574287882, 0.27512085938202446, 0.27903976698781885, 0.2655400753274577, 0.25707672566372053, 0.28839897831324546, 0.304665721944796, 0.294676297391238, 0.25256227991556035, 0.4432686337053787, 0.5069567330569101, 0.4570721212263239, 0.5659510927054406, 0.5148918209537312, 0.48822525317012533, 0.44845080553876404, 0.48015090669144234, 0.5737686283486952, 0.2035546637227782, 0.21776809723216506, 0.1922617264935097, 0.19295551666490351, 0.19112727903053184, 0.20329909590601114, 0.18248697816012438, 0.18558590681939324, 0.19039232121668004, 0.26590810672092635, 0.20262412557322063, 0.2478705277570349, 0.19896570748771414, 0.1898945574843749, 0.21006400128611358, 0.20116059360641014, 0.18038861883098667, 0.17767191801210325, 0.1452734902820655, 0.13419412053226643, 0.11332992200070768, 0.137437781847207, 0.1207874242023077, 0.12707341679536877, 0.13972760994258426, 0.1197476498699711, 0.10871034497075993, 0.2372446908742849, 0.24260722856793426, 0.2492488941111617, 0.24630176255767477, 0.2137158125515749, 0.26388227431289246, 0.3063046928730374, 0.2989901507202055, 0.26534093388673163, 0.02290889934761131, 0.02591889892228827, 0.04208512626824101, 0.027977756595870096, 0.0424996658587683, 0.03628238413466023, 0.024462741223342688, 0.03054744951406596, 0.02546818390063732, 0.14836226873515057, 0.15120061630071546, 0.14058683801107985, 0.1542719055574211, 0.16642226295977802, 0.17521075820028742, 0.1506585679995751, 0.16930453633705456, 0.13900460521913716, 0.4772795602417985, 0.47124016554218195, 0.4960849290168735, 0.4603916665327743, 0.47956021940045834, 0.4847520214337866, 0.4889447937663556, 0.4887621540922402, 0.5102272801033869, 0.08283186723016023, 0.09203737322930738, 0.08511227336660054, 0.09012520746718622, 0.07842140372037942, 0.08006729809752633, 0.0776528873084128, 0.0850334709407995, 0.10027784781062932, 0.1629030350610905, 0.15091162382133938, 0.16182748148229198, 0.15600236355612995, 0.2148041044216389, 0.1642484561167179, 0.16668143678430913, 0.1718860013332726, 0.13001445116362775, 0.2800700269528317, 0.2623690925213825, 0.2773767616844305, 0.2496105087899929, 0.26728628969468393, 0.2612840531140279, 0.28553508864734845, 0.29493433668584024, 0.2810541161776592, 0.2011179277827756, 0.20205922748909844, 0.2088491578670184, 0.1995818615799131, 0.18958932488632851, 0.19705791207008427, 0.21271066441803677, 0.2307769525190434, 0.2129105692368527, 0.2114910113239462, 0.20397208665417932, 0.171606719322961, 0.18253183604709133, 0.175745960171248, 0.18280043286897074, 0.17650494360339652, 0.18242332694377494, 0.1704631014016772, 0.17242692775126722, 0.17819966963457212, 0.1697523791339698, 0.17213333486776572, 0.16844107167432953, 0.18192356056687764, 0.1785569897677548, 0.192979563358329, 0.1790643452523596, 0.18533052331237476, 0.5902708846402491, 0.4856995792726977, 0.3198947236678318, 0.18250987862600454, 0.49862916323406836, 0.3155609145202075, 0.29313711144920185, 0.39279549916310574, 0.43392756880126304, 0.19851866206197177, 0.3801537697802895, 0.1738959202317284, 0.17245374838186, 0.29257035812673415, 0.20587867857115405, 0.2046380522096266, 0.19423012634701542, 0.20401783836094423, 0.18188717529114362, 0.19179354566340112, 0.1809332872404551, 0.17465066987739974, 0.18648555952272294, 0.17766005783292327, 0.18628840342817965, 0.176507246048902, 0.0835297512194334, 0.0825744567429425, 0.05923596284628507, 0.06772275739011524, 0.06991333596532456, 0.06939811580258937, 0.07864984732699087, 0.07342352688856735, 0.07047471674388339]}, "mutation_prompt": null}
{"id": "42d40b91-14e6-4584-8ba6-3394c4e7c1b7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Dynamic mutation factor\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n                \n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                self.cr = 0.5 + 0.5 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                \n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evals % eval_step == 0:\n                top_percentage = 0.2  # Keep top 20%\n                keep_size = max(2, int(top_percentage * self.pop_size))\n                best_indices = fitness.argsort()[:keep_size]\n                population = population[best_indices]\n                fitness = fitness[best_indices]\n                new_members = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - keep_size, self.dim))\n                population = np.vstack((population, new_members))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_members])))\n                evals += new_members.shape[0]\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Introducing a dynamic mutation strategy and adaptive crossover rate to enhance exploitation and convergence speed.", "configspace": "", "generation": 21, "fitness": 0.3064804471110315, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "876121a8-5a00-495e-85e3-436940dfa165", "metadata": {"aucs": [0.6909990581930939, 0.6632727910465024, 0.706294360122141, 0.6949809332393955, 0.7077134602879086, 0.7039389269327159, 0.6910679429560259, 0.6877282988848183, 0.6979169844348821, 0.4974242801419897, 0.4913935052119415, 0.5207590802973847, 0.5016068099745397, 0.5193002612945204, 0.506516197063671, 0.506869896993584, 0.502456974606737, 0.5141381787116932, 0.14661445594990696, 0.12196391869550438, 0.11001638096751942, 0.13610456313705022, 0.1202804126083824, 0.10343126287158777, 0.12518473262146002, 0.12190356510597722, 0.1221022133756765, 0.10610752743323137, 0.11135503802127134, 0.10082644134167895, 0.1149696486559717, 0.11048480359902257, 0.1131125908555839, 0.10553543577260205, 0.10090188119662657, 0.11526200664346631, 0.9468662267626863, 0.8825927851726011, 0.9103901282509217, 0.9479217248853229, 0.9361180139404668, 0.8830522849029556, 0.9265385380520531, 0.867345385271318, 0.9155322815122741, 0.3031461599851608, 0.28493577518169244, 0.29307352265829345, 0.32705203068046473, 0.27369720122662844, 0.3560119039774938, 0.3192674804063631, 0.30633212637463225, 0.31165074601513354, 0.5482524637614861, 0.5665287668613697, 0.6176468276849851, 0.6310946794249751, 0.6262710218246519, 0.5576753427411697, 0.5690764340901369, 0.5687642729016186, 0.5581751880724677, 0.16434297835352973, 0.21121205851904268, 0.15789041797376924, 0.1589922007968495, 0.1535468405859174, 0.1755209069907121, 0.16846834928560306, 0.1602923887694815, 0.16942929796462392, 0.3008036422300323, 0.19036577470987914, 0.14293420629525577, 0.1570182745326032, 0.1812753982189268, 0.17684876749372092, 0.14070310307980904, 0.15205035197533612, 0.16094069807429368, 0.26758021804515764, 0.3455847961997147, 0.26800038802088955, 0.302516500490172, 0.29980879518749437, 0.24633146552714702, 0.2757388868879166, 0.33275545699302533, 0.2956343012530184, 0.3689791341694404, 0.40475003765479955, 0.4986805205855812, 0.4482034856755269, 0.5369881872036069, 0.3743293171395291, 0.39808447169171246, 0.5926849221317416, 0.38855007568649746, 0.1188824570951581, 0.051724884932873416, 0.07139218636243749, 0.15873597656227034, 0.11650233044871494, 0.13426162955974918, 0.10531719055380107, 0.1318588516236705, 0.08090947613221633, 0.1770441060985366, 0.1900491979429142, 0.21751093638196528, 0.24840759206773178, 0.20121412582527087, 0.2000445720608739, 0.22036561321127757, 0.1568870022585923, 0.1748476464311539, 0.575926177025829, 0.5779670146608931, 0.5911070923317008, 0.5634422518313084, 0.5511896755038725, 0.5270853152382333, 0.586054324461299, 0.5183267262313063, 0.5458785727371822, 0.08103086415836025, 0.0931506726026693, 0.09070317004821515, 0.09169517916190939, 0.09096934337015139, 0.1017278649269856, 0.0891641926751856, 0.08457227451012528, 0.08982391325258432, 0.1310832166536815, 0.13341898644055694, 0.13678648998765652, 0.17944660370610088, 0.13642192934120645, 0.14335683236474783, 0.15064188541680412, 0.13978975711917085, 0.12278503015283126, 0.34290199984995906, 0.32324764231919767, 0.36397645694357783, 0.3197805478173321, 0.35118726912988185, 0.3298490017921929, 0.36101340215278466, 0.36991780894587234, 0.37493059844156473, 0.23943283762163148, 0.24894355596418072, 0.2393898310315844, 0.24977394466730862, 0.2748984890887478, 0.28571527574557065, 0.2700952993428636, 0.2731341253071331, 0.27886086187223114, 0.18088873220222668, 0.18512004509533853, 0.1940183401301152, 0.194809789760921, 0.17441635859919657, 0.19943321354979793, 0.19310509125021902, 0.2350439723980179, 0.18750944183682228, 0.1911884924115781, 0.19248760125537334, 0.23887639763608615, 0.18736484707903267, 0.1975089893996158, 0.18798096588352942, 0.19432729134239168, 0.19098275316068825, 0.18336803803558666, 0.4810513256567095, 0.18711930488473227, 0.16897766234612188, 0.4062163923564739, 0.1775597171534371, 0.46220680857322716, 0.21932973727147442, 0.42009340251329064, 0.37370992580243667, 0.5529230113035339, 0.5937144052086258, 0.2918866042058871, 0.1815337747537028, 0.30034327527980653, 0.18948041339246324, 0.19097866730869084, 0.5615581802273335, 0.25186888448042266, 0.18165789430690737, 0.183802140103142, 0.19481379791090647, 0.20774145134294397, 0.17948075308915956, 0.19949544910618688, 0.1828811788950181, 0.2054290819595347, 0.1905089521037313, 0.08547987348704555, 0.0764949114641097, 0.07322469335792048, 0.07357781687721199, 0.07678963263094518, 0.079522129018745, 0.07357946299001783, 0.07739151435584712, 0.06899316148738432]}, "mutation_prompt": null}
{"id": "deb0458c-a00a-40e3-82b7-fa963a112052", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Initial suggested population size\n        self.f = 0.8  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 10  # Reinitialization threshold\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                # Dynamic mutation factor\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n                \n                # Mutation and crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                self.cr = 0.5 + 0.5 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                \n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Local search exploitation\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            # Check for reinitialization condition\n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//3:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        # Return best solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Integrating a strategic reinitialization mechanism and local search exploitation to enhance exploration and fine-tuning.", "configspace": "", "generation": 22, "fitness": 0.3146075176383358, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "42d40b91-14e6-4584-8ba6-3394c4e7c1b7", "metadata": {"aucs": [0.7227079111690338, 0.6866467596881609, 0.7069689399854733, 0.7009940933971747, 0.7142401822720688, 0.7010015985273065, 0.6901766575251493, 0.6975501118299754, 0.7113988114694411, 0.525515405877069, 0.5160699870312885, 0.49624843373417815, 0.5102594877386076, 0.5410075339319977, 0.5149346054058616, 0.522344550065424, 0.5209851241867964, 0.5225840389764168, 0.1455288270612164, 0.14805772641383208, 0.12873897926061362, 0.121463239830232, 0.11701211432763559, 0.12603285090390637, 0.11016234900226773, 0.1337674456352521, 0.10878420695488145, 0.10671014735922313, 0.11685031144147451, 0.11726863168748936, 0.10989879323771945, 0.1084099197378815, 0.10724080744988718, 0.11363743800542347, 0.1150554850980019, 0.10626966948040828, 0.9786796513115052, 0.9520796971380274, 0.8811381771199392, 0.9282074709983628, 0.9091503441023583, 0.9553913912725734, 0.915452402167792, 0.9599980457737973, 0.9438262921752485, 0.3287645656806071, 0.3322665534629031, 0.3582869972227448, 0.3044365715703581, 0.2733196067922802, 0.3419352266665683, 0.34420769851265165, 0.2675585010042071, 0.2910430622899628, 0.5597392775555199, 0.6031464567476115, 0.6062063945559233, 0.6197615100053364, 0.5896311220333105, 0.5892439356987342, 0.5995884547625521, 0.5830707790548215, 0.5763467477131171, 0.1809335481547627, 0.1698428746268097, 0.17689272102668308, 0.1537626125251469, 0.19618515447234408, 0.1858024645620091, 0.1836176703585931, 0.15260563812517125, 0.16152594811346555, 0.1875608088880314, 0.18251422264970463, 0.31217907363596775, 0.1892993678283199, 0.15003034946704197, 0.15692960904551578, 0.1697279742151161, 0.13264789704219349, 0.16665263082197868, 0.3673808386252001, 0.3043723586223941, 0.3320641463822872, 0.3931436064614269, 0.3615560514361338, 0.28203735775255123, 0.293048897067718, 0.2914629247042244, 0.35939551336084474, 0.5804102901923863, 0.4949142514132532, 0.43701358975180926, 0.45877159226907416, 0.41221541972376097, 0.50164985162294, 0.5578877811649555, 0.4925092110964533, 0.5464964332763014, 0.06308268338498069, 0.08622132626273282, 0.07516312851527052, 0.12175628626727197, 0.09160344331342263, 0.1610881375730605, 0.0986984149874115, 0.11994954362662225, 0.0835745955108318, 0.1870537103967418, 0.16928109011929315, 0.17463055087112644, 0.21105526261258867, 0.18700430892235598, 0.1994741722222555, 0.24106092755017816, 0.17998719984678013, 0.18535711187234027, 0.5331184520070666, 0.5503031629801005, 0.6319736843407764, 0.5726318828768807, 0.6302549664262618, 0.548605054201891, 0.5224520883710062, 0.5840532861504077, 0.6083414999415561, 0.09792709032066671, 0.09965685146345726, 0.08440147622100358, 0.10355663635316437, 0.09694326812873844, 0.09712632997410509, 0.08444724477523702, 0.08964230630599979, 0.08300529068209872, 0.15716954309790454, 0.1555920806515142, 0.15210774332092458, 0.14969067513699863, 0.15028701439427272, 0.14003241800966548, 0.14002072697803636, 0.13729058300295638, 0.15641247446143935, 0.32975991090250056, 0.3591982427551387, 0.3532005440522623, 0.2957617430202625, 0.31541103611854304, 0.3340810293898997, 0.3639707279906189, 0.356273151147365, 0.34595374357580433, 0.253029229286184, 0.24008286206078921, 0.2398679974333332, 0.2238146620391508, 0.22212764461786894, 0.23346824991729875, 0.2731205339349946, 0.274525555268502, 0.2740682924281096, 0.1844715530063693, 0.1835973873869461, 0.18722038900833438, 0.2030007275072313, 0.1825824081757128, 0.19192134814887563, 0.18880882612579686, 0.18706532678474308, 0.2001759877906406, 0.2088209027920812, 0.19490029038947176, 0.21520392803628519, 0.19168976348300337, 0.2077454684806881, 0.19410056557640132, 0.19840402556249415, 0.18923023721843035, 0.18037400535143355, 0.2494930729313104, 0.6590452981486215, 0.48962275694816415, 0.28371093093134836, 0.2658421530052648, 0.6103239301352741, 0.15974432135981065, 0.2692219411665212, 0.21851272498301455, 0.501534492451156, 0.19472717432364817, 0.42322097657992386, 0.3792135753086272, 0.33836414079375243, 0.3152981852058703, 0.20140726381539065, 0.1999845306431235, 0.6744108001406597, 0.20118878018646924, 0.17175445168171322, 0.17869345241044343, 0.18272401385789527, 0.19300957704428012, 0.19350270586456608, 0.187885066169025, 0.17907686187391447, 0.18686047012510099, 0.07027037313021278, 0.06740862314368423, 0.06818396346027455, 0.0770317677564637, 0.0803491021321624, 0.07192694425343504, 0.07111264972836184, 0.07757335121376285, 0.08283857621417723]}, "mutation_prompt": null}
{"id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 23, "fitness": 0.381412935939355, "feedback": "The algorithm RefinedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "deb0458c-a00a-40e3-82b7-fa963a112052", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "8be777e9-f70e-4dcc-ae35-99f91f5cacf5", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "1ca08c73-2a6f-4b87-b245-8a3b9d3ce4ab", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "e261ab5e-6718-4da2-9b62-8eb12234ecf7", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "bd916d8d-5ac0-4ea0-a368-0cfddeb996a5", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "1d2873dd-6583-4bbd-a1d8-99845b5374a7", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "50a22cf0-0e0e-4280-95f6-808e24773ab2", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "8db58ff0-e6cc-4f65-9ebc-1cd5855b6be3", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "58262ca5-6d33-4285-8e63-8507a0b3b0ca", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        pop_size = self.initial_pop_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = pop_size\n        eval_step = self.budget // (4 * pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(pop_size):\n                f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.mean(fitness))  # Adjusted scaling\n                indices = np.random.choice(pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n                \n                cr = 0.8 + 0.2 * np.exp(-(fitness[i] - np.min(fitness))**2 / (2 * (np.max(fitness) - np.min(fitness) + 1e-10)**2))\n                cross_points = np.random.rand(self.dim) < cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-pop_size//5:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n            if evals % (self.budget // 5) == 0:  # Adjust population size dynamically\n                pop_size = np.clip(pop_size + np.random.randint(-5, 6), self.dim, 20 * self.dim)\n                population = np.vstack((population, np.random.uniform(self.lower_bound, self.upper_bound, (pop_size - population.shape[0], self.dim))))\n                fitness = np.append(fitness, [func(ind) for ind in population[-(pop_size - fitness.size):]])\n                evals += pop_size - fitness.size\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation balance using dynamic population size adjustment and controlled mutation strategies to improve solution diversity and convergence.", "configspace": "", "generation": 31, "fitness": 0.37769420907152346, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.749785990848353, 0.8261653966105197, 0.6418275351047726, 0.7799247414640281, 0.7573489214830224, 0.7942188515804769, 0.8287368987898569, 0.7677882329831899, 0.6297517990564772, 0.6745484352312647, 0.6660579164196829, 0.6615604718744952, 0.3613467845441499, 0.4049743363017625, 0.38286471823272694, 0.596627113127748, 0.6056286372981554, 0.6080896414121528, 0.11278002233453577, 0.12109441609510341, 0.10671547710052842, 0.10047290902209116, 0.11147823471423923, 0.1119706340338753, 0.10721652971070394, 0.11474163469004195, 0.09848269633142859, 0.10972683060369759, 0.09665373801814026, 0.09857047140887809, 0.10161663555904599, 0.11026101119914711, 0.09404025323796705, 0.09799478137526618, 0.11162014736764081, 0.0893714656975706, 0.6630998355888553, 0.6511333268559188, 0.543378245579367, 0.9534695853553081, 0.9188315382995376, 0.6192023244214755, 0.6758447077180035, 0.9859083613855654, 0.9707018014723774, 0.3695143395022765, 0.3791953594341211, 0.35922730342351983, 0.4247929059755693, 0.3916698820426917, 0.4452670017467988, 0.3644794183640435, 0.3712687275720469, 0.40060969178706507, 0.7854092237563727, 0.7413567223397011, 0.6506143274110232, 0.8080485874557894, 0.3618086146005801, 0.808433988756077, 0.8614936582778562, 0.8281343727492596, 0.8025001087735212, 0.436801991500809, 0.4229468469242438, 0.48145857915391965, 0.5138384922390898, 0.4561834844070145, 0.4720071291655238, 0.3981363182681318, 0.38586559679701793, 0.43788006958783277, 0.5207475886759688, 0.12344701067739294, 0.5073563438089552, 0.4036472741375373, 0.1250334947073254, 0.4304383361408002, 0.42375148530808693, 0.4298116092923423, 0.47154521558158624, 0.32867663632499966, 0.5859863062305168, 0.3238426325184044, 0.40942588823049786, 0.46075426610563286, 0.37849650331075335, 0.48684451393221584, 0.49158778778597545, 0.48765621265174774, 0.6854289136226771, 0.6161766395599428, 0.6242535200184384, 0.4085055729948137, 0.3878176884785295, 0.39929421760973405, 0.684745877910486, 0.6890678326993726, 0.6897937007861845, 0.18124997126129405, 0.14661181890305597, 0.07877966877611342, 0.3851658322472934, 0.19011609345517277, 0.2550190527573414, 0.27483547116629947, 0.1537259019165682, 0.21907936055423516, 0.3508357759121433, 0.3233611028381752, 0.3145887070764054, 0.3399331760153391, 0.326649886066553, 0.33219595452308737, 0.3842714067516606, 0.33522076660325273, 0.33607619626175866, 0.8136763007056089, 0.5650690914186106, 0.6125171456995383, 0.5794129926492305, 0.6270581163143862, 0.4683755224986037, 0.6530135351639984, 0.6246732634572679, 0.6958519605823118, 0.11032278425537856, 0.11775010169884959, 0.11998383631159737, 0.11030373435396545, 0.121922660562778, 0.09355367362789979, 0.09823730843346135, 0.10169979826871534, 0.09623799055736804, 0.16109452822184012, 0.17018993584490294, 0.21280994901937933, 0.18129652314388012, 0.15742412358142044, 0.15716044428414422, 0.417616089678145, 0.17039580919998665, 0.1569448488192755, 0.3995352633305833, 0.3840204448197485, 0.5499738983952743, 0.3996410555612724, 0.4012335612848327, 0.3790789862299201, 0.2776726601183591, 0.3613682368200989, 0.4512882466145798, 0.3789027490573309, 0.2971781936647603, 0.3646218971078823, 0.3730400781677553, 0.3260186191480262, 0.34380205448245504, 0.34957045639142126, 0.3424703141292875, 0.28834033158307903, 0.2021897964757866, 0.1975436784170279, 0.20191510884761077, 0.19832563930672975, 0.1986817836837701, 0.216295856640638, 0.2149876889605985, 0.1767266293944031, 0.18845842647971733, 0.20896980887161842, 0.23581934326759824, 0.2631767557028053, 0.18919697961766413, 0.1866609603878565, 0.19270275020310712, 0.20843737888550684, 0.18725124105656865, 0.1900979417608576, 0.16990111105117234, 0.1927906085223714, 0.7162377103791631, 0.6979898645436955, 0.1937733076809618, 0.18902233209342956, 0.6946614578797272, 0.715259496503412, 0.6857467188389865, 0.7305103655673741, 0.20629601588186575, 0.7094729322814772, 0.18421101278827678, 0.1924988215179394, 0.6536814817812325, 0.21841254518859643, 0.8155395794140522, 0.2093172538027651, 0.17549423045273904, 0.18814999430246027, 0.18362033828812574, 0.18811686487405788, 0.18950211260845395, 0.17419237711045754, 0.18559824169467587, 0.19319058969379044, 0.19456428543574011, 0.08339308201665152, 0.07504645722541137, 0.0791480807515178, 0.07809869761795907, 0.07981801927090926, 0.08372158932144635, 0.08232046796282044, 0.09318232048325603, 0.08526591966531527]}, "mutation_prompt": null}
{"id": "e547b6b6-26f7-4f0f-9155-9f186cdfa01b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.f = 0.7\n        self.cr = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 6  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (4 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.4 + 0.3 * np.sin(3 * np.pi * evals / self.budget)  # Chaotic scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.75 + 0.25 * ((fitness[i] - np.min(fitness)) / (np.ptp(fitness) + 1e-10))\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.08, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//3:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced adaptive approach with chaotic search and dynamic population adjustment for improved global exploration.", "configspace": "", "generation": 32, "fitness": 0.37790085575032034, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.8479696743344339, 0.8236220004994614, 0.8238611005258994, 0.8377304389329213, 0.8337101981013076, 0.8219273827621149, 0.8231086813367687, 0.8299889618095356, 0.8379653276151795, 0.6700585119098352, 0.7078050002444412, 0.6779239726308349, 0.691487246549381, 0.709458548836975, 0.7001831677256874, 0.7186778177212135, 0.7260121993773374, 0.6542709289734729, 0.3248219980971163, 0.25040608585591706, 0.4455456395772619, 0.3857399588013358, 0.14868586535782702, 0.14838782710766774, 0.14737731684264122, 0.1489215607378659, 0.38370845431737277, 0.14296610164129575, 0.13021263709965802, 0.14502151721584056, 0.13056857059165727, 0.13952288976520433, 0.14861523133617882, 0.22982259665508875, 0.1451939095015523, 0.14331833233855018, 0.9372214446175742, 0.9068176708313279, 0.9243111323292407, 0.9229371450146053, 0.9047897159477856, 0.9006504151952125, 0.9346882700034862, 0.9358169927797966, 0.9328159574370212, 0.35617054104977564, 0.38986504303953196, 0.37583921294154365, 0.42621921403928653, 0.30794483822939545, 0.3493155975970209, 0.38473877980346516, 0.3993541398928301, 0.39722541652880594, 0.7809827881768703, 0.8371671544862958, 0.7675980618958753, 0.8065775908301436, 0.784890471527072, 0.7654048314987532, 0.7767481801865622, 0.831667439098575, 0.774876107990006, 0.17482247404777773, 0.3142028709839443, 0.21894680784443665, 0.1787389932471679, 0.24414041264976571, 0.23511705883369005, 0.1909405410207301, 0.18625831594398068, 0.16867482866508143, 0.20592244719075692, 0.17555397132816475, 0.17615207355053752, 0.21450031502842326, 0.15724291131228096, 0.20548366005273322, 0.22056098285324055, 0.23512822586334103, 0.18757997654823289, 0.2628252283946052, 0.24458132798257237, 0.28038324778404, 0.25257888678540086, 0.11208914844084283, 0.26778099258335974, 0.30319444994811673, 0.28711829056305305, 0.3011934560778974, 0.36266642264934823, 0.4168884225017939, 0.4724114865566732, 0.40019981602692256, 0.37033612529794735, 0.30469154242729946, 0.4625510100674406, 0.46837239726789826, 0.36265979712059293, 0.13670172256348945, 0.09463465358578882, 0.17349418627126323, 0.18940268895700452, 0.13113380016239573, 0.15905740055512874, 0.13396883068766785, 0.18338833958505207, 0.11653829231902213, 0.40671569616744074, 0.28437850198697623, 0.3206060580892971, 0.2940218879577937, 0.28309660367292744, 0.3055858262489701, 0.28451218065156225, 0.30958239871805004, 0.3107482696553645, 0.7228259369638258, 0.7570155196306427, 0.6767733329337782, 0.6467750866255002, 0.6608121675033254, 0.6303023757813622, 0.6205602886441359, 0.6130691561728769, 0.6495258857942876, 0.12029462564141247, 0.12904540898038996, 0.2597460983651414, 0.13521146123689665, 0.12616696654092519, 0.13061031397694456, 0.14054059286488607, 0.1016083822353292, 0.12209316427331884, 0.24638410946168532, 0.2109511347252655, 0.21843891991058895, 0.15489842504005646, 0.16373292809609663, 0.16489099492984283, 0.15594740827880726, 0.2014900026799873, 0.17458628808608267, 0.39360213483064777, 0.43248160806394975, 0.4131869856412481, 0.39188706103562876, 0.3875357680186795, 0.4055871977503571, 0.4532694254633092, 0.46396567306888803, 0.4828817821052428, 0.32373216480410505, 0.3214192863474472, 0.35634228898577824, 0.36992307439705796, 0.36822817208412284, 0.2778071065842833, 0.3661110496310094, 0.38194608228228677, 0.3395707566703129, 0.21004405832243767, 0.22393115682724385, 0.1895030038090103, 0.22242647221721634, 0.20879274591457953, 0.20022813456395283, 0.1989801871361988, 0.20348755683674746, 0.2248958122680198, 0.3317425255827222, 0.21611958713718482, 0.223004294547146, 0.21009593496836076, 0.22590895749933337, 0.2256929818989466, 0.3642660167029955, 0.22201602917158547, 0.19793213331750414, 0.7834644267599665, 0.7529027022828119, 0.18614737839552076, 0.7404875896850038, 0.661378440245946, 0.5313562178253293, 0.6078348339991181, 0.4756824134273935, 0.6452547093617653, 0.8226990720597167, 0.20892954082115012, 0.5572096274213749, 0.22875586965783679, 0.37218341133720956, 0.7471882017464007, 0.4641967731069161, 0.2061501536047935, 0.21049055132602734, 0.18465582887087773, 0.18646266782641518, 0.18504778751435336, 0.1732450351377096, 0.18374516108869188, 0.18081565821661172, 0.1989339277938632, 0.17916831472230077, 0.18700675247714826, 0.09340979412805006, 0.08761275517577105, 0.08740098472489521, 0.08832036770440554, 0.08250878421722241, 0.08336574955526954, 0.08526780220064789, 0.07983566554548871, 0.08733965127628329]}, "mutation_prompt": null}
{"id": "84bf4afc-0041-453c-b37a-27fa707189d2", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "813f17b7-aed5-4146-9888-6490c9c0e16e", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "97e45886-4043-490d-ae9a-0712586bb601", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "8f39e14f-0b1e-4353-a94d-0b0e7a2954ed", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "08a5b323-98c5-4f2c-9a4f-cfc5f9d27647", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "b5133ba2-ac00-4c0d-a3f0-d5395dda1482", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            f_adaptive = 0.5 + 0.3 * (1 - evals / self.budget)  # Adaptive mutation based on evaluations\n            for i in range(self.pop_size):\n                diversity = np.std(population, axis=0).mean()  # Calculate diversity\n                self.f = f_adaptive + 0.1 * diversity\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introduce variable mutation based on convergence rate and diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.26425114033116454, "feedback": "The algorithm RefinedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.6192882267541429, 0.5941397221177543, 0.6359609854550731, 0.6819920337316558, 0.6726191095380425, 0.6851070974057869, 0.6708736395101421, 0.6391217666668529, 0.6352406042376701, 0.39638296995303834, 0.41597644520456856, 0.4207165549027081, 0.4030173494554512, 0.38480469623075064, 0.437804327765959, 0.42234385026406474, 0.3923257379476477, 0.4320102201195146, 0.09979470820202463, 0.08870895290497571, 0.10543868463340278, 0.08504326309412535, 0.10097885790662098, 0.10045934021762148, 0.0926744519570113, 0.09400391076950709, 0.09776399204222175, 0.08028489400157246, 0.0810765012261856, 0.07721506110507947, 0.09058517145202427, 0.07773278965714525, 0.07795379854660656, 0.08798765055924473, 0.08590424373498173, 0.08856697552542159, 0.9601657963124103, 0.9591615638505633, 0.9759892616704654, 0.9428504216874359, 0.9714871199707604, 0.9309840143466969, 0.9645202436881913, 0.9739441759184156, 0.9296748389129792, 0.2768223370600841, 0.3167014004510178, 0.2855564968695673, 0.25988480018828564, 0.2900000104543864, 0.29786292591644836, 0.29782297612520536, 0.3300712409288501, 0.2812094457416885, 0.44531615999620644, 0.44277091981697514, 0.4519827280751155, 0.4753124183179941, 0.44062659883099287, 0.5053292563586265, 0.560567966979774, 0.5069326219716961, 0.45081963358537935, 0.15495567231274399, 0.17826435961096943, 0.20661912921795222, 0.16034549721891234, 0.20895253435618677, 0.16542607204992432, 0.22849926458584935, 0.18487989212331168, 0.20738125002853058, 0.020834823238241373, 0.11245082118550176, 0.020093536688430835, 0.1612439012232706, 0.16061622997357317, 0.20941083992681475, 0.2618131920602714, 0.2513881265310546, 0.1362200930221481, 0.11728706753470419, 0.1792857940174043, 0.185883665207498, 0.20265142482775245, 0.22625359366822262, 0.14894529005927948, 0.10150734895962799, 0.09704928721841022, 0.11741396298945328, 0.18283981450298759, 0.22880079435719425, 0.30060727251898767, 0.2392606147693076, 0.1918875350022805, 0.23360514860607373, 0.3148014473860624, 0.3008672435245432, 0.357366217420955, 0.026250635552801382, 0.03195509321360224, 0.05207015839624052, 0.04906932971802036, 0.10833873687269857, 0.10635917020237995, 0.038698132836840204, 0.0489251989738998, 0.03852061727866163, 0.1573283031310715, 0.13505636192695913, 0.12879291173543894, 0.161000044150459, 0.16414608014774135, 0.17752333796014685, 0.15634634487221732, 0.16641189525685274, 0.16719735994134277, 0.49226459847870696, 0.5074522089494038, 0.5185833336103214, 0.5237381069254351, 0.49466303057276473, 0.5021415874551882, 0.4823321740623526, 0.481725872248738, 0.523953312995674, 0.08481692986236644, 0.08195926140547927, 0.09171343541761723, 0.084483170436908, 0.07933660782508267, 0.0691105626400138, 0.0697262848462582, 0.07285437278709828, 0.09054991339768714, 0.14555885979665872, 0.3097156057287047, 0.20044683109742023, 0.1373135725427277, 0.15251912823816272, 0.16741444653109616, 0.21992106875928052, 0.15835968072619577, 0.15411740942979757, 0.26511889745457407, 0.2527581898990662, 0.2857036912333746, 0.2510960231116457, 0.2317427047695818, 0.23071508432848475, 0.29018887783101477, 0.28032541159053304, 0.2882197458682475, 0.18593293658057486, 0.17701905347107494, 0.19417545138279146, 0.1888802496133566, 0.1678592654524329, 0.17565925540907734, 0.1922451380348369, 0.1989411554839151, 0.18291047408038774, 0.17604429856177373, 0.1633543079016958, 0.1718044051294113, 0.17782267015843756, 0.18025350911189164, 0.1666068437366135, 0.17444736949094009, 0.16721835907725435, 0.17161326772632624, 0.18129566911805428, 0.16578181227424138, 0.18147599554775806, 0.1870557652271183, 0.17500659491757142, 0.17345985097715255, 0.17061049388678984, 0.17687979257724196, 0.1767541062961533, 0.4379142273043213, 0.6342572383649102, 0.1776472884607725, 0.1780404864324815, 0.15028728463432095, 0.1636332040061632, 0.37959610525658205, 0.17751763197807358, 0.1879330125476949, 0.5255422350071446, 0.4706976256839196, 0.4735983374903687, 0.2844693740933625, 0.1884715578412527, 0.3378432770278085, 0.200029246860838, 0.18767956982928058, 0.21032646476025363, 0.19754885617068274, 0.19236185164200992, 0.18039936070893658, 0.1958483046137991, 0.18710318457440167, 0.18561025824351074, 0.2040984219628541, 0.19322576198269492, 0.16524246106207352, 0.05896263227989362, 0.06553329653007767, 0.058348888804025556, 0.06193537354147016, 0.0687146761270484, 0.06709325552902812, 0.07368781250822698, 0.07125002866073771, 0.06608520601737289]}, "mutation_prompt": null}
{"id": "cd8f79f3-7750-4543-8ce0-9b6c7166d153", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "cd5bc5ce-0c35-44da-bf7a-94f8773929f7", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "eb79403f-4383-4fd3-8922-b2730f06e1e2", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "2b2cb8cc-0718-48f4-b8b5-67360b568344", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n        self.chaos_map = np.random.rand()  # Added a chaos map variable\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                \n                # Introduced chaotic sequence for mutation scaling\n                self.chaos_map = 4 * self.chaos_map * (1 - self.chaos_map)\n                chaotic_factor = 0.5 + self.chaos_map / 2\n                mutant = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n\n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ChaoticDifferentialEvolution", "description": "Integrating chaotic maps for diversity intensification and dynamic mutation factors in differential evolution.", "configspace": "", "generation": 42, "fitness": 0.2951420694541786, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.6870151306897767, 0.6408645436008411, 0.650863289818385, 0.6705997934196095, 0.6728664149975985, 0.6874085890950242, 0.6834201689329238, 0.6950853092358694, 0.6922055746924716, 0.43692415741617885, 0.4294491175085776, 0.4435169924620159, 0.4714625232357075, 0.4199307817581148, 0.42677629611866874, 0.45543742163105105, 0.4502742233335132, 0.4477889016225435, 0.0997687315889525, 0.1002420690729221, 0.11104881261399624, 0.10725142084593131, 0.10976880353589336, 0.0983777766659869, 0.10522564875429163, 0.1070317323491734, 0.10306501350821895, 0.09622803996028328, 0.08452876154200117, 0.08011904496248512, 0.08583829300484869, 0.10039353634446302, 0.09525616355004862, 0.09359608509896933, 0.09671813892242898, 0.09235786733769624, 0.9219462896246409, 0.9650148679428986, 0.9564169014192171, 0.9625015676082842, 0.9790667862985993, 0.9248652445136425, 0.9492443027531416, 0.9495015079126735, 0.9200986891130014, 0.3058158286039113, 0.32457620268604603, 0.31182123643480364, 0.27454085012404794, 0.3180595493567191, 0.31705172160999306, 0.3406284832365446, 0.32035742385083066, 0.32776169171887126, 0.493241118130487, 0.6157061401074827, 0.580567614313064, 0.5988840032386038, 0.6305244371761087, 0.6642614385355222, 0.624132924941833, 0.47961980959578665, 0.6312880821188878, 0.24009104671814885, 0.23559505288124094, 0.2330735795928225, 0.24174526652742634, 0.15328247105836057, 0.1875989899243553, 0.20801993105363004, 0.2738995500976623, 0.22453830750178227, 0.34283865877992736, 0.23304151645115823, 0.24890850486822313, 0.22170539049913207, 0.20703018284065822, 0.20197797831853925, 0.2059486059162542, 0.19729927870529684, 0.23702030577477218, 0.24377912029538706, 0.22488319422449865, 0.2289060187888342, 0.25090162416479045, 0.24160828746165375, 0.19527427501549766, 0.1910531383301084, 0.2117659130250168, 0.17867535892123232, 0.32850447316529574, 0.38004382255551905, 0.40479608355994956, 0.36763082012064774, 0.3846631698238201, 0.39413098788695244, 0.36846428861396385, 0.41214498977576486, 0.4304685246504655, 0.05201510798910913, 0.055559984742766355, 0.07473845623635411, 0.08269775526574541, 0.10643660350828499, 0.05521195564767345, 0.1098534528821874, 0.07092032605290566, 0.04853165122984504, 0.16965587731061438, 0.17974945778687745, 0.16214862492047943, 0.17262037415644682, 0.1725043107012425, 0.15375689210265087, 0.16863084046542753, 0.16286996426366873, 0.1685790693897714, 0.5432322114994729, 0.527474485374055, 0.5190140557186325, 0.5262160829394287, 0.4951396714724179, 0.5160571928478933, 0.5152167847507996, 0.4990576613868528, 0.5400790681143346, 0.08475661413770597, 0.08633200528811324, 0.101893754863289, 0.08780731028213085, 0.08611975520230297, 0.09410143596621257, 0.09503149033517222, 0.09643982778632565, 0.07920261325251599, 0.14733380740682844, 0.21956330410906444, 0.1519124784418373, 0.16308650296191807, 0.15911962670825064, 0.14622251040519585, 0.12572834996392135, 0.13548085247593245, 0.18360702279479757, 0.280846445981751, 0.26318774352877194, 0.285038215695825, 0.2524455552185969, 0.2765993267131399, 0.29611733742252977, 0.29871121680169077, 0.31284065588160925, 0.31722111398407127, 0.2127940744084157, 0.2099761016711721, 0.20972132348871986, 0.2074482356503703, 0.22059075613261603, 0.20444859507936053, 0.2078507924637808, 0.23242789671628106, 0.21799336517427859, 0.21544232333069624, 0.1717610540386777, 0.21791556709844506, 0.17891065718156018, 0.16594785158921155, 0.1904457615404288, 0.18489229549437192, 0.20824786949811303, 0.17603233504012172, 0.17711219196122752, 0.17388609472050698, 0.1785541600312459, 0.17914553548307177, 0.17444015940163593, 0.17889525160023567, 0.19324124222458072, 0.1755491598687926, 0.18461189575071912, 0.5212734599540869, 0.5328595295352871, 0.4703295873114225, 0.16432698637893262, 0.4514177541581268, 0.18971947165321612, 0.19792943916739036, 0.34113804737345044, 0.16092580397679868, 0.5253507767777549, 0.5665779719808971, 0.19210161956117233, 0.31201540797102945, 0.1768202091119614, 0.18318861274403586, 0.20823005648325243, 0.6863573420731787, 0.551990842651359, 0.188311859762052, 0.18552962004813123, 0.1910848967228208, 0.18782538843601915, 0.18832043222931738, 0.18963907287602277, 0.18205948920114334, 0.177825962293386, 0.192844987033149, 0.07949579483854596, 0.06975320614406177, 0.07551268416042245, 0.07741461914745251, 0.07456024411616147, 0.08187598695982345, 0.0705369401122723, 0.06473090465610654, 0.0703060654163653]}, "mutation_prompt": null}
{"id": "4919ef06-b32d-43f9-9b42-17dbc14900c2", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "a6d4422d-175f-4063-97c0-02035affcf1f", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "7d4cba60-4fd5-48e6-a4fa-271c0924a718", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "adc2518d-80fe-4aa0-94c8-0cbb1e5e0f8a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "2786c197-c2b5-42bf-a1cf-9b14b19e467b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 6  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (4 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.mean(fitness))  # Modified scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.6 + 0.4 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)  # Adjusted crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//5:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Introducing selective reinitialization and dynamic crossover control to boost exploitation and exploration balance.", "configspace": "", "generation": 47, "fitness": 0.36682077495485776, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.8030827354525454, 0.7165876676428766, 0.8146915884558166, 0.7549184132732663, 0.7842255708724807, 0.7661519410564614, 0.8185849288368665, 0.7984236449169448, 0.8252605657218642, 0.5603426903664737, 0.565080908650065, 0.6658505552375326, 0.6791093191658665, 0.5766136848104072, 0.6665004838649611, 0.5981630002294873, 0.5849406015150722, 0.6028739664686519, 0.13805424464735716, 0.11099512772126874, 0.13066411927421628, 0.11985400999350371, 0.11290375128111596, 0.15813882620318587, 0.13640268305460101, 0.11169243907665971, 0.1076770528540093, 0.10602480201411923, 0.10944131645077781, 0.10199998677070565, 0.11567373990341712, 0.14283661760676292, 0.10411487684531606, 0.14184937772362793, 0.10717192270897336, 0.1121817563917844, 0.8866921945908666, 0.7965932179709898, 0.8784398455476021, 0.9586655545033126, 0.9428360510234594, 0.8834078311588129, 0.9474380809858071, 0.9625321152910931, 0.9558505058825757, 0.34981325306351896, 0.3333072505917025, 0.3136638240856602, 0.41022953085772185, 0.3916188550896873, 0.4208103530799274, 0.3278061518031261, 0.3410433444042765, 0.36067051383191817, 0.5798784861338268, 0.6250584548759865, 0.5565986422441707, 0.779136588996747, 0.5052024205873278, 0.5567255652685781, 0.8371210145184852, 0.7465198266072335, 0.8264193600483711, 0.2612104840767737, 0.3661638829934817, 0.14185450501851793, 0.264452062805429, 0.21075563539214603, 0.23030452382348243, 0.29959498696554254, 0.33897159908083074, 0.32795264075415, 0.147083660562357, 0.12111738012726347, 0.28134034572284583, 0.24917822484256325, 0.27476145134574204, 0.3300025264863008, 0.3332997020116436, 0.2660411488900907, 0.41719850777103507, 0.36287860291353957, 0.40062229424898743, 0.2752881003788977, 0.5410555001676642, 0.4081516789639662, 0.516800053595746, 0.3942608751257116, 0.42452210204821395, 0.39261159130217294, 0.5223425366016348, 0.6703387689853678, 0.5831205773163033, 0.41785722049188634, 0.3316066379585253, 0.45838387308308615, 0.3412163921602007, 0.5741809170479146, 0.672179420705423, 0.06427417555354586, 0.1344124583137707, 0.19134265740295942, 0.23390704570183685, 0.16661849447036625, 0.3044551066156741, 0.14204601126924976, 0.11404807761908975, 0.12306611222301966, 0.25838833116492976, 0.24123096584209436, 0.25281310313860883, 0.2688888974922016, 0.26809795203078124, 0.2535630726678991, 0.26329811337522824, 0.21578626538019063, 0.21206052820789312, 0.7171683137924822, 0.6882776209831593, 0.7278762754490082, 0.7123022678501785, 0.5963490429978939, 0.5824522164100625, 0.6703978897676182, 0.5890052435534834, 0.5481192016312227, 0.1007691797817144, 0.08508147434541335, 0.11557389895062065, 0.10611965703749082, 0.10438480361326896, 0.08914015844176959, 0.11664915008724219, 0.09332673115323709, 0.10078721782870692, 0.1388913348944727, 0.12753108794545298, 0.13058934157059232, 0.15418922721330652, 0.13688131726273078, 0.14814997426131105, 0.13446008802522824, 0.1544175627016524, 0.14452712907122, 0.43901465520490535, 0.45938693787061224, 0.3685575854617089, 0.3773165078664742, 0.3576287622091684, 0.3629987831913747, 0.46719218476331237, 0.4801023052197575, 0.5183215936528036, 0.20519762775595407, 0.20368973008498248, 0.3640254210339583, 0.3182936347659071, 0.32295373534863836, 0.32565963590171665, 0.2474024251322613, 0.26471922150361527, 0.2476869081673393, 0.19967721215436773, 0.22416408065960303, 0.22118144952135965, 0.19545501649655295, 0.18243829895864383, 0.18195804435064833, 0.18641414025799974, 0.1867098968102684, 0.2252107980482021, 0.5296212531003517, 0.4998088174799663, 0.45979670334475975, 0.5208702932594799, 0.5102634306916067, 0.36092810500124395, 0.55956527336507, 0.21969493567941945, 0.23655599592142829, 0.16856876486521688, 0.5197955378757413, 0.6532837321457599, 0.6546074906996593, 0.5509805765622555, 0.6739344627884245, 0.6389659950735005, 0.1768753882607873, 0.4026991116997357, 0.2021827967842993, 0.20067589730788227, 0.6194231871099416, 0.6755832515716862, 0.21168573701600057, 0.34632339897777065, 0.2046517316537625, 0.6708770126764674, 0.20483482563222033, 0.17958773619596868, 0.1955867075397828, 0.19242872415678425, 0.1856014541020159, 0.18513703097936063, 0.1900384806778299, 0.18341801611024167, 0.17636321947478373, 0.19298515250966808, 0.07850418084907274, 0.0695888353995906, 0.07736431526086474, 0.07537998943660129, 0.0649029425172517, 0.07096793316901129, 0.06821189466309063, 0.07735989352045602, 0.06987764779318872]}, "mutation_prompt": null}
{"id": "a6f3836c-56ed-4ae8-b4e0-59c9e0272b37", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "e4807f8c-9ba9-4fbc-98b8-07622fe00aae", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "615af89d-f6e3-48a3-835b-e4905a88c0ab", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "5e492439-c0cb-4ce3-b7a6-7c8f0e832ce1", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "37d8fd0d-b582-47e9-98bd-ee9df405889d", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "3a93794e-cc31-4830-9893-26886801108a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "c3f00e69-72a8-449d-8d5f-06dbac08eff4", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 10\n        self.scaling_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.initial_pop_size\n        eval_step = self.budget // (4 * self.initial_pop_size)\n        no_improvement_count = 0\n        pop_size_variation = int(self.initial_pop_size * 0.2)  # Dynamically adjust population size\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.initial_pop_size):\n                # Dynamic scaling factor based on diversity\n                current_scaling = self.scaling_factor * (1.0 - np.std(fitness) / np.mean(fitness))\n                indices = np.random.choice(self.initial_pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + current_scaling * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.crossover_rate = 0.6 + 0.4 * (1 - fitness[i] / (np.max(fitness) + 1e-10))\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.initial_pop_size//5:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n            # Dynamic population resizing\n            if no_improvement_count % (self.reinit_threshold // 2) == 0:\n                if evals < self.budget * 0.5:\n                    self.initial_pop_size += pop_size_variation\n                else:\n                    self.initial_pop_size -= pop_size_variation\n                population = np.resize(population, (self.initial_pop_size, self.dim))\n                fitness = np.resize(fitness, self.initial_pop_size)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic population resizing and adaptive mutation strategies for improved exploration-exploitation balance.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {}, "mutation_prompt": null}
{"id": "bb5c56e9-1c70-42a1-a302-ddb8bd3bb79a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "13f3f7a9-dd18-46bf-a42d-413d1e387bd0", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "7fe48bcc-6f7b-4ad1-9b74-bd49e89d0a9c", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "27ffe055-0c1e-4724-af74-aa0b0518fcb6", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "b9e37e50-9f63-4253-806b-6e83efbb64f9", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "42c90325-b3bd-43a7-927a-dfac0e4b310a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "42722253-ae1a-4e53-8be4-5f4219bc9877", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "86993840-a3bd-4ecf-81ef-78f61f75cdd7", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "93896620-ce6d-4210-8e3a-0a3ddea4c4ce", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "939fc32d-a878-4084-a26d-bcef33c5f98f", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "2e129886-a7b6-4a49-a354-0ae5f1bdcf1e", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "6c09c6e1-e709-4754-9311-a5fea6e4bf60", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "80195dfc-a145-47f3-bf87-d84b48ab1d6b", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "afe1bbfd-9c24-4c59-8759-e2d9dd076cde", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "f6d42b72-1d1f-441d-a43f-b9c81ec065b5", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "c16c1cc1-a29c-4b4d-84a5-972e37a0662a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "527c6491-cf52-4187-bfef-250ad08b8696", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "4f37052e-77b0-4e8d-bc04-22ae29831c98", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "25163d63-349f-4726-ae8e-cb46bcb95509", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "8f66cf26-2428-47a2-aea1-55b163c21120", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "182609af-83a4-4d95-8dc3-7fd16634783c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 6  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (4 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n        swarm_best = np.min(fitness)\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.5 * np.random.rand() * np.sin(np.pi * evals / self.budget)  # Modified scaling strategy\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.6 + 0.4 * (swarm_best - fitness[i]) / (swarm_best - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < swarm_best:\n                        swarm_best = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim) * (0.5 + 0.5 * np.random.rand())  # Enhanced search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//3:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced dynamic adaptation of parameters and hybrid search to improve exploration and exploitation balance for robust convergence.", "configspace": "", "generation": 75, "fitness": 0.2465945750757315, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.7556823123866525, 0.7425950499913716, 0.769064438981572, 0.7486346144343026, 0.7538258311941063, 0.7426996116961209, 0.7575306711014573, 0.7419063448106771, 0.7510779273485553, 0.49774081170613227, 0.4762933971317731, 0.48250037603278184, 0.547714428402938, 0.5410586337446694, 0.5224155300844338, 0.48786571453148286, 0.5074225564691821, 0.5246510546566274, 0.43884483361940774, 0.42207066022305506, 0.42554795817170765, 0.4678223938723959, 0.4647207078513167, 0.4376672652789445, 0.46735310234808447, 0.43718664398894047, 0.45497122431341175, 0.36495249205706104, 0.3427502815298954, 0.375342400574152, 0.4256454650017465, 0.37622303512374133, 0.4058308585917604, 0.380836287382991, 0.4010367983253089, 0.35347800375586225, 0.9212287481278528, 0.9424673876357237, 0.9242515033779689, 0.9388636948736415, 0.9269649002897596, 0.9262318411169499, 0.9483341837824962, 0.925496679795951, 0.9270253208766175, 0.14962694978434044, 0.1423431047598891, 0.14186820502156428, 0.17062717780368786, 0.1272991791043533, 0.1433720153578344, 0.13605614463763527, 0.15475734645986872, 0.14100860297198847, 0.15354100730463793, 0.18979507423577957, 0.14918592067699377, 0.24959430129716798, 0.22307048830057008, 0.21378189791825186, 0.18588487974582169, 0.200028746168053, 0.17934774270100462, 0.14981596212724801, 0.16652456651104552, 0.15424302519818045, 0.14828113438651214, 0.1699162761855718, 0.16692792873559226, 0.1573226860429724, 0.1681862441814952, 0.15893403543569495, 0.11657364120020464, 0.11994122350983327, 0.13221921787943824, 0.1399038382993797, 0.13225627398676154, 0.1333328486386134, 0.11139801734750854, 0.1236323892662825, 0.1452333011338971, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07124938241331458, 0.08082419796190721, 0.07438366711287636, 0.06859376877047585, 0.043516107494584455, 0.047234284772872726, 0.12721584168014288, 0.06924283618698213, 0.07454797481802089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06665742931913465, 0.06413997456023623, 0.055480058180386704, 0.06893291688557657, 0.07401441175596413, 0.10231724235417572, 0.06307102030903078, 0.07494417591515445, 0.06268059934441195, 0.3851630731238991, 0.38859380400183163, 0.4237537310633407, 0.38102456272505936, 0.4107041501168295, 0.41137076012335605, 0.3864919491155664, 0.3803994762342301, 0.4014242028729055, 0.12038805639012995, 0.10393457691612706, 0.1067805079032269, 0.0944534184309388, 0.08114751813346899, 0.08663336271601751, 0.0899150712924458, 0.08232312267945929, 0.08101292442262698, 0.152953568188529, 0.1541461748958758, 0.15162395456417288, 0.14125537516619657, 0.13934163555535994, 0.19039984029693202, 0.21181354545354836, 0.18265984300436255, 0.1777142592368307, 0.20283918208773621, 0.2091245794154224, 0.21520847066957605, 0.2075978946973871, 0.20060930833190005, 0.20721338949355173, 0.21540589411254663, 0.2026586584840423, 0.19761726882645747, 0.1444065522378032, 0.14646419617822726, 0.15790698776081735, 0.16352604705251816, 0.16142510040465208, 0.16019440586900113, 0.1506112535720795, 0.17618473879217322, 0.15391956252551264, 0.1918945536294243, 0.18318540469631495, 0.19791786553381552, 0.20403029765459635, 0.188102232198053, 0.18372948918807064, 0.19262796454450692, 0.22319225081522143, 0.18696848627132745, 0.22516172019253566, 0.23035917491361724, 0.20602051556325662, 0.2064731898191945, 0.21540912310724425, 0.21662305304498264, 0.22012557192896587, 0.2139931751948786, 0.214290369676428, 0.1657565377095387, 0.21871157741433678, 0.2132557944890302, 0.2837587827598148, 0.19986005451568045, 0.24513235390051769, 0.23064556106138256, 0.4184024364153459, 0.1780014261854279, 0.19414744629851788, 0.22899671129890575, 0.18259214714055072, 0.21583442548024367, 0.16999986408702028, 0.16985634915088943, 0.2090628313488858, 0.1867995858314373, 0.2124770903608828, 0.17106442016321344, 0.18265456551203496, 0.1803837868431687, 0.18966649729350715, 0.20630901019425452, 0.19054643933924886, 0.18062112260373087, 0.18517799149241043, 0.1692636916671696, 0.07068087887518981, 0.06788494295025338, 0.08051694602098447, 0.087479960383821, 0.07458031205117455, 0.062159320260421924, 0.08180037258754924, 0.08291405836957455, 0.0764912704522751]}, "mutation_prompt": null}
{"id": "5406c756-6837-4f63-9391-ed14db176131", "solution": "import numpy as np\n\nclass MemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 5  # Introduced memory for past solutions\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)\n        no_improvement_count = 0\n        memory = []  # Memory to store past solutions\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if memory and np.random.rand() < 0.5:  # Stochastic use of memory\n                    a = memory[np.random.randint(len(memory))]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n\n                self.cr = 0.6 + 0.4 * np.random.rand()  # Stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    memory.append(trial)  # Update memory\n                    if len(memory) > self.memory_size:\n                        memory.pop(0)  # Maintain memory size\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n\n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MemoryDifferentialEvolution", "description": "Introduce enhanced memory-based selection and stochastic control to balance exploration and exploitation effectively.", "configspace": "", "generation": 76, "fitness": 0.37251259634000705, "feedback": "The algorithm MemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.8613750903931692, 0.8296594673665177, 0.8545929346674694, 0.7977575401506598, 0.8166862944996871, 0.7965423660840936, 0.8495371327551179, 0.8495637890752941, 0.8589290306943708, 0.7055932004306019, 0.7369092233403434, 0.6629572250375566, 0.6687344610220333, 0.6534525634064393, 0.7113947920290039, 0.6451289473731623, 0.6569684075927353, 0.6717993987793914, 0.12299435477331011, 0.1480161523671979, 0.16568496397643617, 0.12862657072045336, 0.13369540677184977, 0.1397494949707625, 0.1419203097773628, 0.20368066669470508, 0.1369429151267535, 0.1400009043740007, 0.1821848725056776, 0.1393185037235567, 0.12108300846146025, 0.11905249159765718, 0.17547177689155347, 0.11669030237010991, 0.1325657416363547, 0.16042649435860434, 0.9235226201221829, 0.9588414261341817, 0.915471513082695, 0.9373331750803248, 0.9402755599479035, 0.9217101285485048, 0.9360212110540849, 0.95126069047245, 0.952312972765883, 0.36017239964070846, 0.43619258835097685, 0.4065620402336688, 0.44788578700734694, 0.47263171337263266, 0.4394760876976256, 0.4622001856927409, 0.39812674535303216, 0.438654864363342, 0.6691599856972211, 0.6093780680294262, 0.6646778360949172, 0.682221441174052, 0.7056899028294352, 0.7566170287481437, 0.775538843436017, 0.7232354663499361, 0.6606631783196596, 0.361547860145635, 0.31571828593970364, 0.35891968220331705, 0.23353594657808596, 0.1422414101073295, 0.39386355892514824, 0.3568518063796451, 0.32821249990628065, 0.31609566550688417, 0.12937674080414385, 0.4201014379493868, 0.32161300435578977, 0.3034828064451546, 0.34733195418139196, 0.31652010646260065, 0.34662716422534234, 0.192213686108745, 0.4023667905743914, 0.2962133501909603, 0.24785671707332568, 0.34508664057521177, 0.24497573766069358, 0.31023149517001036, 0.24005589602246313, 0.3202855860219733, 0.3426237536044855, 0.27814014000461007, 0.2152368709100967, 0.31083695664550737, 0.3891672103948719, 0.428515678133625, 0.3774241948900864, 0.3747658773204162, 0.36382512836944103, 0.5604219661471455, 0.5551182352444368, 0.09019901688987353, 0.11389173290082288, 0.2017839325544314, 0.20627760887719404, 0.19344650388865592, 0.07100046595488907, 0.13025505434838236, 0.11876251025331619, 0.1295288478505543, 0.2588989932076855, 0.2887965763316521, 0.2572723106136353, 0.2623012803887239, 0.29087407233316354, 0.28283238340808947, 0.2267328880352063, 0.2319360009568212, 0.22772492636134622, 0.7104252032613987, 0.7092824953587911, 0.7011375447250542, 0.5833499546731734, 0.5937046453208932, 0.6377356825605829, 0.6974527190772999, 0.6664885081443233, 0.6892299337333776, 0.08702326301367047, 0.10528412176350099, 0.09561491330510163, 0.10708312796527919, 0.09014908427449486, 0.14411179217378922, 0.1057727120945332, 0.11080863647647932, 0.08869478025963906, 0.1421437713683723, 0.1517261775798221, 0.14497624261843467, 0.18929828177326757, 0.20472814936838435, 0.1551283816388992, 0.2452194657513792, 0.3672949341364041, 0.1597599649493523, 0.5104571586380382, 0.4835160306284121, 0.5454041672538612, 0.41917042798075743, 0.43038077504333627, 0.4513616850354144, 0.5402230471006705, 0.5274072177768755, 0.4489304888454547, 0.42777590147712463, 0.37002455345280927, 0.26467837447460196, 0.39088758654026, 0.3442578405236715, 0.34007458869841123, 0.25219415377722165, 0.2839454638859462, 0.38953728596397574, 0.1916825547142953, 0.16860661510686226, 0.1826910852128042, 0.2228800437879186, 0.20963773086858994, 0.21593297921656063, 0.21336096357456868, 0.2144235476152213, 0.19707165677338023, 0.6120386349092497, 0.23563506379003796, 0.5995527942537154, 0.23676996614479118, 0.18742329728752483, 0.23650358803335703, 0.21282978161105115, 0.19121018462580341, 0.46495488141357666, 0.16537416618449075, 0.61896417838902, 0.693111466070278, 0.653260491674508, 0.17286125558700838, 0.7632972737803242, 0.6018561775958652, 0.7408363621278558, 0.7227101014196664, 0.16830661251457535, 0.16711054407255665, 0.1660428326074309, 0.20135744854020443, 0.2081790446668469, 0.22294621391586844, 0.2063876259257369, 0.20439577077840776, 0.36725733264146043, 0.17051524883849656, 0.17502220131209467, 0.17411903077852386, 0.17480872533899872, 0.18047438985138542, 0.19220902068448376, 0.18480305314425693, 0.19396598256603903, 0.18364067170609, 0.07901620991941749, 0.07936277670053982, 0.08457068862562278, 0.08178599081384763, 0.09153716404124568, 0.07506119056731331, 0.09120082969078558, 0.07410120829858569, 0.08377772294252173]}, "mutation_prompt": null}
{"id": "d1195311-0841-48a7-b986-eb5260dd48bd", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "b9085463-865c-48c2-a784-61202212d6d4", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "bfa457b3-0e3a-4e5c-9a28-10c7565823f4", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "52518a4a-e297-436a-b895-0d3fbfb60c96", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 6  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (2 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.6 + 0.4 * np.abs(np.sin(3 * np.pi * evals / self.budget + np.std(fitness)))  # Adjusted scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.8 + 0.2 * (fitness[i] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                diversity_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)  # Enhanced diversity\n                diversity_vector = np.clip(diversity_vector, self.lower_bound, self.upper_bound)\n                diversity_fitness = func(diversity_vector)\n                evals += 1\n                if diversity_fitness < fitness[best_idx]:\n                    population[best_idx] = diversity_vector\n                    fitness[best_idx] = diversity_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//3:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Introducing enhanced diversity and adaptive crossover strategies to improve convergence speed and solution accuracy.", "configspace": "", "generation": 80, "fitness": 0.2527770548517947, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.6104973233616374, 0.6093533878645702, 0.5965320158710423, 0.6318643009524243, 0.613915648287473, 0.6287968266929329, 0.5967694924436464, 0.5921873306217611, 0.6169615869470564, 0.3189356159023341, 0.3246746454522388, 0.33259663982612464, 0.3320755083208219, 0.31325845312834166, 0.32588935406670894, 0.32571556026866033, 0.3141293721317543, 0.3311584549375849, 0.09396293917244691, 0.10462777374540566, 0.10406752233595362, 0.08791695692688029, 0.08899099521393805, 0.09902553861155938, 0.10415715466323439, 0.1068411177111881, 0.12801289332079668, 0.09358078214039212, 0.08398679358259764, 0.08592925843687516, 0.0987345443897506, 0.10106795084351705, 0.09268256236072703, 0.08648774520912117, 0.09069632573313757, 0.08364289422395599, 0.9867201761822891, 0.9636180373788249, 0.9393479329805117, 0.9642835826932382, 0.972844612128126, 0.9390996760182354, 0.9584533303261518, 0.94991900904846, 0.9269588847019257, 0.25895481100676565, 0.24364799521459257, 0.2745426293500972, 0.26604552107303037, 0.2551630010877701, 0.27069264441843754, 0.2513847235881692, 0.24942075859114043, 0.25848624344856663, 0.3178990174719062, 0.4221760677532006, 0.3662195833787759, 0.5257664430225282, 0.43826410130722393, 0.501288079169425, 0.5136560739481126, 0.4969513765827518, 0.47815397676835114, 0.14622803232255133, 0.1641008461488187, 0.16639178301805657, 0.20663292826777813, 0.1712699957377548, 0.18641049185005854, 0.20619727547950184, 0.1834057065798581, 0.16290348092743956, 0.23591880029161916, 0.16588060373011027, 0.25075404669876866, 0.16714873423476406, 0.2040281870739845, 0.13723341752161256, 0.16055423119938173, 0.2012280129306423, 0.14011356327795, 0.08916305913334766, 0.10531836303488584, 0.08863448373123606, 0.09105679863258609, 0.07185485486570065, 0.09444265522844597, 0.09174083397236643, 0.09232954070764243, 0.09846812207583988, 0.203494885017936, 0.23665820946642468, 0.16971890736014317, 0.18347965710779746, 0.1725358332079251, 0.20209891480077036, 0.21020144869078816, 0.2623374618571652, 0.26930616915737104, 0.015788926941254222, 0.023476996017367857, 0.023590744910632955, 0.022489219747388267, 0.013810117475152373, 0.040801500670279656, 0.010659406249584946, 0.01755669741857746, 0.022700125074312516, 0.1822774853761715, 0.12223676311727083, 0.1445170924447211, 0.1508109388760417, 0.15634673348435735, 0.16153509745477246, 0.15001268626133024, 0.15753595156758438, 0.14376151465170928, 0.4487864575544158, 0.46963001120073566, 0.460193024575102, 0.487884632548081, 0.47099124774317425, 0.460974521130887, 0.47438718711795014, 0.4865475080194175, 0.4796110899766123, 0.08394575410814598, 0.08393233300176306, 0.08903603792961512, 0.09353141152415134, 0.07994655362722514, 0.08034353965570662, 0.07249666074194372, 0.07897613820267724, 0.07578599886733539, 0.2733392811688593, 0.15099283680917452, 0.1740806415070545, 0.1381736257489572, 0.1933773096318986, 0.1459046063769125, 0.1509299216832335, 0.1611986771804641, 0.14028294329112323, 0.2706942990686658, 0.2690913856578646, 0.2839460598132707, 0.2568886730097505, 0.2801826405667811, 0.2736224901990453, 0.2761293776637833, 0.2723587913400942, 0.28351961786797275, 0.19171854532340127, 0.1908072887121176, 0.21705219848643442, 0.20095278557224439, 0.1942113782012681, 0.20320407774282, 0.2013588770869048, 0.18437164552043117, 0.19905244263694744, 0.17437137931718627, 0.17184687016563605, 0.20116006308554135, 0.20250117830006276, 0.1708246315945402, 0.18788493000420747, 0.19675899023874321, 0.17561051417769047, 0.1769708983040149, 0.17407572395853077, 0.1706790846700338, 0.182794523241815, 0.17392731453198373, 0.18631549799935543, 0.17674340603023542, 0.1788274809300756, 0.18253589129514058, 0.1742594079100479, 0.178389337680529, 0.18180530590501076, 0.7349106155146963, 0.5863986045148278, 0.17907822621954184, 0.16694759417821348, 0.18142431362646672, 0.30980362056762933, 0.3196208916224227, 0.19508278947833546, 0.40344189004081, 0.4721973630769455, 0.1864639987144987, 0.19253114315679087, 0.15870593201563066, 0.2067786137873655, 0.685473923254331, 0.2068458170705384, 0.20395179030549848, 0.1926347626078323, 0.18602726480844933, 0.20971101429938965, 0.19230564991654897, 0.18240073949607405, 0.17676731681681412, 0.17140354945172875, 0.19291579678504323, 0.06863782432396859, 0.08176460163406485, 0.07172017875376002, 0.06386877402299562, 0.06793997135109786, 0.08042635806440723, 0.06795006477142884, 0.06442513781364778, 0.07773287377833715]}, "mutation_prompt": null}
{"id": "800d9051-dd62-4a39-95a7-8e4af789018e", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "62392727-83c9-418c-bed7-7177565ace1c", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "4081fdfe-262e-4678-85e7-7cb530f65175", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "527a9603-3c40-4026-9afc-807bdf85a6a2", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "074e3373-1a0a-4372-a401-8d01a5ee0eb4", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "fd5a8756-a5da-4951-bc35-15f29ec8c994", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "26239ac8-8610-438a-afff-ecbea6c3c00c", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n\n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n\n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n            # Diversity preservation mechanism\n            diversity = np.std(population, axis=0).mean()\n            if diversity < 0.1:  # If diversity is low, introduce stochastic tunneling\n                for i in range(self.pop_size):\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    stochastic_vector = population[i] + perturbation\n                    stochastic_vector = np.clip(stochastic_vector, self.lower_bound, self.upper_bound)\n                    stochastic_fitness = func(stochastic_vector)\n                    evals += 1\n                    if stochastic_fitness < fitness[i]:\n                        population[i] = stochastic_vector\n                        fitness[i] = stochastic_fitness\n                    if evals >= self.budget:\n                        break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Integrating a diversity preservation mechanism with stochastic tunneling to enhance exploration and avoid local optima.", "configspace": "", "generation": 87, "fitness": 0.344878871683238, "feedback": "The algorithm RefinedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.7150165911651689, 0.7279757783282652, 0.7312346072309679, 0.6698868067757826, 0.6523626238030047, 0.6814974966444769, 0.7172378367137586, 0.75065463207192, 0.6832581391047154, 0.43573520532921917, 0.46320594207137844, 0.43198962694346643, 0.5971502206852604, 0.6123929028498325, 0.6140522266845634, 0.4821543830983728, 0.501062084522786, 0.5201851264676701, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.18129889368016205, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.13067138067868722, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.897828645595699, 0.8981876111098517, 0.9014449167731928, 0.9166936257823655, 0.9342458453852762, 0.8999572275446455, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.34916241784005875, 0.31445677936864624, 0.3291657319907201, 0.3289624916571684, 0.3429301902484574, 0.3520407377121686, 0.32931187090162684, 0.32965293442135957, 0.3149950934260801, 0.6931568924906047, 0.82163508703291, 0.7782901363443148, 0.6986475745179521, 0.7036213453411326, 0.7815678740724967, 0.8475702202681972, 0.6547114814752513, 0.8055777412518957, 0.28248041309940874, 0.28974300211647963, 0.24173386309081057, 0.16888067519524264, 0.270599447774727, 0.15504843324720385, 0.17912386416995196, 0.21376664024508363, 0.2349869883634519, 0.22641421575207965, 0.13154962495168077, 0.3346578599367487, 0.28535752954687, 0.23315118369405008, 0.15721462274018339, 0.14677872195669828, 0.2486862094367851, 0.18523271576118072, 0.3170459396424642, 0.3841954313728988, 0.22501800719625153, 0.10522547960344164, 0.3178523521198001, 0.4084909304658648, 0.3808830914681747, 0.48974369552955854, 0.3265880326936532, 0.4511315528816391, 0.4615919987048793, 0.44576335841252646, 0.5026761198196407, 0.34694687449129624, 0.375065107264842, 0.4139014817288855, 0.5848118777750717, 0.4382086518359719, 0.10593893757001172, 0.1480761209058128, 0.1439169267957492, 0.2517225753340072, 0.17309912324618448, 0.22675757316892153, 0.14621797761330413, 0.16222003046773947, 0.19485267991482846, 0.26834143911723896, 0.2525146084857859, 0.20142922883811887, 0.24634824597252514, 0.24372673286274082, 0.25620976987268196, 0.22481106215668922, 0.22265813649797717, 0.19785491962000634, 0.5673821534773495, 0.5208974456300114, 0.5512052936551852, 0.5470994145256366, 0.5058186608017012, 0.5730353181655734, 0.5670184991341756, 0.5804906026042422, 0.5499733290273165, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318586027190124, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1809112433737191, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19092353293537878, 0.1287614760582434, 0.23393749587181578, 0.4179699638640594, 0.38012525724556967, 0.39669391592525716, 0.3403579490667026, 0.34948428352022387, 0.348907065288689, 0.35353726785016093, 0.38004179443448716, 0.38609347345767697, 0.3000399092792394, 0.3745380588311482, 0.25306333349565147, 0.29315420565800965, 0.29082814007575464, 0.30364480496244717, 0.25717847580823405, 0.2625107208520653, 0.2502801516859273, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23164326351826103, 0.20957740259511137, 0.27347155064213935, 0.3258609633822712, 0.45336182733329355, 0.1901766015324331, 0.27730248745601727, 0.18971706075113648, 0.19162333074449756, 0.7203916720785686, 0.6586845778920523, 0.1925598295104698, 0.6979842743072011, 0.741459527545026, 0.6629301232310794, 0.17644731980340111, 0.1652654836143922, 0.6406764391061587, 0.6315637046848495, 0.2012976711998189, 0.7204262819233904, 0.508317250003908, 0.30861661703463883, 0.4578016418239269, 0.678992982273465, 0.2998592113705263, 0.3557950939604829, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "6ba7c1b3-4152-4aa0-b002-54d8df7fca72", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "13a6f0a2-4c1d-4842-8210-052d0cb9c476", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.6 + 0.4 * (np.mean(fitness) - fitness[i]) / (np.ptp(fitness) + 1e-10)  # Adaptive crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                perturbed_indices = np.random.choice(self.pop_size, self.pop_size // 5, replace=False)  # Periodic perturbation\n                for idx in perturbed_indices:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    population[idx] = np.clip(population[idx] + perturbation, self.lower_bound, self.upper_bound)\n                    fitness[idx] = func(population[idx])\n                    evals += 1\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolutionV2", "description": "Introducing adaptive crossover and periodic perturbation to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 89, "fitness": 0.26276702536464064, "feedback": "The algorithm RefinedDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.7768778730889404, 0.7706790204518402, 0.7383424838191296, 0.6842711763170106, 0.7410908637131746, 0.7104264391710207, 0.7858923964965145, 0.79147767993177, 0.7759670631855355, 0.584991536723505, 0.5213887856694357, 0.561188271716156, 0.5621879878574318, 0.533066021108547, 0.5814488792990116, 0.5266545788208215, 0.5732510293823183, 0.5746906772931568, 0.13986772736927455, 0.13842323147026092, 0.1594218372839198, 0.1876898702527291, 0.17173661609396318, 0.1749240889963286, 0.13274785643198828, 0.23554789420469124, 0.16413810443620513, 0.1291771455167534, 0.11987095244058987, 0.1259484353582666, 0.1394859005944048, 0.12066255250153679, 0.11946531473632971, 0.13417381990166866, 0.11985914137513975, 0.14485297928934993, 0.924506775466228, 0.9085215466224127, 0.9495205456610349, 0.9511229113335063, 0.9292360989369788, 0.9224549115435662, 0.9415035459507424, 0.9508227897262379, 0.9440210262999659, 0.26155752520613995, 0.3032404146251132, 0.305286704499972, 0.31047226427425145, 0.33163261998974014, 0.3371332865440647, 0.285652508945642, 0.31075413292961607, 0.2809906046296633, 0.2835629528385164, 0.25551127482976066, 0.25951320091002994, 0.6455383601429385, 0.7340164052216009, 0.5024149473642143, 0.4218039181970237, 0.25326050043905834, 0.2800034763179178, 0.17880552216764323, 0.1590762035012896, 0.16091144296883209, 0.15970946121477314, 0.16933416682864388, 0.15570656449764753, 0.1669888965315437, 0.16098234491327768, 0.16197205916759105, 0.14098797327992474, 0.12350794095207562, 0.1665086042956203, 0.15999344208399235, 0.15298125177225175, 0.1525673198135552, 0.14852329845030277, 0.13141312063311328, 0.14439694612889942, 9.999999999998899e-05, 0.01752369217858707, 0.002052110545290864, 9.999999999998899e-05, 0.006247572588983674, 9.999999999998899e-05, 0.016121775495345325, 0.009387772219288881, 9.999999999998899e-05, 0.08111186953971716, 0.07943792060692445, 0.0985657378725342, 0.051893707086348106, 0.07622184516002906, 0.10591844466030709, 0.12139424286724565, 0.105552128934286, 0.0886684585174875, 0.00214922244937521, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004884172322273672, 0.002187895402091966, 9.999999999998899e-05, 9.999999999998899e-05, 0.015728141334070966, 0.0021599868909126796, 0.1019671984410565, 0.1174676045481785, 0.10721230398663195, 0.11632208595627835, 0.11845945946513581, 0.12839800393827994, 0.10081570046883104, 0.10283484916637153, 0.10579416288173726, 0.4781607350506938, 0.47666809419116585, 0.46854294457073065, 0.48180688403850025, 0.4729632512081926, 0.4775242982064115, 0.535904809296058, 0.5542658694904774, 0.4971764584521374, 0.09670750857940291, 0.0925567230484885, 0.08714558813151652, 0.09195057330806633, 0.08784309828530446, 0.09349823557810089, 0.08485922377657429, 0.08415384272265924, 0.08378563126668581, 0.14422535497253153, 0.15341636057767338, 0.14852800384712406, 0.13921933754736637, 0.15262509273557368, 0.1367770223410576, 0.15177519459047994, 0.14949213363421587, 0.1678211171507502, 0.3190609030901307, 0.3350905716261554, 0.3272632145037172, 0.2819719319021492, 0.3049648485717883, 0.2792612286840539, 0.2940401224832996, 0.32691393990868534, 0.3225446265707981, 0.20524729086404436, 0.22178032845912365, 0.23150103455547655, 0.1989559945359337, 0.22065757722508983, 0.2225400106057832, 0.2337543305826031, 0.24119541868061845, 0.19829105434923133, 0.2047764253743728, 0.19402277368767262, 0.18767101745928605, 0.19834175239921992, 0.19246476576576232, 0.20140869086832303, 0.19162782531425104, 0.21004591382992543, 0.22257244782392915, 0.19459888536240977, 0.20683721549561662, 0.21385739145089278, 0.2001486502461658, 0.2021275202660029, 0.19816716489420116, 0.20623432137243036, 0.19608245126408963, 0.20847092704063175, 0.25814513114416526, 0.39476484722734884, 0.2482626024984208, 0.5945893462527867, 0.25558910068897855, 0.5700200015841324, 0.18977438193888774, 0.31477702794128337, 0.5569667410421583, 0.25900291475335036, 0.18818457013570533, 0.35427706266222847, 0.18752537422366267, 0.21119080904405474, 0.2737029865645786, 0.20685322446311116, 0.19794195020925287, 0.20236377502537084, 0.1844773799380507, 0.17609040532803333, 0.18160233125927594, 0.1931247897662054, 0.18322284025778002, 0.1855731297254647, 0.21112753756470048, 0.19496501610900363, 0.1805409273009897, 0.07471715923438571, 0.07704021865598953, 0.07133635296130691, 0.07945840488782885, 0.07570874116920645, 0.09002711297262123, 0.07791088795844958, 0.08370591717881892, 0.07604217400381386]}, "mutation_prompt": null}
{"id": "b9c6ddf7-c78d-410c-a996-fdbada68061f", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n\n        dynamic_pop_size = self.pop_size  # Dynamic population size initialization\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(dynamic_pop_size):  # Use dynamic population size\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))\n                indices = np.random.choice(dynamic_pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if np.min(fitness) == best_before:\n                dynamic_pop_size = max(4, dynamic_pop_size // 2)  # Adjust population size adaptively\n            else:\n                dynamic_pop_size = min(self.pop_size, dynamic_pop_size + 4)\n\n            if evals % (self.budget // 10) == 0:  # Less frequent local search\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)  # Stochastic local search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdvancedDifferentialEvolution", "description": "Introducing dynamic population adaptation and stochastic local search to enhance exploration and exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.10354677335785958, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.13.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.11869729595922507, 0.26260037528030067, 0.3101429345142166, 0.14775161550394245, 0.20458357081110357, 0.21001434703609767, 0.13712190385293743, 0.1448601499727591, 0.14125997209519048, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03756318363942879, 0.01467079663371329, 0.03548872389172397, 0.05771111815180607, 0.06115607188776706, 0.09447896540534617, 0.07132534080830866, 0.024385413535791822, 0.04737237962253438, 0.07440927388612306, 0.016589019444565034, 0.014937095389765065, 0.01959972157639278, 0.021146906575290836, 0.009285783747838616, 0.051661330917023074, 0.0020388030404330237, 0.055861178357693775, 0.13070475313370333, 0.11569856054541194, 0.9486760072752044, 0.9569053014090174, 0.19647306275802634, 0.1938934659178705, 0.9748646419520561, 0.10658807987837304, 0.1441893320618861, 0.06274794416174423, 0.12608173076147855, 0.07059935159624531, 0.037138610717691645, 0.01816207063453512, 0.017935065040568743, 0.14771062855509975, 0.04995309007405124, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.09963089944039805, 0.09375807306748629, 0.0912530432589499, 0.032138869571939344, 0.15754575596176268, 0.17909237807926148, 0.14163217588441057, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07200650569888256, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021554157145514008, 9.999999999998899e-05, 9.999999999998899e-05, 0.072233963215796, 0.04095487734741943, 0.11410474461401521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03074540320346919, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033986634922287706, 9.999999999998899e-05, 0.045709804947630106, 0.06296594012415813, 0.09414804843828406, 0.056645864704249815, 0.08737311789550206, 0.07188974126320757, 0.043273341606165916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02405899996590566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044546076124654554, 0.17964306693741416, 0.15756555760738078, 0.2553303314660502, 0.21962046430605597, 0.18220462355260558, 0.16697662562833726, 0.16112956940342849, 0.3354802792597128, 0.28450826811692154, 0.03885766523734058, 0.06965563866212665, 0.02198412468535549, 0.07539252626515192, 0.038635640501133994, 0.05294238396550077, 0.09882026336276961, 0.0861058723145125, 0.0644956611566575, 0.08759721346564997, 0.12521629202354778, 0.18184195465612096, 0.1331441584457329, 0.12019781958728837, 0.10798713552628325, 0.1014004978245735, 0.11430692927506747, 0.0967067272750215, 0.23357295142479184, 0.22536678468628857, 0.1613932299901244, 0.19766180531276345, 0.15025205424171617, 0.17204260146425676, 0.18357198152231835, 0.17377774300845283, 0.14543042936702077, 0.13065781586837089, 0.13904848596048158, 0.08398582550377798, 0.16407829860122292, 0.08643537286345704, 0.1011514338479188, 0.11744383288410187, 0.10652108314730158, 0.18111825706203477, 0.2078688915395438, 0.17014367334159852, 0.18743830447116006, 0.17507562794258125, 0.22374940743815064, 0.18035027644252855, 0.19626071601999928, 0.22921792654350515, 0.1928446197571808, 0.1546061906136723, 0.16649284329331893, 0.1603698388122462, 0.1596832760249428, 9.999999999998899e-05, 0.17500006579825855, 0.15280107115782526, 0.15641783516745633, 0.0072259104365614, 0.16347309598823268, 0.11195223215097816, 0.08167024703901915, 0.12253352678216911, 0.180745648146993, 0.1468342287546699, 0.12462461074092734, 0.16804685254434404, 0.11409810796472264, 0.11040265245322212, 0.3115234152594729, 0.13307508995067385, 0.10465876636844806, 0.08600917452461876, 0.18010168080274158, 0.08515234002320926, 0.14954717903860837, 0.11982076836242772, 0.174681569164591, 0.16975035903340618, 0.17287686899861476, 0.16441824708953923, 0.19357502066784926, 0.157196611088112, 0.17631151568812442, 0.1612915670034939, 0.1695691843018673, 0.06569913304021069, 0.04915611301917433, 0.04686464397936618, 0.06903633650037633, 0.07321131169016915, 0.07457706754512416, 0.0682968921202719, 0.05290654632882541, 0.04190387098903814]}, "mutation_prompt": null}
{"id": "33c2c9f9-eb82-45cd-a022-3fe7ade4a762", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 6  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        adaptive_steps = self.budget // (4 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget + np.min(fitness))  # Adjusted scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.8 + 0.2 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % adaptive_steps == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)  # Enhanced search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//5:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridDifferentialEvolution", "description": "Introducing hybrid local-global search and adaptive reinitialization to boost exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.356526961258997, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.8248429121715034, 0.8105558690822815, 0.8335762418665892, 0.7597695292695804, 0.7710315320756804, 0.7438376497682464, 0.791653387204657, 0.7882870536499864, 0.8261476136860001, 0.5543892421861729, 0.5727177090977142, 0.495330009815379, 0.6589107148425674, 0.611330094298393, 0.6241515671406498, 0.53927103487228, 0.5694526457789214, 0.5440988502998465, 0.1015104256186109, 0.09964252734356105, 0.09834622905828205, 0.1165602814557144, 0.09586190630990055, 0.10211599767766055, 0.10583862758494056, 0.09872657208819424, 0.13355706693580705, 0.09294623548673375, 0.10915518528759172, 0.10952428904846745, 0.1048192557458626, 0.096075772257459, 0.09408241437562614, 0.09659483638240762, 0.09939257119647316, 0.10160659598688015, 0.9132978026253749, 0.8232712034702938, 0.94677925364647, 0.9223113238544526, 0.7987244827775373, 0.8884286981106664, 0.911574227847098, 0.9746239947535977, 0.7981043560307067, 0.3504155083992103, 0.3657636977634985, 0.3052866335560165, 0.4158396925136325, 0.39356868960201596, 0.4007249099688225, 0.33859464169456144, 0.3795878192781147, 0.34149319069100015, 0.5465413638810421, 0.5538129462867003, 0.5925949013376386, 0.7865791418196539, 0.834464416011903, 0.7630013229269583, 0.7950066860019839, 0.8037662151608419, 0.757725033762896, 0.2855423747175302, 0.27944909407342144, 0.3274016449584384, 0.3465708890738973, 0.33601202227045723, 0.1389284474024265, 0.31008375479223316, 0.3056772234955615, 0.3246200089341289, 0.3338096444912112, 0.11693340348210168, 0.31385911958088786, 0.19412220954730097, 0.21226559916961363, 0.3211695904363956, 0.37727944316383333, 0.3173116786493604, 0.26024369756921706, 0.40750986444978976, 0.44434563697476626, 0.6252453675770131, 0.4432683069280483, 0.33646990415184497, 0.43208094226153726, 0.34755809338420496, 0.32418149407414676, 0.2742658917933021, 0.5715457130589892, 0.5893767470162512, 0.6036962050248351, 0.6558150105180592, 0.6213886757864073, 0.6072284037226389, 0.6201399762471751, 0.578339126807268, 0.6152232494464713, 0.08642299038954138, 0.15962185357604308, 0.08759726029484005, 0.15897109299015522, 0.15212238292962177, 0.15891358343303874, 0.14976401404906814, 0.14887036232246353, 0.13062444281748742, 0.23360130058044903, 0.22410939790626727, 0.22843783733451883, 0.2407750834733815, 0.22442687697983021, 0.2263056592737427, 0.23560895645582147, 0.2024644793343755, 0.18547986915515324, 0.6826516797925953, 0.6595507196129833, 0.6911065413631052, 0.7040564219910114, 0.7444782703791439, 0.7270374076474151, 0.7192788431446533, 0.7099947207445103, 0.7110484399918725, 0.09069633702536506, 0.09665707102199483, 0.09659229681089931, 0.10552452245793065, 0.09437674315296063, 0.10323810818012968, 0.08595551503356147, 0.09336092558592246, 0.09340663706403707, 0.2102101493878974, 0.14492504639522596, 0.14377044801176675, 0.14830148417317957, 0.1541351887706658, 0.12848768943567135, 0.1489095287261949, 0.17197268250596476, 0.12507734242650181, 0.4228422734372971, 0.4522525134686213, 0.39964256713995394, 0.3200822648421171, 0.347566448445373, 0.32355490498738304, 0.4463955574130557, 0.47463347040767445, 0.450339949554619, 0.3113902334434945, 0.32445205502418006, 0.3151916116344423, 0.2678368855118982, 0.2707205619993298, 0.2793002922786295, 0.3165001186911218, 0.3098457436098846, 0.3571391066954318, 0.20879381518820805, 0.18514833229721106, 0.18935185420443557, 0.17642684449377177, 0.19577385327666952, 0.1722462718779516, 0.19101504992775187, 0.19364904377137637, 0.199606208457207, 0.1906636563555001, 0.18904394271407454, 0.191935896630394, 0.17665392212716902, 0.1988132899706081, 0.19421542251034096, 0.20658566020294789, 0.20095887092961318, 0.20450672910312162, 0.7215309658030851, 0.17484809256386658, 0.1526249649088075, 0.18007228378985818, 0.4585696788094198, 0.39543707824025554, 0.17673633506842457, 0.5043051112046304, 0.30179662064333623, 0.566208056933063, 0.3422399706768603, 0.6040927029349835, 0.20284899863217254, 0.6460938537381249, 0.43015100530164474, 0.16221057928876703, 0.6480707196176076, 0.20413266325677581, 0.1897329462434587, 0.21510782221908709, 0.2092340960419249, 0.17388945448776116, 0.18844720398349168, 0.19283599143304742, 0.18517664062610462, 0.1854533012207885, 0.18507317109477062, 0.07085815859089817, 0.07667619859622377, 0.07376480169489519, 0.07229520149308843, 0.06753082108039377, 0.0777321608465531, 0.06561132821784088, 0.0756607347657422, 0.08222943539371352]}, "mutation_prompt": null}
{"id": "ad9a5029-022e-4454-8f80-ab622d656c90", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "0fdd8bcb-df65-44a1-8a68-546308210ae7", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "4547db9d-7163-41cc-8546-e7d133cbdf9e", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "a9131caf-0287-4283-8446-ff4cf1c28c58", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 10  # Adjusted reinitialization threshold to 10%\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (4 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                diversity = np.std(population, axis=0).mean()\n                self.f = 0.5 + 0.5 * np.tanh(diversity)  # Adaptive mutation scale\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.6 + 0.4 * (1 - (fitness[i] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-10))  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.1, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//5:]  # Adjusted fraction to 20%\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Incorporating adaptive population diversity and dynamic mutation to enhance exploration and exploitation balance in optimization.", "configspace": "", "generation": 95, "fitness": 0.25771047459285257, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.6954231341230888, 0.6750396732803965, 0.6949505208868827, 0.7224956673150253, 0.751020016228203, 0.7278445791188144, 0.7180622093641987, 0.7236498617990291, 0.713873316278007, 0.41051507248442765, 0.4344986199978418, 0.415652641607685, 0.4125031181812696, 0.4331538594505946, 0.44422329462817367, 0.4581941640799396, 0.45282439300587807, 0.4579443347035893, 0.09429889236215949, 0.08813626952266318, 0.09454596552341576, 0.09752751974587914, 0.09087054817471618, 0.09349104920750761, 0.10047646681261235, 0.09769256320720887, 0.10029477350143279, 0.08887734322870655, 0.07777589439753285, 0.08006301759672874, 0.10471749027899002, 0.0826949048905139, 0.09411048379242204, 0.09227046643369685, 0.07641634538858633, 0.09023157337295418, 0.9803985170196804, 0.9527342824799206, 0.9701258674005924, 0.9648824858781336, 0.9613421840435512, 0.9713281018869306, 0.9831606850692179, 0.9757703431355413, 0.9569186567970507, 0.29670911596566063, 0.2694662886304485, 0.2938307912716156, 0.3220923286360625, 0.2848657123190048, 0.31566221838650055, 0.3461538616981621, 0.3340092589365182, 0.35975851612061727, 0.38499170611048117, 0.41764561192028926, 0.4243699321361052, 0.4306858731019042, 0.44051316928002093, 0.4162369661797205, 0.46847089254302277, 0.421446913702869, 0.32198474205039407, 0.1436893088158524, 0.17018487192294962, 0.1807076261110735, 0.14203085558045003, 0.21529047554195435, 0.1381762689944921, 0.16551692938655838, 0.1499020702179802, 0.16510742818759516, 0.020880549224248535, 0.01532669157525579, 0.04914636122099203, 0.1381473976152422, 0.15876250539845083, 0.1751078759108199, 0.169604287739328, 0.11127241971720037, 0.14852285817124544, 0.06962374860470077, 0.061508443169625004, 0.058510244703200764, 0.08278234679633933, 0.03910839016693868, 0.030696109139379812, 0.07178541684189954, 0.11670548489822485, 0.03572466490209858, 0.22299901912825915, 0.22365997513528024, 0.2472903344832329, 0.26865818748996284, 0.21277163979246416, 0.292759656247485, 0.19232534286812075, 0.21145468437410864, 0.23181317829573045, 0.012252831584992796, 0.00193550040880619, 9.999999999998899e-05, 0.02779782035072753, 0.03361416165005138, 0.029665346518726987, 0.04234978436377479, 0.048361418522791744, 0.11381471294834589, 0.12136491243050218, 0.1462268682751856, 0.13853527118298703, 0.15955189834125938, 0.1645460404744692, 0.1423437441468488, 0.1253585486201988, 0.17276676764167243, 0.1275547768839761, 0.5616737212299061, 0.5609504038903919, 0.6041554768072487, 0.5330004039524048, 0.6051425725267855, 0.5752975672162206, 0.5242263670453695, 0.5679253997093336, 0.5741773364247522, 0.08496026767177012, 0.09481256879221345, 0.09206166662837545, 0.06823500036226249, 0.08353657946568038, 0.0802410266355299, 0.07555518971078323, 0.07465253559985685, 0.06861930619399104, 0.12316015409974368, 0.20140548564569782, 0.21969709239549284, 0.22779947675577894, 0.1635339773858352, 0.13171521266959896, 0.1438015718295701, 0.1679256414449496, 0.17785303024189447, 0.2530560106760136, 0.2652071629752629, 0.251820347298242, 0.2201893547019832, 0.18456107067736782, 0.20655178795553586, 0.28547651987576306, 0.31113000346303965, 0.26115501909858485, 0.16898866874379437, 0.18766745793065176, 0.20316983953398082, 0.15156754303761122, 0.15481410979230947, 0.1407661579571703, 0.20347933299423115, 0.18751095751810265, 0.1690905173938927, 0.21464553567251343, 0.1923831811171015, 0.17356777400994994, 0.16073464394176296, 0.17891788471873826, 0.16173681954668606, 0.17995241355261804, 0.15532553814055916, 0.17334357752210894, 0.1697416547675572, 0.16123076483714371, 0.16748727604605862, 0.17241010470928086, 0.15547906789857702, 0.1676129950601244, 0.16735952822617273, 0.17524909127654154, 0.16636149478719198, 0.6008912334473807, 0.5342305850099491, 0.3781354431878028, 0.1860666700883109, 0.5400413230463519, 0.16242503168687095, 0.1637954495248367, 0.15210682203975234, 0.18059434513164507, 0.2501555193299412, 0.19298583002424685, 0.1705631596949856, 0.1667448923343945, 0.16656415600938157, 0.1571426419640668, 0.5430338531283744, 0.20491202132040676, 0.19839275573741988, 0.19850024094402074, 0.17974499938994593, 0.1901017182225132, 0.2120744634322025, 0.24720146421491596, 0.20139818506497553, 0.19087306679085658, 0.20865731209489458, 0.19588652418844843, 0.06046550863188349, 0.06526845951845572, 0.08386159832256579, 0.06777065521026293, 0.0732509609483235, 0.06142009023300665, 0.06296903967961076, 0.08694037902081986, 0.056830754271823936]}, "mutation_prompt": null}
{"id": "696c1056-3d6c-40f1-9ec5-e716484c51b4", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "c48e1c1a-580d-48c2-9c33-038d30f9499b", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "72160125-fc6c-440b-aace-8f2cc7726c6f", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
{"id": "55ac3a3d-0406-49a6-a9e1-e3cba423916d", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.reinit_threshold = budget // 8  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.pop_size\n        eval_step = self.budget // (3 * self.pop_size)  # Adjusted dynamic eval step\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            best_before = np.min(fitness)\n            for i in range(self.pop_size):\n                self.f = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget + np.max(fitness))  # Added scaling\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                \n                self.cr = 0.7 + 0.3 * (np.max(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals % eval_step == 0:\n                best_idx = np.argmin(fitness)\n                local_search_vector = population[best_idx] + np.random.normal(0, 0.05, self.dim)  # Refined search\n                local_search_vector = np.clip(local_search_vector, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_vector)\n                evals += 1\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_search_vector\n                    fitness[best_idx] = local_fitness\n            \n            if np.min(fitness) == best_before:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count >= self.reinit_threshold:\n                worst_indices = fitness.argsort()[-self.pop_size//4:]  # Adjusted fraction\n                population[worst_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                evals += len(worst_indices)\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "Introducing adaptive scaling and local refinement to enhance convergence efficiency and solution robustness.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4580bf3a-19ff-42c9-ad85-0e815f5424d6", "metadata": {"aucs": [0.827981068316551, 0.8188266570947358, 0.8259574435831991, 0.78081517737791, 0.7684876603287464, 0.74558296788733, 0.8112332102548572, 0.8174804333155621, 0.7970665561427779, 0.6318626987496254, 0.6328363823689868, 0.612778066103604, 0.6646078526343836, 0.6572289872840644, 0.6188326854519004, 0.6002165710753079, 0.6328569314656516, 0.6202904666632015, 0.11688509655367707, 0.16398623720129557, 0.12888889663249303, 0.13454478743498077, 0.10811733257117284, 0.2021344851420782, 0.11757590573991927, 0.10630538962386271, 0.12123936132012347, 0.09965153335144972, 0.11499362159638837, 0.10623976370889865, 0.1308537545806937, 0.12895770526476735, 0.10726356981200169, 0.10986994849216103, 0.10900073533660493, 0.10191743569889677, 0.8479899911432787, 0.7893879850311432, 0.9014449167731928, 0.9053505325798304, 0.9342458453852762, 0.8998421923720856, 0.9810483982866566, 0.9283935507352513, 0.9217822314238296, 0.45958889576037, 0.3643654030727984, 0.38962581064515955, 0.38335625679690954, 0.41959379152130993, 0.4397034695610783, 0.40564147681731455, 0.3822196966803325, 0.397128346857203, 0.6768079502198203, 0.82163508703291, 0.8072323356522539, 0.6964837318903446, 0.7084045764126861, 0.7815678740724967, 0.8475702202681972, 0.6997231972273321, 0.8192989200717857, 0.42974107212088375, 0.4260072203717076, 0.3553574595677417, 0.16137537539165547, 0.420994040001725, 0.14474167597360543, 0.31501594091810925, 0.33788485689211556, 0.40675839165029204, 0.36238293768811525, 0.08889738670702574, 0.4074092132253445, 0.3497424019168546, 0.30051468946491355, 0.2465104006946649, 0.15178380194610597, 0.3357802154390269, 0.3221233568753227, 0.4207600283436371, 0.3009362639448184, 0.38883816395228177, 0.10561278970425869, 0.3677273554778817, 0.5601129055161769, 0.4359379586740063, 0.5906807274388304, 0.40115870900208084, 0.6624938587425657, 0.565732156741783, 0.6132173973222086, 0.5453536622246176, 0.3673055188864597, 0.4830197757048983, 0.5535945868961221, 0.5831220974304121, 0.6480201917581574, 0.11372008086241236, 0.17387592631539484, 0.14781997001375002, 0.28309350975093284, 0.2729610472868893, 0.27641639426263775, 0.15126435747332412, 0.17447703181257823, 0.21482988998595975, 0.2997161249677581, 0.2796167413102517, 0.26239389025613613, 0.29145665326175196, 0.2988377673781789, 0.3185852643700736, 0.24164806265079264, 0.31695530276243367, 0.20523698631376386, 0.6995627094689381, 0.6278408153678066, 0.6409645540008788, 0.7192504010146281, 0.6171967888438483, 0.6560966066994985, 0.627147969938676, 0.7227788803210982, 0.6338151550716622, 0.10295859134555085, 0.09230132995903861, 0.10476738723420953, 0.10245730527075592, 0.10318075550446903, 0.08952318892916156, 0.10921349796274171, 0.10310370647223321, 0.09653368782072025, 0.1657310639957683, 0.14054858990896368, 0.1313182303589976, 0.1465214954751889, 0.15166694825367488, 0.1460465037163724, 0.19094530453612957, 0.1287614760582434, 0.23889241262887295, 0.4734947483039854, 0.4154633723928184, 0.40990750211311133, 0.40437391459827277, 0.40306822325418834, 0.41281486915077603, 0.4264197903255753, 0.46621300354706274, 0.48761958085469315, 0.3496839607335962, 0.4385591715504291, 0.2613441168222972, 0.337106702665917, 0.3310843794715561, 0.3426951021441029, 0.29258663232770044, 0.2644424572403149, 0.26253616083051534, 0.19550425188677523, 0.17108780395628798, 0.18504599505184915, 0.2199492388179568, 0.19190123195256092, 0.20360704353506187, 0.2281563502973446, 0.19066580478442352, 0.20829809997385773, 0.23156803190582664, 0.2096651632766151, 0.2751013351562447, 0.4110329021452901, 0.5525652143589834, 0.1901766015324331, 0.2963133177127496, 0.18971706075113648, 0.19162333074449756, 0.7275771607788292, 0.3755891517603793, 0.19261170568397845, 0.7370143311392487, 0.7718241975254739, 0.6871241222910276, 0.1764522203618304, 0.16526952527186878, 0.662150042441304, 0.6343005284954232, 0.20129580736268604, 0.7372603345374709, 0.4535636916583552, 0.255411066305414, 0.4398551630950007, 0.6822389712530288, 0.2044807913911083, 0.28328172937935026, 0.18462203656386933, 0.18219908217167735, 0.19448632516027997, 0.19209861749816914, 0.2077770535164435, 0.19704985040988854, 0.1846917856305128, 0.18459509104657246, 0.19518123245855046, 0.08134624833397996, 0.07891674349681854, 0.07846400237904294, 0.07727237923062058, 0.07196626556547958, 0.08872615365071401, 0.07396802371489997, 0.06963030973550544, 0.08203495318880727]}, "mutation_prompt": null}
