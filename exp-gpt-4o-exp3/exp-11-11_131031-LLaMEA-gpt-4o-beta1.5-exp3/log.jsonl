{"id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2024055606717674, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "1f3fb9ef-9ce1-4a38-8ec9-b01cfc76c9cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "42e5207d-2dc3-40d1-93ec-6f82d0716a16", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "6a8134b4-2ac8-4639-9ba0-1ca9ec0dc231", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "78976e1b-2472-415c-b1d7-cea2b9e19243", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "24fd8547-0032-4027-b2f9-8b2efbd2b72c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "0ceddbff-182d-498a-9dbb-58a9a9ad4dcd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "f1b86e81-c5aa-43dd-a2ce-b60c3cfb6ac7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "20e31109-7080-4179-9899-7d1dd49d0df6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "3122fa4b-37a1-4614-aac1-b558543897c9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "0dc91195-2f24-445d-bc20-ebd0ef16eb13", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "1acc9136-295d-47df-a045-2ef0abe348dd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "396fcf77-c1b3-4fd9-950a-f1714de5b3cd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "6bd3eb02-6eef-4b0d-abff-adeb41ec8ce3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "0c5482a7-cb7c-4f2d-bfbc-32f43f3fd89c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Common practice for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size  # Initial evaluations done during population initialization\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            self.crossover_rate = 0.9 - 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n            \n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution (ADE) algorithm dynamically adjusts mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.4520063604302569, 0.4291553361039552, 0.4406043283607646, 0.43219718256861617, 0.45290689392027916, 0.44730909687384746, 0.45714882105202803, 0.4665542056745362, 0.46693549411460533, 0.214699433442479, 0.2159663436628485, 0.21649707928191086, 0.19103523568713665, 0.2041447410216094, 0.2190067517027039, 0.19926834342688227, 0.21109694899842046, 0.22188565632522994, 0.10050711941063506, 0.09926275797437178, 0.10118887727938997, 0.10193245436907405, 0.10138290448628717, 0.10348083011277864, 0.09468939161931444, 0.09049423496020659, 0.10421806186309046, 0.07913670415619378, 0.09659776612906257, 0.09168796641303123, 0.08365289517725505, 0.08861498331745132, 0.08350519563139736, 0.08446183911371286, 0.07944536335651997, 0.09756746831811214, 0.9356166187977998, 0.9483471516172066, 0.9440802037062279, 0.9533396156998625, 0.9419375242576573, 0.9361752296190156, 0.8987370900352308, 0.9693867281349157, 0.9254693871998917, 0.20126518098993706, 0.18299481571228982, 0.19419305725558966, 0.19796234888098352, 0.19371633634160856, 0.21150832119479757, 0.2331954296541079, 0.21997908076785555, 0.20887234342718097, 0.24957733698204143, 0.2916391177048743, 0.3402388714209843, 0.2909102554844496, 0.2759048136339717, 0.27593450201403547, 0.2523338931421857, 0.2433293518268076, 0.324316508467247, 0.13102789507401935, 0.11637155231570417, 0.1181774780475725, 0.13372741062207183, 0.13583770343274304, 0.13443958638982623, 0.1136839165507203, 0.11480999333386421, 0.0952729688479611, 0.1709158164122857, 0.13697783892737703, 0.11301645702083774, 0.10497976543916743, 0.11717682154563058, 0.11980730219384716, 0.09585202498037837, 0.09681546006045483, 0.11958130327733796, 0.026842569264879934, 0.020943958163447518, 0.03884477042066048, 0.034526337193672596, 0.03440256114663698, 0.034265665894111064, 0.02078949403139685, 0.01699974209883548, 0.03687122083988348, 0.17191524033990224, 0.12227233212697597, 0.13347889197157115, 0.132191543549261, 0.08468419182322107, 0.1157520883850881, 0.17068203838219365, 0.169219266774996, 0.18769450480126892, 0.0017452895677790847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004579268850153362, 0.0015466145430386158, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010292576829884492, 0.09031849217700327, 0.07174280124873689, 0.0891972362419956, 0.09794431516107382, 0.08888205861771326, 0.10600121181149735, 0.10253364081863492, 0.10333591213005877, 0.09657914671013479, 0.37963724316274483, 0.3823280140233706, 0.3741417406519806, 0.3883773518209307, 0.38944498214305523, 0.38720112606788104, 0.3589485191068652, 0.3664264793634413, 0.3916104415632271, 0.09541178640090753, 0.08592589866415523, 0.08757095401549853, 0.07941395157035658, 0.08956739573627659, 0.07931954062876645, 0.07643344558631648, 0.07455400023680103, 0.07590007825668832, 0.1640153326119087, 0.1343187066151641, 0.19692320048952972, 0.13964003666697677, 0.12244573863848163, 0.14589325510863949, 0.16797561177915488, 0.17125565797703823, 0.14483586673579685, 0.2189001995566192, 0.22744995899991727, 0.22587454399066254, 0.22158410640431958, 0.21177697153782038, 0.21210326087434372, 0.25335803759417674, 0.23712564965705218, 0.22829350215391608, 0.16895505790996102, 0.18463948092044302, 0.1734237656740243, 0.15854878011682116, 0.16714268304906366, 0.1598812859036467, 0.18482016553092628, 0.17998855245271683, 0.1724897458196567, 0.17158197132635, 0.16691474700682862, 0.16558508248823622, 0.17911805640219447, 0.18492567297506035, 0.1760376669253343, 0.20175215743748576, 0.19639201463293243, 0.17416618660856187, 0.16278448658460587, 0.17583710277500908, 0.17891866315816463, 0.18542411692984728, 0.16441045794933473, 0.17360530662424278, 0.17151843226055008, 0.18344801361272678, 0.17515736222483025, 0.1841336963253538, 0.28841196594233487, 0.1583416384479015, 0.24687451321858278, 0.2573926129908455, 0.20835171613863923, 0.30408259668807247, 0.20813383733789537, 0.20753302619048586, 0.2846135849970618, 0.34025805388026054, 0.15900557599181242, 0.17258930261778915, 0.22993648680492262, 0.22697011676686685, 0.2038468548538238, 0.2011684372400362, 0.19146765124104892, 0.17408899604784744, 0.1864692655346687, 0.19542549355836114, 0.18059680464176742, 0.1865947927826207, 0.1907163361697889, 0.2008769656308227, 0.18743069362010178, 0.1851522567309678, 0.0686048003956099, 0.06797641008988464, 0.06986790115489216, 0.07224584906175091, 0.06276022644388746, 0.06463766540895155, 0.06467623501362996, 0.06306848587307745, 0.06890919391352912]}, "mutation_prompt": null}
{"id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * (1 - progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                # Mutation\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive population size reduction\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "RefinedAdaptiveDifferentialEvolution", "description": "The Refined Adaptive Differential Evolution (RADE) algorithm introduces adaptive population sizing and dynamic parameter tuning based on evaluation progress to balance exploration and exploitation efficiently.", "configspace": "", "generation": 15, "fitness": 0.31014860802206834, "feedback": "The algorithm RefinedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "7aa141e1-acf5-4955-b2d4-aba657ea69cf", "metadata": {"aucs": [0.6867564252091858, 0.690090084101042, 0.6854604659008778, 0.6810885242843867, 0.7149854781990248, 0.7093850889880371, 0.6972501227663807, 0.7097726587301576, 0.6898147516520652, 0.5244497059565008, 0.5289387516194355, 0.532410516414052, 0.5279200603573118, 0.5386428411993978, 0.5178872558303309, 0.5407132366638067, 0.5380793892196032, 0.5562888659357389, 0.330269458287772, 0.35000467204526353, 0.3302133435878387, 0.29793740721588424, 0.32666185571307615, 0.3579621064405295, 0.3468075479011019, 0.28692744681733673, 0.36903917469058933, 0.30640814374447034, 0.3273555219778438, 0.2728246095897495, 0.31528829131298763, 0.2573336237366288, 0.27199224593326765, 0.12523521803888993, 0.3038745443516301, 0.1184470451413685, 0.9706994232519732, 0.932961873225896, 0.9200262369249697, 0.8948837347523804, 0.9145479894842614, 0.9301448297496835, 0.8815862174108615, 0.9062974370115768, 0.9814168665297464, 0.38324311346435547, 0.4428348918107553, 0.42034624906302664, 0.42041237720379765, 0.4064350978633031, 0.39322958261143826, 0.41964778476165754, 0.4117158682025486, 0.37429357002895225, 0.5299404607767451, 0.5844323149552008, 0.5253979173036216, 0.57005411529359, 0.595534994119425, 0.5621452193787757, 0.563979388826729, 0.5886877549720752, 0.5900079357116137, 0.17834567163569193, 0.16397007840094013, 0.18944317030633573, 0.1586692139764394, 0.1664255773714809, 0.1883159791413841, 0.1707845296129804, 0.1632058228228409, 0.1484434140281886, 0.1583854749549619, 0.10830822900651493, 0.1947001691813266, 0.16605408074249484, 0.17991971727365985, 0.17099898820448778, 0.1942795777059093, 0.16877606696992975, 0.18934089732915882, 0.07731520745424936, 0.09402748067197009, 0.09429454267241266, 0.06276233924858221, 0.09959012258003963, 0.054050406990931665, 0.1422077854426227, 0.11050842169994957, 0.09971937318288893, 0.24038304692555224, 0.26863317997126646, 0.2406643127323097, 0.24300847963238126, 0.2033353402499286, 0.2559365966908568, 0.28137869757791945, 0.2493020513748102, 0.2898162212245292, 0.050796454411247915, 0.03746869066545877, 0.0404650774263553, 0.0636705521832297, 0.052435628407276225, 0.04312811895230917, 0.06026083488460021, 0.07457774162127606, 0.0543795124558214, 0.1574716019888427, 0.16928322114719052, 0.1630667983248073, 0.1589246205516356, 0.19682901577828527, 0.18144008688555646, 0.15504594925864634, 0.1611903860819779, 0.17522038545139496, 0.540240817432188, 0.5159581764018342, 0.5282465748616358, 0.49449981807363197, 0.5174960711339727, 0.49729921924960363, 0.5006512856645402, 0.503528585519232, 0.5048823568671946, 0.09344442501115813, 0.0833159521828537, 0.09967335278632161, 0.09115150567228048, 0.09759338919073235, 0.0916037669726516, 0.08500484613574733, 0.10891543627105271, 0.09366955523773757, 0.12468150865411864, 0.16193042424474047, 0.15779285832517254, 0.14070880361532578, 0.13948670588801737, 0.16283029291019935, 0.13971832079800606, 0.14763403652814855, 0.1620650310343752, 0.3454913951287406, 0.3435350965919022, 0.36212990475349216, 0.346927653031773, 0.39630679864437024, 0.3345739660780419, 0.41104141221508006, 0.36359347834126354, 0.3933758358408517, 0.25510058707366556, 0.24397850085838446, 0.22865277856708544, 0.2296434952965577, 0.25362779584758277, 0.2677735000644952, 0.27042501669653785, 0.28499136672473946, 0.25277785064953495, 0.19099751651494468, 0.18676312637847992, 0.18225707882714448, 0.19460757267232287, 0.1737261790598148, 0.18234039825735548, 0.18756966793863372, 0.18877940620434497, 0.20013153604480305, 0.21856570131796982, 0.3887286594538486, 0.23416330598897872, 0.3381363944225294, 0.18339877919785408, 0.27605500046455356, 0.3978044238360663, 0.20445209199216874, 0.3213375719424352, 0.5418432336975385, 0.5101405038862884, 0.1654294013252906, 0.5378728254902809, 0.48908042260290807, 0.5605110207332336, 0.587658338850239, 0.4852520304873751, 0.23193686992754659, 0.15976344481239813, 0.38495402958939295, 0.18188682320595662, 0.19094526250329413, 0.3526498543930152, 0.184451653896043, 0.408231319355401, 0.20040676905107935, 0.20376305738306233, 0.19095957812526498, 0.21087881127805475, 0.20011524956874904, 0.17769001227261982, 0.1773117236834565, 0.17038085132013603, 0.18116811819940426, 0.18816473861144378, 0.18030417085095396, 0.06850955361150612, 0.07334096206743457, 0.07475695080301592, 0.09140278664508028, 0.07656130594598742, 0.07616864496617459, 0.07176536211441364, 0.07524350577502104, 0.07244152045050245]}, "mutation_prompt": null}
{"id": "0cbf444b-3980-4e89-b7cf-33dc52d106a6", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * (1 - progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                # Mutation\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive population size reduction\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "RefinedAdaptiveDifferentialEvolution", "description": "The Refined Adaptive Differential Evolution (RADE) algorithm introduces adaptive population sizing and dynamic parameter tuning based on evaluation progress to balance exploration and exploitation efficiently.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "metadata": {"aucs": [0.6867564252091858, 0.690090084101042, 0.6854604659008778, 0.6810885242843867, 0.7149854781990248, 0.7093850889880371, 0.6972501227663807, 0.7097726587301576, 0.6898147516520652, 0.5244497059565008, 0.5289387516194355, 0.532410516414052, 0.5279200603573118, 0.5386428411993978, 0.5178872558303309, 0.5407132366638067, 0.5380793892196032, 0.5562888659357389, 0.330269458287772, 0.35000467204526353, 0.3302133435878387, 0.29793740721588424, 0.32666185571307615, 0.3579621064405295, 0.3468075479011019, 0.28692744681733673, 0.36903917469058933, 0.30640814374447034, 0.3273555219778438, 0.2728246095897495, 0.31528829131298763, 0.2573336237366288, 0.27199224593326765, 0.12523521803888993, 0.3038745443516301, 0.1184470451413685, 0.9706994232519732, 0.932961873225896, 0.9200262369249697, 0.8948837347523804, 0.9145479894842614, 0.9301448297496835, 0.8815862174108615, 0.9062974370115768, 0.9814168665297464, 0.38324311346435547, 0.4428348918107553, 0.42034624906302664, 0.42041237720379765, 0.4064350978633031, 0.39322958261143826, 0.41964778476165754, 0.4117158682025486, 0.37429357002895225, 0.5299404607767451, 0.5844323149552008, 0.5253979173036216, 0.57005411529359, 0.595534994119425, 0.5621452193787757, 0.563979388826729, 0.5886877549720752, 0.5900079357116137, 0.17834567163569193, 0.16397007840094013, 0.18944317030633573, 0.1586692139764394, 0.1664255773714809, 0.1883159791413841, 0.1707845296129804, 0.1632058228228409, 0.1484434140281886, 0.1583854749549619, 0.10830822900651493, 0.1947001691813266, 0.16605408074249484, 0.17991971727365985, 0.17099898820448778, 0.1942795777059093, 0.16877606696992975, 0.18934089732915882, 0.07731520745424936, 0.09402748067197009, 0.09429454267241266, 0.06276233924858221, 0.09959012258003963, 0.054050406990931665, 0.1422077854426227, 0.11050842169994957, 0.09971937318288893, 0.24038304692555224, 0.26863317997126646, 0.2406643127323097, 0.24300847963238126, 0.2033353402499286, 0.2559365966908568, 0.28137869757791945, 0.2493020513748102, 0.2898162212245292, 0.050796454411247915, 0.03746869066545877, 0.0404650774263553, 0.0636705521832297, 0.052435628407276225, 0.04312811895230917, 0.06026083488460021, 0.07457774162127606, 0.0543795124558214, 0.1574716019888427, 0.16928322114719052, 0.1630667983248073, 0.1589246205516356, 0.19682901577828527, 0.18144008688555646, 0.15504594925864634, 0.1611903860819779, 0.17522038545139496, 0.540240817432188, 0.5159581764018342, 0.5282465748616358, 0.49449981807363197, 0.5174960711339727, 0.49729921924960363, 0.5006512856645402, 0.503528585519232, 0.5048823568671946, 0.09344442501115813, 0.0833159521828537, 0.09967335278632161, 0.09115150567228048, 0.09759338919073235, 0.0916037669726516, 0.08500484613574733, 0.10891543627105271, 0.09366955523773757, 0.12468150865411864, 0.16193042424474047, 0.15779285832517254, 0.14070880361532578, 0.13948670588801737, 0.16283029291019935, 0.13971832079800606, 0.14763403652814855, 0.1620650310343752, 0.3454913951287406, 0.3435350965919022, 0.36212990475349216, 0.346927653031773, 0.39630679864437024, 0.3345739660780419, 0.41104141221508006, 0.36359347834126354, 0.3933758358408517, 0.25510058707366556, 0.24397850085838446, 0.22865277856708544, 0.2296434952965577, 0.25362779584758277, 0.2677735000644952, 0.27042501669653785, 0.28499136672473946, 0.25277785064953495, 0.19099751651494468, 0.18676312637847992, 0.18225707882714448, 0.19460757267232287, 0.1737261790598148, 0.18234039825735548, 0.18756966793863372, 0.18877940620434497, 0.20013153604480305, 0.21856570131796982, 0.3887286594538486, 0.23416330598897872, 0.3381363944225294, 0.18339877919785408, 0.27605500046455356, 0.3978044238360663, 0.20445209199216874, 0.3213375719424352, 0.5418432336975385, 0.5101405038862884, 0.1654294013252906, 0.5378728254902809, 0.48908042260290807, 0.5605110207332336, 0.587658338850239, 0.4852520304873751, 0.23193686992754659, 0.15976344481239813, 0.38495402958939295, 0.18188682320595662, 0.19094526250329413, 0.3526498543930152, 0.184451653896043, 0.408231319355401, 0.20040676905107935, 0.20376305738306233, 0.19095957812526498, 0.21087881127805475, 0.20011524956874904, 0.17769001227261982, 0.1773117236834565, 0.17038085132013603, 0.18116811819940426, 0.18816473861144378, 0.18030417085095396, 0.06850955361150612, 0.07334096206743457, 0.07475695080301592, 0.09140278664508028, 0.07656130594598742, 0.07616864496617459, 0.07176536211441364, 0.07524350577502104, 0.07244152045050245]}, "mutation_prompt": null}
{"id": "0ef9857a-9322-492b-bad3-e9523662d4e7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionWithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        \n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * (1 - progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n            # Local Search using Simulated Annealing\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                sa_candidate = np.copy(best_solution)\n                T = 1.0\n                cooling_rate = 0.9\n                while T > 1e-3 and evaluations < self.budget:\n                    neighbor = sa_candidate + np.random.normal(0, 0.1, self.dim)\n                    neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                    neighbor_fitness = func(neighbor)\n                    evaluations += 1\n\n                    if neighbor_fitness < best_fitness or np.exp((best_fitness - neighbor_fitness) / T) > np.random.rand():\n                        sa_candidate = neighbor\n                        if neighbor_fitness < best_fitness:\n                            best_solution = neighbor\n                            best_fitness = neighbor_fitness\n\n                    T *= cooling_rate\n\n        return best_solution", "name": "EnhancedDifferentialEvolutionWithLocalSearch", "description": "Integration of local search via simulated annealing within adaptive differential evolution for enhanced exploitation and convergence acceleration.", "configspace": "", "generation": 17, "fitness": 0.28671744749988864, "feedback": "The algorithm EnhancedDifferentialEvolutionWithLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "metadata": {"aucs": [0.6497305379335638, 0.6359884376373901, 0.6637877215259684, 0.6857769848792581, 0.6754292245807321, 0.6675106706300388, 0.6591124597833474, 0.6562590558138148, 0.6539586642481048, 0.4356740348841799, 0.44463189727114383, 0.45411425852571596, 0.441228457616501, 0.4288087791362767, 0.4500215138355427, 0.45155427283560134, 0.4749744838508766, 0.4546513331324824, 0.18635684646345452, 0.14660507372729537, 0.13525510258652484, 0.17295788919757926, 0.14641995325889146, 0.1706122590311867, 0.14768941119477164, 0.1793073748456453, 0.2582854437669784, 0.18537265099201317, 0.12419859785817022, 0.11297051347374232, 0.1351971573580999, 0.11664012442388338, 0.10950192021994098, 0.16547513575426842, 0.11113496195970962, 0.12528399304123727, 0.923297865717246, 0.9491886281706386, 0.9022196319195774, 0.8757810499645573, 0.923706343574846, 0.9349258819113238, 0.9243565723743842, 0.8741374354898392, 0.9298550919700835, 0.3944544127300508, 0.4137531784605212, 0.3389845901436297, 0.354582614242539, 0.3704982159470521, 0.343032311176788, 0.34965230065398023, 0.33978248425211877, 0.31309145944448913, 0.5865613071894901, 0.5568462106300875, 0.4120632301676209, 0.5813224377990525, 0.5148398133920304, 0.5702878290202459, 0.42545329866418047, 0.46622124392306163, 0.44209421441435914, 0.17044570512563972, 0.16068124591895028, 0.21537957319136491, 0.21337655425862923, 0.1586858840572306, 0.15508949801389338, 0.19890584186552118, 0.17089897017866784, 0.1896818149009457, 0.16544937297661544, 0.13675833085620048, 0.21890563748636904, 0.21092577188944694, 0.20599075181835802, 0.16667295421499184, 0.18686652376818624, 0.17670451476377835, 0.17293570187285734, 0.07118908848005778, 0.05094668707825256, 0.06094488782111929, 0.08260254796339228, 0.08367674085118437, 0.0253317683100579, 0.07233495455318373, 0.06265902144146585, 0.06813130510656229, 0.23000455451980284, 0.20476808802600832, 0.19839473391541118, 0.16973123727052375, 0.17007187903648413, 0.19507068913245562, 0.21601039649990805, 0.23344965455407252, 0.20143294597124872, 0.010798260742499566, 9.999999999998899e-05, 0.00985561962072612, 0.021816838743306866, 0.015246685587717912, 0.012103983571434385, 0.017023184685811654, 0.029420769862157248, 0.024706494943369628, 0.14122953200959454, 0.13592620830757618, 0.15152107697438255, 0.1462586470033833, 0.14790654216993193, 0.15519710909199658, 0.1346185691989613, 0.12145763069517468, 0.1334702829920097, 0.4502539353453655, 0.4699910881605537, 0.48483583622766613, 0.4690710233601719, 0.489017435187894, 0.4857980047936432, 0.46247999635113324, 0.44975374468190843, 0.48548747681073123, 0.10402587137573283, 0.11402485299581244, 0.12120099419013297, 0.1034491374655232, 0.11511186264185413, 0.10146863049991517, 0.1102533145121335, 0.1307088949094819, 0.12811137582525267, 0.17024955906548644, 0.27948841416177395, 0.17882148890248029, 0.14794638792820025, 0.30748480681118495, 0.2066174610252245, 0.22079823121301467, 0.18455456306484597, 0.2796168010934933, 0.31686346611310867, 0.28385812169046376, 0.31340030222059745, 0.28947113223628984, 0.2674417145244159, 0.3180799389618235, 0.33037958121023725, 0.38518498466203, 0.33120672260912487, 0.2618674246059727, 0.22228140813997033, 0.26671605388951314, 0.23032740367663473, 0.19791312208056022, 0.2481896698244226, 0.22150222460750335, 0.23427634261252994, 0.25058571025558685, 0.21396917198317322, 0.22682228956328077, 0.2058630189505417, 0.20607845365364852, 0.20696021396828113, 0.2016691708146532, 0.20296894250788977, 0.1732315699030612, 0.20127541172436048, 0.21266762784898618, 0.2084292871073058, 0.22489836329086332, 0.2686603685525837, 0.1971741483037771, 0.21492007343185437, 0.20126999678295387, 0.20949161966394025, 0.2355799421809346, 0.5082687603526241, 0.4179480527603112, 0.6323991285745165, 0.6875440673159141, 0.2036785699106748, 0.6494481944899744, 0.628663219430146, 0.38430068185402777, 0.3788586972706661, 0.5979507775188926, 0.21164613730426696, 0.3669551354696772, 0.30208854552245945, 0.423429689723238, 0.18654063098866525, 0.2123985997121529, 0.41336290117301766, 0.4974590092046557, 0.17978599417188523, 0.18272253732693067, 0.2005619201865686, 0.1813743675443492, 0.18191590083949039, 0.18194005301515725, 0.19591293484290695, 0.19751947645892587, 0.1951303836464997, 0.07796115264392178, 0.0862778286647704, 0.07617941090103719, 0.06885932111388682, 0.07897991416211336, 0.07340348093318516, 0.06981192818909354, 0.08624393230597505, 0.07812102719328484]}, "mutation_prompt": null}
{"id": "7e5f2be9-c8d9-4b63-af57-50dad94eedc4", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * (1 - progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                # Mutation\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive population size reduction\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "RefinedAdaptiveDifferentialEvolution", "description": "The Refined Adaptive Differential Evolution (RADE) algorithm introduces adaptive population sizing and dynamic parameter tuning based on evaluation progress to balance exploration and exploitation efficiently.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "metadata": {"aucs": [0.6867564252091858, 0.690090084101042, 0.6854604659008778, 0.6810885242843867, 0.7149854781990248, 0.7093850889880371, 0.6972501227663807, 0.7097726587301576, 0.6898147516520652, 0.5244497059565008, 0.5289387516194355, 0.532410516414052, 0.5279200603573118, 0.5386428411993978, 0.5178872558303309, 0.5407132366638067, 0.5380793892196032, 0.5562888659357389, 0.330269458287772, 0.35000467204526353, 0.3302133435878387, 0.29793740721588424, 0.32666185571307615, 0.3579621064405295, 0.3468075479011019, 0.28692744681733673, 0.36903917469058933, 0.30640814374447034, 0.3273555219778438, 0.2728246095897495, 0.31528829131298763, 0.2573336237366288, 0.27199224593326765, 0.12523521803888993, 0.3038745443516301, 0.1184470451413685, 0.9706994232519732, 0.932961873225896, 0.9200262369249697, 0.8948837347523804, 0.9145479894842614, 0.9301448297496835, 0.8815862174108615, 0.9062974370115768, 0.9814168665297464, 0.38324311346435547, 0.4428348918107553, 0.42034624906302664, 0.42041237720379765, 0.4064350978633031, 0.39322958261143826, 0.41964778476165754, 0.4117158682025486, 0.37429357002895225, 0.5299404607767451, 0.5844323149552008, 0.5253979173036216, 0.57005411529359, 0.595534994119425, 0.5621452193787757, 0.563979388826729, 0.5886877549720752, 0.5900079357116137, 0.17834567163569193, 0.16397007840094013, 0.18944317030633573, 0.1586692139764394, 0.1664255773714809, 0.1883159791413841, 0.1707845296129804, 0.1632058228228409, 0.1484434140281886, 0.1583854749549619, 0.10830822900651493, 0.1947001691813266, 0.16605408074249484, 0.17991971727365985, 0.17099898820448778, 0.1942795777059093, 0.16877606696992975, 0.18934089732915882, 0.07731520745424936, 0.09402748067197009, 0.09429454267241266, 0.06276233924858221, 0.09959012258003963, 0.054050406990931665, 0.1422077854426227, 0.11050842169994957, 0.09971937318288893, 0.24038304692555224, 0.26863317997126646, 0.2406643127323097, 0.24300847963238126, 0.2033353402499286, 0.2559365966908568, 0.28137869757791945, 0.2493020513748102, 0.2898162212245292, 0.050796454411247915, 0.03746869066545877, 0.0404650774263553, 0.0636705521832297, 0.052435628407276225, 0.04312811895230917, 0.06026083488460021, 0.07457774162127606, 0.0543795124558214, 0.1574716019888427, 0.16928322114719052, 0.1630667983248073, 0.1589246205516356, 0.19682901577828527, 0.18144008688555646, 0.15504594925864634, 0.1611903860819779, 0.17522038545139496, 0.540240817432188, 0.5159581764018342, 0.5282465748616358, 0.49449981807363197, 0.5174960711339727, 0.49729921924960363, 0.5006512856645402, 0.503528585519232, 0.5048823568671946, 0.09344442501115813, 0.0833159521828537, 0.09967335278632161, 0.09115150567228048, 0.09759338919073235, 0.0916037669726516, 0.08500484613574733, 0.10891543627105271, 0.09366955523773757, 0.12468150865411864, 0.16193042424474047, 0.15779285832517254, 0.14070880361532578, 0.13948670588801737, 0.16283029291019935, 0.13971832079800606, 0.14763403652814855, 0.1620650310343752, 0.3454913951287406, 0.3435350965919022, 0.36212990475349216, 0.346927653031773, 0.39630679864437024, 0.3345739660780419, 0.41104141221508006, 0.36359347834126354, 0.3933758358408517, 0.25510058707366556, 0.24397850085838446, 0.22865277856708544, 0.2296434952965577, 0.25362779584758277, 0.2677735000644952, 0.27042501669653785, 0.28499136672473946, 0.25277785064953495, 0.19099751651494468, 0.18676312637847992, 0.18225707882714448, 0.19460757267232287, 0.1737261790598148, 0.18234039825735548, 0.18756966793863372, 0.18877940620434497, 0.20013153604480305, 0.21856570131796982, 0.3887286594538486, 0.23416330598897872, 0.3381363944225294, 0.18339877919785408, 0.27605500046455356, 0.3978044238360663, 0.20445209199216874, 0.3213375719424352, 0.5418432336975385, 0.5101405038862884, 0.1654294013252906, 0.5378728254902809, 0.48908042260290807, 0.5605110207332336, 0.587658338850239, 0.4852520304873751, 0.23193686992754659, 0.15976344481239813, 0.38495402958939295, 0.18188682320595662, 0.19094526250329413, 0.3526498543930152, 0.184451653896043, 0.408231319355401, 0.20040676905107935, 0.20376305738306233, 0.19095957812526498, 0.21087881127805475, 0.20011524956874904, 0.17769001227261982, 0.1773117236834565, 0.17038085132013603, 0.18116811819940426, 0.18816473861144378, 0.18030417085095396, 0.06850955361150612, 0.07334096206743457, 0.07475695080301592, 0.09140278664508028, 0.07656130594598742, 0.07616864496617459, 0.07176536211441364, 0.07524350577502104, 0.07244152045050245]}, "mutation_prompt": null}
{"id": "c0b30472-dae6-4d42-a6f0-fca3b80bf88f", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * (1 - progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                # Mutation\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive population size reduction\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "RefinedAdaptiveDifferentialEvolution", "description": "The Refined Adaptive Differential Evolution (RADE) algorithm introduces adaptive population sizing and dynamic parameter tuning based on evaluation progress to balance exploration and exploitation efficiently.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "metadata": {"aucs": [0.6867564252091858, 0.690090084101042, 0.6854604659008778, 0.6810885242843867, 0.7149854781990248, 0.7093850889880371, 0.6972501227663807, 0.7097726587301576, 0.6898147516520652, 0.5244497059565008, 0.5289387516194355, 0.532410516414052, 0.5279200603573118, 0.5386428411993978, 0.5178872558303309, 0.5407132366638067, 0.5380793892196032, 0.5562888659357389, 0.330269458287772, 0.35000467204526353, 0.3302133435878387, 0.29793740721588424, 0.32666185571307615, 0.3579621064405295, 0.3468075479011019, 0.28692744681733673, 0.36903917469058933, 0.30640814374447034, 0.3273555219778438, 0.2728246095897495, 0.31528829131298763, 0.2573336237366288, 0.27199224593326765, 0.12523521803888993, 0.3038745443516301, 0.1184470451413685, 0.9706994232519732, 0.932961873225896, 0.9200262369249697, 0.8948837347523804, 0.9145479894842614, 0.9301448297496835, 0.8815862174108615, 0.9062974370115768, 0.9814168665297464, 0.38324311346435547, 0.4428348918107553, 0.42034624906302664, 0.42041237720379765, 0.4064350978633031, 0.39322958261143826, 0.41964778476165754, 0.4117158682025486, 0.37429357002895225, 0.5299404607767451, 0.5844323149552008, 0.5253979173036216, 0.57005411529359, 0.595534994119425, 0.5621452193787757, 0.563979388826729, 0.5886877549720752, 0.5900079357116137, 0.17834567163569193, 0.16397007840094013, 0.18944317030633573, 0.1586692139764394, 0.1664255773714809, 0.1883159791413841, 0.1707845296129804, 0.1632058228228409, 0.1484434140281886, 0.1583854749549619, 0.10830822900651493, 0.1947001691813266, 0.16605408074249484, 0.17991971727365985, 0.17099898820448778, 0.1942795777059093, 0.16877606696992975, 0.18934089732915882, 0.07731520745424936, 0.09402748067197009, 0.09429454267241266, 0.06276233924858221, 0.09959012258003963, 0.054050406990931665, 0.1422077854426227, 0.11050842169994957, 0.09971937318288893, 0.24038304692555224, 0.26863317997126646, 0.2406643127323097, 0.24300847963238126, 0.2033353402499286, 0.2559365966908568, 0.28137869757791945, 0.2493020513748102, 0.2898162212245292, 0.050796454411247915, 0.03746869066545877, 0.0404650774263553, 0.0636705521832297, 0.052435628407276225, 0.04312811895230917, 0.06026083488460021, 0.07457774162127606, 0.0543795124558214, 0.1574716019888427, 0.16928322114719052, 0.1630667983248073, 0.1589246205516356, 0.19682901577828527, 0.18144008688555646, 0.15504594925864634, 0.1611903860819779, 0.17522038545139496, 0.540240817432188, 0.5159581764018342, 0.5282465748616358, 0.49449981807363197, 0.5174960711339727, 0.49729921924960363, 0.5006512856645402, 0.503528585519232, 0.5048823568671946, 0.09344442501115813, 0.0833159521828537, 0.09967335278632161, 0.09115150567228048, 0.09759338919073235, 0.0916037669726516, 0.08500484613574733, 0.10891543627105271, 0.09366955523773757, 0.12468150865411864, 0.16193042424474047, 0.15779285832517254, 0.14070880361532578, 0.13948670588801737, 0.16283029291019935, 0.13971832079800606, 0.14763403652814855, 0.1620650310343752, 0.3454913951287406, 0.3435350965919022, 0.36212990475349216, 0.346927653031773, 0.39630679864437024, 0.3345739660780419, 0.41104141221508006, 0.36359347834126354, 0.3933758358408517, 0.25510058707366556, 0.24397850085838446, 0.22865277856708544, 0.2296434952965577, 0.25362779584758277, 0.2677735000644952, 0.27042501669653785, 0.28499136672473946, 0.25277785064953495, 0.19099751651494468, 0.18676312637847992, 0.18225707882714448, 0.19460757267232287, 0.1737261790598148, 0.18234039825735548, 0.18756966793863372, 0.18877940620434497, 0.20013153604480305, 0.21856570131796982, 0.3887286594538486, 0.23416330598897872, 0.3381363944225294, 0.18339877919785408, 0.27605500046455356, 0.3978044238360663, 0.20445209199216874, 0.3213375719424352, 0.5418432336975385, 0.5101405038862884, 0.1654294013252906, 0.5378728254902809, 0.48908042260290807, 0.5605110207332336, 0.587658338850239, 0.4852520304873751, 0.23193686992754659, 0.15976344481239813, 0.38495402958939295, 0.18188682320595662, 0.19094526250329413, 0.3526498543930152, 0.184451653896043, 0.408231319355401, 0.20040676905107935, 0.20376305738306233, 0.19095957812526498, 0.21087881127805475, 0.20011524956874904, 0.17769001227261982, 0.1773117236834565, 0.17038085132013603, 0.18116811819940426, 0.18816473861144378, 0.18030417085095396, 0.06850955361150612, 0.07334096206743457, 0.07475695080301592, 0.09140278664508028, 0.07656130594598742, 0.07616864496617459, 0.07176536211441364, 0.07524350577502104, 0.07244152045050245]}, "mutation_prompt": null}
{"id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 20, "fitness": 0.31618324302083317, "feedback": "The algorithm EnhancedMultiPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "3a92f66a-24d1-4dbf-84e1-422ca8c465a6", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "7d587f08-bd90-490d-bbdc-1110e07b59b0", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "e9f4dec9-1141-402a-9b04-79f4613f0336", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "e962e755-58f0-4a00-9cc3-290d29f199e0", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "ccce0234-abdd-4adb-8165-6f53857a1e22", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "a3ad738e-3d0a-49ca-8b53-e828f537d2a6", "solution": "import numpy as np\n\nclass AdaptiveEliteGuidedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.4 * np.exp(-5 * progress_ratio) * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.8 + 0.2 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                elite_size = max(1, int(elite_fraction * population_size))\n                elite_indices = np.argsort(fitness)[:elite_size]\n                if i in elite_indices:\n                    a, b, c = population[np.random.choice(elite_indices, 3, replace=False)]\n                else:\n                    a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEliteGuidedDifferentialEvolution", "description": "Adaptive Elite-Guided Differential Evolution (AEGDE) integrates adaptive mutation strategy and elite-guided recombination to enhance exploration and exploitation balance for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {}, "mutation_prompt": null}
{"id": "a4ac1221-f2b8-485b-b0e0-ce2349582443", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "5a44b228-e317-4c4b-a1e1-3f341a342857", "solution": "import numpy as np\n\nclass AdaptiveNicheBasedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            niche_radius = 0.01 * (1 - evaluations / self.budget) * (self.upper_bound - self.lower_bound)\n            mutation_factor = 0.5 + 0.5 * (1 - evaluations / self.budget)\n            crossover_rate = 0.7 + 0.3 * (evaluations / self.budget)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n\n                # Adaptive niche control\n                if np.linalg.norm(a - b) < niche_radius and np.linalg.norm(b - c) < niche_radius:\n                    mutation_factor *= 0.5  # Increase diversity if in same niche\n\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - evaluations/self.budget)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveNicheBasedMultiPhaseDifferentialEvolution", "description": "The Adaptive Niche-based Multi-phase Differential Evolution (ANMDE) enhances convergence by incorporating adaptive niche preservation and multi-scale exploration, balancing exploration-exploitation dynamics effectively.", "configspace": "", "generation": 27, "fitness": 0.27666381742903595, "feedback": "The algorithm AdaptiveNicheBasedMultiPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.6005763391868431, 0.47625605699500295, 0.45708870476861707, 0.5179157576280368, 0.4881516782615779, 0.5263475879738371, 0.4988221699916088, 0.520803661716051, 0.5064368647620763, 0.4034124078923764, 0.3436244338108446, 0.29895811490991486, 0.29811822915046704, 0.31492989728369725, 0.3187845622340658, 0.3212996166083256, 0.38905006242077445, 0.35703405502837726, 0.2002430126317628, 0.13377236840405626, 0.12823683638080363, 0.13314763631321025, 0.11252549627694242, 0.12249707206247862, 0.13499289058221076, 0.12127418094614073, 0.2423959719882307, 0.12878019006536323, 0.10347334903067984, 0.15839722793038724, 0.13634740351381547, 0.1249387762397498, 0.11580538983822208, 0.09195555501029207, 0.10080519846518143, 0.12211454833964108, 0.9568570444437329, 0.9378692079302288, 0.9701678885464637, 0.973597228670303, 0.9393289556470995, 0.9849601776500131, 0.9606668562231803, 0.9741453845579955, 0.9644587874170363, 0.26786000647190145, 0.2833362970797315, 0.2697960379093679, 0.2786114191199479, 0.2967849036727349, 0.23809141018381674, 0.276311106348737, 0.2357285693882636, 0.28270042066059475, 0.6113032344201896, 0.609705094447357, 0.5914886842731292, 0.6112935140014755, 0.6664716824244654, 0.6037140255983335, 0.6243260398388759, 0.6242947946593205, 0.6204086326836254, 0.13727313784170014, 0.16282722246145132, 0.1477322478701022, 0.16366768359566397, 0.14788801265383755, 0.14430298343925274, 0.14906808793099302, 0.17300853646085157, 0.13779261298242473, 0.14744678144324463, 0.26916093387962536, 0.18624023918550625, 0.14309055155293193, 0.14197411857495668, 0.18148309387749784, 0.1440226029193975, 0.14831603643025615, 0.15078763070436507, 0.20490004643989224, 0.22734783096094646, 0.13352468935784567, 0.1424152554155218, 0.14868433672349346, 0.2402207119070604, 0.22537523154025152, 0.20791633396549347, 0.14194556363464617, 0.30966771227654943, 0.30969994320824334, 0.29598436911734094, 0.26248072340813144, 0.24917464093314223, 0.2806571039714637, 0.329272502312008, 0.33302519389955976, 0.24327811751607442, 0.08351171224991671, 0.07443629546461072, 0.06415751429128136, 0.1389660882772823, 0.12322428025842491, 0.07720599185669341, 0.08033768371275496, 0.10941119766415974, 0.1102057664139755, 0.16335127026300122, 0.16887465773042643, 0.14179221335959502, 0.17400469262891527, 0.19274141985835191, 0.1496190722289511, 0.15401719129906855, 0.1820600099267211, 0.1692805778578208, 0.47866787324387206, 0.4675452905370062, 0.48174294519854766, 0.4249488594453178, 0.4688628989168009, 0.42835968526132484, 0.46715483294097915, 0.4381327761651028, 0.47684388617820483, 0.10942339982757021, 0.09164587460444795, 0.10088175786638964, 0.08734854927628388, 0.07739032469725338, 0.08702978102776893, 0.08724364239353544, 0.1080815930027833, 0.09393798329466152, 0.14876430778285554, 0.15867606228481546, 0.14290050986453096, 0.18436420844282198, 0.16885018728831602, 0.1350740682588938, 0.14517367550749372, 0.19269948726383113, 0.20532985691522598, 0.31214369696400435, 0.32058882858858073, 0.29461923128186296, 0.2976328016970896, 0.3252801207271432, 0.3093480560982321, 0.30820929151965004, 0.3040534255318875, 0.29850663952134204, 0.23757342659335234, 0.2390271769598047, 0.2502780004294004, 0.23767933971817512, 0.23547093985232603, 0.23894545072956253, 0.23452228736469605, 0.26698730611458876, 0.2492656578890292, 0.16573154109146837, 0.17854119277536806, 0.19270967769670766, 0.16850394325282736, 0.18508877011320035, 0.19289071134208458, 0.1590370566433772, 0.1723947966479138, 0.16589425320430073, 0.1870360712083391, 0.3109537636529538, 0.18867572484904982, 0.21601886070547316, 0.21023597334214317, 0.18941069499820617, 0.3070865732145297, 0.2034310278103717, 0.2074408156272297, 0.16235845323442666, 0.19345163194548454, 0.15869288221102074, 0.6436756765160767, 0.5074508133406301, 0.16994848054246559, 0.16500131612359237, 0.15203303376280897, 0.5843481248538248, 0.6402586914790427, 0.19573840106384588, 0.18781716192436293, 0.5886099115658997, 0.6306118080884464, 0.5873185781542938, 0.19769986276010332, 0.19911536937476726, 0.20250095627916576, 0.1870264033840754, 0.17774889081659417, 0.18068251977481609, 0.21505894040303464, 0.16674375543352593, 0.18274703387975022, 0.18339399906119647, 0.21013796512478544, 0.1714758908209083, 0.07556430459390562, 0.07755579439881954, 0.07466954610003218, 0.07497033058235536, 0.08364115146187467, 0.07001929042580213, 0.06981382153267646, 0.0781604777036109, 0.07261468806758808]}, "mutation_prompt": null}
{"id": "23eaaaca-b899-458e-80ee-dd29feb93a65", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "b16aa76d-bcf3-4bb2-8661-8cc0b5bc6bb3", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.8 * (1 - progress_ratio) + 0.2 * (1 - diversity / (self.upper_bound - self.lower_bound))\n            crossover_rate = 0.9 - 0.5 * (1 - progress_ratio)\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedMultiPhaseDifferentialEvolution", "description": "Enhanced Multi-phase Differential Evolution (EMDE) algorithm utilizes a multi-phase strategy with adaptive parameter scaling and elite preservation to improve convergence efficiency across diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.7299242595346332, 0.7120074501602324, 0.7289209152934264, 0.7415960380020671, 0.7345290819453263, 0.7303457998091676, 0.7410040069263251, 0.737972806822629, 0.7307843755166732, 0.592948755981012, 0.594651887622459, 0.5912214875454742, 0.6014161543611587, 0.5911427125231319, 0.5983314827880988, 0.5973414838407485, 0.5994235402800815, 0.5982562615230944, 0.1529411225908257, 0.5488478725081174, 0.14306380525474305, 0.46650094572008105, 0.4544807301563647, 0.5064542383267066, 0.17531057758475888, 0.21412536245372993, 0.5067263365214936, 0.14889842965537514, 0.12661730704341911, 0.145782319678736, 0.1373177561673511, 0.11655192128314085, 0.1302045328460415, 0.1480250988508125, 0.1468725984557353, 0.14380720535979052, 0.9556747837104893, 0.9515879731080314, 0.9586613175638016, 0.957378298556628, 0.9559057842242965, 0.9661299901923568, 0.9432320889341749, 0.9614906506634907, 0.9558336640036412, 0.37382448375849, 0.36547815814215623, 0.40570278221441236, 0.42810830652118925, 0.43012703428952337, 0.43841677665265133, 0.3185232120450654, 0.2523743452904077, 0.3575098456531869, 0.5869987409430231, 0.5890702875635261, 0.6054814187312128, 0.6351625081403586, 0.6127097261701239, 0.6051531324468202, 0.6501581753540138, 0.5991049186018322, 0.3162936606332831, 0.13698340963568845, 0.14432900681691951, 0.1581145510734261, 0.12283798381080546, 0.17059214343071583, 0.12451614803764299, 0.15344528119243073, 0.12950915972531618, 0.1544804573231946, 0.12830396251158804, 0.08117330588880545, 0.1330727764917703, 0.14086903196775225, 0.13638794734744608, 0.12562802897232428, 0.13692748723233816, 0.11836516373292472, 0.13748019440198767, 0.19436804493785798, 0.06189272043043914, 0.10494762034552574, 0.00037169923369129165, 0.1537713239533216, 0.10173264597083875, 0.11902767297401406, 0.050719619498730384, 0.08077145048816814, 0.1570698686666503, 0.21889295927681818, 0.19981530627324873, 0.1440425775131804, 0.1886617872823273, 0.19744016576616108, 0.2502074807460911, 0.21807111624153253, 0.16494644095754718, 0.06441661738774584, 0.07744530925547477, 0.07049217051772882, 0.07256724037056883, 0.10296632341400114, 0.10359783829751812, 0.11613293269522729, 0.12895793343622064, 0.10941808405122333, 0.17229299916891827, 0.16609278362373747, 0.2190048388572512, 0.22473817797627105, 0.2165461718569034, 0.20378815619404023, 0.19569725751362133, 0.2156544283035573, 0.15887870040563434, 0.5117542187018971, 0.5531177738248434, 0.5984533892838687, 0.5904747827647461, 0.5661676095778445, 0.5933371409083141, 0.5344686760547247, 0.5492108599728114, 0.47890989682589535, 0.09020845489258356, 0.10725491657255226, 0.08849212003409579, 0.13460920012520583, 0.11853230738229725, 0.07765687688780087, 0.0998675716472861, 0.10791746051365403, 0.10292621940923907, 0.1690732423987179, 0.20686408067553907, 0.14246590522358327, 0.14695656783607813, 0.16151916925923615, 0.26090638068340444, 0.14325992199187076, 0.13365270698291898, 0.1351093390224538, 0.4211376538775373, 0.4612988513782247, 0.39358238476282026, 0.388495452013514, 0.40606978083972234, 0.3786320947515053, 0.5159753542762238, 0.47558106839616177, 0.45256009370629047, 0.2853193840528627, 0.3363726105489061, 0.3542849091832625, 0.2686659647186699, 0.27496655821629223, 0.24949772679868287, 0.3520140861665024, 0.27453259521923423, 0.38471712960913806, 0.17475416088990114, 0.18301390707469534, 0.18645492359446958, 0.17483038604000956, 0.17254969865586645, 0.17421724023122498, 0.18878304077363095, 0.17499858856031547, 0.1847684907588506, 0.21864378332939016, 0.5300004752743299, 0.25972045813842515, 0.4115826858241116, 0.579893652348838, 0.1993276573009779, 0.5444525704786489, 0.5805092454452621, 0.5686725363507452, 0.1616115280920627, 0.18941419352616107, 0.633604155163799, 0.6326299948292948, 0.1788164016613688, 0.17014899188868293, 0.23998289753462965, 0.15616362893247426, 0.16706097822298538, 0.15893396796557513, 0.19079622792535766, 0.6113815191660597, 0.18104050427354046, 0.18108228614587618, 0.5988466757845836, 0.32534698716154753, 0.17899941813853526, 0.20062821759913585, 0.17346490169054063, 0.1787189834689762, 0.18232497838524309, 0.1894372047335826, 0.18879624511796478, 0.17023704812557028, 0.19284289726381731, 0.17627548134945847, 0.18500407088296866, 0.0793936515025856, 0.08271350717831938, 0.07613297067684055, 0.08344670041917435, 0.07369270451001908, 0.08728207663463672, 0.06759726953491207, 0.08486397930096667, 0.0839300301579935]}, "mutation_prompt": null}
{"id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 30, "fitness": 0.3229799443233226, "feedback": "The algorithm AdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "f09d0a64-db66-436a-a978-5f68ca1b278e", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "8fefd69b-9acf-4cb8-892c-4dcf35dc7b60", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "002c2589-d955-4187-b072-13da0e151a32", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "607f494a-9d9a-47c2-bebc-73cfbc641ded", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "ab984f13-389b-4242-be14-72ac0420966d", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "762ee24d-c8ac-4baf-b17e-a8355aa0a42a", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "0292bef2-5e82-4c4a-a36d-37d321cd2b29", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "e2aceeed-e92a-4f62-885f-a5a651ac4e65", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "f8a8a469-dddd-4ba3-b273-1a61b26fec6e", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "5d679452-ab53-422a-8282-e4ed54cafc7b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n        restart_threshold = 0.5\n        no_improvement_counter = 0\n        max_no_improvement = 50\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    no_improvement_counter = 0\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                else:\n                    no_improvement_counter += 1\n\n                if evaluations >= self.budget:\n                    break\n\n            # Local Search\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n                        no_improvement_counter = 0\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Adaptive restart mechanism\n            if no_improvement_counter > max_no_improvement:\n                no_improvement_counter = 0\n                new_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n                fitness = np.array([func(ind) for ind in new_population])\n                evaluations += self.initial_population_size\n                best_idx = np.argmin(fitness)\n                best_solution = new_population[best_idx]\n                best_fitness = fitness[best_idx]\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution (EADE) introduces a dynamic learning rate and adaptive restart mechanism to improve convergence and robustness in diverse optimization landscapes.", "configspace": "", "generation": 39, "fitness": 0.3069724627027909, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.12257925954071758, 0.1338431658544128, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.11770394046213295, 0.1119366268231955, 0.11827347881412531, 0.3479434135083328, 0.12715025281841608, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.062097012606704305, 0.12990133738071052, 0.12922090787647156, 0.07347094772841045, 0.07714824965308054, 0.16799162492478903, 0.05417658747591181, 0.1292267479482132, 0.1404311356396667, 0.13952771534559538, 0.1976126253401601, 0.13548372468827186, 0.11618744362224775, 0.2117754468772174, 0.13639987905156048, 0.2005632270607245, 0.24826398249779447, 0.27378862328001774, 0.028134097747066544, 0.037445432245120314, 0.06467860186283392, 0.04278691955200897, 0.07733148952448687, 0.038936571524124886, 0.048483945359490854, 0.035268356883976004, 0.03325734043736139, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.12804929759039863, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5081849571550592, 0.5276689981856666, 0.4465917104221033, 0.455280848725775, 0.44312068628836887, 0.48626098931224637, 0.08649618041871276, 0.09230788287234792, 0.09605470465852739, 0.10416602604203617, 0.08354712320974267, 0.09676411958259501, 0.08135989847919578, 0.10505382564325028, 0.0909944238388718, 0.1491510236821506, 0.19395357207187436, 0.19717989382537637, 0.1443611444185764, 0.3358712531837341, 0.16143528896360604, 0.14720603019968292, 0.19308656462677332, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.28834064258083814, 0.3549224511085626, 0.34009051627461073, 0.35272905823815603, 0.4142706539267902, 0.40166195392046955, 0.36865828724855554, 0.24992904408683703, 0.28797182863774107, 0.23205115802595233, 0.25946983166440907, 0.23176379635966193, 0.2569986779522405, 0.21480836294604244, 0.29319117380434645, 0.28122545178280345, 0.17787297720267436, 0.1963013650123635, 0.19694963036455115, 0.19269888821021486, 0.17970829181312842, 0.18271161824571924, 0.17678672168541087, 0.2048594912448698, 0.18288026889732922, 0.17911070730436218, 0.20965237972165962, 0.2026142904333489, 0.4919610615824038, 0.21864975698684352, 0.18868592671271045, 0.3681033838262555, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.5054042783592811, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.20073314631184846, 0.20175249635119907, 0.1785988956865544, 0.17885686060644368, 0.18011562392905123, 0.1791905054935904, 0.1906174520970808, 0.19826621882519802, 0.19887561404496856, 0.19952950335581388, 0.18980935550372846, 0.0610356008038383, 0.07940153040265763, 0.06668375608448063, 0.0681369857710642, 0.07005929266812383, 0.07152719840100086, 0.0651526364513596, 0.0892862158069414, 0.07061671127623648]}, "mutation_prompt": null}
{"id": "2e415efb-675a-4074-af3a-3d16b8a96c6d", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "5be0371b-1cb1-4635-b99d-602723a1c300", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "28cebdf9-3ec8-46e0-8a40-f561e5bb9bc9", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "2766ce08-d5fc-4602-bf0b-a935ab79244f", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "e8f3cbe2-5e93-4e58-afcd-de96674ecd4d", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "c446697f-82f4-4375-9212-ddc97653214e", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "ee8bfcd4-7124-4a01-9467-f188c61441dc", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "2adde309-e9f9-45b7-b5d4-db314dd4e68b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim  # Slightly increased initial population\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.15  # Slightly reduced to foster diversity\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic mutation range\n            crossover_rate = 0.5 + 0.4 * np.random.rand()  # More dynamic range for crossover\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.6:  # Early local search to aid exploration\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.4:  # Slightly earlier elitism\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution (E-ADE) incorporates adaptive mutation strategies, elitist selection, and dynamic crossover for balanced exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.2840464621104459, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.5639498615164973, 0.5777538857657967, 0.5744846915583346, 0.5929576572602884, 0.575221371097196, 0.5636511695119502, 0.5760040636476719, 0.5624550094638916, 0.5727976004106414, 0.39214294118134485, 0.3552641307935379, 0.3777201854670099, 0.38489250158613375, 0.38560777415674163, 0.36367311099105015, 0.3609233931222766, 0.36412380635314023, 0.38183284675246565, 0.2970433973379071, 0.27700110553559787, 0.26217187137515163, 0.2929231421957533, 0.27546747577904174, 0.29096849368775524, 0.2795005840602338, 0.21125523677235647, 0.23774382596300958, 0.1077680159858535, 0.12420578692359718, 0.11421484871219112, 0.11684990247197002, 0.24201416262402042, 0.12209186599574018, 0.23907601317382177, 0.26215760852140835, 0.2536991744216728, 0.855607886393968, 0.9204877228778118, 0.9218245364753123, 0.8722169085641737, 0.8872914874550015, 0.8662767919916594, 0.8574904417524163, 0.8616736755300551, 0.8592005626532894, 0.2940260107653303, 0.34271187640900713, 0.32646716967295064, 0.3100077544554739, 0.3151528553200885, 0.31348233176307405, 0.3168373387607055, 0.3357498165541396, 0.28157931438737804, 0.45575707482529026, 0.444993137258497, 0.446077761931307, 0.47221525785463037, 0.5218991421248205, 0.5081884748394407, 0.5011373838191227, 0.5039989642146679, 0.4132500868619714, 0.1527620665162529, 0.2419675717698756, 0.19251481761976952, 0.1659783552676536, 0.1540134692864683, 0.13176867342431997, 0.17567740876297833, 0.16614414547482448, 0.16361075138094872, 0.12568748812913688, 0.13047723438547765, 0.11651890217411853, 0.12452956387118497, 0.15600235195179724, 0.1702664040290005, 0.15092628044029022, 0.14803213021911366, 0.11987130063582352, 0.12191344127296522, 0.10050264168216783, 0.08096209430925205, 0.08849571005246726, 0.1044230136945149, 0.11283514981840526, 0.11666588732541783, 0.10936572936226985, 0.07799051919006195, 0.21836702496376148, 0.16971927199802883, 0.2254570364203361, 0.2012392392733755, 0.17234744167482352, 0.1803420906424812, 0.21995392724613672, 0.21645211290029376, 0.2488008211298237, 0.02439879893992969, 0.027111966482065708, 0.03490839916140409, 0.04935103106732752, 0.07616368708878785, 0.038247716708847856, 0.06051297956688073, 0.03770491870770565, 0.033838671228751616, 0.12824242519494655, 0.13990053503263045, 0.13276620219366742, 0.1555304589284493, 0.14293677443353336, 0.15097223010375527, 0.12740522985228253, 0.12349686307760532, 0.15346202448790058, 0.46056498152537173, 0.4787361332585769, 0.44574326293568134, 0.44332133782166316, 0.42963147469747665, 0.45754796950366394, 0.45914799309094845, 0.46950142611170553, 0.4311832199494099, 0.10131288646665093, 0.2567626444000436, 0.0885532390558117, 0.09485963300359235, 0.09119159873398963, 0.09104018871165265, 0.11151715713121524, 0.09253915859100437, 0.12352925323787878, 0.23663479548824362, 0.1942765745062811, 0.22350117636581812, 0.19062869527440884, 0.2653843969850196, 0.23457032812111145, 0.31560113870254536, 0.21328997037111608, 0.22048367633251997, 0.3113369192633648, 0.3050463606967282, 0.310535992295097, 0.30958032264195245, 0.311656393745638, 0.3151705773192659, 0.3348716253255204, 0.35162421747749484, 0.3489742201842698, 0.2279702818359658, 0.19310454199797544, 0.2191915632082141, 0.21947332117645768, 0.2015899752377326, 0.22941956774009253, 0.24297854032055588, 0.22831528285538605, 0.239933954247471, 0.1980458842585161, 0.18561352019768607, 0.17829053084218416, 0.17889239027452808, 0.17801991980358522, 0.1840235545106691, 0.17667150735747295, 0.19177441217374602, 0.18806020032115633, 0.35539369158274825, 0.41634273269339284, 0.39925634302974955, 0.38243734837330357, 0.20789718516892797, 0.33177597392147207, 0.1890902345462563, 0.29926830252794123, 0.355410278930674, 0.5085530490181952, 0.4354792934822773, 0.5266309852914977, 0.4738076791215201, 0.18520394304593146, 0.5145226736857438, 0.46287801273983764, 0.44973707028730314, 0.4631358325248962, 0.15311293787270208, 0.46919529737592613, 0.47149928510986294, 0.44308533990774235, 0.16663358188020316, 0.4293511673592214, 0.46069936842153925, 0.475216831646759, 0.47500185980246235, 0.17169817403228793, 0.1939367694749341, 0.21219329679220655, 0.1780540543521838, 0.17338272360468654, 0.19660904180359629, 0.183550484530835, 0.19068323093033135, 0.18038498275970272, 0.07057515045912244, 0.08417642329572261, 0.07472326450473243, 0.06717986525736741, 0.07225378119831782, 0.07746603042397271, 0.06389308727311382, 0.07630738518348557, 0.07838862471276697]}, "mutation_prompt": null}
{"id": "9bcf3e72-7a40-4037-aaf8-76af9f614623", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n        restart_threshold = self.budget * 0.2\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + np.random.rand() * 0.5 * (1 - progress_ratio)\n            crossover_rate = 0.4 + np.random.rand() * 0.6 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations > restart_threshold and np.min(fitness) > 0.9 * best_fitness:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                best_idx = np.argmin(fitness)\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                evaluations += population_size\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "Enhanced Adaptive Hybrid Differential Evolution (EAHDE) incorporates self-adaptive parameter tuning and strategic restart mechanisms to improve exploration and convergence performance.", "configspace": "", "generation": 48, "fitness": 0.21794170319232914, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.2352436005848364, 0.2705798971698231, 0.29019688988433134, 0.29949935914401926, 0.26915337456528476, 0.28570010339903684, 0.6889009710402831, 0.6816668331716782, 0.7007278784631827, 0.32873983374979554, 0.5308300502395941, 0.5289997950231778, 0.45911482166371675, 0.5157343164630013, 0.33974565365267595, 0.21311543195022065, 0.05353425028166203, 0.4178885549171887, 0.1385684911508751, 0.46236919950741595, 0.5062452197000086, 0.07516596607982284, 0.07075584196077322, 0.07641435952922415, 0.08068032218741028, 0.11108027881193361, 0.11055085466710701, 0.43924095975886845, 0.4474510706135171, 0.40751703958090046, 0.06396630176493723, 0.05328696468579852, 0.09514071595255824, 0.06219258637814362, 0.07451360951704555, 0.09366110655474824, 0.9313770178939547, 0.9061764981507674, 0.9160313967412947, 0.9340706823028736, 0.9118499140847476, 0.8961126735007556, 0.9213819736429874, 0.9200993225546605, 0.9016441000050048, 0.08984691851255922, 0.10537795872759415, 0.10797369766102016, 0.1309831761060808, 0.08065043306567621, 0.12366608700804371, 0.2859512499758742, 0.3255164986005541, 0.2767407586020919, 0.15726039011190895, 0.17607407899628724, 0.13561021143311824, 0.1507619826587253, 0.1574109229793077, 0.1550714263255164, 0.1609445254250642, 0.16291437780067608, 0.1655477514855478, 0.06629106246735339, 0.04324914494280241, 0.046705988835125, 0.14351900069992574, 0.13145203127000582, 0.17293465869278957, 0.06861142825323518, 0.05987599964035928, 0.06281281133187966, 0.020326040389953004, 0.054916619598626704, 0.03122068985357962, 0.06852292229853552, 0.05629245990122289, 0.07219823329398478, 0.067924549689931, 0.03905209550338873, 0.032182683200695616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04812135436989573, 0.08328745307671548, 0.0767533960707999, 0.046478884084287575, 0.089425843525201, 0.06122467343923277, 0.037761410425012354, 0.05774047926591597, 0.08590054455508545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01858136490717588, 0.027358972684548677, 0.012640858046860326, 0.19307489390778354, 0.009431819625370763, 0.009407426357907256, 0.16043452525347968, 0.16331746876094855, 0.19413464449569062, 0.5382596896135431, 0.4971659655853099, 0.5452074301361753, 0.5208427170089016, 0.5078624209129805, 0.5454011887426305, 0.2458639732497363, 0.22173290583789107, 0.26546645871454544, 0.0740722464796667, 0.07228151993687315, 0.06455566264974844, 0.09266568407463383, 0.059216858445439224, 0.07930506759127942, 0.11071363246405075, 0.11356028680727137, 0.10178350799703728, 0.13384440211186843, 0.14197903860632233, 0.13091252954691046, 0.25422647317417746, 0.43064047997071064, 0.18356840027145316, 0.1336422523148718, 0.1549584461349094, 0.14324485886753924, 0.43949105326431237, 0.4115268127554593, 0.36628541514795787, 0.1951847662743278, 0.17136233540375356, 0.21676338126575223, 0.1820471193555856, 0.19505688734860882, 0.18480894872410325, 0.3000808161785711, 0.213569697816274, 0.3130005076571274, 0.12851991979244026, 0.12810770606576138, 0.127282736238158, 0.13880556194484983, 0.11763052505473348, 0.1333909831743676, 0.1879404062724328, 0.1772126447008373, 0.1813344943929327, 0.16334508924686542, 0.17874365867608522, 0.17239267749460174, 0.1639870907094383, 0.17751743411334553, 0.2134713218213099, 0.4815970110810115, 0.527234002996182, 0.48116364329717976, 0.1593535903801323, 0.18092123432342055, 0.17196618053333657, 0.16413548487131047, 0.16317576785588372, 0.1685277964877827, 0.16370249165855044, 0.1703142111910222, 0.2160961850698775, 0.6066949274439755, 0.1461095813271791, 0.61919276634816, 0.621430710978587, 0.6097079696104003, 0.6377714109048389, 0.4892181527424536, 0.2969590048469106, 0.2954246846184706, 0.1506570818857783, 0.14944710316865562, 0.18496986766799628, 0.3702886681766452, 0.19550378557917758, 0.19519568198240622, 0.18680719076502317, 0.17107207375798317, 0.19127846824396777, 0.19551049174199875, 0.1732905890275117, 0.19437341344115378, 0.1813880990882626, 0.18335434136289364, 0.18561270849482336, 0.05903253648573825, 0.057114275409651194, 0.06904016829436987, 0.05778343969364197, 0.07299844642218445, 0.06851016231771423, 0.05912540733223437, 0.060336973284424, 0.07000305838312781]}, "mutation_prompt": null}
{"id": "a7cef861-dad3-4a4c-9126-7e7698cbe445", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "6b3d3d1f-a058-445a-83d4-79d2beb46c70", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "0bd6fba9-50b5-4e96-ada8-32e89a4b93f0", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "63f26401-2398-41ac-b310-a191af9152ba", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "b75023fe-e3ea-435f-9b1e-95b079eeb024", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.25\n        local_search_prob = 0.2\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.5 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            quantum_population = np.array([\n                np.random.choice([pop, np.random.uniform(self.lower_bound, self.upper_bound, self.dim)], \n                                 p=[0.5, 0.5]) for pop in population])\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = quantum_population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and progress_ratio > 0.5:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution leverages quantum superposition principles with adaptive population control for enhanced exploration-exploitation in black-box optimization.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {}, "mutation_prompt": null}
{"id": "6aadfd7a-c9ce-454f-a4dd-f0abe54b39b5", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "a30f1b52-a301-4283-a3cb-17584a4629b4", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "ee5c7ba4-a2ff-4114-8e6b-171551fe4b0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.1\n        local_search_prob = 0.1\n        reinit_prob = 0.05\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            fitness_variance = np.var(fitness)\n            mutation_factor = 0.7 + 0.5 * np.random.rand() * (1 - progress_ratio) + 0.2 * fitness_variance\n            crossover_rate = 0.5 + 0.4 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n                if np.random.rand() < reinit_prob:\n                    reinit_indices = np.random.choice(new_population_size, int(0.1 * new_population_size), replace=False)\n                    new_population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                    for idx in reinit_indices:\n                        fitness[idx] = func(new_population[idx])\n                        evaluations += 1\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "Enhanced Adaptive Hybrid Differential Evolution (EAHDE) incorporates elite re-initialization and adaptive mutation based on fitness variance to improve convergence and diversity balance.", "configspace": "", "generation": 56, "fitness": 0.14969217124751127, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.3329142533070363, 0.3444038254486198, 0.3380685121290602, 0.4364859374541643, 0.48536081906382067, 0.4641938808563364, 0.3969084944444553, 0.3814384764335088, 0.3916851584744462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004999656869375535, 0.04295798059518163, 0.052075263953865414, 0.047542818107671914, 0.05943956549281271, 0.057801544471926314, 0.048528666986502156, 0.054899172931368034, 0.07678843391702506, 0.06551839849436747, 0.02375075452432651, 0.03289173670580914, 0.05430491184998898, 0.058207449464190764, 0.03632918710585398, 0.0537673181180609, 0.04290753197594355, 0.03527174064221239, 0.029286313835643396, 0.9878675893884186, 0.9845164491943079, 0.9590683229926827, 0.9657500759798369, 0.9684500379402008, 0.976032460305343, 0.9666380729280128, 0.9781596435589178, 0.9660512005336696, 0.09819463377379745, 0.05160904673125022, 0.06549606422539289, 0.06296743542366112, 0.06674560408896746, 0.02077122971712886, 0.06751836795352151, 0.05572230338782158, 0.09158023306889551, 0.1785058906513728, 0.1542676539092276, 0.11122525421898499, 0.16997050047207685, 0.12042151806035195, 0.16069829452930606, 0.14936873225865788, 0.12010267486600368, 0.17079129987916708, 0.0022154144952771793, 0.0018105762284221782, 9.999999999998899e-05, 0.001168968559702277, 9.999999999998899e-05, 0.04173823885166206, 0.00882124205635737, 0.0011476528100636818, 0.003824107212253014, 0.043354829701347075, 0.05095104655699101, 0.04660931493637632, 0.017570643520596785, 9.999999999998899e-05, 9.999999999998899e-05, 0.023304035144145585, 0.004916230642801334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04440067232411715, 0.056040990861710216, 0.04707164198313274, 0.026503388908829417, 0.04683367851350617, 0.04230310136381488, 0.03204450072743603, 0.02488466647605636, 0.049686117087735515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002218759814516802, 9.999999999998899e-05, 0.007382927691235497, 0.0023959517831901866, 0.005528403086000777, 0.0019388576695907878, 0.01660426252528291, 0.0033839169983027606, 0.01775075262017689, 0.33290379385576063, 0.34953465345899437, 0.33915967281065384, 0.32899270029401306, 0.3174886604753854, 0.3356767225240421, 0.3403771802099296, 0.33734161170199894, 0.32752345757873913, 0.04802223328844535, 0.05391844021098935, 0.053198924556353444, 0.047329570211397054, 0.04194502929942423, 0.0915656746545701, 0.03498957229570099, 0.035107049302477544, 0.050088925352124725, 0.1388110511960503, 0.14544541050130133, 0.14824521417162617, 0.19178769164818688, 0.2228088820870966, 0.13930404178252354, 0.15526281830555833, 0.20571175813930465, 0.1857503523462648, 0.23023576601306073, 0.2074610485712065, 0.24681873512809072, 0.2206329301159733, 0.24386137722399115, 0.2576778486133676, 0.2309734840683787, 0.2853246503632144, 0.25655828583530615, 0.1010212893037915, 0.10489216404480817, 0.1356599154417647, 0.1143145186023885, 0.10943652533074577, 0.1543332316668632, 0.16111029034535695, 0.1723011392240369, 0.12914728447787893, 0.14648464253059446, 0.14702649895639064, 0.14983222613405434, 0.14181037031673915, 0.14470368106583187, 0.16198883493260108, 0.1737440967624645, 0.15143343910098195, 0.16837306735411461, 0.07362605432742508, 0.06253734017309598, 0.11177370748119408, 0.10041063626487323, 0.15887499639855884, 0.09393435705117303, 0.06610668614562565, 0.09053377514642813, 0.17313234315735915, 0.38871306296914576, 0.17584334661608503, 0.3967744273099253, 0.15176604152925754, 0.1548247489792468, 0.13834938814384645, 0.15918474033397179, 0.14881742560392774, 0.14402439646312992, 0.355245210017336, 0.1762780540116321, 0.127739341333296, 0.29444855614286713, 0.12024247857517911, 0.27253628660020657, 0.18597227857983178, 0.17299242156706918, 0.17032381070554492, 0.1808356944962054, 0.17427186466852795, 0.16711567073032751, 0.22506648183437716, 0.18050905457198574, 0.19724118160827664, 0.20390678255351236, 0.21593253938517587, 0.18382336678825628, 0.03744397432919455, 0.035182813872758234, 0.043053182136222334, 0.04557350994011666, 0.05503158475671266, 0.04496564761900357, 0.04169975252577296, 0.049330979459901725, 0.047247277934787224]}, "mutation_prompt": null}
{"id": "391cd134-32c4-4911-9e15-e27c95add3f7", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "7287e3f9-cf79-408a-aef8-507274c370cd", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "f1dc5ef3-85e4-4b2c-989c-9385bcc167cc", "solution": "import numpy as np\n\nclass AdaptiveVariableNeighborhoodDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    neighborhood_size = 1.0 - progress_ratio\n                    candidate = new_population[idx] + np.random.normal(0, neighborhood_size, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveVariableNeighborhoodDifferentialEvolution", "description": "Adaptive Variable Neighborhood Differential Evolution (AVNDE) enhances AHDE by introducing a variable neighborhood search to exploit diverse regions effectively, improving convergence in complex landscapes.", "configspace": "", "generation": 59, "fitness": 0.3091464891751102, "feedback": "The algorithm AdaptiveVariableNeighborhoodDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6505727753923102, 0.6375610252918849, 0.6395221567585669, 0.6850534130400989, 0.6713571421173352, 0.6628492299265691, 0.6500052872566471, 0.6477653982165786, 0.6521962313830273, 0.47874103774506593, 0.4683269945737303, 0.483556488399154, 0.5005595346083185, 0.4709748274412532, 0.47062077887176, 0.46877249826671974, 0.4637843880232334, 0.492286503641155, 0.3985224149360529, 0.3963056059875113, 0.3901285260448978, 0.13703782217820715, 0.38842260857637034, 0.34936090361195216, 0.3640793249846105, 0.3843559412204184, 0.3959374438237847, 0.3663796385335769, 0.34031206602863473, 0.12297352589160127, 0.3474768678468636, 0.11390889174650343, 0.1272458874396194, 0.325791490403309, 0.2668972146774399, 0.12993082962908264, 0.9242206845066068, 0.9453752319568112, 0.9459913957050593, 0.9355482364448554, 0.9517474676483112, 0.9241206270238314, 0.9480133325878192, 0.9294959581369668, 0.9372549367718743, 0.3945306177306356, 0.390785441706505, 0.4061856905281567, 0.4216192648877627, 0.3992599156289125, 0.41167539032941836, 0.4294244610651117, 0.3665630410039862, 0.3893759365482864, 0.5411174509580255, 0.5113302493920218, 0.5415942688571125, 0.5343527482002131, 0.5528169713920428, 0.49521431103066393, 0.5677479767443782, 0.5235739964972753, 0.5331897048211529, 0.14497973059556446, 0.15353856570030489, 0.13469768602253185, 0.1597407279420855, 0.1841091935681013, 0.14619067388686457, 0.14396826143543495, 0.13698682591698452, 0.13302099188940397, 0.14995592336809482, 0.148762350405233, 0.11922146087741914, 0.16362663601641103, 0.16940480642030875, 0.1469394727012252, 0.1486360898627579, 0.1589822803882449, 0.16292246327330706, 0.11861806771729866, 0.09893219890401084, 0.14106494005239256, 0.11523948978477605, 0.0956598008126388, 0.11331213209494162, 0.12954847166123074, 0.06404488112023954, 0.12689323050612533, 0.24662667528334448, 0.24787334675299166, 0.21309972248669096, 0.2232434190971746, 0.16414073175177546, 0.24843162728528534, 0.25541280713839365, 0.2551018391663228, 0.2763136171334867, 0.07906614877410012, 0.06272966699596327, 0.036664936235011214, 0.057511877423829016, 0.058376986822107235, 0.10917104927374699, 0.03545319096825661, 0.08789565181565517, 0.08611407435949259, 0.16990923638044697, 0.1565332985119694, 0.17124205327122854, 0.19047743863219568, 0.1808652674125486, 0.2046264057153443, 0.20648092990802036, 0.15106925438390773, 0.19789553280280103, 0.5134744929896702, 0.5020462126854789, 0.5133090361667219, 0.4905249367879464, 0.48164296740157, 0.5135675264458556, 0.508178158238463, 0.4688811219833975, 0.550822113586279, 0.10186932129392312, 0.09831091003691839, 0.08871133151925281, 0.11297694300856542, 0.10611217466053569, 0.09036918756351864, 0.07874808201574013, 0.10948044036999183, 0.08468182584379724, 0.18849861254386935, 0.216817275652746, 0.22319387052080675, 0.14761132514725217, 0.14697005031524113, 0.1819666360092378, 0.18856917006494167, 0.170834078707651, 0.22066353680013595, 0.3610592898049094, 0.3968474498852622, 0.3618164964011772, 0.37411869714681045, 0.33161895867375346, 0.345947869451829, 0.38825055784427465, 0.3645793451337004, 0.34733706396638286, 0.23929867008685646, 0.24643084341962618, 0.2199366870626459, 0.2661241239877903, 0.2413014646253545, 0.24821554114698408, 0.3006019084350372, 0.2592183002128986, 0.2665343604541832, 0.2130840354725697, 0.18046610686881392, 0.19073768902203303, 0.16835881321395918, 0.19108729655777423, 0.17869463372198657, 0.17086005691244044, 0.18564763859918998, 0.1720432732995839, 0.39859656899397733, 0.19387829594860795, 0.2144205121634608, 0.20213310183856503, 0.4184646492215648, 0.18343016427751058, 0.2046530022097297, 0.19817134538817804, 0.4474328560344647, 0.15788386863886372, 0.5812348331796116, 0.6040579487250997, 0.5875942155384903, 0.1845689929390555, 0.5708778612017419, 0.5622330523448729, 0.5636659886154967, 0.1686814597474806, 0.50937141533353, 0.4863987222069346, 0.18596407786249114, 0.48941001101946613, 0.181072087957601, 0.5085701129761198, 0.4682326662206079, 0.18538192736394754, 0.19677623126288613, 0.18138507209644983, 0.1804755719650517, 0.17565067040310312, 0.196961643531401, 0.17107785366115769, 0.2046182346334262, 0.1766836741483503, 0.1834243015210829, 0.23411355544701362, 0.06299516016969176, 0.06586469065061173, 0.0721030539312385, 0.07384084244738243, 0.07315864939612016, 0.06715805956671228, 0.06938674917197873, 0.07385255500383714, 0.07766468377783609]}, "mutation_prompt": null}
{"id": "7547de4b-ad5e-4793-afad-fa69a4df1146", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "6d71d2eb-ebd1-4576-a6dc-91e023ab3120", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "96a735ea-3878-433e-81f1-745e700ce57f", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "5d642222-2ab6-41b1-bff5-54be07b32077", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.7 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = new_population[idx] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveHybridDifferentialEvolution", "description": "Adaptive Hybrid Differential Evolution (AHDE) integrates dynamic population sizing and adaptive crossover strategies with a local search phase to enhance exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6575535257641316, 0.6464596886494028, 0.6229032271354277, 0.6679253806422414, 0.6539612191985049, 0.6757025554719343, 0.6454026304023971, 0.6591431453824753, 0.6644464295481041, 0.4851606239115268, 0.5091305058195414, 0.4971456384523919, 0.48432922617149965, 0.4832296956404448, 0.49380696658965806, 0.5021420416650274, 0.47986267465963595, 0.48356195812552427, 0.4132370894057492, 0.43474905694777455, 0.3879422195135469, 0.14540475854724633, 0.3869872253390908, 0.39721104459084844, 0.42374514727318124, 0.39930763343635767, 0.41878219635203073, 0.1351635658172159, 0.1263260573631616, 0.3518562301143532, 0.2908498703207322, 0.3289138445528238, 0.3479434135083328, 0.34555837743166595, 0.10692831780793133, 0.3170561091777153, 0.894432682460047, 0.9159863831485744, 0.9465927436489541, 0.9211204954883597, 0.9496911158542485, 0.9205318535209296, 0.9479719354643326, 0.9293222888091104, 0.9239754682999585, 0.3811213637294635, 0.39233422229102666, 0.4383647054613522, 0.3801237901601744, 0.41915574532963695, 0.4094481265686022, 0.3625465770547164, 0.3465882396391007, 0.3779949311358919, 0.4882933134804819, 0.49512499370437413, 0.5101466725105996, 0.5720814227892462, 0.5736338890289111, 0.5557495089275456, 0.5080134718995664, 0.5734053463699507, 0.6059926736762206, 0.15481338862836203, 0.14488131745780142, 0.31540077323600957, 0.14588923087426442, 0.1525287103632701, 0.16516092276494843, 0.17009724870304166, 0.17426064539252162, 0.131550999070692, 0.1646463807426085, 0.14273746385437647, 0.1614602405394202, 0.1954372267134843, 0.25700942602966137, 0.17446098132421362, 0.18499802449239888, 0.17033147602990162, 0.1888282996650259, 0.06956259973070189, 0.12990133738071052, 0.12922090787647156, 0.09062625696114557, 0.1272347364835128, 0.16799162492478903, 0.12333677038486024, 0.1292267479482132, 0.1404311356396667, 0.23176465918351974, 0.2460343452250443, 0.26955323669932385, 0.1720050222577385, 0.23488554499714498, 0.17419113948473464, 0.2597753906684418, 0.24826398249779447, 0.27378862328001774, 0.04183982968540256, 0.05817137558903818, 0.06467860186283392, 0.08183578028731464, 0.07268756735130522, 0.0843760830229463, 0.07026031434240831, 0.08012816902349662, 0.04729384862202746, 0.14952529691028937, 0.15770858418450917, 0.19792543578450283, 0.18132748789146946, 0.18868951448089755, 0.21855622758856885, 0.15586792229867918, 0.17503265591051387, 0.17242921621790752, 0.48082969059659386, 0.5073963829293477, 0.5157895324698624, 0.5356272871760983, 0.5276689981856666, 0.5110442938175048, 0.5144457587999826, 0.48819669150647094, 0.4927498006107981, 0.08200722180352149, 0.11343517653969937, 0.10185493721663919, 0.12120512275002715, 0.1067625794326077, 0.11461136849764386, 0.10273805264721048, 0.0824487673384332, 0.10610766140414984, 0.3511480330342098, 0.2745862128732891, 0.4541954107510625, 0.24087749308841866, 0.4043102971868312, 0.20314033073741067, 0.17220037854021542, 0.21875021562006203, 0.41129674636369873, 0.35180882380659284, 0.3476583833438269, 0.2853385565165528, 0.3549224511085626, 0.34009051627461073, 0.3562805885230429, 0.4142706539267902, 0.40166195392046955, 0.4009144687433023, 0.24992904408683703, 0.28797182863774107, 0.2342578644019282, 0.25946983166440907, 0.2491935257268656, 0.2569986779522405, 0.25605056165687234, 0.29319117380434645, 0.28122545178280345, 0.18820275629594185, 0.19390697957066594, 0.19694963036455115, 0.1940495084845537, 0.17744595239758654, 0.18988244793389708, 0.1719290676025672, 0.19979064762715637, 0.17828714282021285, 0.39033006233431833, 0.19972988629444277, 0.18607331659795578, 0.4919610615824038, 0.21864975698684352, 0.38426974985223095, 0.40611269794468086, 0.21003878571540247, 0.39802276091354216, 0.1649242609883126, 0.5410508098684371, 0.6537248249363325, 0.5973750793346013, 0.19496131291114704, 0.5806151655479683, 0.1480353318455052, 0.5487120889104506, 0.5801722265461011, 0.49139290058304286, 0.15961349384432322, 0.556231367961031, 0.39552168739948734, 0.4460548605418173, 0.5465902674251527, 0.5826419112416688, 0.1907717540915096, 0.20175249635119907, 0.17923559617713813, 0.18648531344022334, 0.18343269941424833, 0.17559836318503008, 0.17850852026007702, 0.17570265471677737, 0.199589441798519, 0.19952950335581388, 0.18560281252934152, 0.07015290722238043, 0.07220324529317135, 0.07559752726628033, 0.07368558583675278, 0.07707300884465218, 0.07133920871358823, 0.0675317031039846, 0.0892862158069414, 0.07048683768952146]}, "mutation_prompt": null}
{"id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 64, "fitness": 0.338341404439709, "feedback": "The algorithm AdaptiveEnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "b52e0e5f-4539-4323-84d3-ba3d9848fae1", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "27c5f682-bb96-43ab-94b1-beaf75d7b1b7", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "bbaeb8c1-8801-40e5-998d-44c63e41c580", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "9f25fcab-9aef-4aa5-94af-484cf4adc9b0", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "b3b88f18-33ca-444b-8c3b-c09d5b2790ff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.4 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population and Adaptive Mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.3084636440339167, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6417816523040976, 0.6372828642900951, 0.6350961410426287, 0.6516966065783714, 0.6373530212133517, 0.6352161480925034, 0.6397079582182561, 0.6346237562687522, 0.6424005692858464, 0.45615684319744776, 0.4553894005187765, 0.44883409895242954, 0.48058692008404325, 0.4503749016457834, 0.4544393919628915, 0.4517037405030777, 0.4519970703842875, 0.46398497526820903, 0.35184558853340553, 0.36606544137925934, 0.35055078409291407, 0.3728322132427516, 0.3034385707970124, 0.375475952705815, 0.36745562260320086, 0.37292807308905207, 0.33401450744751815, 0.26173464215176323, 0.11447854610982156, 0.1279953426453161, 0.3504192309185382, 0.3148321085311302, 0.33028534322499814, 0.34824369550377055, 0.1267772439055359, 0.12611964638810658, 0.8286549218629629, 0.8688024682091771, 0.9427845570910255, 0.8554623564120787, 0.9115287375241397, 0.9097590290610874, 0.8592371970833534, 0.8991479171505347, 0.8811289623084834, 0.3163365636999579, 0.316128369942824, 0.3498487212646477, 0.31874151382910854, 0.2644596487636498, 0.30304773905542004, 0.2840562737805682, 0.3341143832812541, 0.32801339973671273, 0.5328713109079029, 0.4855790389653386, 0.547883121710611, 0.6038628423127888, 0.540338851364184, 0.5383173284824949, 0.6098611059460901, 0.5199607717048287, 0.5528809778258714, 0.1298536898402961, 0.15886586607069453, 0.16073381235886552, 0.22745948848794384, 0.12154903488358937, 0.13372672734825486, 0.12947713477386857, 0.15119984504217265, 0.12730703582751013, 0.12307915462782237, 0.10229889711962992, 0.1197868627833355, 0.13328044254648053, 0.1418395538067625, 0.14711806585585085, 0.1179022424857259, 0.1261014086379284, 0.13500415467563032, 0.15122539933600843, 0.12910793302114199, 0.13805196061820457, 0.17037170353884978, 0.11833525570633119, 0.09160354581144892, 0.1291344173396205, 0.18309294510620533, 0.1592159376879696, 0.25211778566751886, 0.23103260730170927, 0.23197075435876024, 0.19290248725921533, 0.2247012438288012, 0.2455793075572137, 0.28562965915115224, 0.26706680668797356, 0.2943301811362595, 0.08584501169574799, 0.06402527677172243, 0.09684857340086106, 0.09848326411260788, 0.058711093892435895, 0.07778320174551723, 0.07517389987461043, 0.07713105729248637, 0.08968184118044142, 0.18734757631715715, 0.15985767916139526, 0.1606838718635779, 0.18712006079441568, 0.1948901960076317, 0.20621400849200955, 0.16775304161917415, 0.16927405753367641, 0.18353366238361535, 0.4963704066765562, 0.5287776788080919, 0.5116680598157645, 0.516340009155513, 0.543558401661965, 0.5006042780859081, 0.5065612857476756, 0.46831134669568375, 0.5097115700418493, 0.1309803287171366, 0.1121025192505396, 0.08319328855837871, 0.10322840781333198, 0.10913714713516132, 0.12578182189369314, 0.11497379271000696, 0.10822462873018845, 0.13446586615892087, 0.23964859739864797, 0.25605382372028673, 0.30832285577106244, 0.17174016287899085, 0.39979627846648613, 0.2807676633979861, 0.38373691001071664, 0.19704813765691453, 0.2631178984762611, 0.33394601994305595, 0.3286826984471023, 0.3935628467682678, 0.3819792768204827, 0.3654645019625964, 0.3551682171423729, 0.37744175342256026, 0.38276332284750847, 0.4136773931228429, 0.26747500455614426, 0.25514592788849844, 0.26384050885543064, 0.21053568233089826, 0.27612471714423525, 0.2697303153541276, 0.27890633573923707, 0.2743868561770595, 0.2971352127767175, 0.1799314376542649, 0.18693898784989793, 0.1788179413168216, 0.19159362701712157, 0.19412239964181854, 0.17592633213035458, 0.22101212327007236, 0.18885518794348732, 0.19093980987998593, 0.472565872644124, 0.39732163010100574, 0.21082383320841935, 0.21490088617057668, 0.4581302746224728, 0.43836883294298234, 0.17592218399772497, 0.19159185397038647, 0.46934583114623796, 0.5649107320638975, 0.5954942938296857, 0.5966865795551749, 0.5677970650424166, 0.5418609131212393, 0.4866486072029478, 0.1703182889528393, 0.505575940829148, 0.1686374141119017, 0.28480254711950415, 0.40546800041394304, 0.18002935345874416, 0.14626366472804642, 0.4810737054115094, 0.19167154531329933, 0.18599291297024245, 0.18486085224461157, 0.17957219661568247, 0.17534544623747939, 0.17859452331269932, 0.184412787998674, 0.1903043369598193, 0.1863307590374077, 0.20739137712106737, 0.2167745710266522, 0.1997252851300082, 0.18779466407884993, 0.07768907565402283, 0.0764724510478485, 0.08640638273220702, 0.07536929425065231, 0.07987072527003547, 0.08443561719995674, 0.07264569916509789, 0.07723348441589928, 0.07704977067849728]}, "mutation_prompt": null}
{"id": "f022b88a-3cfd-4b9d-b88a-56bde93e1b98", "solution": "import numpy as np\n\nclass DynamicMultiStrategyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        mutation_strategies = [self.de_rand_1, self.de_best_1]\n        adaptive_params = [0.8, 0.9]  # Initial values for mutation_factor and crossover_rate\n\n        def local_search(individual):\n            adapted_step_size = np.clip(0.02 * np.exp(-0.005 * evaluations / self.budget), 0.001, 0.05)\n            candidate = individual + np.random.normal(0, adapted_step_size, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = adaptive_params[0] - 0.3 * (progress_ratio ** 0.5)\n            crossover_rate = adaptive_params[1] * (1 - progress_ratio)\n\n            # Select and apply mutation strategies\n            strategy_choice = np.random.choice(mutation_strategies)\n            new_population, new_fitness = strategy_choice(population, fitness, mutation_factor, crossover_rate, func)\n\n            # Update population and fitness\n            for i in range(population_size):\n                if new_fitness[i] < fitness[i]:\n                    population[i] = new_population[i]\n                    fitness[i] = new_fitness[i]\n                    if new_fitness[i] < best_fitness:\n                        best_solution = new_population[i]\n                        best_fitness = new_fitness[i]\n\n            evaluations += population_size\n\n            # Adaptive local search\n            local_search_indices = np.random.choice(population_size, int(0.1 * population_size), replace=False)\n            for idx in local_search_indices:\n                candidate = local_search(population[idx])\n                candidate_fitness = func(candidate)\n                evaluations += 1\n                if candidate_fitness < fitness[idx]:\n                    population[idx] = candidate\n                    fitness[idx] = candidate_fitness\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            # Adjust adaptive parameters based on performance\n            adaptive_params[0] = mutation_factor * 0.9 + 0.1 * adaptive_params[0]\n            adaptive_params[1] = crossover_rate * 0.9 + 0.1 * adaptive_params[1]\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution\n\n    def de_rand_1(self, population, fitness, mutation_factor, crossover_rate, func):\n        population_size = len(population)\n        new_population = np.copy(population)\n        new_fitness = np.copy(fitness)\n        for i in range(population_size):\n            indices = [idx for idx in range(population_size) if idx != i]\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            trial = [mutant[j] if np.random.rand() < crossover_rate else population[i][j] for j in range(self.dim)]\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n                new_fitness[i] = trial_fitness\n        return new_population, new_fitness\n\n    def de_best_1(self, population, fitness, mutation_factor, crossover_rate, func):\n        population_size = len(population)\n        new_population = np.copy(population)\n        new_fitness = np.copy(fitness)\n        best_idx = np.argmin(fitness)\n        for i in range(population_size):\n            indices = [idx for idx in range(population_size) if idx != i]\n            a, b = population[np.random.choice(indices, 2, replace=False)]\n            mutant = np.clip(population[best_idx] + mutation_factor * (a - b), self.lower_bound, self.upper_bound)\n            trial = [mutant[j] if np.random.rand() < crossover_rate else population[i][j] for j in range(self.dim)]\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n                new_fitness[i] = trial_fitness\n        return new_population, new_fitness", "name": "DynamicMultiStrategyDifferentialEvolution", "description": "Dynamic Multi-Strategy Differential Evolution (DMSDE) enhances convergence by dynamically adjusting mutation strategies, incorporating self-adaptive parameters, and leveraging a learning-based adaptive local search.", "configspace": "", "generation": 69, "fitness": 0.1890101361480069, "feedback": "The algorithm DynamicMultiStrategyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.43424014469978234, 0.3783229037395971, 0.45167704479667026, 0.45796410528693476, 0.4349408441026813, 0.48557529629940377, 0.39784520930448175, 0.3969765859773614, 0.4210500049030633, 0.12967835735535227, 0.07740158089085869, 0.1365722548368451, 0.07790414404909918, 0.06804261165708025, 0.07823899652752186, 0.05733940269497362, 0.08074972349053045, 0.08467132581892534, 0.10764492902248857, 0.13848748090704122, 0.18548736264095134, 0.10476719662247502, 0.12532741566765637, 0.13986819459689992, 0.1020487415490694, 0.13616832944111124, 0.13053135187116727, 0.11639437602996783, 0.10742092649093138, 0.13464918126879744, 0.09505391899105486, 0.09440244481862081, 0.12190756887056264, 0.08160279645882385, 0.12532285659500542, 0.10138685646335399, 0.9519554508259981, 0.9572218546281316, 0.9686057042220134, 0.9329792445276259, 0.9694422593749669, 0.9583029217236413, 0.953205744051713, 0.9344672837303544, 0.9638538273852166, 0.12884748915521016, 0.15021172029388707, 0.13387518247550234, 0.11470255444130983, 0.12898309536134733, 0.17047465453123145, 0.16322633297266786, 0.10941203734897531, 0.1787397398206364, 0.20495608781007546, 0.20200389678579356, 0.20875463732172106, 0.20751413977865274, 0.1940653126277747, 0.18839177276430874, 0.22568925333415812, 0.266212581305483, 0.18307062775368665, 0.11453708894992543, 0.1396175137080038, 0.13494041483559904, 0.09351157389736742, 0.12741721117923321, 0.12740056106342112, 0.12857091980866353, 0.11234893918451494, 0.13653240301391723, 0.10107392850381713, 0.03570880904456719, 0.1064971196786515, 0.17631809043641655, 0.12382012470736359, 0.16795536406006484, 0.1133066042228098, 0.10530703886896486, 0.14773091001462313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0887907296698035, 0.0609825230302522, 0.08896741636570404, 0.09827877803088836, 0.04276086087707076, 0.050005534599869006, 0.10632274936299257, 0.12151707866863748, 0.08659358603897527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09711621235339063, 0.03785713589057049, 0.07585544344151351, 0.0434868976170677, 0.10203501753901434, 0.058685849047691585, 0.07889240517746765, 0.0783906564117598, 0.08234966302245161, 0.34883172589238953, 0.37113754497767115, 0.3616935984657853, 0.3516038228205527, 0.36281601844417133, 0.38926663789547644, 0.36527754506989707, 0.3460607534945801, 0.3820476896600088, 0.08447742599516261, 0.08995830515615888, 0.09364072123213141, 0.08152369455592778, 0.09354564069036264, 0.08358440730831063, 0.0872872004705939, 0.07330691898720665, 0.10285672471976282, 0.13138732504839679, 0.1823201457656518, 0.16378084290749118, 0.15359295322637478, 0.14837061657180106, 0.16062652608618777, 0.14331573348554028, 0.1648382231855594, 0.11293825151033454, 0.2589281219982157, 0.23480767479471898, 0.24540512784634305, 0.22224178606634282, 0.22420163453616593, 0.23312132002363473, 0.2449157579829606, 0.23730868682571482, 0.23284365845096644, 0.19884229109616414, 0.15398352154890382, 0.18162983237935615, 0.13407416424751095, 0.1447692671069052, 0.17156318707825302, 0.1992394479140548, 0.17085085638896058, 0.15196899658747898, 0.17996068000547927, 0.1783310456594137, 0.19516922826875238, 0.17801608489890752, 0.16316395785447368, 0.21960159619677144, 0.17961628483532444, 0.20802659752536812, 0.19084780068427076, 0.19427304417874058, 0.18265319930485502, 0.1876426168247367, 0.18387372432924232, 0.20846496532896786, 0.19874877014677073, 0.18122089554668597, 0.1710165393117803, 0.19262770529651463, 0.1595422873068153, 0.1718263909570673, 0.28650422202716297, 0.17497274336469004, 0.22687139353680952, 0.16151670402144191, 0.34997763313930574, 0.16064062965703485, 0.24299588416077011, 0.2652149478696132, 0.2218455998649802, 0.1896186206168391, 0.2959234141993564, 0.16533885283975125, 0.1634225299285581, 0.3007934239107827, 0.19570886678062838, 0.15137288727273812, 0.17603837537314193, 0.16902327758102564, 0.1776931661370409, 0.18004229122252835, 0.19275504001487132, 0.1758589385483743, 0.18308577371729462, 0.19739920095461116, 0.17476387385834946, 0.08170963289170052, 0.0830278034024643, 0.08657440520357218, 0.06891802830064842, 0.07164482508538716, 0.0780278913558694, 0.07896553224436942, 0.08360654535816792, 0.07881968916027238]}, "mutation_prompt": null}
{"id": "ec174847-283a-4613-80fa-4729b5760463", "solution": "import numpy as np\n\nclass AdaptiveDynamicDifferentialPopulationEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.3 + 0.4 * np.random.rand() * (1 - progress_ratio)**2\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio**2\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.7:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveDynamicDifferentialPopulationEvolution", "description": "The Adaptive Dynamic Differential Population Evolution (ADDPE) dynamically adjusts population size and mutation strategies based on convergence progress to balance exploration and exploitation effectively.", "configspace": "", "generation": 70, "fitness": 0.3128766282474463, "feedback": "The algorithm AdaptiveDynamicDifferentialPopulationEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6856717404347998, 0.678335715947946, 0.6916336585133793, 0.6898830254266808, 0.689913251676963, 0.6793270460090559, 0.6873258119400745, 0.6928944826288845, 0.6818665355337574, 0.5260575966310305, 0.5176640150671217, 0.5236341291681855, 0.5272867710077402, 0.5191039006867986, 0.5228243704944859, 0.51575036588442, 0.5160314476168129, 0.5231374516669467, 0.3228136422243101, 0.13712736590384178, 0.22537109006131628, 0.3439988282184029, 0.19677231101139558, 0.39308525498454017, 0.375375827258968, 0.464143489068092, 0.41063541392552194, 0.21551690531515633, 0.12433933376230288, 0.13441354913498693, 0.21280359170450835, 0.1414853566614751, 0.23577967593887272, 0.11952299100926922, 0.1359447591164542, 0.1358749043504991, 0.8331054074217393, 0.8707805457298472, 0.8800014625535779, 0.8367440643006552, 0.791957419092083, 0.8591498870548363, 0.8808231402831571, 0.8739553991678904, 0.9260341627654852, 0.21732157834555133, 0.28550730867298046, 0.2896232617417388, 0.2139389358901178, 0.2622183639923842, 0.2465007651852178, 0.23071954112465687, 0.26088209476123025, 0.25877255109802266, 0.619747176644714, 0.6126593655816993, 0.5617876863455207, 0.6074870645962231, 0.6106515278082932, 0.612510228050781, 0.6034332325198778, 0.6176740405711605, 0.6048326701704079, 0.1498396098058853, 0.1517985239244608, 0.150500356011544, 0.1245917621708098, 0.1500606505665979, 0.1613537403590628, 0.14249655635985659, 0.129967685455199, 0.15815089388292558, 0.1388631326862545, 0.13464336186157577, 0.14015777029591026, 0.14603152867428637, 0.1322522883144438, 0.19983175158938238, 0.1858717202343636, 0.11651105190460509, 0.1328682153196158, 0.11903353534847849, 0.07333672377789557, 0.0923974039135006, 0.07236072916415981, 0.06625015707565307, 0.12622040122815692, 0.10062903878887663, 0.03661573945369878, 0.10039339599883845, 0.25268729140054225, 0.19163862943310783, 0.17263781311926996, 0.1739517465260837, 0.21412430231640178, 0.21166662594762864, 0.2589187076118076, 0.27998726219008174, 0.2443244862947136, 0.0871374793389863, 0.05882964009470093, 0.09262145376220432, 0.1642661107412463, 0.06572982822945794, 0.14603772753456212, 0.09038971395266948, 0.14215937627509978, 0.05602253718097905, 0.18989090706497802, 0.15743107692492997, 0.20748040710259297, 0.2120003648663511, 0.22404615843267128, 0.1807304596572381, 0.19957756046402042, 0.1897236058406846, 0.16741556934723245, 0.4716765577048313, 0.476891787288122, 0.4936674593601168, 0.5323189665726544, 0.4931808921446673, 0.5066313787178197, 0.5431178437911701, 0.5204020266983329, 0.4799950858885086, 0.14381589129432526, 0.11904492650290266, 0.11725404565634712, 0.11718435193624865, 0.11593070347234136, 0.11011514848810544, 0.12126812047912316, 0.11546702770101402, 0.13202813908807387, 0.19149405234069872, 0.21487156885854086, 0.168633048329775, 0.19060951797364212, 0.21832647284575046, 0.1963330173579647, 0.21830846046021102, 0.20926683508354438, 0.19707482025337497, 0.4241821373142538, 0.4013585009920416, 0.3811564224115378, 0.3913266650253452, 0.36249030255290327, 0.40577408736464815, 0.42548822459640256, 0.42711626334962893, 0.4479970668340202, 0.28693508070241325, 0.31965885559302765, 0.29486099321247916, 0.29907417042604756, 0.287509067480918, 0.3092983093121643, 0.2729430839649829, 0.3298269111934591, 0.3006738266184792, 0.20838093075828734, 0.19013230451509822, 0.201538553603829, 0.1966353552140554, 0.22794348664113218, 0.20225672213462909, 0.2012987187465356, 0.1925431686350172, 0.19818728928719365, 0.43517883297340254, 0.19865691627651705, 0.4296512312170718, 0.4942804542184607, 0.45148782839996815, 0.5443511309341413, 0.2132141710316059, 0.2163939919301946, 0.45109491168536797, 0.18015423063918456, 0.6362341712956288, 0.597185640138155, 0.642364670767149, 0.19637664977856317, 0.6135934376466533, 0.1792584956179748, 0.511183518371308, 0.61312583714884, 0.5376125558394944, 0.19255573915614954, 0.18694709391452047, 0.18684976971326528, 0.1796185027644135, 0.616143897447528, 0.331977205984073, 0.37466078421723326, 0.5731144197832689, 0.17531048210183175, 0.21864077980310515, 0.181100621463553, 0.19536345884999462, 0.18558212959347498, 0.18822902383193885, 0.19622999201838942, 0.1928807327241866, 0.1962814071779705, 0.08982474649849304, 0.08515088777318358, 0.07673783400645184, 0.07868064654023332, 0.0867479871711897, 0.0845686577435446, 0.08194404461974392, 0.07918898075468572, 0.07750950184644367]}, "mutation_prompt": null}
{"id": "02fd449f-6c7d-431d-9c5c-0b5b62ccfcdc", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "f412230a-c8fa-47ef-bac4-9cc27206abb0", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "801d6fbb-9bc4-436a-bbcd-98058841da83", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.1\n        local_search_prob = 0.2\n        restart_prob = 0.1\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.3 + 0.4 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.9:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.4:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for enhanced exploration\n            if evaluations < self.budget * 0.3 and np.random.rand() < restart_prob:\n                restart_size = int(0.15 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution integrates multi-scale search, adaptive elitism, and stochastic learning to enhance exploration-exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.29430314668136265, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.20.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6493254568564393, 0.6401678212375521, 0.6371427723938519, 0.6572421149660397, 0.6406750289999885, 0.622433085355748, 0.6414065916784673, 0.6395940517809362, 0.6553366102635882, 0.44330549981379463, 0.45010542610568105, 0.4524921204985911, 0.4426671095043051, 0.44982431987457705, 0.43549309040760287, 0.4507273478687154, 0.4412830722831159, 0.4488519486297955, 0.20654939197238542, 0.3323995910348867, 0.21921492084818028, 0.2670258747718307, 0.3049603195326813, 0.1979598166219637, 0.2816588269253344, 0.1252965338249471, 0.33681835647806124, 0.12367162428922751, 0.10875688346649226, 0.12002295131305418, 0.17373592737992982, 0.10748114220749083, 0.11715140309826222, 0.17283908283050464, 0.11049671769080593, 0.11815861760104795, 0.8614004935698243, 0.8439204014536645, 0.8383291709550141, 0.8513707352465034, 0.8312460298620837, 0.8358251024090021, 0.853369628263822, 0.8993839776528443, 0.8810119383936168, 0.23021109251459138, 0.2541336670863845, 0.2709209673926062, 0.26121570973070474, 0.24234762733905857, 0.21001397757501017, 0.31766654722995435, 0.21755216610105732, 0.2081797304895493, 0.5899198517471353, 0.5649718028677607, 0.5275225704306714, 0.5236288138898302, 0.5686609333747505, 0.5566103089185397, 0.521389983431287, 0.553857690777358, 0.5786020396594791, 0.17072029444954173, 0.1544961344898813, 0.19580382819968467, 0.15739556319595305, 0.1365471570553617, 0.14338041534896406, 0.12905514436096432, 0.18334871724807944, 0.15997063418497326, 0.12777703404476015, 0.17066992417657745, 0.1402771379538793, 0.1353358991498188, 0.1816957891253841, 0.1721698847887616, 0.15120494092789227, 0.1291813645797638, 0.20007426183687038, 0.13239952799690236, 0.07582740726114301, 0.0727698908710972, 0.07265721904886446, 0.058170468599878955, 0.06657208736003961, 0.08708311425981341, 0.10995808567217713, 0.10068190198444105, 0.24865208426220176, 0.22317416803978585, 0.17567083796717686, 0.16792653380244338, 0.20278183354969104, 0.20336815925054508, 0.22997161112426667, 0.22561569231574108, 0.1928834773453909, 0.07483445701838587, 0.043487606664146417, 0.03082981616769176, 0.04471243111060408, 0.08465959384561306, 0.05341501227530354, 0.0627023282999386, 0.09305145390371983, 0.12521074501694784, 0.13886643918403785, 0.17190141387568203, 0.1672596373671711, 0.17058515990627787, 0.16993012109418304, 0.1793559547844601, 0.13377922355963967, 0.13629852042570567, 0.18734025756344252, 0.46125767523926164, 0.4869499076650795, 0.5040842271079801, 0.5091783548438737, 0.5101905242536753, 0.506354757518023, 0.49766399104257075, 0.4847863054956638, 0.44455649606004777, 0.11836626821507912, 0.1044876519281348, 0.09115233043953375, 0.10187477892698993, 0.09333058393394855, 0.11489113347024926, 0.11155097056271202, 0.11121364973753045, 0.09290096547011639, 0.19976699747664672, 0.1925683085865083, 0.17475425810498857, 0.23876434955601777, 0.2624191113019144, 0.36728305959430796, 0.19644909336693783, 0.19652494989078573, 0.20307798021687917, 0.36125257229707697, 0.3477574810972559, 0.35602863630529435, 0.38285672265296766, 0.3634370548992679, 0.3811233114478203, 0.3817805102310319, 0.39954994830777135, 0.3304217077221975, 0.26447723540300216, 0.2733468278615505, 0.2582454265084181, 0.2621378945695848, 0.29800307529189285, 0.28840765989263295, 0.27068147132220777, 0.30506585056010715, 0.28507169836477664, 0.19917701269154509, 0.20058782934612196, 0.1826270107748671, 0.19213169937755337, 0.18350026083679782, 0.19352103433661472, 0.18426579572698976, 0.18471951707802026, 0.19832589120593525, 0.3330078838795265, 0.38837293683262064, 0.21011702179931235, 0.3684456044714033, 0.2680788033018686, 0.2038718778398183, 0.40811755755633994, 0.21300651962474726, 0.39980873289907637, 0.5668300608151942, 0.3517247529180243, 0.5618454259987893, 0.5567953394549798, 0.3358041737975763, 0.5611188659310291, 0.5678953396446813, 0.5521891535308872, 0.5126257616015177, 0.2907096560270501, 0.30444180600394344, 0.2926013774678986, 0.29999804700000177, 0.24243340774492306, 0.4802684417004359, 0.5139951725991954, 0.49774811371998895, 0.4088124786070839, 0.17864989161962608, 0.18105542855389356, 0.1769865828882088, 0.19125259984774434, 0.18325047383393556, 0.18623442818797054, 0.1743508023420336, 0.17510837961483994, 0.17678600094082708, 0.06610742560352556, 0.07787117453923509, 0.07029883632242162, 0.07395256852586041, 0.08672209580827872, 0.07937941231704992, 0.06993639127129048, 0.07934325243311668, 0.07760700298216194]}, "mutation_prompt": null}
{"id": "9a43fdd2-7e8e-4dee-a4ad-ad42f8f7b620", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "06f1c768-cf6f-42aa-9796-c0e081c12477", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "d73e22ef-2143-439d-9f44-a4dca65a108a", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "401b3d19-3af6-45e4-b37f-8168d9489867", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "e048b566-3fc4-4a18-8e8c-6ef89a0a3067", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        adaptive_factor = 0.1\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.5 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.3 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Quantum-inspired mutation\n                quantum_mutant = a + mutation_factor * (np.sin(b) - np.cos(c))\n                quantum_mutant = np.clip(quantum_mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    quantum_mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive population reduction\n            if evaluations < self.budget and evaluations > self.budget * 0.5:\n                new_population_size = max(4, int(self.initial_population_size * (1 - adaptive_factor * progress_ratio)))\n                sorted_indices = np.argsort(fitness)\n                new_population = new_population[sorted_indices[:new_population_size]]\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.3 and np.random.rand() < 0.05:\n                restart_size = int(0.15 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution introduces quantum-inspired operators and adaptive population sizing in Differential Evolution to enhance exploration and exploitation balance for improved performance.", "configspace": "", "generation": 78, "fitness": 0.14016534411408502, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.10.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.28052364288704923, 0.24462512359619548, 0.27781987381519735, 0.27651685262721315, 0.26470648599225255, 0.30764799741720716, 0.2628965014689145, 0.25848470981334604, 0.2527864287110325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016258752190498438, 9.999999999998899e-05, 9.999999999998899e-05, 0.09410111125086007, 0.08635103723170556, 0.10825367442886258, 0.10453711508956076, 0.10054151899122754, 0.11653277760553993, 0.10304196910016872, 0.09784659269802864, 0.09514551808572591, 0.08260269402878584, 0.08930209874047579, 0.07665533749739839, 0.07597107308205342, 0.09386152071702725, 0.09780168879645901, 0.0886723260737814, 0.07922846697693564, 0.08294532792433607, 0.14446449120135962, 0.13177814835509927, 0.13518650290184708, 0.1419330998608651, 0.1419517996412356, 0.1277991678467848, 0.12010149608732068, 0.12531234526857737, 0.12484156721007367, 0.159985780972561, 0.1673633525128616, 0.17696359252575933, 0.1568910813106117, 0.08956558083079214, 0.17086927626920223, 0.1376224669694016, 0.16352226812638382, 0.14290975682968532, 0.20224336694471468, 0.20534387757108352, 0.2073793642583911, 0.2369341902331884, 0.21701990692137751, 0.24063028436238743, 0.16617152299789628, 0.2103310526321014, 0.257575644557157, 0.0578496753381218, 0.051961466732545536, 0.04928596386342032, 0.13777996914463042, 0.027193919064236072, 0.11985732301333007, 0.0991858313782441, 0.09393127943359336, 0.09096605120360468, 0.05990117120155869, 0.07549381670646094, 0.03550578397109516, 0.07730176250004173, 0.08213999483885259, 0.06052220726305568, 0.06290079368220136, 0.08631199507541698, 0.06235378911288714, 9.999999999998899e-05, 0.00030760370891114164, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003175178589798211, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0896563872666315, 0.04370379379195599, 0.08404632968066927, 0.07433996481547633, 0.022452577138117324, 0.08585871063243289, 0.08228865176727973, 0.08322787676765764, 0.06832717159462809, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035257302372985966, 0.031356991886602015, 0.036386476466477635, 0.034277096355438186, 0.02988269276187605, 0.027021924032625266, 0.0155808085591298, 0.02563793621033783, 0.032974759064455794, 0.2765347698295354, 0.29694279042839633, 0.2684315839045308, 0.30120142424349117, 0.30163537383564476, 0.2995897712570611, 0.3031418921625557, 0.31292507267743996, 0.29684776029460236, 0.08699413668161993, 0.09926625452748017, 0.10369422695976704, 0.08439677045653937, 0.07553071453881588, 0.0884310542031218, 0.0914008027632035, 0.08357012767837313, 0.09906147373813767, 0.1483032431258674, 0.16385248524722607, 0.16546367307684107, 0.15325761500595125, 0.1585894713608812, 0.14423699051657257, 0.15303851630652332, 0.1524502622523385, 0.18132392670639996, 0.21551786309684418, 0.21577071896927047, 0.2214441227449231, 0.21219912411719277, 0.19742239808216488, 0.21332702529030556, 0.21765902450999952, 0.20994414075861645, 0.25264491490208363, 0.16254070234977802, 0.1659698502892234, 0.16205359939832775, 0.15988255357821546, 0.17014181438411324, 0.15490652220626655, 0.15262323195878758, 0.16473532285860404, 0.17107381884871975, 0.18632423623253336, 0.19494784603815907, 0.18361048551661507, 0.1977388138353242, 0.20316172629163576, 0.1968133424430626, 0.2043673031381682, 0.1925255724421977, 0.18975920176517125, 0.21381738763947156, 0.19656775450933184, 0.18489851173207794, 0.18432874966291057, 0.18280273840868888, 0.17930894014191034, 0.17839600210022777, 0.18426536468450117, 0.17701012130311866, 0.3804216246248783, 0.40779401160327156, 0.4128387901488282, 0.3043605456821471, 0.2944274695369613, 0.37522213736985, 0.33949783267708655, 0.20573450381546254, 0.3148239193516994, 0.3192442096986927, 0.19648951801848158, 0.17353745803892362, 0.3527428213716418, 0.1809684453007312, 0.18695184283970434, 0.3362910445314883, 0.22855331514891863, 0.26198069117357337, 0.1845875389158088, 0.20066450419305049, 0.209753699340961, 0.17404275930293733, 0.18331441780176916, 0.18295501791157243, 0.19193009015627538, 0.18025877898906606, 0.1798788766763062, 0.07621199436476322, 0.07550404315820591, 0.09810006746973976, 0.07973270359808626, 0.07416936683411313, 0.08363385440000126, 0.07880883337324684, 0.08443167632765802, 0.07114832659648107]}, "mutation_prompt": null}
{"id": "04d3a7d3-bda2-4d87-8610-b31bd409bd4e", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolutionWithDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.25\n        local_search_prob = 0.2\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.6 + 0.4 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio ** 2)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.15 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolutionWithDynamicPopulation", "description": "Adaptive Enhanced Hybrid Differential Evolution with Dynamic Population Adjustment (AEHDE-DPA) incorporates dynamic population resizing based on convergence, adaptive mutation, and intensified elite local search to enhance exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.2906069513818453, "feedback": "The algorithm AdaptiveEnhancedHybridDifferentialEvolutionWithDynamicPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.5856240173635099, 0.5963042660886907, 0.5946721184849701, 0.6126616276720243, 0.5979885680550701, 0.5997603560861339, 0.5877683007744572, 0.599994266576229, 0.6125533752594517, 0.37967926038161426, 0.3832731656619177, 0.3722910892762803, 0.3848752037781764, 0.3717749414670164, 0.37709312889784796, 0.36177716448090436, 0.38700366440171097, 0.37610755028052667, 0.24179052520885091, 0.29631985775271674, 0.29979348974382436, 0.2700394916853802, 0.26709537529592975, 0.28545713979841947, 0.32922040302030353, 0.2944639841906185, 0.2686304666315903, 0.12594406988684714, 0.26869681820648816, 0.1262634316115716, 0.20425373523099233, 0.2074125464617469, 0.22331388575683442, 0.11324287261979693, 0.24027376407827417, 0.1137047213814234, 0.8939075375565436, 0.8965474147593784, 0.9325349563155388, 0.860236842755522, 0.8962856729904011, 0.8247153932942592, 0.858503245128871, 0.9019693184565429, 0.9060814866375986, 0.2640741414591272, 0.26686729781012797, 0.26146374121050175, 0.2682685386248812, 0.2667172782085465, 0.28959789253246027, 0.28231934421370763, 0.26727402623556784, 0.2677037759487577, 0.5171203435349334, 0.4899054904449638, 0.4898264771838846, 0.5665006396537495, 0.5435170219842274, 0.531878702180701, 0.4972819978945703, 0.5348767709589244, 0.5820912718192081, 0.243822562341808, 0.11965309239319999, 0.16924878964171808, 0.15181226802446068, 0.14004994831895423, 0.15154581521931865, 0.15142882241366262, 0.1381845376289893, 0.14803058090135435, 0.19072864680194102, 0.1093359565946197, 0.14303988048471383, 0.1529945118018904, 0.12208974363721814, 0.188889979857932, 0.12748881128698575, 0.13001077817967377, 0.15515295227285986, 0.12392645980955208, 0.11610844217646177, 0.1471610244931817, 0.10584379359707197, 0.14097499469486974, 0.12831309706382654, 0.13201076341147655, 0.1308059688102754, 0.12933648426187683, 0.22587305357736598, 0.2585856517954612, 0.26292044656423263, 0.2286200770703407, 0.2423146133866062, 0.22785518994370235, 0.23125099545925332, 0.23873576942173724, 0.24232604836896876, 0.043382696259215536, 0.06279246741479327, 0.0426570605807689, 0.05841004702273511, 0.06952817471014638, 0.055427516998755366, 0.058661507875585994, 0.06533190830527169, 0.06710428434489224, 0.13761478046520992, 0.14487892353061982, 0.14883129808090667, 0.1726229379796732, 0.16159601850841243, 0.17375054990371863, 0.16560045961242142, 0.15835313418080788, 0.17142350504166537, 0.48774265299015407, 0.4605078349769478, 0.4949607996997817, 0.49962350560204527, 0.47624932502813766, 0.46553242753315505, 0.48442370476630314, 0.48464583673283357, 0.47666250624320394, 0.10886382395764338, 0.12308085932005564, 0.13615932631216088, 0.10240728048175096, 0.2590570741061584, 0.1243235313287161, 0.12476020676685762, 0.09204923665794063, 0.1140407314569547, 0.27254237960358996, 0.24616572831596928, 0.17638487304350126, 0.1945587508582982, 0.35999731083467745, 0.25206124212424164, 0.23588600323296016, 0.3104785044889351, 0.3421475994532813, 0.3158065471064959, 0.31361849304547285, 0.35315981880878566, 0.32491336651285574, 0.3349284285635046, 0.3215695410291042, 0.3594143546986702, 0.35726238802174903, 0.35506508354539845, 0.23410142555441982, 0.2488836399343537, 0.23370437788097387, 0.23328805989828838, 0.22552543854607265, 0.23914505464168445, 0.23866144025514047, 0.25050612296809105, 0.26481074434690655, 0.17476187684526334, 0.18964471009964823, 0.20037419457357286, 0.1921777290878094, 0.18523673378002314, 0.1768688421463781, 0.19264902492516445, 0.19709997351889386, 0.18228857358760442, 0.19699734017573234, 0.36084252774965175, 0.3951257897924475, 0.35169551513833563, 0.3453744203080181, 0.21835318926885716, 0.3547698263355964, 0.1993190948035578, 0.2047427051594407, 0.5115190180914468, 0.1813937378104018, 0.5426010472279498, 0.5536168885022796, 0.1667676487732338, 0.5465615363102586, 0.17398857293823056, 0.4812985205380035, 0.49911437378755685, 0.47982307002739744, 0.49595452231384696, 0.23801104917671811, 0.5143682957002689, 0.3429284107288123, 0.18396370861692868, 0.27055828979588026, 0.5046876568664367, 0.185312906174105, 0.18665827292835813, 0.19346719207665364, 0.17967601463052196, 0.17042785217206036, 0.17698720553976655, 0.17913699630468782, 0.1810967176750694, 0.1907785533518931, 0.17651227448001827, 0.07716576208174808, 0.07472180294166153, 0.07355686411702622, 0.07541491543750456, 0.08471763286337952, 0.08497186409284518, 0.0820452392847123, 0.08499049523027136, 0.0786840554556365]}, "mutation_prompt": null}
{"id": "fbc80c5a-d2ab-4de2-854c-7929f52120ca", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "de33eda3-e986-46f7-9d5c-995157f876d1", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "1b8035b9-6e4e-4b3a-b23c-dd96d34bd5a6", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "2fdf1b7c-bb1e-4561-8806-7f41dcc93826", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "f414e257-6148-4bb6-96ef-d55bf6477adf", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "67da411e-3935-494b-8174-aefcb10b7040", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "d8f5a22f-8beb-4e9e-8059-5c921864d008", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "8c7a6452-a9c9-4c29-9840-929095659063", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "3d96d5d0-e849-492f-92e5-8d2f86e99bff", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "9f19f560-9c88-46c8-ba07-3005e8f364d8", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "2b20a8f2-bc65-45e6-a5ca-65b63a92e590", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "cd3c622b-78a8-4798-8503-975323de54a6", "solution": "import numpy as np\n\nclass MultiStrategyAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.1\n        mutation_strategies = [self.de_rand_1, self.de_best_2]\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            \n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            adaptive_crossover_rate = lambda x: 0.9 if x < 0.3 else 0.6 + 0.4 * x\n            crossover_rate = adaptive_crossover_rate(progress_ratio)\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                strategy = np.random.choice(mutation_strategies)\n                mutant = strategy(population, fitness, i, mutation_factor)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution\n\n    def de_rand_1(self, population, fitness, idx, F):\n        indices = [i for i in range(len(population)) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        return a + F * (b - c)\n\n    def de_best_2(self, population, fitness, idx, F):\n        sorted_indices = np.argsort(fitness)\n        best1, best2 = population[sorted_indices[:2]]\n        indices = [i for i in range(len(population)) if i != idx]\n        a, b = population[np.random.choice(indices, 2, replace=False)]\n        return best1 + F * (best2 - a + b)", "name": "MultiStrategyAdaptiveDifferentialEvolution", "description": "Multi-strategy Adaptive Differential Evolution (MADE) enhances AEHDE with distinct mutation strategies, adaptive population resizing, and hybrid crossover to balance exploration and exploitation.", "configspace": "", "generation": 91, "fitness": 0.2791562645739316, "feedback": "The algorithm MultiStrategyAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.5508023539251188, 0.5636651792714322, 0.5702315897616553, 0.5791374337818833, 0.5907992751290401, 0.5881859422473742, 0.5724117654699261, 0.5623134002698784, 0.5856422869894032, 0.2942332766503204, 0.25799832411265, 0.33446405612684116, 0.34806721564809606, 0.3360570166112805, 0.33464998138989, 0.3091956783260882, 0.29511814909464407, 0.34441325827128944, 0.15710068145637202, 0.13042333860705435, 0.2200230179906575, 0.11396142064184533, 0.09828113973038999, 0.11470535894757272, 0.12670128557644855, 0.12305160960016404, 0.1345993909778248, 0.11427326940878557, 0.11084172586344698, 0.0963522406062508, 0.10570030972988576, 0.10672953087111603, 0.090801611915868, 0.1056993190051051, 0.10193938473473152, 0.09778969608519306, 0.9697721366134141, 0.968943616263006, 0.9629491957633498, 0.8945719431439599, 0.9471762566730185, 0.960041468821936, 0.9623098674546949, 0.9904182339722993, 0.9611517354981187, 0.2576004069700577, 0.23856126073554218, 0.25866237215756005, 0.28413847577512963, 0.2694562672026969, 0.3092560578941531, 0.22347730839651436, 0.2829187514972725, 0.2777607836958016, 0.5563462900392335, 0.21293891317776648, 0.483945825699731, 0.5745872108204398, 0.5190882291645239, 0.5192243929986688, 0.5203458166048607, 0.47717772527322366, 0.49823188794358453, 0.19385124639782036, 0.1291480494464473, 0.1329495333213021, 0.1023684434042742, 0.1348842775502841, 0.1227048684882982, 0.13098000663004383, 0.1461406749729105, 0.13384367157327393, 0.12490643777376786, 0.09824915319574334, 0.12758873126020864, 0.13350458587019542, 0.12839345685470438, 0.14853005562251675, 0.14431427257814666, 0.13262572261230254, 0.12627977387928857, 0.16742577212907161, 0.14544333391781816, 0.15898973793351456, 0.06757840532308657, 0.15876748029564935, 0.17906541308318535, 0.11726901520172783, 0.17759359475364367, 0.1795675382312658, 0.3073461496326846, 0.2291075683436269, 0.2465102145698702, 0.31047481902078067, 0.27285003851965217, 0.23702312106233503, 0.28881646194410027, 0.23947577625076655, 0.25209348480815796, 0.028441633407500166, 0.03717408987558868, 0.07369383949960795, 0.09214170163301405, 0.056929364166982466, 0.09660371174200122, 0.0384719699786259, 0.047417025918697786, 0.0702845935333426, 0.15511062612422744, 0.1252420630664477, 0.13762531514999732, 0.1408296191754853, 0.17005811162279882, 0.18567675776783776, 0.17467301775916644, 0.16426981926085904, 0.1433280464746418, 0.43444551099635786, 0.46924355483122315, 0.4796889598022882, 0.4702870871982524, 0.4997991051611538, 0.5072375624355275, 0.46701852948837064, 0.47727371821927966, 0.4526194318338028, 0.10673482391631572, 0.10268958829334374, 0.10046798149490677, 0.1132132754680204, 0.09406831575887487, 0.12329809261534264, 0.10134978854409982, 0.08564306972320024, 0.10873955683493608, 0.3025832333792865, 0.14580480624561876, 0.18357363820618833, 0.17647381660340855, 0.291292526922753, 0.24110846449361978, 0.2085466443462849, 0.1966720753242157, 0.2149748958865212, 0.2713396102597694, 0.32469726487269257, 0.30559096066785796, 0.3277403011152227, 0.329083569342028, 0.34013895272268324, 0.3252993790272808, 0.3281789332139935, 0.34103072953543045, 0.22957507663278476, 0.23669690238764485, 0.25575116710084733, 0.17698743519913318, 0.21537607936579195, 0.2748384014700531, 0.2303403360839028, 0.25919961776057965, 0.2709157509004074, 0.18129750287020574, 0.19478718414115026, 0.21094195628414436, 0.2154537727233824, 0.19445193412539274, 0.20692532507024097, 0.1872415685886707, 0.18457418443389972, 0.1956370232650515, 0.19875429065250705, 0.4208859839309538, 0.1905032370041796, 0.2040984260324853, 0.36776553631196107, 0.21515832266159918, 0.19300773552337436, 0.2051149590810062, 0.3612445850785272, 0.17147025513361602, 0.6209577894875479, 0.625635262884694, 0.1583163594096122, 0.39563685779194235, 0.5848440818051843, 0.5442503835733675, 0.5363972687081361, 0.5722087313683956, 0.5720181944231977, 0.19474634475257635, 0.5694051177702446, 0.19257791066816776, 0.5816771758242449, 0.5727414399821875, 0.20072275151279806, 0.598859720920558, 0.20214987819648556, 0.19616959452084726, 0.17811827297047134, 0.1845610520870733, 0.18511493065992057, 0.20633393101080266, 0.18847588241095692, 0.24357515128955443, 0.18713101866647375, 0.19213187456846648, 0.07484515378418255, 0.0750908653175486, 0.08651132659414051, 0.07882625288810308, 0.08394755580253055, 0.07125177291853413, 0.06871702945158231, 0.09498585434426243, 0.06983291732542929]}, "mutation_prompt": null}
{"id": "828fc291-a962-495a-a4f9-d7538d57e365", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "856ebf1a-3e6a-44f5-9943-1ed1d2550240", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            # Random restarts for diversification\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.05:\n                restart_size = int(0.1 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdaptiveEnhancedHybridDifferentialEvolution", "description": "Adaptive Enhanced Hybrid Differential Evolution (AEHDE) utilizes adaptive differential evolution with elite retention, random restarts, and intensified local search to improve convergence and robustness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.6909489726966505, 0.6866008670774434, 0.6889855452818519, 0.6907399703252692, 0.6899104104082097, 0.6944961130737456, 0.6913247924643348, 0.6995924270307725, 0.6944042358085248, 0.5241010174996465, 0.5220233987307925, 0.5361175621343962, 0.52617687595544, 0.5364299208111616, 0.5404191606405762, 0.5439679917821236, 0.5349278061061822, 0.5165870616899371, 0.45317701322494264, 0.4190981909096866, 0.4481527834723661, 0.4216641959541535, 0.14838742502105196, 0.4567458881255604, 0.40978117297565164, 0.4450454355178566, 0.42099892411151774, 0.11607610858491968, 0.12247397188973319, 0.12970168724221964, 0.13012935154149852, 0.1321749141380304, 0.13604752767093597, 0.11584238764631649, 0.12060946849491971, 0.13566426027154976, 0.8864187229739495, 0.9328314767772505, 0.8609072360578328, 0.9126727814080416, 0.8855991913762973, 0.9610877259268463, 0.9316356931600925, 0.8998183998629155, 0.901833683064399, 0.3787990519766604, 0.43481105310389945, 0.4493811948606773, 0.34274713990654593, 0.32604038684937864, 0.3794768585200655, 0.34204491384454927, 0.33648997399060376, 0.2806467036072693, 0.5980906614147188, 0.6131338841749179, 0.6378557671058187, 0.6650659396540453, 0.6370091118392891, 0.6390707875869983, 0.6242041385593685, 0.6029658630374999, 0.6444951124003346, 0.13979261240557794, 0.13350070259022728, 0.15975770232967557, 0.14181586722280737, 0.2445434327187952, 0.15797521722535968, 0.16237161828828506, 0.13790523882971706, 0.156071994860553, 0.14639130900462094, 0.14630288672218017, 0.1649130574098837, 0.1600626286387462, 0.12517533571632888, 0.16436011181070576, 0.1742023202182318, 0.1608282619266298, 0.14755730174967085, 0.23849876392840808, 0.17358215870784155, 0.23484045228402328, 0.1723458524067868, 0.20211468117712028, 0.12032278663995133, 0.1432384852948595, 0.25100471333337304, 0.2138650364631275, 0.32272644339144907, 0.3354334932269626, 0.33098100646146833, 0.28949421099175165, 0.31009291226730074, 0.27630828683561437, 0.2603728197384837, 0.4151399071938784, 0.31946140740726703, 0.14619210506992253, 0.18565562278403813, 0.09413918766610618, 0.12454784861878421, 0.11921342026462589, 0.07971122795422958, 0.10894887962471289, 0.08379070459699012, 0.1109528374083304, 0.22058060787379996, 0.22015393085513257, 0.19811645580918302, 0.2350646028272798, 0.23960850442574433, 0.25187428627397335, 0.19457305252993862, 0.24720100841705928, 0.25795160698827446, 0.5833670672024802, 0.6005490160090579, 0.576465031508862, 0.5585488829090536, 0.5811778915645193, 0.5912231232405465, 0.6069598661399564, 0.530252009876448, 0.5575419694073773, 0.1114724670681122, 0.1223458509387878, 0.09719556666499662, 0.11271633920717827, 0.10846910478797167, 0.14301067449319038, 0.1268495018176765, 0.10794504360819324, 0.11054190651739204, 0.3937497849239646, 0.34859103097499633, 0.23877175428850905, 0.2973189596342005, 0.21474658840249172, 0.21400792202132268, 0.2146993585649889, 0.21882036299926622, 0.43972322500327143, 0.37959666556840066, 0.37842177189429904, 0.4610129300642587, 0.36959267626316783, 0.40564039963923637, 0.43992699915812805, 0.47548965360179274, 0.40638340279873897, 0.4351519109355044, 0.26144560979661324, 0.2813601956710424, 0.3223200280357621, 0.3060601551657439, 0.30856622027533964, 0.30661472036251103, 0.2777956561878273, 0.3169599699295579, 0.26844219833493976, 0.18874730992360433, 0.19342119484275777, 0.19559983450184693, 0.2097866054329004, 0.2223485802776417, 0.1796583556406851, 0.18423432768925918, 0.1866104481636165, 0.2141588921820623, 0.21098861358657184, 0.2142577493246105, 0.20957171037055555, 0.45799014282957096, 0.5138617203304165, 0.4956876206082079, 0.19099704570146792, 0.212466650077468, 0.5348164489745069, 0.16152063248675808, 0.17288286010823628, 0.5632946315058727, 0.6426109427306517, 0.6389939885091345, 0.16002452263195321, 0.19514201754896765, 0.635544393793404, 0.19161209812881186, 0.39476744660110363, 0.5988762171437098, 0.19217046731197496, 0.27839488003604773, 0.5650252132572895, 0.6444516766694635, 0.1984279966227842, 0.6579071906467002, 0.2022483475899819, 0.187410175460632, 0.19481346969461788, 0.20254586586008605, 0.1794173435717188, 0.19579282758766292, 0.20707815386899542, 0.19556661097000128, 0.19474625847482652, 0.2428891863114503, 0.08053896949496997, 0.07885988454389203, 0.07359828642904398, 0.07358929309234119, 0.09063261956188651, 0.08038294049783778, 0.08166914629220223, 0.08772076008571184, 0.09126613318497179]}, "mutation_prompt": null}
{"id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant1 = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                mutant2 = np.clip(a + mutation_factor * (best_solution - a) + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant1[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n                trial = np.array([\n                    mutant2[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.2 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with Dual Mutation Strategy and Smart Restart for enhanced exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.3850408743683367, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.23.", "error": "", "parent_id": "81755af4-c7a6-4f07-80b1-7048f1f8ac72", "metadata": {"aucs": [0.7243650187903578, 0.7359669810873941, 0.7243289366325452, 0.7259468739955611, 0.7276662943334842, 0.7221321210642334, 0.7224112003462273, 0.7292552626805254, 0.7221250676594311, 0.5381585789480612, 0.5668346596518931, 0.5555562357003114, 0.5413970806439273, 0.5558696052839383, 0.5620195794055637, 0.5466486001853053, 0.5505099730890659, 0.5516377487865018, 0.43784198189252943, 0.4527698734991038, 0.4224191780568777, 0.41107705140283857, 0.4730250643430849, 0.4481812493556665, 0.14461721933569383, 0.4812441838435594, 0.41939882049523736, 0.14417153029251417, 0.1417005622015689, 0.12044192876802717, 0.389054892662102, 0.12253243628210853, 0.2584203550642231, 0.12419297229603399, 0.13859494089517588, 0.14656790278220322, 0.9484890325137778, 0.95279425323875, 0.9508618422652186, 0.9145841879878744, 0.9527617175320299, 0.9736351747236802, 0.9524735095800568, 0.947665479752625, 0.9452708171422283, 0.530134970017017, 0.5637767719426423, 0.5268145519941987, 0.4444373123312032, 0.5152106478515842, 0.4615445619622026, 0.4575611179966549, 0.5395477260396583, 0.4102595746275619, 0.6985268800649249, 0.6640190366211903, 0.6351258467583635, 0.7095183538477489, 0.6823370033044622, 0.6918429558357364, 0.67826753016086, 0.7085453989824151, 0.6974078109722514, 0.17353070945523663, 0.18391972190973338, 0.18174102894236188, 0.16007217000532914, 0.15955326745620568, 0.15469044721189806, 0.1964583866827435, 0.15641796996267, 0.2501548037100869, 0.1683072021170694, 0.17323414187116182, 0.17738973133745317, 0.17241843932381762, 0.20723812995008517, 0.16848193242002474, 0.1748123230423374, 0.18577552004429365, 0.26591623366230555, 0.3757477674100773, 0.34572724167927893, 0.350784598477514, 0.29301619195272577, 0.38321309741396214, 0.36286571660529376, 0.3712513169854502, 0.2597868183882067, 0.11423165343436936, 0.4949025378560977, 0.45611660688276734, 0.45702314923308385, 0.4260927086298053, 0.4795583219290477, 0.4460140721589201, 0.4624072355088472, 0.512963790409311, 0.49510984582845985, 0.14516791941987994, 0.04322692943923845, 0.17527734661875238, 0.1617886873886879, 0.23773579184676796, 0.16507212031642116, 0.1285958524881593, 0.21161744999130128, 0.11971965275216967, 0.2758615649926002, 0.3179683560188533, 0.2939775781916303, 0.3415401553286853, 0.30073852936106105, 0.27435404209062586, 0.27694892082402955, 0.29309424708888077, 0.2330338231199226, 0.6435295406592767, 0.6342577962201118, 0.585826164475821, 0.6036554569604089, 0.616678145515389, 0.5698601906306364, 0.6608538743557703, 0.6589604071368691, 0.6167645510269899, 0.1142262078931886, 0.1243229843613346, 0.11422875947872813, 0.11255645098028433, 0.10505238787763738, 0.11415162320350025, 0.11964705943366649, 0.12693434890359145, 0.12447218102705448, 0.18767451106320232, 0.25701186073865634, 0.20241741477986908, 0.327902157897935, 0.40369964907219, 0.27549770487502934, 0.23799935940993366, 0.20703146599759326, 0.3240401889807112, 0.4778690814610005, 0.5144828742072975, 0.4756202772641652, 0.42767330809959836, 0.4764577788533588, 0.5067935428848229, 0.5256912661545036, 0.4524191557828845, 0.4845693488423217, 0.3449976127448394, 0.34278026223351166, 0.3337632353023976, 0.3275021514347398, 0.32530393708524885, 0.35038875155237337, 0.378914485583304, 0.38749266410311356, 0.4120140220279296, 0.2147767390091777, 0.19290134830401084, 0.19793918661511412, 0.19428629248555407, 0.20640637242323856, 0.2146016902483221, 0.21617896849043683, 0.20792746687371233, 0.19090887349104912, 0.5281637164104138, 0.18801140448251852, 0.4671653108652002, 0.19782247319810675, 0.5126174893030664, 0.507103438442522, 0.2136302244449062, 0.5237664379200626, 0.49700146139498846, 0.17500550874377718, 0.17104126281200827, 0.6473064537911355, 0.7147354713660783, 0.18530331170270997, 0.6972509344276419, 0.7074660854650068, 0.18106628965542948, 0.6770070615641366, 0.6035243394264118, 0.19982618693633714, 0.16317826761069099, 0.6787938910677789, 0.18057207864252356, 0.6578713983804156, 0.26545340659903505, 0.7207814093885269, 0.6366461092430158, 0.19182634942563515, 0.19908192631056187, 0.18164986669652583, 0.21939738099221162, 0.18602381831432446, 0.21361104182604163, 0.17776453779918489, 0.1794653705973036, 0.21181779068704942, 0.08583307799380069, 0.07616047048866093, 0.08294121550781308, 0.08653687376177155, 0.09073162808093316, 0.08074888148265114, 0.08124291620928503, 0.07268673178308638, 0.0781446008405523]}, "mutation_prompt": null}
{"id": "6f5abaa3-2348-4135-830a-07785f9b1661", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n        stagnation_threshold = 50\n        improvement_threshold = 0.001\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n            best_fitness_improvement = 0\n            stagnation_counter = 0\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness_improvement = best_fitness - trial_fitness\n                        best_fitness = trial_fitness\n                        stagnation_counter = 0\n                    else:\n                        stagnation_counter += 1\n\n                if evaluations >= self.budget or stagnation_counter > stagnation_threshold:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                        if candidate_fitness < best_fitness:\n                            best_solution = candidate\n                            best_fitness = candidate_fitness\n\n            if best_fitness_improvement < improvement_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > stagnation_threshold and evaluations < self.budget:\n                    restart_size = int(0.1 * population_size)\n                    restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                    for idx in range(restart_size):\n                        restart_fitness = func(restart_population[idx])\n                        evaluations += 1\n                        if restart_fitness < best_fitness:\n                            best_solution = restart_population[idx]\n                            best_fitness = restart_fitness\n                    population[:restart_size] = restart_population\n                    stagnation_counter = 0\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Parameter Adjustment and Hybrid Strategy for improved global optimization.", "configspace": "", "generation": 95, "fitness": 0.19663115454139546, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "metadata": {"aucs": [0.45843255724646204, 0.45506742305529224, 0.44164037313124216, 0.47004738853516215, 0.4799733948200685, 0.4704131277509631, 0.4593200982228737, 0.47647693870626495, 0.4498963833268358, 0.17090742912665935, 0.19362842886156384, 0.18060102959704094, 0.16527961253939483, 0.18557878067900102, 0.1715674639411996, 0.18612216407161863, 0.20080101940703254, 0.19342737059115844, 0.10136727765477427, 0.10777215140580243, 0.09608622020958024, 0.10302570963598723, 0.10320170480328894, 0.1049845735459759, 0.12207978514835194, 0.10649760173406253, 0.11009741832919262, 0.09897721498229761, 0.09139259450921022, 0.08969732040312972, 0.09153977646668132, 0.08781326954695867, 0.08397174423986598, 0.08377388571955435, 0.0970170083256271, 0.09622386017093199, 0.8875169274491203, 0.9327117557064568, 0.8780452107719448, 0.8562314534468276, 0.8795840046283967, 0.8492041055056635, 0.8283246109527911, 0.8628906550077118, 0.887554387744195, 0.18029476553738533, 0.17603048595823456, 0.16871005321527388, 0.1722581453204497, 0.16530311766795602, 0.19462946931585812, 0.19465063011334427, 0.21229555867765115, 0.18743799464811106, 0.24197215410436135, 0.265544779499869, 0.25026199395724635, 0.33269009920191495, 0.24301425168506707, 0.3353816071444329, 0.283878044537488, 0.25905166678989655, 0.28505739656252527, 0.10597980184241373, 0.12853433943510206, 0.12309846290467608, 0.12021629113822108, 0.13855072677383373, 0.10866083876980082, 0.11587706079982507, 0.1326263331779579, 0.13530415125909256, 0.08344444141384522, 0.09721973736419531, 0.10078898712800366, 0.1091836502377832, 0.12067547581188942, 0.13624054161652022, 0.08717621702154155, 0.12205494762183444, 0.10635269607861353, 0.03409286662068878, 0.025491333289415552, 0.010466787316143145, 0.030431023688240577, 0.018971511880523262, 0.014356690144802453, 0.014913290525554457, 0.02216183979914854, 0.028879579823152368, 0.12954210486962237, 0.12291536524290003, 0.13512966169914686, 0.11478786922370032, 0.12282785233913585, 0.10947757335733477, 0.1617509963397008, 0.14711035609789358, 0.14751981645919843, 9.999999999998899e-05, 9.999999999998899e-05, 0.007252505830364631, 0.0004768018266495533, 0.00035281115323382295, 9.999999999998899e-05, 0.00958682518403653, 0.002144605491289031, 0.015502998737697449, 0.07637003172986001, 0.0910022550504127, 0.07316833244551613, 0.08519133175264693, 0.08697197428671821, 0.0937655982869815, 0.07852894735185523, 0.08098111451723378, 0.09205899705857845, 0.35426714732151654, 0.3792599627939093, 0.3787235398859894, 0.37025394711853865, 0.3798468940054268, 0.37874623614984393, 0.3952924692425316, 0.3971889310733262, 0.3721579720955529, 0.10711458570006238, 0.09654155621220306, 0.09699147785728546, 0.08423916058757497, 0.08088829042843315, 0.07706177488560495, 0.08378960873242935, 0.08968059242079385, 0.09153514484897662, 0.14901477938918195, 0.18194008249835447, 0.1866952686923783, 0.17119586133961306, 0.16369049783066458, 0.13535692186925663, 0.15234158367887862, 0.16320036406517924, 0.167957992240246, 0.24661258862111524, 0.2216607013538383, 0.2382990477902881, 0.22697366765680294, 0.22551682997326328, 0.2262231554420674, 0.25135894702556927, 0.26160663363996306, 0.2387601710065509, 0.17477341034928917, 0.1640444209036701, 0.16859059673290488, 0.15792925216136278, 0.15583029010425675, 0.1632423485554767, 0.1773709876388544, 0.18272369356520113, 0.17306799224283875, 0.18214221704702505, 0.19089851618833076, 0.20511142313447994, 0.20118578435005086, 0.17640554629087946, 0.2055312492439617, 0.1839489749507408, 0.21464076507004382, 0.18917081559303406, 0.18588217948332053, 0.16789341522591583, 0.18056193449939817, 0.17889634878683514, 0.1950446620954135, 0.18199941575900236, 0.17398954072214934, 0.1802135812255954, 0.17915857606105, 0.18488691107885435, 0.2470287745142633, 0.25727121413169174, 0.22323596295654957, 0.17178587473950724, 0.15001547329006537, 0.16572061177033715, 0.19305396428053212, 0.17880727550737607, 0.15853916620658615, 0.16965075916041716, 0.17757269901373185, 0.15086066759501793, 0.17200518109275886, 0.16701038801875834, 0.26996967608890776, 0.2428072053042296, 0.29481319284769225, 0.1760703194348855, 0.18821013316205104, 0.18744421240894882, 0.1718012177959679, 0.1919920575588765, 0.19815811127475003, 0.17862094289872732, 0.18306139909818075, 0.18683507572958846, 0.08678986069914796, 0.06626383500026478, 0.07034944846418312, 0.07138774095662992, 0.07505888304402164, 0.08597383774597434, 0.06810066206821852, 0.07170679763660104, 0.07554574950702098]}, "mutation_prompt": null}
{"id": "8eb99354-5b99-4912-ae58-7f938ad4556b", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant1 = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                mutant2 = np.clip(a + mutation_factor * (best_solution - a) + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant1[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n                trial = np.array([\n                    mutant2[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.2 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with Dual Mutation Strategy and Smart Restart for enhanced exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "metadata": {"aucs": [0.7243650187903578, 0.7359669810873941, 0.7243289366325452, 0.7259468739955611, 0.7276662943334842, 0.7221321210642334, 0.7224112003462273, 0.7292552626805254, 0.7221250676594311, 0.5381585789480612, 0.5668346596518931, 0.5555562357003114, 0.5413970806439273, 0.5558696052839383, 0.5620195794055637, 0.5466486001853053, 0.5505099730890659, 0.5516377487865018, 0.43784198189252943, 0.4527698734991038, 0.4224191780568777, 0.41107705140283857, 0.4730250643430849, 0.4481812493556665, 0.14461721933569383, 0.4812441838435594, 0.41939882049523736, 0.14417153029251417, 0.1417005622015689, 0.12044192876802717, 0.389054892662102, 0.12253243628210853, 0.2584203550642231, 0.12419297229603399, 0.13859494089517588, 0.14656790278220322, 0.9484890325137778, 0.95279425323875, 0.9508618422652186, 0.9145841879878744, 0.9527617175320299, 0.9736351747236802, 0.9524735095800568, 0.947665479752625, 0.9452708171422283, 0.530134970017017, 0.5637767719426423, 0.5268145519941987, 0.4444373123312032, 0.5152106478515842, 0.4615445619622026, 0.4575611179966549, 0.5395477260396583, 0.4102595746275619, 0.6985268800649249, 0.6640190366211903, 0.6351258467583635, 0.7095183538477489, 0.6823370033044622, 0.6918429558357364, 0.67826753016086, 0.7085453989824151, 0.6974078109722514, 0.17353070945523663, 0.18391972190973338, 0.18174102894236188, 0.16007217000532914, 0.15955326745620568, 0.15469044721189806, 0.1964583866827435, 0.15641796996267, 0.2501548037100869, 0.1683072021170694, 0.17323414187116182, 0.17738973133745317, 0.17241843932381762, 0.20723812995008517, 0.16848193242002474, 0.1748123230423374, 0.18577552004429365, 0.26591623366230555, 0.3757477674100773, 0.34572724167927893, 0.350784598477514, 0.29301619195272577, 0.38321309741396214, 0.36286571660529376, 0.3712513169854502, 0.2597868183882067, 0.11423165343436936, 0.4949025378560977, 0.45611660688276734, 0.45702314923308385, 0.4260927086298053, 0.4795583219290477, 0.4460140721589201, 0.4624072355088472, 0.512963790409311, 0.49510984582845985, 0.14516791941987994, 0.04322692943923845, 0.17527734661875238, 0.1617886873886879, 0.23773579184676796, 0.16507212031642116, 0.1285958524881593, 0.21161744999130128, 0.11971965275216967, 0.2758615649926002, 0.3179683560188533, 0.2939775781916303, 0.3415401553286853, 0.30073852936106105, 0.27435404209062586, 0.27694892082402955, 0.29309424708888077, 0.2330338231199226, 0.6435295406592767, 0.6342577962201118, 0.585826164475821, 0.6036554569604089, 0.616678145515389, 0.5698601906306364, 0.6608538743557703, 0.6589604071368691, 0.6167645510269899, 0.1142262078931886, 0.1243229843613346, 0.11422875947872813, 0.11255645098028433, 0.10505238787763738, 0.11415162320350025, 0.11964705943366649, 0.12693434890359145, 0.12447218102705448, 0.18767451106320232, 0.25701186073865634, 0.20241741477986908, 0.327902157897935, 0.40369964907219, 0.27549770487502934, 0.23799935940993366, 0.20703146599759326, 0.3240401889807112, 0.4778690814610005, 0.5144828742072975, 0.4756202772641652, 0.42767330809959836, 0.4764577788533588, 0.5067935428848229, 0.5256912661545036, 0.4524191557828845, 0.4845693488423217, 0.3449976127448394, 0.34278026223351166, 0.3337632353023976, 0.3275021514347398, 0.32530393708524885, 0.35038875155237337, 0.378914485583304, 0.38749266410311356, 0.4120140220279296, 0.2147767390091777, 0.19290134830401084, 0.19793918661511412, 0.19428629248555407, 0.20640637242323856, 0.2146016902483221, 0.21617896849043683, 0.20792746687371233, 0.19090887349104912, 0.5281637164104138, 0.18801140448251852, 0.4671653108652002, 0.19782247319810675, 0.5126174893030664, 0.507103438442522, 0.2136302244449062, 0.5237664379200626, 0.49700146139498846, 0.17500550874377718, 0.17104126281200827, 0.6473064537911355, 0.7147354713660783, 0.18530331170270997, 0.6972509344276419, 0.7074660854650068, 0.18106628965542948, 0.6770070615641366, 0.6035243394264118, 0.19982618693633714, 0.16317826761069099, 0.6787938910677789, 0.18057207864252356, 0.6578713983804156, 0.26545340659903505, 0.7207814093885269, 0.6366461092430158, 0.19182634942563515, 0.19908192631056187, 0.18164986669652583, 0.21939738099221162, 0.18602381831432446, 0.21361104182604163, 0.17776453779918489, 0.1794653705973036, 0.21181779068704942, 0.08583307799380069, 0.07616047048866093, 0.08294121550781308, 0.08653687376177155, 0.09073162808093316, 0.08074888148265114, 0.08124291620928503, 0.07268673178308638, 0.0781446008405523]}, "mutation_prompt": null}
{"id": "2864d3e8-3937-4bbb-a3aa-f2bab82ced13", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant1 = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                mutant2 = np.clip(a + mutation_factor * (best_solution - a) + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant1[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n                trial = np.array([\n                    mutant2[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.2 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with Dual Mutation Strategy and Smart Restart for enhanced exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "metadata": {"aucs": [0.7243650187903578, 0.7359669810873941, 0.7243289366325452, 0.7259468739955611, 0.7276662943334842, 0.7221321210642334, 0.7224112003462273, 0.7292552626805254, 0.7221250676594311, 0.5381585789480612, 0.5668346596518931, 0.5555562357003114, 0.5413970806439273, 0.5558696052839383, 0.5620195794055637, 0.5466486001853053, 0.5505099730890659, 0.5516377487865018, 0.43784198189252943, 0.4527698734991038, 0.4224191780568777, 0.41107705140283857, 0.4730250643430849, 0.4481812493556665, 0.14461721933569383, 0.4812441838435594, 0.41939882049523736, 0.14417153029251417, 0.1417005622015689, 0.12044192876802717, 0.389054892662102, 0.12253243628210853, 0.2584203550642231, 0.12419297229603399, 0.13859494089517588, 0.14656790278220322, 0.9484890325137778, 0.95279425323875, 0.9508618422652186, 0.9145841879878744, 0.9527617175320299, 0.9736351747236802, 0.9524735095800568, 0.947665479752625, 0.9452708171422283, 0.530134970017017, 0.5637767719426423, 0.5268145519941987, 0.4444373123312032, 0.5152106478515842, 0.4615445619622026, 0.4575611179966549, 0.5395477260396583, 0.4102595746275619, 0.6985268800649249, 0.6640190366211903, 0.6351258467583635, 0.7095183538477489, 0.6823370033044622, 0.6918429558357364, 0.67826753016086, 0.7085453989824151, 0.6974078109722514, 0.17353070945523663, 0.18391972190973338, 0.18174102894236188, 0.16007217000532914, 0.15955326745620568, 0.15469044721189806, 0.1964583866827435, 0.15641796996267, 0.2501548037100869, 0.1683072021170694, 0.17323414187116182, 0.17738973133745317, 0.17241843932381762, 0.20723812995008517, 0.16848193242002474, 0.1748123230423374, 0.18577552004429365, 0.26591623366230555, 0.3757477674100773, 0.34572724167927893, 0.350784598477514, 0.29301619195272577, 0.38321309741396214, 0.36286571660529376, 0.3712513169854502, 0.2597868183882067, 0.11423165343436936, 0.4949025378560977, 0.45611660688276734, 0.45702314923308385, 0.4260927086298053, 0.4795583219290477, 0.4460140721589201, 0.4624072355088472, 0.512963790409311, 0.49510984582845985, 0.14516791941987994, 0.04322692943923845, 0.17527734661875238, 0.1617886873886879, 0.23773579184676796, 0.16507212031642116, 0.1285958524881593, 0.21161744999130128, 0.11971965275216967, 0.2758615649926002, 0.3179683560188533, 0.2939775781916303, 0.3415401553286853, 0.30073852936106105, 0.27435404209062586, 0.27694892082402955, 0.29309424708888077, 0.2330338231199226, 0.6435295406592767, 0.6342577962201118, 0.585826164475821, 0.6036554569604089, 0.616678145515389, 0.5698601906306364, 0.6608538743557703, 0.6589604071368691, 0.6167645510269899, 0.1142262078931886, 0.1243229843613346, 0.11422875947872813, 0.11255645098028433, 0.10505238787763738, 0.11415162320350025, 0.11964705943366649, 0.12693434890359145, 0.12447218102705448, 0.18767451106320232, 0.25701186073865634, 0.20241741477986908, 0.327902157897935, 0.40369964907219, 0.27549770487502934, 0.23799935940993366, 0.20703146599759326, 0.3240401889807112, 0.4778690814610005, 0.5144828742072975, 0.4756202772641652, 0.42767330809959836, 0.4764577788533588, 0.5067935428848229, 0.5256912661545036, 0.4524191557828845, 0.4845693488423217, 0.3449976127448394, 0.34278026223351166, 0.3337632353023976, 0.3275021514347398, 0.32530393708524885, 0.35038875155237337, 0.378914485583304, 0.38749266410311356, 0.4120140220279296, 0.2147767390091777, 0.19290134830401084, 0.19793918661511412, 0.19428629248555407, 0.20640637242323856, 0.2146016902483221, 0.21617896849043683, 0.20792746687371233, 0.19090887349104912, 0.5281637164104138, 0.18801140448251852, 0.4671653108652002, 0.19782247319810675, 0.5126174893030664, 0.507103438442522, 0.2136302244449062, 0.5237664379200626, 0.49700146139498846, 0.17500550874377718, 0.17104126281200827, 0.6473064537911355, 0.7147354713660783, 0.18530331170270997, 0.6972509344276419, 0.7074660854650068, 0.18106628965542948, 0.6770070615641366, 0.6035243394264118, 0.19982618693633714, 0.16317826761069099, 0.6787938910677789, 0.18057207864252356, 0.6578713983804156, 0.26545340659903505, 0.7207814093885269, 0.6366461092430158, 0.19182634942563515, 0.19908192631056187, 0.18164986669652583, 0.21939738099221162, 0.18602381831432446, 0.21361104182604163, 0.17776453779918489, 0.1794653705973036, 0.21181779068704942, 0.08583307799380069, 0.07616047048866093, 0.08294121550781308, 0.08653687376177155, 0.09073162808093316, 0.08074888148265114, 0.08124291620928503, 0.07268673178308638, 0.0781446008405523]}, "mutation_prompt": null}
{"id": "5a8c4bb8-5534-40a2-bf1d-5c2f5add94bf", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.2\n        local_search_prob = 0.15\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.05, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.3 * np.random.rand() * (1 - progress_ratio)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant1 = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                mutant2 = np.clip(a + mutation_factor * (best_solution - a) + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant1[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n                trial = np.array([\n                    mutant2[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.8:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations < self.budget and evaluations > self.budget * 0.3:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.2 and np.random.rand() < 0.1:\n                restart_size = int(0.2 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with Dual Mutation Strategy and Smart Restart for enhanced exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "metadata": {"aucs": [0.7243650187903578, 0.7359669810873941, 0.7243289366325452, 0.7259468739955611, 0.7276662943334842, 0.7221321210642334, 0.7224112003462273, 0.7292552626805254, 0.7221250676594311, 0.5381585789480612, 0.5668346596518931, 0.5555562357003114, 0.5413970806439273, 0.5558696052839383, 0.5620195794055637, 0.5466486001853053, 0.5505099730890659, 0.5516377487865018, 0.43784198189252943, 0.4527698734991038, 0.4224191780568777, 0.41107705140283857, 0.4730250643430849, 0.4481812493556665, 0.14461721933569383, 0.4812441838435594, 0.41939882049523736, 0.14417153029251417, 0.1417005622015689, 0.12044192876802717, 0.389054892662102, 0.12253243628210853, 0.2584203550642231, 0.12419297229603399, 0.13859494089517588, 0.14656790278220322, 0.9484890325137778, 0.95279425323875, 0.9508618422652186, 0.9145841879878744, 0.9527617175320299, 0.9736351747236802, 0.9524735095800568, 0.947665479752625, 0.9452708171422283, 0.530134970017017, 0.5637767719426423, 0.5268145519941987, 0.4444373123312032, 0.5152106478515842, 0.4615445619622026, 0.4575611179966549, 0.5395477260396583, 0.4102595746275619, 0.6985268800649249, 0.6640190366211903, 0.6351258467583635, 0.7095183538477489, 0.6823370033044622, 0.6918429558357364, 0.67826753016086, 0.7085453989824151, 0.6974078109722514, 0.17353070945523663, 0.18391972190973338, 0.18174102894236188, 0.16007217000532914, 0.15955326745620568, 0.15469044721189806, 0.1964583866827435, 0.15641796996267, 0.2501548037100869, 0.1683072021170694, 0.17323414187116182, 0.17738973133745317, 0.17241843932381762, 0.20723812995008517, 0.16848193242002474, 0.1748123230423374, 0.18577552004429365, 0.26591623366230555, 0.3757477674100773, 0.34572724167927893, 0.350784598477514, 0.29301619195272577, 0.38321309741396214, 0.36286571660529376, 0.3712513169854502, 0.2597868183882067, 0.11423165343436936, 0.4949025378560977, 0.45611660688276734, 0.45702314923308385, 0.4260927086298053, 0.4795583219290477, 0.4460140721589201, 0.4624072355088472, 0.512963790409311, 0.49510984582845985, 0.14516791941987994, 0.04322692943923845, 0.17527734661875238, 0.1617886873886879, 0.23773579184676796, 0.16507212031642116, 0.1285958524881593, 0.21161744999130128, 0.11971965275216967, 0.2758615649926002, 0.3179683560188533, 0.2939775781916303, 0.3415401553286853, 0.30073852936106105, 0.27435404209062586, 0.27694892082402955, 0.29309424708888077, 0.2330338231199226, 0.6435295406592767, 0.6342577962201118, 0.585826164475821, 0.6036554569604089, 0.616678145515389, 0.5698601906306364, 0.6608538743557703, 0.6589604071368691, 0.6167645510269899, 0.1142262078931886, 0.1243229843613346, 0.11422875947872813, 0.11255645098028433, 0.10505238787763738, 0.11415162320350025, 0.11964705943366649, 0.12693434890359145, 0.12447218102705448, 0.18767451106320232, 0.25701186073865634, 0.20241741477986908, 0.327902157897935, 0.40369964907219, 0.27549770487502934, 0.23799935940993366, 0.20703146599759326, 0.3240401889807112, 0.4778690814610005, 0.5144828742072975, 0.4756202772641652, 0.42767330809959836, 0.4764577788533588, 0.5067935428848229, 0.5256912661545036, 0.4524191557828845, 0.4845693488423217, 0.3449976127448394, 0.34278026223351166, 0.3337632353023976, 0.3275021514347398, 0.32530393708524885, 0.35038875155237337, 0.378914485583304, 0.38749266410311356, 0.4120140220279296, 0.2147767390091777, 0.19290134830401084, 0.19793918661511412, 0.19428629248555407, 0.20640637242323856, 0.2146016902483221, 0.21617896849043683, 0.20792746687371233, 0.19090887349104912, 0.5281637164104138, 0.18801140448251852, 0.4671653108652002, 0.19782247319810675, 0.5126174893030664, 0.507103438442522, 0.2136302244449062, 0.5237664379200626, 0.49700146139498846, 0.17500550874377718, 0.17104126281200827, 0.6473064537911355, 0.7147354713660783, 0.18530331170270997, 0.6972509344276419, 0.7074660854650068, 0.18106628965542948, 0.6770070615641366, 0.6035243394264118, 0.19982618693633714, 0.16317826761069099, 0.6787938910677789, 0.18057207864252356, 0.6578713983804156, 0.26545340659903505, 0.7207814093885269, 0.6366461092430158, 0.19182634942563515, 0.19908192631056187, 0.18164986669652583, 0.21939738099221162, 0.18602381831432446, 0.21361104182604163, 0.17776453779918489, 0.1794653705973036, 0.21181779068704942, 0.08583307799380069, 0.07616047048866093, 0.08294121550781308, 0.08653687376177155, 0.09073162808093316, 0.08074888148265114, 0.08124291620928503, 0.07268673178308638, 0.0781446008405523]}, "mutation_prompt": null}
{"id": "4e5ac94f-ab19-4596-90a6-950cf48e6dbf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        elite_fraction = 0.1\n        local_search_prob = 0.2\n        mutation_factor = 0.5\n        crossover_rate = 0.7\n\n        def local_search(individual):\n            candidate = individual + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            return candidate\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            mutation_factor = 0.5 + 0.2 * (1 - progress_ratio)\n            crossover_rate = 0.9 - 0.4 * progress_ratio\n\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.array([\n                    mutant[j] if np.random.rand() < crossover_rate or j == np.random.randint(self.dim) else population[i][j]\n                    for j in range(self.dim)\n                ])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.75:\n                local_search_indices = np.random.choice(population_size, int(local_search_prob * population_size), replace=False)\n                for idx in local_search_indices:\n                    candidate = local_search(new_population[idx])\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[idx]:\n                        new_population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n            if evaluations >= 0.5 * self.budget and evaluations < self.budget * 0.9:\n                elite_size = max(1, int(elite_fraction * population_size))\n                sorted_indices = np.argsort(fitness)\n                elite_population = population[sorted_indices[:elite_size]]\n                new_population_size = max(4, int(self.initial_population_size * (1 - progress_ratio)))\n                new_population = np.vstack((new_population[sorted_indices[:new_population_size - elite_size]], elite_population))\n                fitness = fitness[sorted_indices[:new_population_size]]\n                population_size = new_population_size\n\n            if evaluations < self.budget * 0.3 and np.random.rand() < 0.1:\n                restart_size = int(0.15 * population_size)\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (restart_size, self.dim))\n                for idx in range(restart_size):\n                    restart_fitness = func(restart_population[idx])\n                    evaluations += 1\n                    if restart_fitness < best_fitness:\n                        best_solution = restart_population[idx]\n                        best_fitness = restart_fitness\n                population[:restart_size] = restart_population\n\n            population = new_population\n\n        return best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Hybrid Mutation and Dynamic Restart to improve convergence speed and robustness across various optimization landscapes.", "configspace": "", "generation": 99, "fitness": 0.26722843058604717, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.19.", "error": "", "parent_id": "644ccbc5-46dd-4f14-a4eb-bcc8cd2f2927", "metadata": {"aucs": [0.5602024676751524, 0.5551320054875246, 0.5573949529618161, 0.5842296710945265, 0.5684768423811262, 0.5685827134191099, 0.5637494617837717, 0.5696765529290224, 0.5566769973157735, 0.3359065864644538, 0.3477257024639371, 0.35571214844091015, 0.3452090794730548, 0.3719815200517833, 0.3515859595416725, 0.35642822544713504, 0.3682088722739, 0.36519021755546466, 0.280478624872901, 0.24604611195456105, 0.2809184821303513, 0.21298133999110536, 0.14548845473635574, 0.22855725659326886, 0.26128983735748057, 0.26666092554880383, 0.24485684138847574, 0.20057465625993165, 0.11028896255128662, 0.10480111071395093, 0.1100869163815068, 0.21948549959210562, 0.10477528673190917, 0.11305860638392018, 0.10852886525711258, 0.1264038000064387, 0.8932936743658133, 0.9440400545559011, 0.8470350630245567, 0.8343245625669458, 0.8536577437191258, 0.8913692506220863, 0.8769637536752651, 0.8940078144401173, 0.8893029721003465, 0.26149980322689925, 0.27015879885557337, 0.2822584082662315, 0.29219903433003935, 0.28643506087465354, 0.2577283936328778, 0.2462955296578485, 0.2817559447406125, 0.2942257981456927, 0.47519389490818, 0.4760535754338432, 0.4379574276525964, 0.4794402663863331, 0.4857747065971264, 0.49225246612315154, 0.46840290888965197, 0.49378906247330434, 0.4990811277095357, 0.12974569765080635, 0.16322650992930443, 0.1642092339741661, 0.15940226268231672, 0.12140771550867391, 0.13525313632852298, 0.1980735014309738, 0.17914826966436415, 0.13392560331265646, 0.14995340715246397, 0.10711163512750588, 0.11951526734412588, 0.13817807311757258, 0.14347049907806153, 0.14754418079866394, 0.13526862447266463, 0.1002129520070264, 0.11965310433803666, 0.051149183449282654, 0.09717051328192905, 0.050816512940785596, 0.06914452564985807, 0.06937930271173065, 0.09012270724910976, 0.06937013710074957, 0.06352111029193397, 0.07304830581242117, 0.20704595692606087, 0.18044989917933285, 0.1752593737531104, 0.1663597132611916, 0.15801805718657302, 0.1698033650884737, 0.19160238768995053, 0.2007922298400936, 0.19939940132271072, 0.02960381631303588, 0.03333806198847944, 0.02999600854621398, 0.04255214080649561, 0.03266756648666347, 0.05147661233615708, 0.039190213149194686, 0.04169993985413256, 0.036741112813384325, 0.12135270122311836, 0.09836413524956189, 0.11991814598828454, 0.13262010079706, 0.1347208441026715, 0.13856539485541797, 0.11333700484630571, 0.11650727769680802, 0.1365483150706872, 0.4228686002261153, 0.4255425302808532, 0.44536714901506524, 0.44137036590743584, 0.43695489624298445, 0.4359932308543334, 0.4229514112848479, 0.4060202311388421, 0.46082910011081235, 0.10179728446138092, 0.10921312235313796, 0.10397000664400369, 0.09259301097147776, 0.22297873897269826, 0.09942197761607441, 0.09334669932304407, 0.10108356426755438, 0.08096913814431905, 0.17320903714474079, 0.2317524591171476, 0.20687265299798063, 0.2585482539805265, 0.1859307777773257, 0.2172632073641284, 0.20257475304123518, 0.1917531551642626, 0.1807850516742756, 0.3058242436764652, 0.31311086247982334, 0.3080744146289993, 0.3166565998553752, 0.3028347397893145, 0.3047362052335295, 0.35341122733146313, 0.3426879565639712, 0.36325928780440486, 0.22281558946295565, 0.20149274723868793, 0.22223726190720905, 0.21204878435895458, 0.21547577903788728, 0.2056763352917086, 0.23909603355206277, 0.23272522135253992, 0.23741191147442398, 0.19495394476818662, 0.19128427281441207, 0.17853952761633352, 0.18804131864217277, 0.21875042330260963, 0.1730319521862579, 0.19781971710469815, 0.18396104281434356, 0.19915633912449193, 0.2954914144389791, 0.18402977251838926, 0.320013096418731, 0.30990890453102093, 0.36450436624614435, 0.19011461498061932, 0.3255019452720167, 0.36746303527549595, 0.1976766790062071, 0.1722073771221745, 0.4576465157755112, 0.4954419656917689, 0.4438315204033796, 0.531847444849475, 0.44792697190692377, 0.4332704545752257, 0.38775004236651767, 0.4370353551071211, 0.4137548308762985, 0.4140598435422681, 0.17429084543144635, 0.5072806578574549, 0.37986522846464554, 0.16596019491873415, 0.19521684317415178, 0.5315814393316438, 0.19904794326951292, 0.2155655249275732, 0.1865725569340222, 0.18091998427083322, 0.1901928107582277, 0.1953309991627563, 0.17648719653549216, 0.17781884584529484, 0.177283978165513, 0.19387325024787028, 0.07164058492325198, 0.06654265606023835, 0.08374095982180463, 0.07043565273580243, 0.08300760209691327, 0.08319481483184754, 0.0703219666776369, 0.07874636453504813, 0.07107140825153346]}, "mutation_prompt": null}
