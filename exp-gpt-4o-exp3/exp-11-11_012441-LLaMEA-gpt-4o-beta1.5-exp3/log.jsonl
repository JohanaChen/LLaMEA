{"id": "df1dec76-410e-479e-a4c4-2c8bac694ba1", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.population_size))\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Learning Strategies for efficient exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.26026521216793036, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.705088999100631, 0.7034376020405991, 0.7159096479918916, 0.7144646609188507, 0.7184568769597384, 0.7164476091218199, 0.7023889151124153, 0.7173552838003723, 0.7308176785444497, 0.5352775961290843, 0.5379350446378333, 0.5223475225721959, 0.5560098023426601, 0.553217131351315, 0.5258714574562195, 0.5530755581095881, 0.5479417194193212, 0.544161728781337, 0.11513324934525826, 0.1279244281189047, 0.1543682544226993, 0.143358110829914, 0.14095953683562512, 0.1252275077259437, 0.14855901241195313, 0.12121609468181904, 0.14578491030221574, 0.1335182805072549, 0.11453659628409973, 0.11095262477751544, 0.1395963308088991, 0.11449694632793994, 0.12213743179339176, 0.11008904682256215, 0.11032143649931314, 0.12551795523576115, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.3089412491128357, 0.31658655627128707, 0.2992985141968607, 0.3108791425541142, 0.3232260794379277, 0.30442829452129505, 0.3080194351176454, 0.31120376716117293, 0.31652569413534504, 0.423437211607286, 0.5471453469689576, 0.2543771857057502, 0.38479446168612574, 0.5748903235906819, 0.4519891956171097, 0.35744756236972974, 0.5245447995434714, 0.5449985398277895, 0.15015549431576014, 0.14886720595066294, 0.15111590521224882, 0.1556326050562995, 0.15034136982908652, 0.14139088503750719, 0.1581661422871633, 0.1396160907916958, 0.14346214733164775, 0.1143445228888178, 0.11543114936421883, 0.16796237630875732, 0.1466795880195776, 0.1435673004858039, 0.13740094952516668, 0.16546952322524888, 0.18153122292000035, 0.16972360013697385, 0.04486158701133025, 0.051485736995566134, 0.035415649571853836, 0.027666936953641752, 0.05379794883773337, 0.01256988105320489, 0.022607234265570098, 0.029886528453687222, 0.03758746251382927, 0.1663785343040336, 0.16633778220217754, 0.1554931750943409, 0.14688030133547014, 0.14058027287560215, 0.1277449705875593, 0.1616628037347413, 0.1830121728529771, 0.1847013518115017, 0.0005403006180809689, 0.003721785718157622, 0.0005140482036620764, 0.0005140688924242243, 0.000584415456792553, 0.013045187019749438, 0.01593275338240785, 0.006791201773345135, 0.047802169441821585, 0.13269521552493369, 0.13028460427583433, 0.12361307760054463, 0.11855285712511177, 0.14011482770532224, 0.13489802504937176, 0.11503026240024883, 0.1347868723484622, 0.12560233031159296, 0.45386794371609485, 0.4756893102360926, 0.4741311463188542, 0.45584607924518183, 0.4365042322676883, 0.4410558478597151, 0.4627188346710779, 0.4407997472867753, 0.4676837419627956, 0.1032004774367522, 0.08984421747602422, 0.09364754485400684, 0.09336500560219196, 0.09020442749244562, 0.09683806441809362, 0.14691993581543938, 0.09084098150282682, 0.08678164943278921, 0.14755826457620047, 0.1330206882087327, 0.13617480268505155, 0.1468146215421724, 0.17336957145175458, 0.13737238139153995, 0.138342691238435, 0.13492560039796697, 0.1351708929676817, 0.2838040445790484, 0.2933283425178209, 0.3006030356983753, 0.28135750095448697, 0.2757493863757453, 0.3047264601871902, 0.32931592035720547, 0.3414627023407125, 0.3216979335939143, 0.19698018111939575, 0.19484554100514728, 0.20149222186057691, 0.1997610236036388, 0.18796819266190845, 0.1978141514026034, 0.20566362323118648, 0.22599649091421314, 0.2129250597114164, 0.17633772631099165, 0.172178250141526, 0.19881308026595457, 0.19522251439788052, 0.17242531349746915, 0.19057295134796426, 0.1761930886565657, 0.19298620032522829, 0.17885167123423018, 0.1923159036117844, 0.19865400922684773, 0.19996546758569067, 0.1899971733075465, 0.18520558486881145, 0.20604627209489512, 0.19800910320105836, 0.19356537327422585, 0.18846949306872374, 0.4516359024651905, 0.1725196858163981, 0.1653463079732812, 0.5613215394664042, 0.43841211598529795, 0.21345264374665285, 0.23331800267617742, 0.15827318473133256, 0.24476943685801855, 0.4314407704771447, 0.19879835896275777, 0.26348489937388353, 0.26728710611073125, 0.18494762510048135, 0.20853347810454415, 0.20559267761408107, 0.3582257503596644, 0.20606293770291473, 0.17400802692719752, 0.20862162108223115, 0.17532017903104347, 0.1823193433249698, 0.19502491702486047, 0.18392805160482895, 0.18219220334737285, 0.18796302035414214, 0.18375612637896432, 0.07936426515632777, 0.08163056924899115, 0.07609966347299779, 0.06692002945940645, 0.07147012976210576, 0.0807564153357454, 0.06818371104018639, 0.08130988411723195, 0.07264472147084067]}, "mutation_prompt": null}
{"id": "ce76a055-6949-4178-a238-f01fbfe78fed", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.population_size))\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Learning Strategies for efficient exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df1dec76-410e-479e-a4c4-2c8bac694ba1", "metadata": {"aucs": [0.705088999100631, 0.7034376020405991, 0.7159096479918916, 0.7144646609188507, 0.7184568769597384, 0.7164476091218199, 0.7023889151124153, 0.7173552838003723, 0.7308176785444497, 0.5352775961290843, 0.5379350446378333, 0.5223475225721959, 0.5560098023426601, 0.553217131351315, 0.5258714574562195, 0.5530755581095881, 0.5479417194193212, 0.544161728781337, 0.11513324934525826, 0.1279244281189047, 0.1543682544226993, 0.143358110829914, 0.14095953683562512, 0.1252275077259437, 0.14855901241195313, 0.12121609468181904, 0.14578491030221574, 0.1335182805072549, 0.11453659628409973, 0.11095262477751544, 0.1395963308088991, 0.11449694632793994, 0.12213743179339176, 0.11008904682256215, 0.11032143649931314, 0.12551795523576115, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.3089412491128357, 0.31658655627128707, 0.2992985141968607, 0.3108791425541142, 0.3232260794379277, 0.30442829452129505, 0.3080194351176454, 0.31120376716117293, 0.31652569413534504, 0.423437211607286, 0.5471453469689576, 0.2543771857057502, 0.38479446168612574, 0.5748903235906819, 0.4519891956171097, 0.35744756236972974, 0.5245447995434714, 0.5449985398277895, 0.15015549431576014, 0.14886720595066294, 0.15111590521224882, 0.1556326050562995, 0.15034136982908652, 0.14139088503750719, 0.1581661422871633, 0.1396160907916958, 0.14346214733164775, 0.1143445228888178, 0.11543114936421883, 0.16796237630875732, 0.1466795880195776, 0.1435673004858039, 0.13740094952516668, 0.16546952322524888, 0.18153122292000035, 0.16972360013697385, 0.04486158701133025, 0.051485736995566134, 0.035415649571853836, 0.027666936953641752, 0.05379794883773337, 0.01256988105320489, 0.022607234265570098, 0.029886528453687222, 0.03758746251382927, 0.1663785343040336, 0.16633778220217754, 0.1554931750943409, 0.14688030133547014, 0.14058027287560215, 0.1277449705875593, 0.1616628037347413, 0.1830121728529771, 0.1847013518115017, 0.0005403006180809689, 0.003721785718157622, 0.0005140482036620764, 0.0005140688924242243, 0.000584415456792553, 0.013045187019749438, 0.01593275338240785, 0.006791201773345135, 0.047802169441821585, 0.13269521552493369, 0.13028460427583433, 0.12361307760054463, 0.11855285712511177, 0.14011482770532224, 0.13489802504937176, 0.11503026240024883, 0.1347868723484622, 0.12560233031159296, 0.45386794371609485, 0.4756893102360926, 0.4741311463188542, 0.45584607924518183, 0.4365042322676883, 0.4410558478597151, 0.4627188346710779, 0.4407997472867753, 0.4676837419627956, 0.1032004774367522, 0.08984421747602422, 0.09364754485400684, 0.09336500560219196, 0.09020442749244562, 0.09683806441809362, 0.14691993581543938, 0.09084098150282682, 0.08678164943278921, 0.14755826457620047, 0.1330206882087327, 0.13617480268505155, 0.1468146215421724, 0.17336957145175458, 0.13737238139153995, 0.138342691238435, 0.13492560039796697, 0.1351708929676817, 0.2838040445790484, 0.2933283425178209, 0.3006030356983753, 0.28135750095448697, 0.2757493863757453, 0.3047264601871902, 0.32931592035720547, 0.3414627023407125, 0.3216979335939143, 0.19698018111939575, 0.19484554100514728, 0.20149222186057691, 0.1997610236036388, 0.18796819266190845, 0.1978141514026034, 0.20566362323118648, 0.22599649091421314, 0.2129250597114164, 0.17633772631099165, 0.172178250141526, 0.19881308026595457, 0.19522251439788052, 0.17242531349746915, 0.19057295134796426, 0.1761930886565657, 0.19298620032522829, 0.17885167123423018, 0.1923159036117844, 0.19865400922684773, 0.19996546758569067, 0.1899971733075465, 0.18520558486881145, 0.20604627209489512, 0.19800910320105836, 0.19356537327422585, 0.18846949306872374, 0.4516359024651905, 0.1725196858163981, 0.1653463079732812, 0.5613215394664042, 0.43841211598529795, 0.21345264374665285, 0.23331800267617742, 0.15827318473133256, 0.24476943685801855, 0.4314407704771447, 0.19879835896275777, 0.26348489937388353, 0.26728710611073125, 0.18494762510048135, 0.20853347810454415, 0.20559267761408107, 0.3582257503596644, 0.20606293770291473, 0.17400802692719752, 0.20862162108223115, 0.17532017903104347, 0.1823193433249698, 0.19502491702486047, 0.18392805160482895, 0.18219220334737285, 0.18796302035414214, 0.18375612637896432, 0.07936426515632777, 0.08163056924899115, 0.07609966347299779, 0.06692002945940645, 0.07147012976210576, 0.0807564153357454, 0.06818371104018639, 0.08130988411723195, 0.07264472147084067]}, "mutation_prompt": null}
{"id": "e161c5f1-1257-4214-bbe7-39683b5b8657", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def opposition_based_learning(self):\n        for i in range(self.population_size):\n            opposite_solution = self.lower_bound + self.upper_bound - self.population[i]\n            opposite_solution = np.clip(opposite_solution, self.lower_bound, self.upper_bound)\n            opposite_value = func(opposite_solution)\n            self.function_evals += 1\n            if opposite_value < self.population_values[i]:\n                self.population[i] = opposite_solution\n                self.population_values[i] = opposite_value\n                if opposite_value < self.best_value:\n                    self.best_value = opposite_value\n                    self.best_solution = np.copy(opposite_solution)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.population_size))\n        self.f = max(self.f, 0.4)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        self.opposition_based_learning()\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Dynamic Parameter Tuning and Opposition-Based Learning for improved convergence in black box optimization.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "df1dec76-410e-479e-a4c4-2c8bac694ba1", "metadata": {}, "mutation_prompt": null}
{"id": "de1263a9-1f54-49d9-9fea-8389909777ed", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution using Adaptive Population Resizing and Dynamic Parameters for improved exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 3, "fitness": 0.26843606000395803, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "df1dec76-410e-479e-a4c4-2c8bac694ba1", "metadata": {"aucs": [0.7125564039503486, 0.6972748730208758, 0.7213198500730311, 0.6764500591725927, 0.7253567846051645, 0.7225288424672884, 0.7111661181618643, 0.7162853212821552, 0.734531147486063, 0.4344230573109513, 0.4431659028891526, 0.4617623104463283, 0.5079730232327127, 0.5248985748250361, 0.47214455340031836, 0.5521071042768602, 0.4738973285393252, 0.4929160755482528, 0.14713441580669628, 0.1673181582459471, 0.12721445401948916, 0.12218998647402901, 0.170847193207451, 0.17772436848625606, 0.1378515209563762, 0.14450697411157765, 0.1416208704305012, 0.1293043328807727, 0.11003519712315502, 0.11799141315739003, 0.15936904291303344, 0.11831182760095038, 0.1252821383839413, 0.11059485774674993, 0.12492229430839508, 0.12210563056653612, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.24743270829927955, 0.28270654382376703, 0.2760358929515925, 0.2881786740554112, 0.25907067121006466, 0.29508087977346786, 0.2924639506254648, 0.27986279874347575, 0.2917224099039013, 0.28979624812743376, 0.30810132459030504, 0.270899537696103, 0.3115361284995555, 0.6067783750905026, 0.584511375902278, 0.5765891417967881, 0.5616678727221105, 0.3385654484466385, 0.15535929980943364, 0.14389183580822207, 0.14160450506005096, 0.15313349803218756, 0.14256475556474069, 0.13771880203923137, 0.1582767267862868, 0.1358430456962496, 0.13920828232325, 0.11434454754374168, 0.11543114932959309, 0.17704285697937305, 0.1446111841421549, 0.13935360062419844, 0.13115199186276372, 0.1605450213837174, 0.16630113267619073, 0.16019051521516336, 0.05475548317358969, 0.08010015869058718, 0.05746835553292817, 0.033093551863425774, 0.054234464087817846, 0.05451863599313134, 0.049321466546139336, 0.0517132543161144, 0.05931240875304533, 0.1652460519242448, 0.14935875898826834, 0.14453622713281877, 0.15389043967400573, 0.1547578383287791, 0.12890167536073316, 0.18781408784712816, 0.19455467614708755, 0.1998765612235689, 0.00138076239409346, 0.021865668080445877, 0.03281253398840911, 0.09299243751583075, 0.09792548826771996, 0.08781307099529334, 0.09649305887614867, 0.044175337631046196, 0.10957384473568565, 0.17986811345056308, 0.15218201284818078, 0.161202291757937, 0.15534117394194347, 0.16664614155294077, 0.14728718702292098, 0.14871174169415557, 0.1439112841948208, 0.17273651423450298, 0.46863903849165534, 0.5110313709107133, 0.4911351832647297, 0.4932155608938027, 0.4712776028441894, 0.43645347722114325, 0.49310775065690204, 0.5019108651310085, 0.5273124470765488, 0.10669657911626051, 0.09558673291570507, 0.11052719426781965, 0.10821784155993175, 0.1005569153300232, 0.1113484573921345, 0.1498844512416463, 0.09323733300004611, 0.10435158068505024, 0.14947196643230432, 0.1520937996200038, 0.1424848578914274, 0.1587105959129178, 0.17044405291959452, 0.13795837200833672, 0.13848386545694524, 0.16090541493622335, 0.16949140848805544, 0.29635485885228063, 0.28745972346391147, 0.3440420629716273, 0.280792012805672, 0.3417624684766898, 0.3003367884313598, 0.33540842790519565, 0.3481758971862371, 0.3559542959882982, 0.20215821300198966, 0.2124703544781561, 0.21365601704114867, 0.19677393056783088, 0.2578207358695985, 0.21639466960607334, 0.2609561489360773, 0.23616916342893624, 0.22424272095821973, 0.19570738590486203, 0.18278220012476398, 0.1976022633840272, 0.2021037417906112, 0.18885478461763738, 0.18716032275425554, 0.1934078746499719, 0.19621035902142225, 0.18338615072748854, 0.19263559388147045, 0.3078854078726071, 0.1925761301802731, 0.19319681539426414, 0.23646932459583148, 0.3061576507613901, 0.20440747260591519, 0.21027660504697343, 0.2314189848795264, 0.36680143315359315, 0.18060487914057288, 0.16494273064473852, 0.5155000680414569, 0.4311710052814932, 0.177442021862125, 0.3196870868455707, 0.40027904362804567, 0.38071994070241455, 0.3880539909830303, 0.1988051121005301, 0.26173439172652124, 0.29615635149712793, 0.1849945681125802, 0.2298521647801034, 0.20559267784131063, 0.48963247949417477, 0.2060629379094424, 0.17711879692475063, 0.20862162108223115, 0.1734394015157621, 0.18942505519381592, 0.19521273880288725, 0.1816907475016617, 0.18271901496051535, 0.18537535133543914, 0.1825856423108082, 0.08030493559856933, 0.08902372153316829, 0.07630177797042292, 0.07035505517089491, 0.07813703992362553, 0.07766881543566928, 0.07994807974220108, 0.08438016451091102, 0.08794586827464967]}, "mutation_prompt": null}
{"id": "343bdc23-8054-4516-a5ad-7e96ba5268bd", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def local_search(self, solution, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        perturbed_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n        perturbed_value = func(perturbed_solution)\n        self.function_evals += 1\n        if perturbed_value < self.best_value:\n            self.best_value = perturbed_value\n            self.best_solution = perturbed_solution\n        return perturbed_solution, perturbed_value\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n                if np.random.rand() < 0.1:  # Local search with a small probability\n                    trial, _ = self.local_search(trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Resizing, Dynamic Parameters, and Randomized Local Search for intensified exploitation and exploration balance in black box optimization.", "configspace": "", "generation": 4, "fitness": 0.25634702030425605, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.6489893690613218, 0.625368294991008, 0.596026659232961, 0.7059140611193011, 0.6789721879580839, 0.6666390175965187, 0.7041125558803745, 0.6801382913626375, 0.6403832560381046, 0.472493852805865, 0.3913003564892058, 0.41751677834472867, 0.47974514952638836, 0.42514729032151943, 0.430784094256192, 0.4565297813667074, 0.4065361077725529, 0.5056328744446972, 0.14939225473898277, 0.13520194838579536, 0.20672575087512068, 0.16590765781030747, 0.12272395502905398, 0.12417311520356411, 0.13527909142369632, 0.13092861415510215, 0.12795289876157656, 0.10451754245175415, 0.10632358652155549, 0.11375897572887372, 0.13228584825494782, 0.1396017450953101, 0.11279806362687539, 0.115365073545037, 0.12306466279816619, 0.10647060390692953, 0.9194117354165735, 0.937423933495796, 0.9681701113144056, 0.9642270339362649, 0.9629120492277209, 0.947558481214829, 0.9438336049909207, 0.9574708784204706, 0.8793390564629051, 0.2597381989597477, 0.2595905040840759, 0.26564986318437456, 0.2655070569200285, 0.2728794717555266, 0.27619802320508946, 0.26585238995665295, 0.23730304929188129, 0.28083765517752957, 0.2854265834939521, 0.27956366101586916, 0.5697907701847198, 0.5954307949055764, 0.45066329464524457, 0.6036758735959287, 0.3163705223928682, 0.607074419858427, 0.317929550894648, 0.13351893583740804, 0.15904741543475542, 0.143306727601332, 0.11515468998099443, 0.13860527968036185, 0.15799485224610854, 0.13116978162028714, 0.16069564176306428, 0.16114574638173085, 0.12144297025616468, 0.07350176705598643, 0.036513230806318075, 0.13859468018788845, 0.11533673829216673, 0.152741887482699, 0.14034739207669156, 0.1310399183961667, 0.13156874194802837, 0.0891394305320109, 0.05847969519520613, 0.06834875945332275, 0.042681653710135325, 0.032736389476037075, 0.01917915122905056, 0.029697060544276233, 0.07500048532566239, 0.08371544599467162, 0.149726701454738, 0.14810479118375275, 0.14957109795628387, 0.16821176884437194, 0.13147458367829645, 0.15190351192356943, 0.19211298961700096, 0.22934655103920087, 0.16964303601738207, 0.04903051527814983, 0.015504770330108997, 0.026675221641064506, 0.023964945821694728, 0.014133430795298718, 0.032094184977325635, 0.025048132591551475, 0.1107756902009156, 0.08587878938180349, 0.14292126028072039, 0.143563663432961, 0.13909642089628338, 0.19289685594395356, 0.18248915472457006, 0.1503219239712149, 0.1643940271333506, 0.14603705747338103, 0.14460284197271556, 0.4542138879511325, 0.45121347587329175, 0.4843215265226375, 0.476080831411977, 0.47973726379064463, 0.4773023721707569, 0.46001617815633566, 0.5007219340058671, 0.4635090476990833, 0.09020388897309639, 0.09100977807031418, 0.10309526842139638, 0.11163033809288392, 0.09522413913361483, 0.10506233388243746, 0.10063685429171565, 0.11828326179651816, 0.11395596763513527, 0.14254504367055687, 0.14580136673308952, 0.15456803434510746, 0.1606102300144494, 0.205435942372588, 0.13738252158966657, 0.13477497804036742, 0.14414807979436994, 0.15655836872302586, 0.288439813576848, 0.27982670388851516, 0.3118736916597583, 0.30702729995838396, 0.27992097342365063, 0.3067824838352531, 0.29539423351015437, 0.36876198385528647, 0.33218922783591065, 0.1852720839701122, 0.2348046516256942, 0.227679387444355, 0.22023586300608045, 0.23703043080381225, 0.19851339310210336, 0.2422457271224011, 0.2507042286313452, 0.2053916705554797, 0.1811237697596031, 0.22105618144238348, 0.1945841441637518, 0.1827233903503549, 0.18417098563829237, 0.18416826386120466, 0.18609074491693312, 0.1935727186464774, 0.1896283007221613, 0.20475182263507163, 0.19707370654135326, 0.22109563069935723, 0.2860246314172942, 0.26558752215911197, 0.20356186327900128, 0.2572174415813434, 0.23607915587136763, 0.25357909893724573, 0.1678347005251991, 0.4204693002976587, 0.273894406429116, 0.17492132838999974, 0.1750007466938105, 0.4560174286814267, 0.22673324707649156, 0.1489725012748606, 0.19169783737365076, 0.38990128309504646, 0.1975190551569439, 0.1719828458033842, 0.19732885389355803, 0.2800334225212763, 0.1800363119986127, 0.4825628734125945, 0.2043191845836302, 0.20891577734200106, 0.1928082034521521, 0.1811112593321199, 0.18789160716561015, 0.1897084454420458, 0.18186056295711173, 0.17615691684274448, 0.17800403293892397, 0.1863035743147229, 0.1881850883214886, 0.08054195875415315, 0.0740045937741397, 0.07725510294034443, 0.07110490452286866, 0.0771847123018482, 0.07867518663383488, 0.08050977710530438, 0.0798341575772551, 0.07469074125084552]}, "mutation_prompt": null}
{"id": "22a8d259-725d-4455-8a58-2c2046d13fb1", "solution": "import numpy as np\n\nclass AdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory_factor = 0.5\n        self.memory = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n                    self.memory.append(self.best_solution)\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n                self.memory.append(self.best_solution)\n\n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n\n    def levy_flight(self, step_factor=0.01):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1 / 3)\n        return step_factor * step\n\n    def enhance_exploration(self):\n        if len(self.memory) > 0 and np.random.rand() < self.memory_factor:\n            mem_idx = np.random.randint(0, len(self.memory))\n            direction = self.levy_flight()\n            new_sol = self.memory[mem_idx] + direction\n            new_sol = np.clip(new_sol, self.lower_bound, self.upper_bound)\n            return new_sol\n        else:\n            return None\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                enhanced_solution = self.enhance_exploration()\n                if enhanced_solution is not None:\n                    trial = self.crossover(self.population[i], enhanced_solution)\n                else:\n                    mutant = self.mutate(i)\n                    trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "AdaptiveMemoryDE", "description": "Adaptive Memory-Based DE using Levy Flight for Enhanced Exploration-Exploitation across Diverse Landscapes.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AdaptiveMemoryDE' object has no attribute 'resize_population'\").", "error": "AttributeError(\"'AdaptiveMemoryDE' object has no attribute 'resize_population'\")", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {}, "mutation_prompt": null}
{"id": "da67c9ae-82ed-4705-ac9d-b3b2a2183017", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        quantum_superposition = np.random.uniform(0, 1, self.dim) * (self.population[a] - self.population[b])\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c]) + quantum_superposition\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-Inspired Differential Evolution leveraging quantum superposition states for enhanced diversity and robustness in black box optimization.", "configspace": "", "generation": 6, "fitness": 0.21958155180034208, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.588266185447446, 0.5943467564975999, 0.6207725050121735, 0.6547353929619996, 0.6470441160924402, 0.6551594275135137, 0.6501517365119174, 0.6196310072245172, 0.6293410310953957, 0.3575053173848797, 0.4635607637617538, 0.49952986145841627, 0.4612400531857035, 0.46856013564187704, 0.5113193357274158, 0.42537723195175225, 0.5212788613278088, 0.39474810663976845, 0.13310737543681228, 0.13970166681137342, 0.13780382683301162, 0.11374548731114642, 0.3714664890732122, 0.10728747719443055, 0.11639494944458872, 0.13927444468789762, 0.11540546063987245, 0.11462644154496682, 0.1106356320210714, 0.10336654489452035, 0.1339449663319099, 0.1120686266266071, 0.12330607055091991, 0.1316924574641738, 0.12947241929217201, 0.10379008992877992, 0.9593411716836955, 0.9723581990466006, 0.9676590893427607, 0.9788980364494725, 0.9587817902264706, 0.9740309954273747, 0.9838468436786271, 0.9676641281200675, 0.9899600499487377, 0.2724983043474718, 0.20377259275844672, 0.2408693846850689, 0.29447412319479427, 0.27755942351515983, 0.3359837343929243, 0.25247306362237576, 0.25957517830272714, 0.23374918698228142, 0.20996943899885723, 0.27015783120755377, 0.23692732958271379, 0.5322932180711494, 0.213749142377903, 0.2622828783819693, 0.2029378663283372, 0.18611759388642046, 0.2770571282697041, 0.15498627627515105, 0.1122865067130715, 0.1339009776392095, 0.11981777971440966, 0.0961631399374443, 0.1297739126783184, 0.12009179436882556, 0.11158802975545568, 0.11748387580917063, 0.10791955303178435, 0.051362748155972415, 0.048840817314486196, 0.12510649489700465, 0.13041717329933, 0.0889758233497927, 0.09070465759634028, 0.06253801387229285, 0.09927968660744502, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021434519201557478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051731581373061775, 0.03520526542037261, 0.013896370336198394, 0.039980790993839, 0.02499358399056073, 0.048888911846310834, 0.03993267513197951, 0.01630397888334356, 0.007096513274713834, 0.019688435595397458, 0.015777087678443102, 9.999999999998899e-05, 0.002495186893990309, 0.04844552965617188, 0.03800015128865486, 0.03802636923338598, 0.0017268565326987728, 0.012819581915162082, 0.07151337332821495, 0.07786119842359107, 0.0685471005430538, 0.09288136631337507, 0.07853418459832229, 0.07845814411380447, 0.04192972153301744, 0.11230275326764949, 0.050705951200496036, 0.35814148853267447, 0.4148626543872057, 0.40385916496472685, 0.3938528829009893, 0.3942220863871787, 0.3869334430221485, 0.406276433891946, 0.36254306231980726, 0.3932814986853338, 0.09240282214549211, 0.09319919759860751, 0.09513939199356614, 0.08188602460324312, 0.09139270209367623, 0.09392861674783182, 0.08060279294946848, 0.09034094707420648, 0.10393247379895287, 0.16150752064061713, 0.1489437790923197, 0.14748543619875165, 0.14294208103270745, 0.1419319789546769, 0.14057709683803954, 0.18187789217985062, 0.13786842805112642, 0.16137357051392753, 0.2770143131853129, 0.2618353683015332, 0.27707908574852314, 0.24044452774188063, 0.21693070040027118, 0.21251427122450217, 0.3441398289424096, 0.3310269157193587, 0.26051240743381143, 0.183126533006151, 0.18316085445943375, 0.22866660545414652, 0.15538901674232186, 0.14086464100565632, 0.15843780098739113, 0.187252161169432, 0.1978865092471236, 0.19189797995289837, 0.17257947335667556, 0.1744155404293808, 0.16880709668887173, 0.18379656067796224, 0.18707957280474052, 0.1636220423346889, 0.17233518940640113, 0.17708071062836261, 0.1619228156489011, 0.18747107610413027, 0.16503982333559142, 0.19727064989276255, 0.22146622115089099, 0.26050244821487367, 0.17278682697071368, 0.31037554633340425, 0.1923564759455728, 0.20574064142944948, 0.16071030711193957, 0.14937717571668485, 0.2795013193182784, 0.17994167018295792, 0.17248588233732864, 0.17592273997142405, 0.1755242241044731, 0.17006743497983534, 0.1760996394909069, 0.15538340751483626, 0.16267520019354964, 0.1650872329482731, 0.22928215568116095, 0.11638477664346314, 0.15839947838557422, 0.20310957150819275, 0.11367804371071888, 0.20748154398463892, 0.1857201506953685, 0.1826040228267023, 0.2009869037184212, 0.19388641932356854, 0.16791863818056008, 0.19300222354562935, 0.1702526154185232, 0.18928753640134688, 0.17038745458709892, 0.06915148719630726, 0.06880653099655032, 0.08143500208519039, 0.07604358218859308, 0.07478343379785923, 0.06865514893040658, 0.07234014265771638, 0.07674752841090471, 0.0676206205274642]}, "mutation_prompt": null}
{"id": "0242634c-9b45-48d1-9737-f59c32770a79", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution using Adaptive Population Resizing and Dynamic Parameters for improved exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.7125564039503486, 0.6972748730208758, 0.7213198500730311, 0.6764500591725927, 0.7253567846051645, 0.7225288424672884, 0.7111661181618643, 0.7162853212821552, 0.734531147486063, 0.4344230573109513, 0.4431659028891526, 0.4617623104463283, 0.5079730232327127, 0.5248985748250361, 0.47214455340031836, 0.5521071042768602, 0.4738973285393252, 0.4929160755482528, 0.14713441580669628, 0.1673181582459471, 0.12721445401948916, 0.12218998647402901, 0.170847193207451, 0.17772436848625606, 0.1378515209563762, 0.14450697411157765, 0.1416208704305012, 0.1293043328807727, 0.11003519712315502, 0.11799141315739003, 0.15936904291303344, 0.11831182760095038, 0.1252821383839413, 0.11059485774674993, 0.12492229430839508, 0.12210563056653612, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.24743270829927955, 0.28270654382376703, 0.2760358929515925, 0.2881786740554112, 0.25907067121006466, 0.29508087977346786, 0.2924639506254648, 0.27986279874347575, 0.2917224099039013, 0.28979624812743376, 0.30810132459030504, 0.270899537696103, 0.3115361284995555, 0.6067783750905026, 0.584511375902278, 0.5765891417967881, 0.5616678727221105, 0.3385654484466385, 0.15535929980943364, 0.14389183580822207, 0.14160450506005096, 0.15313349803218756, 0.14256475556474069, 0.13771880203923137, 0.1582767267862868, 0.1358430456962496, 0.13920828232325, 0.11434454754374168, 0.11543114932959309, 0.17704285697937305, 0.1446111841421549, 0.13935360062419844, 0.13115199186276372, 0.1605450213837174, 0.16630113267619073, 0.16019051521516336, 0.05475548317358969, 0.08010015869058718, 0.05746835553292817, 0.033093551863425774, 0.054234464087817846, 0.05451863599313134, 0.049321466546139336, 0.0517132543161144, 0.05931240875304533, 0.1652460519242448, 0.14935875898826834, 0.14453622713281877, 0.15389043967400573, 0.1547578383287791, 0.12890167536073316, 0.18781408784712816, 0.19455467614708755, 0.1998765612235689, 0.00138076239409346, 0.021865668080445877, 0.03281253398840911, 0.09299243751583075, 0.09792548826771996, 0.08781307099529334, 0.09649305887614867, 0.044175337631046196, 0.10957384473568565, 0.17986811345056308, 0.15218201284818078, 0.161202291757937, 0.15534117394194347, 0.16664614155294077, 0.14728718702292098, 0.14871174169415557, 0.1439112841948208, 0.17273651423450298, 0.46863903849165534, 0.5110313709107133, 0.4911351832647297, 0.4932155608938027, 0.4712776028441894, 0.43645347722114325, 0.49310775065690204, 0.5019108651310085, 0.5273124470765488, 0.10669657911626051, 0.09558673291570507, 0.11052719426781965, 0.10821784155993175, 0.1005569153300232, 0.1113484573921345, 0.1498844512416463, 0.09323733300004611, 0.10435158068505024, 0.14947196643230432, 0.1520937996200038, 0.1424848578914274, 0.1587105959129178, 0.17044405291959452, 0.13795837200833672, 0.13848386545694524, 0.16090541493622335, 0.16949140848805544, 0.29635485885228063, 0.28745972346391147, 0.3440420629716273, 0.280792012805672, 0.3417624684766898, 0.3003367884313598, 0.33540842790519565, 0.3481758971862371, 0.3559542959882982, 0.20215821300198966, 0.2124703544781561, 0.21365601704114867, 0.19677393056783088, 0.2578207358695985, 0.21639466960607334, 0.2609561489360773, 0.23616916342893624, 0.22424272095821973, 0.19570738590486203, 0.18278220012476398, 0.1976022633840272, 0.2021037417906112, 0.18885478461763738, 0.18716032275425554, 0.1934078746499719, 0.19621035902142225, 0.18338615072748854, 0.19263559388147045, 0.3078854078726071, 0.1925761301802731, 0.19319681539426414, 0.23646932459583148, 0.3061576507613901, 0.20440747260591519, 0.21027660504697343, 0.2314189848795264, 0.36680143315359315, 0.18060487914057288, 0.16494273064473852, 0.5155000680414569, 0.4311710052814932, 0.177442021862125, 0.3196870868455707, 0.40027904362804567, 0.38071994070241455, 0.3880539909830303, 0.1988051121005301, 0.26173439172652124, 0.29615635149712793, 0.1849945681125802, 0.2298521647801034, 0.20559267784131063, 0.48963247949417477, 0.2060629379094424, 0.17711879692475063, 0.20862162108223115, 0.1734394015157621, 0.18942505519381592, 0.19521273880288725, 0.1816907475016617, 0.18271901496051535, 0.18537535133543914, 0.1825856423108082, 0.08030493559856933, 0.08902372153316829, 0.07630177797042292, 0.07035505517089491, 0.07813703992362553, 0.07766881543566928, 0.07994807974220108, 0.08438016451091102, 0.08794586827464967]}, "mutation_prompt": null}
{"id": "36929d87-c711-4686-a78e-6528e86bc90d", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9\n        self.f = 0.8\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.quantum_prob = 0.2\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def quantum_superposition(self):\n        quantum_mutants = self.population + np.random.uniform(-1, 1, (self.population_size, self.dim)) * self.quantum_prob\n        quantum_mutants = np.clip(quantum_mutants, self.lower_bound, self.upper_bound)\n        return quantum_mutants\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n        self.quantum_prob *= 0.95  # Gradually reduce quantum effect to emphasize exploitation\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            quantum_mutants = self.quantum_superposition()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                if np.random.rand() < self.quantum_prob:\n                    trial = self.crossover(self.population[i], quantum_mutants[i])\n                else:\n                    trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "QuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution utilizing Quantum Superposition Principles for enhanced global search capability and convergence speed in black box optimization.", "configspace": "", "generation": 8, "fitness": 0.2642938521719748, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.7178352439902388, 0.7151591184396038, 0.7090119494621221, 0.683872277094105, 0.7251178058810042, 0.7292322582560159, 0.7059384547769296, 0.7162579104799693, 0.7161794716786304, 0.37145923809149783, 0.503266920971742, 0.4261242144670716, 0.4100403378038734, 0.44982054936139093, 0.48518873867837264, 0.5038433268498865, 0.550288300252231, 0.43676748298322, 0.15940761546012727, 0.1348830785853402, 0.1263761321393062, 0.19118683345037402, 0.12183664566543173, 0.14003994712592394, 0.1717210535456949, 0.16324098153441768, 0.1317646518193205, 0.13478131292787388, 0.11651083825462627, 0.20522659365367812, 0.1319787385091673, 0.11947496118852996, 0.11285578899243343, 0.11797604733377443, 0.11577130054716367, 0.12023944583556945, 0.8816523690506535, 0.9503123194865262, 0.9414708966665607, 0.9610639548683075, 0.9630358241496544, 0.8849277943558252, 0.9514045983265025, 0.9415195106756327, 0.9384657513778755, 0.2737855888796735, 0.2986336004717218, 0.2572085845962008, 0.2627708859164495, 0.26190906253116664, 0.28394263018675026, 0.2740959970756891, 0.3328906993661649, 0.27055925321079544, 0.5858997016308306, 0.589800859850815, 0.5830109350639139, 0.6014675402718012, 0.5751814871585439, 0.580252277554997, 0.3162954262865828, 0.3281400142757307, 0.6141361700323464, 0.16080914323595275, 0.1402836819161135, 0.1551891305038141, 0.16437330824653706, 0.15017730732221624, 0.14974108163907363, 0.14617955074412914, 0.16584553966958426, 0.13829174070295214, 0.11049749140783738, 0.10912295131466343, 0.13508068848929944, 0.18181209351746686, 0.13136147219910732, 0.1291805772035184, 0.16137903115409624, 0.14754331414281807, 0.1213176197522815, 0.06899107606551713, 0.04936733070023258, 0.032114246573425986, 0.023688855251389085, 0.08730598864897143, 0.015971673222547556, 0.037267084625579594, 0.047323594483969056, 0.04262667248535912, 0.1406652366747878, 0.14276433342915085, 0.14855221464862045, 0.14923966410571188, 0.17722759703069624, 0.17495358118623683, 0.18257752387783732, 0.20341055887095805, 0.21180441783022097, 0.015153296198299304, 0.04992860281891098, 0.025656064785961274, 0.03598193981363673, 0.059760346999331304, 0.09597380673816114, 0.07803618564685455, 0.014756761977332111, 0.07614122388997635, 0.14939022280571812, 0.15426494276901648, 0.14317934313505998, 0.16230638120465046, 0.1426842437612439, 0.1814529347493501, 0.11996330856105453, 0.1483728959839229, 0.15933604563119952, 0.44991808958254664, 0.4832735850892249, 0.49065056216394565, 0.4794426629680978, 0.4764992211718271, 0.4754241840448159, 0.47431675241526683, 0.46935648751345294, 0.4862678323799019, 0.09549916817307291, 0.13037774274218317, 0.08753247546007137, 0.10612656534037945, 0.09950152492654829, 0.08981572082845268, 0.10897771636544529, 0.13167295434789195, 0.09755310525254912, 0.14350632585653234, 0.15861763778237348, 0.15533649304547614, 0.13828486480102542, 0.16068383339338832, 0.1338196306049626, 0.14886357575465914, 0.1711097631075521, 0.1463525658159982, 0.34487204167361296, 0.3355403667371316, 0.3392350266300832, 0.2867534601619448, 0.3284350219006579, 0.30630571179874844, 0.3041368956658588, 0.3522047366155199, 0.32854437242130397, 0.20718051983812158, 0.21926491487532362, 0.21205548096852556, 0.18003825742324697, 0.2134145267123284, 0.22432454466379936, 0.24704005068169277, 0.2981931223795462, 0.23750676314702313, 0.20623127979458455, 0.18597680428409447, 0.17853415477504897, 0.19045624806087036, 0.17394704940232186, 0.2057805495507562, 0.23962425485376637, 0.18834160151257895, 0.1949742216095366, 0.20465936642995586, 0.19787118856918895, 0.2851108290337846, 0.20276793698552265, 0.23191946560963184, 0.20761078656534748, 0.2318984879105035, 0.21094615174572828, 0.3282408087688987, 0.14755476279950486, 0.16366106995545182, 0.3484790842887773, 0.2834549098338113, 0.17049279101360448, 0.4557012801273991, 0.16872008101063762, 0.17666749119087033, 0.3665478360075509, 0.1975988781142176, 0.35009475721618843, 0.1544736856211939, 0.18105979688246787, 0.16391064959534218, 0.19134113951806897, 0.19777254383827858, 0.2028239252129037, 0.2015112245212547, 0.18540105106573723, 0.19037506091935763, 0.1787107011225627, 0.19398272278755535, 0.20415904485225322, 0.21299705080782505, 0.2021363867036332, 0.18541043855747774, 0.18487283723018877, 0.07379865783343009, 0.07678171414738921, 0.08163076551665838, 0.0849708101262171, 0.0793063268409322, 0.07943474390229988, 0.0678851932404827, 0.06849013843255347, 0.07565925788152195]}, "mutation_prompt": null}
{"id": "9c9bf2a5-d355-45a6-90a5-0ce80a72291a", "solution": "import numpy as np\n\nclass QuantumHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.quantum_prob = 0.05  # Probability of quantum tunneling\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def quantum_tunneling(self, idx):\n        quantum_step = np.random.normal(0, 1, self.dim)\n        trial = self.population[idx] + quantum_step\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[idx]:\n            self.population[idx] = trial\n            self.population_values[idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                if np.random.rand() < self.quantum_prob:\n                    self.quantum_tunneling(i)\n                else:\n                    mutant = self.mutate(i)\n                    trial = self.crossover(self.population[i], mutant)\n                    self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "QuantumHybridDE", "description": "Hybrid Quantum-inspired Differential Evolution with Dynamic Quantum Tunneling for enhanced exploration and exploitation in black box optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {}, "mutation_prompt": null}
{"id": "a94ea634-b409-454a-a3ac-518382768eda", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution using Adaptive Population Resizing and Dynamic Parameters for improved exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.7125564039503486, 0.6972748730208758, 0.7213198500730311, 0.6764500591725927, 0.7253567846051645, 0.7225288424672884, 0.7111661181618643, 0.7162853212821552, 0.734531147486063, 0.4344230573109513, 0.4431659028891526, 0.4617623104463283, 0.5079730232327127, 0.5248985748250361, 0.47214455340031836, 0.5521071042768602, 0.4738973285393252, 0.4929160755482528, 0.14713441580669628, 0.1673181582459471, 0.12721445401948916, 0.12218998647402901, 0.170847193207451, 0.17772436848625606, 0.1378515209563762, 0.14450697411157765, 0.1416208704305012, 0.1293043328807727, 0.11003519712315502, 0.11799141315739003, 0.15936904291303344, 0.11831182760095038, 0.1252821383839413, 0.11059485774674993, 0.12492229430839508, 0.12210563056653612, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.24743270829927955, 0.28270654382376703, 0.2760358929515925, 0.2881786740554112, 0.25907067121006466, 0.29508087977346786, 0.2924639506254648, 0.27986279874347575, 0.2917224099039013, 0.28979624812743376, 0.30810132459030504, 0.270899537696103, 0.3115361284995555, 0.6067783750905026, 0.584511375902278, 0.5765891417967881, 0.5616678727221105, 0.3385654484466385, 0.15535929980943364, 0.14389183580822207, 0.14160450506005096, 0.15313349803218756, 0.14256475556474069, 0.13771880203923137, 0.1582767267862868, 0.1358430456962496, 0.13920828232325, 0.11434454754374168, 0.11543114932959309, 0.17704285697937305, 0.1446111841421549, 0.13935360062419844, 0.13115199186276372, 0.1605450213837174, 0.16630113267619073, 0.16019051521516336, 0.05475548317358969, 0.08010015869058718, 0.05746835553292817, 0.033093551863425774, 0.054234464087817846, 0.05451863599313134, 0.049321466546139336, 0.0517132543161144, 0.05931240875304533, 0.1652460519242448, 0.14935875898826834, 0.14453622713281877, 0.15389043967400573, 0.1547578383287791, 0.12890167536073316, 0.18781408784712816, 0.19455467614708755, 0.1998765612235689, 0.00138076239409346, 0.021865668080445877, 0.03281253398840911, 0.09299243751583075, 0.09792548826771996, 0.08781307099529334, 0.09649305887614867, 0.044175337631046196, 0.10957384473568565, 0.17986811345056308, 0.15218201284818078, 0.161202291757937, 0.15534117394194347, 0.16664614155294077, 0.14728718702292098, 0.14871174169415557, 0.1439112841948208, 0.17273651423450298, 0.46863903849165534, 0.5110313709107133, 0.4911351832647297, 0.4932155608938027, 0.4712776028441894, 0.43645347722114325, 0.49310775065690204, 0.5019108651310085, 0.5273124470765488, 0.10669657911626051, 0.09558673291570507, 0.11052719426781965, 0.10821784155993175, 0.1005569153300232, 0.1113484573921345, 0.1498844512416463, 0.09323733300004611, 0.10435158068505024, 0.14947196643230432, 0.1520937996200038, 0.1424848578914274, 0.1587105959129178, 0.17044405291959452, 0.13795837200833672, 0.13848386545694524, 0.16090541493622335, 0.16949140848805544, 0.29635485885228063, 0.28745972346391147, 0.3440420629716273, 0.280792012805672, 0.3417624684766898, 0.3003367884313598, 0.33540842790519565, 0.3481758971862371, 0.3559542959882982, 0.20215821300198966, 0.2124703544781561, 0.21365601704114867, 0.19677393056783088, 0.2578207358695985, 0.21639466960607334, 0.2609561489360773, 0.23616916342893624, 0.22424272095821973, 0.19570738590486203, 0.18278220012476398, 0.1976022633840272, 0.2021037417906112, 0.18885478461763738, 0.18716032275425554, 0.1934078746499719, 0.19621035902142225, 0.18338615072748854, 0.19263559388147045, 0.3078854078726071, 0.1925761301802731, 0.19319681539426414, 0.23646932459583148, 0.3061576507613901, 0.20440747260591519, 0.21027660504697343, 0.2314189848795264, 0.36680143315359315, 0.18060487914057288, 0.16494273064473852, 0.5155000680414569, 0.4311710052814932, 0.177442021862125, 0.3196870868455707, 0.40027904362804567, 0.38071994070241455, 0.3880539909830303, 0.1988051121005301, 0.26173439172652124, 0.29615635149712793, 0.1849945681125802, 0.2298521647801034, 0.20559267784131063, 0.48963247949417477, 0.2060629379094424, 0.17711879692475063, 0.20862162108223115, 0.1734394015157621, 0.18942505519381592, 0.19521273880288725, 0.1816907475016617, 0.18271901496051535, 0.18537535133543914, 0.1825856423108082, 0.08030493559856933, 0.08902372153316829, 0.07630177797042292, 0.07035505517089491, 0.07813703992362553, 0.07766881543566928, 0.07994807974220108, 0.08438016451091102, 0.08794586827464967]}, "mutation_prompt": null}
{"id": "fcb24b73-5930-4607-8dbd-037322117bc4", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.generation = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self):\n        self.cr = 0.9 - 0.5 * (self.generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (self.generation / (self.budget / self.initial_population_size))\n\n    def quantum_gate(self, vector):\n        phase_shift = np.random.uniform(-np.pi, np.pi, self.dim)\n        return vector + np.sin(phase_shift)\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                quantum_mutant = self.quantum_gate(mutant)\n                trial = self.crossover(self.population[i], quantum_mutant)\n                self.select(i, trial, func)\n            self.generation += 1\n        return self.best_solution", "name": "QuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution using Quantum Gates for enhanced diversity and convergence speed in black box optimization.", "configspace": "", "generation": 11, "fitness": 0.19052929538124347, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.39556480954573603, 0.37869927743529797, 0.38154754989431294, 0.36068310248612523, 0.38362912601914345, 0.36916897289687345, 0.36152503885272314, 0.3717655156534222, 0.3751636541413418, 0.030764706294374777, 0.02319569553352807, 0.06483132884695275, 0.059197777410184615, 0.05172054360280476, 0.05647573846506371, 0.053403866844832226, 0.034788214232596926, 0.0368268611771162, 0.15102658333394536, 0.15057392054217322, 0.15677705801088815, 0.13440169962004234, 0.165763212225415, 0.14484250518029207, 0.16090629007202462, 0.17071869547393437, 0.1510528429234006, 0.12169957276146792, 0.12979967774534584, 0.136345166383244, 0.11212859752454585, 0.13249802474927364, 0.16722143707244375, 0.12713641765639772, 0.12897119392200962, 0.13125817168084564, 0.9247195389145997, 0.9040595758698641, 0.947644132236223, 0.926216543376487, 0.8818484071207217, 0.9066107120403147, 0.9409821677349871, 0.9282172055588651, 0.9373991500443443, 0.18863850714625818, 0.18497580335868802, 0.18237718356340726, 0.18692490579181353, 0.18256890320770347, 0.1982813887555479, 0.17389744325773338, 0.17913741999035215, 0.1868531178138535, 0.2301035378991101, 0.1899074637246837, 0.22943567439427992, 0.21955712870720445, 0.18541785205097483, 0.24981668332653295, 0.43782774055559237, 0.25046955348724775, 0.2400392550908358, 0.11395620362082448, 0.14731359133459376, 0.13514450655724908, 0.1136886614837469, 0.10665915537087456, 0.10842741753241003, 0.11929654666599965, 0.14203450946620233, 0.1322206372856517, 0.11233585013207414, 0.11383969206354416, 0.08867312199930277, 0.11171909160370219, 0.12204405121651507, 0.1069923176263533, 0.10292819925322061, 0.12426006498348419, 0.09883042437975909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019057531402802974, 9.999999999998899e-05, 9.999999999998899e-05, 0.04724910529511617, 0.05727380622848344, 0.06561715442285299, 0.050047915037644275, 0.04359915882850873, 0.040722940756485304, 0.04183656271885117, 0.05268002446881814, 0.09018897788415892, 9.999999999998899e-05, 0.000954571977223484, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010133109526544448, 0.004081730416324314, 0.0020661635084270324, 9.999999999998899e-05, 0.0023039917427971623, 0.06582778482108043, 0.07373478307164638, 0.062198398260850274, 0.06399631524608884, 0.08845093985361363, 0.08975543699077859, 0.07599746075577007, 0.06613450715303204, 0.06552278654218702, 0.3183336563729424, 0.3397908256447515, 0.358820010553353, 0.3298367207550861, 0.33817482814018074, 0.32661317637432663, 0.331479119262688, 0.3364276985681709, 0.3172736303641229, 0.10433064007780746, 0.12335318707534515, 0.09904675283982955, 0.10650466175341411, 0.08323660721037818, 0.11665316581519802, 0.09040127967835909, 0.09958966642473965, 0.11200212117128394, 0.17370534487837597, 0.15386655418814954, 0.16280738300451225, 0.17565571172179173, 0.15000815215436247, 0.16179193212867304, 0.13469767055180748, 0.14176103847558608, 0.17778752871142656, 0.24214705608767306, 0.22533453687177984, 0.2523665133199685, 0.2381565668467912, 0.2293002785787931, 0.2502691450647566, 0.24147472075476417, 0.24795997743897236, 0.22779964444275524, 0.1927455735522241, 0.16214757924775314, 0.17732398471461164, 0.180162916323103, 0.16598255753807645, 0.16104780032081611, 0.17762529176159658, 0.18066968382855553, 0.17370540387602418, 0.18544715525530842, 0.20086049081646062, 0.19648447154558613, 0.19793573889332472, 0.18610065314472857, 0.19552715726272607, 0.1921416753242553, 0.20379963811436896, 0.18732905417216983, 0.18399710221652021, 0.18897137210851866, 0.1922744601349825, 0.21871271495990618, 0.2291466557343258, 0.19389460324514962, 0.20218220264058184, 0.18561232815021134, 0.21827468438493625, 0.16110673258322983, 0.2711601742879749, 0.30368737554167147, 0.3817277794696329, 0.17480963710669872, 0.3850618141753025, 0.17143308613579988, 0.2763762499416905, 0.1700192886800338, 0.1854165460844973, 0.1778884037165841, 0.22403994087848556, 0.21892842640189192, 0.20844138626230724, 0.18139279881342196, 0.23635715396846912, 0.2786556590625614, 0.31304861151603935, 0.18927288700246914, 0.1870236713813419, 0.192007612125502, 0.19328409499632537, 0.19122752931939557, 0.1749485592425597, 0.20410597666125752, 0.19656971796744693, 0.19222064827679342, 0.07113529298429444, 0.06435540707695986, 0.07519473461578652, 0.07645857068579553, 0.08012896164689953, 0.07505185093925171, 0.07960680250382668, 0.06606887934762984, 0.06744360435888375]}, "mutation_prompt": null}
{"id": "0477aa1b-9944-4c78-875d-aee4d042cf88", "solution": "import numpy as np\n\nclass ImprovedEnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        # Dynamic learning approach for parameters\n        adapt_factor = np.exp(-5 * generation / (self.budget / self.initial_population_size))\n        self.cr = 0.9 * adapt_factor\n        self.f = 0.8 * adapt_factor\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def randomized_operation(self):\n        if np.random.rand() < 0.5:\n            np.random.shuffle(self.population)\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            self.randomized_operation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "ImprovedEnhancedHybridDE", "description": "Improved Enhanced Hybrid DE with Adaptive Learning Rate and Randomized Evolutionary Operations for enhanced exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 12, "fitness": 0.1689824912697627, "feedback": "The algorithm ImprovedEnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.3963331740022322, 0.29645015812663134, 0.37406919160843377, 0.31266177801133477, 0.33192733838273736, 0.37775511522947025, 0.4061648554214441, 0.33576328808834965, 0.4292126658697363, 0.018493544043855614, 0.09945402786329582, 0.0752586951860118, 0.02459715548441821, 0.03077624081180419, 0.045181066929149694, 9.999999999998899e-05, 0.07674451813087757, 0.07422995512685171, 0.0969668110248948, 0.11712176287130038, 0.11376539661694152, 0.08867583400965451, 0.10509246058026056, 0.1176463068448691, 0.10222686679294168, 0.13198443486302092, 0.11321134186995774, 0.068630181587369, 0.08693501221195332, 0.10244201275624987, 0.09353491417837723, 0.11555195864053458, 0.10928778026696984, 0.09190107680481341, 0.09234343841984705, 0.11648418178334852, 0.9516906239239122, 0.9389294224393906, 0.9455227057351385, 0.9514854955567817, 0.9363814381360668, 0.9280649700742516, 0.9359965351601198, 0.9362036326169662, 0.9798969144490224, 0.10939993944050053, 0.12054825356207799, 0.08879767347744472, 0.08090325157607536, 0.13974865411267967, 0.14432552031487755, 0.11178334975243942, 0.1271602888788137, 0.12821657101583117, 0.15789664758322364, 0.17167525747759915, 0.1841458651091461, 0.15164930177119218, 0.17406874045583787, 0.183571214090953, 0.1795118322552458, 0.16429608529023043, 0.16424081382296996, 0.06280308558747161, 0.07911474368303084, 0.09365285282633706, 0.054452161714572456, 0.10894844976416718, 0.09819825236113633, 0.09926987269292353, 0.11544454918819047, 0.11108690018194267, 0.061215677881066966, 0.047812383163787, 0.0665994003440541, 0.08577440984439055, 0.06299893732461115, 0.11139375894257808, 0.05593655524544905, 0.06919815168330401, 0.10626471366719836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06376079032642668, 0.09888430227506428, 0.10951870388546558, 0.03846550020844064, 0.04343070430899609, 0.08572057146856082, 0.07011789809531332, 0.04596181901117802, 0.08884874314345836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018526222671779613, 0.04247298632921448, 0.05535034656336213, 0.03297210734958156, 0.05365081329165167, 0.035609686460131185, 0.03044320556752811, 0.045756951424518744, 0.04043904300629475, 0.297391735563979, 0.32102960462479024, 0.30294935183033744, 0.29062340399429076, 0.3028450144420738, 0.3346170866860785, 0.30632336588107123, 0.2909784216053787, 0.30384412994764154, 0.08111277855502008, 0.09102189897994561, 0.08197690935965807, 0.07292354896572428, 0.0808716882493663, 0.09423420247222059, 0.07320193902292649, 0.07283669192455422, 0.08072178943011821, 0.11654653348616417, 0.1823147716679695, 0.13058723358589963, 0.13439459083608285, 0.15014789981086618, 0.18189855917636089, 0.12263959677585534, 0.14220538053896925, 0.12944786572152356, 0.19647093446592423, 0.19645995722998222, 0.2064885696401485, 0.1861568321640762, 0.22701218531713196, 0.21385901404050367, 0.23178576602788736, 0.2169137919862978, 0.22960726748070415, 0.1649500087392295, 0.1657426782454513, 0.14900431360210065, 0.14945059270311523, 0.13935305575445256, 0.15766575869651256, 0.14035292623261664, 0.14072154124288294, 0.1332907843032517, 0.17447365494037437, 0.17567166923819555, 0.1875125980310861, 0.18545976612299186, 0.1791651697926392, 0.18897271846028174, 0.16878787881515056, 0.17848344654941628, 0.20367107542913676, 0.16616261192443016, 0.18048101068158562, 0.18017694593133926, 0.19686470040237858, 0.18418236832833312, 0.18882478288258475, 0.18975821647685842, 0.18106016501743316, 0.18026701385863875, 0.22721075148963077, 0.28845320814870135, 0.2980890033283461, 0.21689219561314754, 0.1922836695648612, 0.22650824882675824, 0.1861703091717536, 0.1889130203790984, 0.21127668978612868, 0.15395431433355466, 0.15813347981532255, 0.16202724102738975, 0.15849422488108755, 0.1862062738624074, 0.2050348997030601, 0.17533812741718302, 0.20590095133125685, 0.19581611801424392, 0.20100519845502107, 0.19272596646869966, 0.2003122054850165, 0.17845044751362382, 0.184625274364426, 0.19540960528215567, 0.17599773221966675, 0.22620808876630094, 0.1826777927038814, 0.07135267312421545, 0.07281857027403216, 0.07224155238700536, 0.07466881260666614, 0.0812101128293019, 0.08518771316328788, 0.07382853485508878, 0.07503846721673291, 0.067828085967793]}, "mutation_prompt": null}
{"id": "85d929bb-5bca-43a8-a2b3-b593b044d5b2", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n    \n    def adapt_params(self, generation):\n        self.cr = 0.9 - 0.5 * (generation / (self.budget / self.initial_population_size))\n        self.f = 0.8 - 0.4 * (generation / (self.budget / self.initial_population_size))\n    \n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n    \n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution using Adaptive Population Resizing and Dynamic Parameters for improved exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.7125564039503486, 0.6972748730208758, 0.7213198500730311, 0.6764500591725927, 0.7253567846051645, 0.7225288424672884, 0.7111661181618643, 0.7162853212821552, 0.734531147486063, 0.4344230573109513, 0.4431659028891526, 0.4617623104463283, 0.5079730232327127, 0.5248985748250361, 0.47214455340031836, 0.5521071042768602, 0.4738973285393252, 0.4929160755482528, 0.14713441580669628, 0.1673181582459471, 0.12721445401948916, 0.12218998647402901, 0.170847193207451, 0.17772436848625606, 0.1378515209563762, 0.14450697411157765, 0.1416208704305012, 0.1293043328807727, 0.11003519712315502, 0.11799141315739003, 0.15936904291303344, 0.11831182760095038, 0.1252821383839413, 0.11059485774674993, 0.12492229430839508, 0.12210563056653612, 0.9363358988778911, 0.9580308037534443, 0.9454044379924561, 0.9649371314715881, 0.9782051771063535, 0.9433109079754521, 0.9389845610507506, 0.9329606689945662, 0.9190028892635995, 0.24743270829927955, 0.28270654382376703, 0.2760358929515925, 0.2881786740554112, 0.25907067121006466, 0.29508087977346786, 0.2924639506254648, 0.27986279874347575, 0.2917224099039013, 0.28979624812743376, 0.30810132459030504, 0.270899537696103, 0.3115361284995555, 0.6067783750905026, 0.584511375902278, 0.5765891417967881, 0.5616678727221105, 0.3385654484466385, 0.15535929980943364, 0.14389183580822207, 0.14160450506005096, 0.15313349803218756, 0.14256475556474069, 0.13771880203923137, 0.1582767267862868, 0.1358430456962496, 0.13920828232325, 0.11434454754374168, 0.11543114932959309, 0.17704285697937305, 0.1446111841421549, 0.13935360062419844, 0.13115199186276372, 0.1605450213837174, 0.16630113267619073, 0.16019051521516336, 0.05475548317358969, 0.08010015869058718, 0.05746835553292817, 0.033093551863425774, 0.054234464087817846, 0.05451863599313134, 0.049321466546139336, 0.0517132543161144, 0.05931240875304533, 0.1652460519242448, 0.14935875898826834, 0.14453622713281877, 0.15389043967400573, 0.1547578383287791, 0.12890167536073316, 0.18781408784712816, 0.19455467614708755, 0.1998765612235689, 0.00138076239409346, 0.021865668080445877, 0.03281253398840911, 0.09299243751583075, 0.09792548826771996, 0.08781307099529334, 0.09649305887614867, 0.044175337631046196, 0.10957384473568565, 0.17986811345056308, 0.15218201284818078, 0.161202291757937, 0.15534117394194347, 0.16664614155294077, 0.14728718702292098, 0.14871174169415557, 0.1439112841948208, 0.17273651423450298, 0.46863903849165534, 0.5110313709107133, 0.4911351832647297, 0.4932155608938027, 0.4712776028441894, 0.43645347722114325, 0.49310775065690204, 0.5019108651310085, 0.5273124470765488, 0.10669657911626051, 0.09558673291570507, 0.11052719426781965, 0.10821784155993175, 0.1005569153300232, 0.1113484573921345, 0.1498844512416463, 0.09323733300004611, 0.10435158068505024, 0.14947196643230432, 0.1520937996200038, 0.1424848578914274, 0.1587105959129178, 0.17044405291959452, 0.13795837200833672, 0.13848386545694524, 0.16090541493622335, 0.16949140848805544, 0.29635485885228063, 0.28745972346391147, 0.3440420629716273, 0.280792012805672, 0.3417624684766898, 0.3003367884313598, 0.33540842790519565, 0.3481758971862371, 0.3559542959882982, 0.20215821300198966, 0.2124703544781561, 0.21365601704114867, 0.19677393056783088, 0.2578207358695985, 0.21639466960607334, 0.2609561489360773, 0.23616916342893624, 0.22424272095821973, 0.19570738590486203, 0.18278220012476398, 0.1976022633840272, 0.2021037417906112, 0.18885478461763738, 0.18716032275425554, 0.1934078746499719, 0.19621035902142225, 0.18338615072748854, 0.19263559388147045, 0.3078854078726071, 0.1925761301802731, 0.19319681539426414, 0.23646932459583148, 0.3061576507613901, 0.20440747260591519, 0.21027660504697343, 0.2314189848795264, 0.36680143315359315, 0.18060487914057288, 0.16494273064473852, 0.5155000680414569, 0.4311710052814932, 0.177442021862125, 0.3196870868455707, 0.40027904362804567, 0.38071994070241455, 0.3880539909830303, 0.1988051121005301, 0.26173439172652124, 0.29615635149712793, 0.1849945681125802, 0.2298521647801034, 0.20559267784131063, 0.48963247949417477, 0.2060629379094424, 0.17711879692475063, 0.20862162108223115, 0.1734394015157621, 0.18942505519381592, 0.19521273880288725, 0.1816907475016617, 0.18271901496051535, 0.18537535133543914, 0.1825856423108082, 0.08030493559856933, 0.08902372153316829, 0.07630177797042292, 0.07035505517089491, 0.07813703992362553, 0.07766881543566928, 0.07994807974220108, 0.08438016451091102, 0.08794586827464967]}, "mutation_prompt": null}
{"id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Variegation using Oscillating Parameters and Dynamic Archiving for enhanced performance in black box optimization.", "configspace": "", "generation": 14, "fitness": 0.2752778476476028, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "de1263a9-1f54-49d9-9fea-8389909777ed", "metadata": {"aucs": [0.7205227542534083, 0.6610791805056094, 0.6288261438083793, 0.7404741016033052, 0.7340346584035817, 0.7354691989449392, 0.7283690051003421, 0.700162576793756, 0.7271573670784253, 0.4016518876050298, 0.48458474423796183, 0.482742968205483, 0.489872429751665, 0.45015980192863625, 0.5388203660465037, 0.44904633353298373, 0.4102611107756027, 0.4543289380178177, 0.14239909949405605, 0.23048630576285156, 0.1343952370043533, 0.1421306769118046, 0.1626141449389794, 0.18363579441704825, 0.14564874473233813, 0.14544503598930147, 0.1746596702586568, 0.12945737156111958, 0.14417889597372668, 0.12352496132035884, 0.11419846322898553, 0.129998654215983, 0.11772336497990221, 0.23267479274637382, 0.18391843769683514, 0.12545206550166876, 0.9397211271145834, 0.945741142053597, 0.9609795468409444, 0.9612835382790119, 0.9782048789654659, 0.950128372403271, 0.9428383582515725, 0.9607966660171657, 0.9531819383406295, 0.31178124113382355, 0.2761547578772212, 0.27362377971402774, 0.27361353006690725, 0.2660545372365104, 0.2918939404382781, 0.3041687812112024, 0.2520837035660606, 0.29581835005763735, 0.2903525831946159, 0.2891538474977361, 0.5601697858747656, 0.29692188529356367, 0.572939425100092, 0.28496475056245685, 0.5745738713153483, 0.5986516479813859, 0.2916073308511531, 0.14474850574775067, 0.16264282244737316, 0.1611551961973562, 0.17712875299066166, 0.1596868424304435, 0.15122295438998135, 0.17758461175711504, 0.16959265206814522, 0.1768285953861103, 0.13321948148946072, 0.10543111637916258, 0.1256497271964161, 0.28601041386590353, 0.16424846195573595, 0.1563103997760953, 0.1390356152576252, 0.1445782107686011, 0.13076826753257265, 0.029934515988802368, 0.04910222066903258, 0.0681552086516598, 0.04314537623361303, 0.06804753982632905, 0.033029542931785505, 0.04209595157543411, 0.05847168885608045, 0.020877969360638016, 0.1892742453955769, 0.10525659697075374, 0.16041535633762072, 0.13117123632947003, 0.10563272509992894, 0.21273014597514694, 0.15896544448721073, 0.1528279643804401, 0.14931034062778403, 0.0723622303986653, 0.13665350007709476, 0.052531733542470316, 0.05230013308015258, 0.20076429258606887, 0.12559193541666047, 0.0634239503477696, 0.07617699941868306, 0.04151686928115361, 0.28345844163850864, 0.13717266362184577, 0.20302360563262056, 0.156545397429382, 0.16899532402869777, 0.1575794132179359, 0.17273988506841143, 0.12951752830627916, 0.18427859825240644, 0.4299793273351876, 0.46026888463232385, 0.5514110166044195, 0.5108264301515071, 0.5018244309779039, 0.5098756758763541, 0.48764733994576237, 0.5033194111973002, 0.5156612038471443, 0.09500188386438835, 0.08502058218873276, 0.08996226987614897, 0.11126816497984326, 0.10291367669151019, 0.08471103434742222, 0.10057646997427006, 0.10726381159383269, 0.08415305085397085, 0.16609522661716858, 0.15407974060336294, 0.13190249776570506, 0.18875243192333913, 0.1616508114436137, 0.18835564880406364, 0.12457775281647754, 0.12862102034495948, 0.1385388165389111, 0.2969241568753479, 0.2835384368369288, 0.29414397103337897, 0.2583584975908565, 0.3061125789058978, 0.27539219661052583, 0.3721875501525935, 0.3163523949032523, 0.3262175309424682, 0.2370828043474611, 0.25231023445117784, 0.2302923608869153, 0.20657942963860743, 0.20113457854725392, 0.20658106142623067, 0.31688056676585796, 0.21296777308150427, 0.23891175756118233, 0.20302218543387385, 0.18902185076307065, 0.17307921046110297, 0.17889165862513434, 0.18328071821074676, 0.18308018069521304, 0.1957352560541108, 0.227565785280464, 0.1981518297073942, 0.19609634005301246, 0.3191053264096506, 0.18460964021094528, 0.2986228874281903, 0.2198965992175287, 0.21066484851653655, 0.20168082456469916, 0.24130330378526865, 0.20027080993802582, 0.592585006287491, 0.1674632969425478, 0.24785494181453394, 0.4669017929262057, 0.4144750107834245, 0.3696158777558538, 0.17375832471644426, 0.23826537943747284, 0.4378521869800268, 0.40848920628872165, 0.20305993134822653, 0.5328400020874622, 0.47753523745645676, 0.18651722863697406, 0.2551721386616683, 0.5455180627915652, 0.19552611102893713, 0.5349314485944088, 0.18399564479085861, 0.18215441069406657, 0.17944102465195233, 0.20996691807320056, 0.19138117875624405, 0.18820828753088803, 0.19911034107160508, 0.18109557145923716, 0.17673473571152676, 0.07068358518245843, 0.07503074302792301, 0.08508139889097999, 0.08325837411047854, 0.07906547821315524, 0.07708200958999956, 0.08212642558792371, 0.07934912892193191, 0.08115510412590443]}, "mutation_prompt": null}
{"id": "a50a9b9a-e7f4-49e6-82b8-2a2f691d67d9", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Variegation using Oscillating Parameters and Dynamic Archiving for enhanced performance in black box optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "metadata": {"aucs": [0.7205227542534083, 0.6610791805056094, 0.6288261438083793, 0.7404741016033052, 0.7340346584035817, 0.7354691989449392, 0.7283690051003421, 0.700162576793756, 0.7271573670784253, 0.4016518876050298, 0.48458474423796183, 0.482742968205483, 0.489872429751665, 0.45015980192863625, 0.5388203660465037, 0.44904633353298373, 0.4102611107756027, 0.4543289380178177, 0.14239909949405605, 0.23048630576285156, 0.1343952370043533, 0.1421306769118046, 0.1626141449389794, 0.18363579441704825, 0.14564874473233813, 0.14544503598930147, 0.1746596702586568, 0.12945737156111958, 0.14417889597372668, 0.12352496132035884, 0.11419846322898553, 0.129998654215983, 0.11772336497990221, 0.23267479274637382, 0.18391843769683514, 0.12545206550166876, 0.9397211271145834, 0.945741142053597, 0.9609795468409444, 0.9612835382790119, 0.9782048789654659, 0.950128372403271, 0.9428383582515725, 0.9607966660171657, 0.9531819383406295, 0.31178124113382355, 0.2761547578772212, 0.27362377971402774, 0.27361353006690725, 0.2660545372365104, 0.2918939404382781, 0.3041687812112024, 0.2520837035660606, 0.29581835005763735, 0.2903525831946159, 0.2891538474977361, 0.5601697858747656, 0.29692188529356367, 0.572939425100092, 0.28496475056245685, 0.5745738713153483, 0.5986516479813859, 0.2916073308511531, 0.14474850574775067, 0.16264282244737316, 0.1611551961973562, 0.17712875299066166, 0.1596868424304435, 0.15122295438998135, 0.17758461175711504, 0.16959265206814522, 0.1768285953861103, 0.13321948148946072, 0.10543111637916258, 0.1256497271964161, 0.28601041386590353, 0.16424846195573595, 0.1563103997760953, 0.1390356152576252, 0.1445782107686011, 0.13076826753257265, 0.029934515988802368, 0.04910222066903258, 0.0681552086516598, 0.04314537623361303, 0.06804753982632905, 0.033029542931785505, 0.04209595157543411, 0.05847168885608045, 0.020877969360638016, 0.1892742453955769, 0.10525659697075374, 0.16041535633762072, 0.13117123632947003, 0.10563272509992894, 0.21273014597514694, 0.15896544448721073, 0.1528279643804401, 0.14931034062778403, 0.0723622303986653, 0.13665350007709476, 0.052531733542470316, 0.05230013308015258, 0.20076429258606887, 0.12559193541666047, 0.0634239503477696, 0.07617699941868306, 0.04151686928115361, 0.28345844163850864, 0.13717266362184577, 0.20302360563262056, 0.156545397429382, 0.16899532402869777, 0.1575794132179359, 0.17273988506841143, 0.12951752830627916, 0.18427859825240644, 0.4299793273351876, 0.46026888463232385, 0.5514110166044195, 0.5108264301515071, 0.5018244309779039, 0.5098756758763541, 0.48764733994576237, 0.5033194111973002, 0.5156612038471443, 0.09500188386438835, 0.08502058218873276, 0.08996226987614897, 0.11126816497984326, 0.10291367669151019, 0.08471103434742222, 0.10057646997427006, 0.10726381159383269, 0.08415305085397085, 0.16609522661716858, 0.15407974060336294, 0.13190249776570506, 0.18875243192333913, 0.1616508114436137, 0.18835564880406364, 0.12457775281647754, 0.12862102034495948, 0.1385388165389111, 0.2969241568753479, 0.2835384368369288, 0.29414397103337897, 0.2583584975908565, 0.3061125789058978, 0.27539219661052583, 0.3721875501525935, 0.3163523949032523, 0.3262175309424682, 0.2370828043474611, 0.25231023445117784, 0.2302923608869153, 0.20657942963860743, 0.20113457854725392, 0.20658106142623067, 0.31688056676585796, 0.21296777308150427, 0.23891175756118233, 0.20302218543387385, 0.18902185076307065, 0.17307921046110297, 0.17889165862513434, 0.18328071821074676, 0.18308018069521304, 0.1957352560541108, 0.227565785280464, 0.1981518297073942, 0.19609634005301246, 0.3191053264096506, 0.18460964021094528, 0.2986228874281903, 0.2198965992175287, 0.21066484851653655, 0.20168082456469916, 0.24130330378526865, 0.20027080993802582, 0.592585006287491, 0.1674632969425478, 0.24785494181453394, 0.4669017929262057, 0.4144750107834245, 0.3696158777558538, 0.17375832471644426, 0.23826537943747284, 0.4378521869800268, 0.40848920628872165, 0.20305993134822653, 0.5328400020874622, 0.47753523745645676, 0.18651722863697406, 0.2551721386616683, 0.5455180627915652, 0.19552611102893713, 0.5349314485944088, 0.18399564479085861, 0.18215441069406657, 0.17944102465195233, 0.20996691807320056, 0.19138117875624405, 0.18820828753088803, 0.19911034107160508, 0.18109557145923716, 0.17673473571152676, 0.07068358518245843, 0.07503074302792301, 0.08508139889097999, 0.08325837411047854, 0.07906547821315524, 0.07708200958999956, 0.08212642558792371, 0.07934912892193191, 0.08115510412590443]}, "mutation_prompt": null}
{"id": "bf85d556-e9cc-4037-aa1e-ddf657d07744", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Variegation using Oscillating Parameters and Dynamic Archiving for enhanced performance in black box optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "metadata": {"aucs": [0.7205227542534083, 0.6610791805056094, 0.6288261438083793, 0.7404741016033052, 0.7340346584035817, 0.7354691989449392, 0.7283690051003421, 0.700162576793756, 0.7271573670784253, 0.4016518876050298, 0.48458474423796183, 0.482742968205483, 0.489872429751665, 0.45015980192863625, 0.5388203660465037, 0.44904633353298373, 0.4102611107756027, 0.4543289380178177, 0.14239909949405605, 0.23048630576285156, 0.1343952370043533, 0.1421306769118046, 0.1626141449389794, 0.18363579441704825, 0.14564874473233813, 0.14544503598930147, 0.1746596702586568, 0.12945737156111958, 0.14417889597372668, 0.12352496132035884, 0.11419846322898553, 0.129998654215983, 0.11772336497990221, 0.23267479274637382, 0.18391843769683514, 0.12545206550166876, 0.9397211271145834, 0.945741142053597, 0.9609795468409444, 0.9612835382790119, 0.9782048789654659, 0.950128372403271, 0.9428383582515725, 0.9607966660171657, 0.9531819383406295, 0.31178124113382355, 0.2761547578772212, 0.27362377971402774, 0.27361353006690725, 0.2660545372365104, 0.2918939404382781, 0.3041687812112024, 0.2520837035660606, 0.29581835005763735, 0.2903525831946159, 0.2891538474977361, 0.5601697858747656, 0.29692188529356367, 0.572939425100092, 0.28496475056245685, 0.5745738713153483, 0.5986516479813859, 0.2916073308511531, 0.14474850574775067, 0.16264282244737316, 0.1611551961973562, 0.17712875299066166, 0.1596868424304435, 0.15122295438998135, 0.17758461175711504, 0.16959265206814522, 0.1768285953861103, 0.13321948148946072, 0.10543111637916258, 0.1256497271964161, 0.28601041386590353, 0.16424846195573595, 0.1563103997760953, 0.1390356152576252, 0.1445782107686011, 0.13076826753257265, 0.029934515988802368, 0.04910222066903258, 0.0681552086516598, 0.04314537623361303, 0.06804753982632905, 0.033029542931785505, 0.04209595157543411, 0.05847168885608045, 0.020877969360638016, 0.1892742453955769, 0.10525659697075374, 0.16041535633762072, 0.13117123632947003, 0.10563272509992894, 0.21273014597514694, 0.15896544448721073, 0.1528279643804401, 0.14931034062778403, 0.0723622303986653, 0.13665350007709476, 0.052531733542470316, 0.05230013308015258, 0.20076429258606887, 0.12559193541666047, 0.0634239503477696, 0.07617699941868306, 0.04151686928115361, 0.28345844163850864, 0.13717266362184577, 0.20302360563262056, 0.156545397429382, 0.16899532402869777, 0.1575794132179359, 0.17273988506841143, 0.12951752830627916, 0.18427859825240644, 0.4299793273351876, 0.46026888463232385, 0.5514110166044195, 0.5108264301515071, 0.5018244309779039, 0.5098756758763541, 0.48764733994576237, 0.5033194111973002, 0.5156612038471443, 0.09500188386438835, 0.08502058218873276, 0.08996226987614897, 0.11126816497984326, 0.10291367669151019, 0.08471103434742222, 0.10057646997427006, 0.10726381159383269, 0.08415305085397085, 0.16609522661716858, 0.15407974060336294, 0.13190249776570506, 0.18875243192333913, 0.1616508114436137, 0.18835564880406364, 0.12457775281647754, 0.12862102034495948, 0.1385388165389111, 0.2969241568753479, 0.2835384368369288, 0.29414397103337897, 0.2583584975908565, 0.3061125789058978, 0.27539219661052583, 0.3721875501525935, 0.3163523949032523, 0.3262175309424682, 0.2370828043474611, 0.25231023445117784, 0.2302923608869153, 0.20657942963860743, 0.20113457854725392, 0.20658106142623067, 0.31688056676585796, 0.21296777308150427, 0.23891175756118233, 0.20302218543387385, 0.18902185076307065, 0.17307921046110297, 0.17889165862513434, 0.18328071821074676, 0.18308018069521304, 0.1957352560541108, 0.227565785280464, 0.1981518297073942, 0.19609634005301246, 0.3191053264096506, 0.18460964021094528, 0.2986228874281903, 0.2198965992175287, 0.21066484851653655, 0.20168082456469916, 0.24130330378526865, 0.20027080993802582, 0.592585006287491, 0.1674632969425478, 0.24785494181453394, 0.4669017929262057, 0.4144750107834245, 0.3696158777558538, 0.17375832471644426, 0.23826537943747284, 0.4378521869800268, 0.40848920628872165, 0.20305993134822653, 0.5328400020874622, 0.47753523745645676, 0.18651722863697406, 0.2551721386616683, 0.5455180627915652, 0.19552611102893713, 0.5349314485944088, 0.18399564479085861, 0.18215441069406657, 0.17944102465195233, 0.20996691807320056, 0.19138117875624405, 0.18820828753088803, 0.19911034107160508, 0.18109557145923716, 0.17673473571152676, 0.07068358518245843, 0.07503074302792301, 0.08508139889097999, 0.08325837411047854, 0.07906547821315524, 0.07708200958999956, 0.08212642558792371, 0.07934912892193191, 0.08115510412590443]}, "mutation_prompt": null}
{"id": "dede60f6-e116-438c-98ad-28720775e741", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9\n        self.f = 0.8\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        # Utilize archive to introduce diversity\n        if np.random.rand() < 0.1 and len(self.archive) > 0:\n            archive_idx = np.random.randint(len(self.archive))\n            mutant += 0.5 * (self.archive[archive_idx] - mutant)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            if len(self.archive) < self.initial_population_size:\n                self.archive.append(self.population[target_idx])\n            else:\n                self.archive[np.random.randint(len(self.archive))] = self.population[target_idx]\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n\n    def adapt_params(self, generation):\n        # Dynamic oscillation and memory-based parameter adaptation\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        # Scale factor adapted based on historical success\n        self.f = 0.6 + 0.2 * oscillation_factor\n        if len(self.archive) > 0:\n            historical_improvement = np.mean(np.array(self.archive) - self.population, axis=0)\n            self.f = 0.6 + 0.2 * np.clip(np.linalg.norm(historical_improvement), 0, 1)\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Scaling and Memory-Based Adaptation for improved convergence and performance on diverse optimization tasks.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (28,5) (50,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (28,5) (50,5) ')", "parent_id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "metadata": {}, "mutation_prompt": null}
{"id": "b048a57e-f417-470c-bd71-2f6cdb62f8e1", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.select(i, trial, func)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Variegation using Oscillating Parameters and Dynamic Archiving for enhanced performance in black box optimization.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "metadata": {"aucs": [0.7205227542534083, 0.6610791805056094, 0.6288261438083793, 0.7404741016033052, 0.7340346584035817, 0.7354691989449392, 0.7283690051003421, 0.700162576793756, 0.7271573670784253, 0.4016518876050298, 0.48458474423796183, 0.482742968205483, 0.489872429751665, 0.45015980192863625, 0.5388203660465037, 0.44904633353298373, 0.4102611107756027, 0.4543289380178177, 0.14239909949405605, 0.23048630576285156, 0.1343952370043533, 0.1421306769118046, 0.1626141449389794, 0.18363579441704825, 0.14564874473233813, 0.14544503598930147, 0.1746596702586568, 0.12945737156111958, 0.14417889597372668, 0.12352496132035884, 0.11419846322898553, 0.129998654215983, 0.11772336497990221, 0.23267479274637382, 0.18391843769683514, 0.12545206550166876, 0.9397211271145834, 0.945741142053597, 0.9609795468409444, 0.9612835382790119, 0.9782048789654659, 0.950128372403271, 0.9428383582515725, 0.9607966660171657, 0.9531819383406295, 0.31178124113382355, 0.2761547578772212, 0.27362377971402774, 0.27361353006690725, 0.2660545372365104, 0.2918939404382781, 0.3041687812112024, 0.2520837035660606, 0.29581835005763735, 0.2903525831946159, 0.2891538474977361, 0.5601697858747656, 0.29692188529356367, 0.572939425100092, 0.28496475056245685, 0.5745738713153483, 0.5986516479813859, 0.2916073308511531, 0.14474850574775067, 0.16264282244737316, 0.1611551961973562, 0.17712875299066166, 0.1596868424304435, 0.15122295438998135, 0.17758461175711504, 0.16959265206814522, 0.1768285953861103, 0.13321948148946072, 0.10543111637916258, 0.1256497271964161, 0.28601041386590353, 0.16424846195573595, 0.1563103997760953, 0.1390356152576252, 0.1445782107686011, 0.13076826753257265, 0.029934515988802368, 0.04910222066903258, 0.0681552086516598, 0.04314537623361303, 0.06804753982632905, 0.033029542931785505, 0.04209595157543411, 0.05847168885608045, 0.020877969360638016, 0.1892742453955769, 0.10525659697075374, 0.16041535633762072, 0.13117123632947003, 0.10563272509992894, 0.21273014597514694, 0.15896544448721073, 0.1528279643804401, 0.14931034062778403, 0.0723622303986653, 0.13665350007709476, 0.052531733542470316, 0.05230013308015258, 0.20076429258606887, 0.12559193541666047, 0.0634239503477696, 0.07617699941868306, 0.04151686928115361, 0.28345844163850864, 0.13717266362184577, 0.20302360563262056, 0.156545397429382, 0.16899532402869777, 0.1575794132179359, 0.17273988506841143, 0.12951752830627916, 0.18427859825240644, 0.4299793273351876, 0.46026888463232385, 0.5514110166044195, 0.5108264301515071, 0.5018244309779039, 0.5098756758763541, 0.48764733994576237, 0.5033194111973002, 0.5156612038471443, 0.09500188386438835, 0.08502058218873276, 0.08996226987614897, 0.11126816497984326, 0.10291367669151019, 0.08471103434742222, 0.10057646997427006, 0.10726381159383269, 0.08415305085397085, 0.16609522661716858, 0.15407974060336294, 0.13190249776570506, 0.18875243192333913, 0.1616508114436137, 0.18835564880406364, 0.12457775281647754, 0.12862102034495948, 0.1385388165389111, 0.2969241568753479, 0.2835384368369288, 0.29414397103337897, 0.2583584975908565, 0.3061125789058978, 0.27539219661052583, 0.3721875501525935, 0.3163523949032523, 0.3262175309424682, 0.2370828043474611, 0.25231023445117784, 0.2302923608869153, 0.20657942963860743, 0.20113457854725392, 0.20658106142623067, 0.31688056676585796, 0.21296777308150427, 0.23891175756118233, 0.20302218543387385, 0.18902185076307065, 0.17307921046110297, 0.17889165862513434, 0.18328071821074676, 0.18308018069521304, 0.1957352560541108, 0.227565785280464, 0.1981518297073942, 0.19609634005301246, 0.3191053264096506, 0.18460964021094528, 0.2986228874281903, 0.2198965992175287, 0.21066484851653655, 0.20168082456469916, 0.24130330378526865, 0.20027080993802582, 0.592585006287491, 0.1674632969425478, 0.24785494181453394, 0.4669017929262057, 0.4144750107834245, 0.3696158777558538, 0.17375832471644426, 0.23826537943747284, 0.4378521869800268, 0.40848920628872165, 0.20305993134822653, 0.5328400020874622, 0.47753523745645676, 0.18651722863697406, 0.2551721386616683, 0.5455180627915652, 0.19552611102893713, 0.5349314485944088, 0.18399564479085861, 0.18215441069406657, 0.17944102465195233, 0.20996691807320056, 0.19138117875624405, 0.18820828753088803, 0.19911034107160508, 0.18109557145923716, 0.17673473571152676, 0.07068358518245843, 0.07503074302792301, 0.08508139889097999, 0.08325837411047854, 0.07906547821315524, 0.07708200958999956, 0.08212642558792371, 0.07934912892193191, 0.08115510412590443]}, "mutation_prompt": null}
{"id": "5de703d5-055a-4d8e-9ccf-733187db4f6c", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n        self.history = {'mutation': [], 'crossover': []}\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_operator_selection(self):\n        if len(self.history['mutation']) > 10:\n            recent_mutation_success = np.mean(self.history['mutation'][-10:])\n            recent_crossover_success = np.mean(self.history['crossover'][-10:])\n            if recent_mutation_success < recent_crossover_success:\n                factor_increase = 0.05\n                self.f = min(self.f + factor_increase, 1.0)\n                self.cr = max(self.cr - factor_increase, 0.0)\n            else:\n                factor_increase = 0.05\n                self.cr = min(self.cr + factor_increase, 1.0)\n                self.f = max(self.f - factor_increase, 0.0)\n\n    def resize_population(self):\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * 0.7))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_operator_selection()\n            self.resize_population()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.history['mutation'].append(success)\n                self.history['crossover'].append(success)\n            generation += 1\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Dynamic Operator Selection and Adaptive Crossover for superior performance in black box optimization tasks.", "configspace": "", "generation": 19, "fitness": 0.2808320031996124, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ce11e8e4-e528-4f31-9d7e-4f4eb3cc7e19", "metadata": {"aucs": [0.7641348020797561, 0.7348045120242124, 0.7445302310418058, 0.7587143100599828, 0.7641798722136673, 0.7648441611044668, 0.7351405642317074, 0.7693356064934334, 0.7631566256912325, 0.5280185517664394, 0.45145403227391157, 0.41651542159893573, 0.41176235988531096, 0.46538337801506313, 0.5043516739301341, 0.42219241526603535, 0.3941604990044639, 0.47999304466605086, 0.14222895619638798, 0.2515180022125544, 0.1352435689500353, 0.145914606134259, 0.13496124086281402, 0.14495180546546893, 0.19233501350455895, 0.14414484209455003, 0.130887368858295, 0.11431230721221419, 0.1072982363200159, 0.12191817138293826, 0.13336868697615412, 0.10970386570815738, 0.11579576335983532, 0.13067480996871494, 0.11998481230256108, 0.1731287333928362, 0.944419304278801, 0.9767360722696677, 0.9446106355699014, 0.9570458985268435, 0.9536147197612217, 0.9477643625306772, 0.9840618904903512, 0.9479729942451993, 0.9366124106358581, 0.2884709964452481, 0.2921787996275089, 0.3095022715638761, 0.24944348515993597, 0.29690090989238727, 0.29787507030508176, 0.33269765792612116, 0.27656210254090274, 0.28638166907900253, 0.5334296162989771, 0.6215227870059654, 0.5914441123402652, 0.3125544144950051, 0.601492055291065, 0.617469335146247, 0.5909965662692931, 0.32394649924805896, 0.6079086638155038, 0.15970423757638397, 0.16427412156405952, 0.1715553622746122, 0.16755823628329325, 0.17626930216183756, 0.1523223826142115, 0.1651761263681205, 0.16644837445562866, 0.14182262862410022, 0.15523765779289056, 0.10918494554980696, 0.14488133883121557, 0.2524279705628836, 0.17122139863368302, 0.1522781417832848, 0.1806651933354606, 0.1701810536097471, 0.15589475211896298, 0.05533537460254123, 0.05883559000413374, 0.07241312867621652, 0.12193718559499389, 0.10058190656555066, 0.065100703764438, 0.06454129487743998, 0.06380760873359526, 0.08519998602783196, 0.20010638457365748, 0.19497056643265165, 0.15680403824023448, 0.13902190222163135, 0.16694613368575595, 0.1930916675616713, 0.179269628710375, 0.2149677178255448, 0.21561016437574987, 0.035320309942248995, 0.07666349197825417, 0.05180820639096728, 0.06991450659050258, 0.09521294457127127, 0.13479316058179025, 0.007385144310908753, 0.14733437349932188, 0.07226306384697068, 0.18177322207563107, 0.15647230391147826, 0.1311015884149942, 0.15531990411867025, 0.14858630924567628, 0.16486011927642552, 0.16198209534009234, 0.20466939661465555, 0.17638033220926785, 0.5006502072519654, 0.5322470114495704, 0.5395539746613691, 0.5031239747610825, 0.5387848367976269, 0.6146656361212111, 0.50369881650666, 0.4965075372283949, 0.537273619780816, 0.10720435649103166, 0.09030104522991711, 0.11597224490304192, 0.10260047443566112, 0.08811367267796755, 0.10427893480330674, 0.10153228522020963, 0.08447170710028917, 0.10035757372291954, 0.12527276045120683, 0.17284863507165826, 0.13603782723647295, 0.14414302606205587, 0.13490481554922495, 0.17707168808775064, 0.13160753149761406, 0.16496084963016144, 0.13477574908540846, 0.2954790360126298, 0.30530885882786785, 0.32639021885122477, 0.31781937661896587, 0.3237120841160849, 0.3161620456432911, 0.3423653583605146, 0.3213496143019453, 0.3703342897055534, 0.2726485647236645, 0.26552660842363207, 0.2591017625476053, 0.19179759433838373, 0.23552915778999028, 0.24538994328000396, 0.2452183975289306, 0.24968160379309723, 0.24876720311388278, 0.20213316490767141, 0.18031219992244207, 0.18865398892693352, 0.19393805357191563, 0.17603923761696116, 0.18754153303004983, 0.20846672917356368, 0.17976164088418067, 0.1857964398072881, 0.20933377624785532, 0.23158363969978724, 0.21099609628773464, 0.21584400103947798, 0.19165139644418805, 0.20325579912023617, 0.19770592942752618, 0.2124856740620119, 0.2127478816369126, 0.5187034656715752, 0.20364970354608447, 0.16088854161006094, 0.5751323519841685, 0.23237032671990787, 0.472008736858594, 0.15930659237701295, 0.3527323886435836, 0.38022162566773987, 0.4834089901474147, 0.2020795427581037, 0.18971195430883303, 0.19646018727905257, 0.20212326235854738, 0.3671176894335191, 0.20584327061803853, 0.5609985430030966, 0.20633089164023843, 0.17931515840553092, 0.18017470272112512, 0.1957904552866201, 0.18297174391138937, 0.18084609675140695, 0.18158807222726192, 0.188926172631258, 0.18023429866615892, 0.19377784752300486, 0.07553676240085094, 0.08248271387520689, 0.07787844380914954, 0.0773381805493214, 0.0830647494444765, 0.07925929240521234, 0.07232925550053737, 0.07559029839568843, 0.077587857846656]}, "mutation_prompt": null}
{"id": "b8f5d5c0-f150-468d-a6ac-21da699431e1", "solution": "import numpy as np\n\nclass MultiStrategyADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cr = 0.9\n        self.f = 0.8\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.archive = []\n        self.history = {'mutation': [], 'crossover': []}\n        self.success_rates = {'mutation': 0, 'crossover': 0}\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.archive.append(self.population[target_idx])\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.cr = 0.5 + 0.4 * oscillation_factor\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_operator_selection(self):\n        if len(self.history['mutation']) > 10:\n            recent_mutation_success = np.mean(self.history['mutation'][-10:])\n            recent_crossover_success = np.mean(self.history['crossover'][-10:])\n            if recent_mutation_success < recent_crossover_success:\n                factor_increase = 0.05\n                self.f = min(self.f + factor_increase, 1.0)\n                self.cr = max(self.cr - factor_increase, 0.0)\n            else:\n                factor_increase = 0.05\n                self.cr = min(self.cr + factor_increase, 1.0)\n                self.f = max(self.f - factor_increase, 0.0)\n\n    def resize_population(self):\n        stochastic_factor = np.random.uniform(0.6, 0.8)\n        if self.function_evals > 0.5 * self.budget:\n            new_size = max(self.dim, int(self.population_size * stochastic_factor))\n            if new_size < self.population_size:\n                indices = np.argsort(self.population_values)[:new_size]\n                self.population = self.population[indices]\n                self.population_values = self.population_values[indices]\n                self.population_size = new_size\n                self.archive = []\n\n    def contextual_learning(self):\n        if len(self.archive) > 0:\n            best_archive = min(self.archive, key=lambda x: func(x))\n            if func(best_archive) < self.best_value:\n                self.best_solution = np.copy(best_archive)\n                self.best_value = func(best_archive)\n                self.archive = []\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_operator_selection()\n            self.resize_population()\n            self.contextual_learning()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.history['mutation'].append(success)\n                self.history['crossover'].append(success)\n            generation += 1\n        return self.best_solution", "name": "MultiStrategyADE", "description": "Multi-Strategy Adaptive Differential Evolution with Stochastic Population Resizing and Contextual Learning for enhanced exploration and exploitation.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "5de703d5-055a-4d8e-9ccf-733187db4f6c", "metadata": {}, "mutation_prompt": null}
{"id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "solution": "import numpy as np\n\nclass SynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDE", "description": "Synergistic Differential Evolution with Adaptive Memory and Dynamic Niching optimizes black box functions by combining memory-based adaptation and niche preservation techniques.", "configspace": "", "generation": 21, "fitness": 0.30949085540472615, "feedback": "The algorithm SynergisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "5de703d5-055a-4d8e-9ccf-733187db4f6c", "metadata": {"aucs": [0.6903554453160837, 0.7062140570939492, 0.7291272372121838, 0.7496531622640143, 0.7229750455763522, 0.7141654852694004, 0.7326623915980632, 0.7095395915216246, 0.7182737898806518, 0.5394973254568955, 0.5116008720523528, 0.5536448919350395, 0.5258056406121385, 0.505870684574923, 0.5128285293611541, 0.5511064860420416, 0.518074489466418, 0.5186340311723445, 0.0956866868655627, 0.09588280728608845, 0.11865693166517577, 0.09395457427096754, 0.09947325464660839, 0.10612506548115164, 0.09554926140462561, 0.09313112108841692, 0.10503330945679223, 0.10667952083081922, 0.09657800485103474, 0.0885529156753111, 0.10107482009655211, 0.08817428395775606, 0.09179270912462689, 0.09112276580897538, 0.09307216699331078, 0.08566776449240099, 0.9185419803579278, 0.916395676840551, 0.9459083781361276, 0.9145179707573869, 0.9633186458764924, 0.935500805995964, 0.9558240649595785, 0.9368763173269852, 0.9164887256612223, 0.3650136380026956, 0.3516171411778294, 0.3479097916268351, 0.3502741127053216, 0.3789762531707914, 0.37424497825848313, 0.3632922992673302, 0.36233776672826934, 0.3656320406890238, 0.6742254543151591, 0.6430409472456828, 0.6803675206548051, 0.6139158976014192, 0.6971268452721571, 0.652493446975426, 0.6737442250239498, 0.7079689701000293, 0.6724174924938003, 0.2529075279114523, 0.2667553404717051, 0.30005311277995683, 0.24755010207030792, 0.2845667084218033, 0.2585498664216668, 0.2974377273927191, 0.3255742605211347, 0.25654200168252383, 0.02153928667202276, 0.3998992301683032, 0.17234097756081668, 0.2845206746020925, 0.29606881917483885, 0.31200423335003125, 0.2993509220018271, 0.1810768377336266, 0.24225391371975813, 0.21289504626449596, 0.21147503032844894, 0.1856932759922605, 0.24486553034955516, 0.16754834650185824, 0.18648495762529382, 0.23060362922130995, 0.2186193834766812, 0.1964535300145429, 0.3122562267360518, 0.32381678632612887, 0.33556860450918324, 0.3790799939315087, 0.2679458078813285, 0.3665018314502506, 0.33114561273105725, 0.3986556921466081, 0.38561565971782696, 0.05756330716104785, 0.08651764605365553, 0.056192712267945755, 0.12233018884200397, 0.07653294629768659, 0.11350876714719438, 0.08485140987574236, 0.0759530639620567, 0.09352661838448073, 0.23142887351909514, 0.18908747138859427, 0.21814286921303871, 0.2017166995861176, 0.2152478473517765, 0.2264846743386968, 0.23880302134872577, 0.2103972523484443, 0.2079022838454394, 0.5994692872506202, 0.5684370235900764, 0.5542972681004366, 0.567802172144463, 0.585938982356851, 0.5709748444032167, 0.5932570310400422, 0.5654091986602909, 0.6090866421569159, 0.10006844335387777, 0.09773754860696537, 0.08872193377344595, 0.08128994414258595, 0.08583489723622284, 0.10016810862193759, 0.09170641362088827, 0.0873138842623492, 0.09613918465934423, 0.12772776004930908, 0.13859438794144885, 0.16021001631662235, 0.15301558054316888, 0.1435397881020084, 0.17364001943741603, 0.16934093372531, 0.1398207050330793, 0.13142249719523003, 0.29831475030077725, 0.3102221466048779, 0.32678549685472125, 0.28664781956007734, 0.30802431954496656, 0.28768016161963783, 0.3111661309998276, 0.35300001316709584, 0.3359718608636809, 0.2258595161494703, 0.2239963487953649, 0.2569166731066642, 0.2039962827645948, 0.24818990955989995, 0.21647840207632751, 0.25963676797610724, 0.2806754081518057, 0.258558735687059, 0.17244012639435546, 0.18485549226893805, 0.18482911081223796, 0.1996147831101306, 0.18367631466184398, 0.19235521853238313, 0.20244121331868914, 0.199803892149917, 0.1692727372863363, 0.18412767042787148, 0.19467425586961706, 0.17951981055765298, 0.17478809654549787, 0.17779010567395215, 0.18201892634179928, 0.18417237330339964, 0.18453935386353937, 0.1873078015795675, 0.16683399551169553, 0.7052894218031935, 0.5670746047070372, 0.25967951969375047, 0.1812123650259546, 0.6262635503477143, 0.43420539771754163, 0.3041105554124153, 0.5207407021262169, 0.5558579752687152, 0.16590017446203276, 0.19486476505031436, 0.1881302257665648, 0.19762083753542636, 0.1863946366975443, 0.20676708529634813, 0.14895083983503332, 0.209989394339548, 0.1840329236282845, 0.1757582120820611, 0.19034494336587648, 0.18096776063436737, 0.1894001925916987, 0.2004083197116201, 0.183029933840269, 0.18897366625294076, 0.17861649236742272, 0.07405543652559898, 0.0764573738894131, 0.07058264417974536, 0.06667599934317292, 0.06765795710769218, 0.07429336638591544, 0.07278750158030145, 0.08107631680691607, 0.06909450930993077]}, "mutation_prompt": null}
{"id": "96359d9a-363a-4fc3-b92a-828dbc2f6a4c", "solution": "import numpy as np\n\nclass SynergisticDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'fitness': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        if len(self.memory['fitness']) > 5:\n            recent_fitness = np.mean(self.memory['fitness'][-5:])\n            self.cr = 0.9 if recent_fitness < self.best_value else 0.6\n            self.f = 0.9 if recent_fitness < self.best_value else 0.5\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n            else:\n                # Encourage exploration by expanding niche radius\n                self.niche_radius *= 1.05\n                self.niche_radius = min(self.niche_radius, 2.0)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                    self.memory['fitness'].append(self.best_value)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDEv2", "description": "SynergisticDEv2 enhances Synergistic Differential Evolution by incorporating adaptive niche exploration and historical memory tuning for improved convergence on complex landscapes.", "configspace": "", "generation": 22, "fitness": 0.23796352598663997, "feedback": "The algorithm SynergisticDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.7239587179055953, 0.7213526470007129, 0.7314747690238608, 0.6963285118111437, 0.7402453735253527, 0.7404064704238893, 0.7264274943135665, 0.7518353410608275, 0.7414682087655178, 0.509925813025891, 0.49886610732182224, 0.5124986097472246, 0.5024802078046555, 0.30671343184159483, 0.4924996719785819, 0.5312447400647723, 0.5264407897522749, 0.5589215603950981, 0.12245494918004718, 0.15158655806429944, 0.1404464962149985, 0.1324242356148485, 0.1487506708710038, 0.13146334082361733, 0.13061242939443396, 0.1318096161015092, 0.14123556457145003, 0.13787410746934314, 0.11386213673776424, 0.0998456355314098, 0.11557606544861787, 0.11585350286941642, 0.12719998033338054, 0.12214635918174377, 0.13139060183321383, 0.12637729078513715, 0.9588877951266912, 0.9492179824085257, 0.9713022094007906, 0.9621387442563096, 0.9469479202220678, 0.9571095786126685, 0.9598640651402999, 0.963054892319869, 0.9702144173320993, 0.2687261985976004, 0.27109655169353364, 0.28409806069087506, 0.24681594568593035, 0.2602879981609796, 0.25483096979914666, 0.2818290490701465, 0.3015561958112698, 0.2854170346731286, 0.22750927998518533, 0.2548543352050211, 0.2473314460127073, 0.2824366524688344, 0.28421058605486416, 0.2576969480894752, 0.3970098457417539, 0.19368675232048616, 0.38470186798934936, 0.14921042297790243, 0.16734667722988794, 0.1488644319730218, 0.1628466428198304, 0.16082044337136925, 0.1466392679452838, 0.163128894509171, 0.15656371906560784, 0.16342373345725592, 0.13196291217259892, 0.13001227367034118, 0.11262566677919261, 0.16870388220548915, 0.12450521663485947, 0.14771552049996195, 0.1446271589284075, 0.14100085537287954, 0.1397278265713492, 0.0002710728004240437, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013912280175896186, 9.999999999998899e-05, 0.0012590786657349362, 9.999999999998899e-05, 0.005490678832278384, 0.013539499052570347, 0.06757028989850955, 0.09660589424413046, 0.05427520454197421, 0.08127889706899238, 0.08605377185013419, 0.049708954091499113, 0.08680437814615138, 0.09885022841094737, 0.0761974016452216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032428787567801987, 0.009453594324820735, 9.999999999998899e-05, 0.09629426535969154, 0.1007273251092069, 0.10761007281286927, 0.0972410782238059, 0.10727512310675169, 0.11198245984936583, 0.0872887001853232, 0.09770021659983452, 0.09832595636662078, 0.4698631550898871, 0.4648233711115195, 0.44315119714006823, 0.4491067749678741, 0.4726121295219372, 0.4408643010575074, 0.4633624291711096, 0.44045748421019315, 0.45710766542682313, 0.08555747456930562, 0.09760601445923678, 0.11579878319907244, 0.10211015231029485, 0.07965576707990496, 0.09193344801932146, 0.10968951928710191, 0.1000251841950649, 0.10181376163665812, 0.13153003090351523, 0.1341803503321064, 0.13074722259705618, 0.13730567892370205, 0.16191604690934913, 0.14672153833106716, 0.16805982525212781, 0.13772869494117423, 0.1396816567586966, 0.26615724220335313, 0.26646584499703396, 0.27445935265731725, 0.276571540675825, 0.2733643832481887, 0.2539165986988684, 0.28568444484543054, 0.2896034499831026, 0.3177554001330922, 0.16792640499130063, 0.1937565599027551, 0.18779212838369785, 0.17465317412408987, 0.17270380234029015, 0.1666958804432621, 0.1906486076137447, 0.21666604702407388, 0.17155976952149488, 0.18422108685784366, 0.18035089326762788, 0.19345345368469113, 0.19199972975530866, 0.20808805589869006, 0.1848058133650139, 0.17547438505982882, 0.1807271151897203, 0.18715310249743355, 0.19189021742454593, 0.18840464489722242, 0.20389603217805563, 0.20180999831535085, 0.1779556652933001, 0.20253558999195886, 0.19454902754913483, 0.19659555539983642, 0.18409937720543457, 0.21873644850941487, 0.2549229518338155, 0.21486299880032633, 0.22086949773852826, 0.1700749066047017, 0.2642944024361955, 0.18334696443334275, 0.19513208808394933, 0.24460949643789176, 0.23579166298103194, 0.23330196239470935, 0.19348268393748336, 0.20196604365869186, 0.1990583676060501, 0.2167549045295556, 0.19798227817051062, 0.3056008793567194, 0.20647340374266965, 0.18668035347119405, 0.18662870206187765, 0.1910866528182813, 0.1737609800418466, 0.18342421113073892, 0.18095999465849633, 0.18209986213410334, 0.18226178102484236, 0.19920673463126004, 0.08091199496498325, 0.0793160022754017, 0.08165679963458583, 0.07024776755536966, 0.07791198908086994, 0.07437930704847528, 0.07175450397776972, 0.07103254713700813, 0.06764433138809]}, "mutation_prompt": null}
{"id": "2477b36a-0380-4bf4-b621-bde55e3d5ddf", "solution": "import numpy as np\n\nclass SynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDE", "description": "Synergistic Differential Evolution with Adaptive Memory and Dynamic Niching optimizes black box functions by combining memory-based adaptation and niche preservation techniques.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.6903554453160837, 0.7062140570939492, 0.7291272372121838, 0.7496531622640143, 0.7229750455763522, 0.7141654852694004, 0.7326623915980632, 0.7095395915216246, 0.7182737898806518, 0.5394973254568955, 0.5116008720523528, 0.5536448919350395, 0.5258056406121385, 0.505870684574923, 0.5128285293611541, 0.5511064860420416, 0.518074489466418, 0.5186340311723445, 0.0956866868655627, 0.09588280728608845, 0.11865693166517577, 0.09395457427096754, 0.09947325464660839, 0.10612506548115164, 0.09554926140462561, 0.09313112108841692, 0.10503330945679223, 0.10667952083081922, 0.09657800485103474, 0.0885529156753111, 0.10107482009655211, 0.08817428395775606, 0.09179270912462689, 0.09112276580897538, 0.09307216699331078, 0.08566776449240099, 0.9185419803579278, 0.916395676840551, 0.9459083781361276, 0.9145179707573869, 0.9633186458764924, 0.935500805995964, 0.9558240649595785, 0.9368763173269852, 0.9164887256612223, 0.3650136380026956, 0.3516171411778294, 0.3479097916268351, 0.3502741127053216, 0.3789762531707914, 0.37424497825848313, 0.3632922992673302, 0.36233776672826934, 0.3656320406890238, 0.6742254543151591, 0.6430409472456828, 0.6803675206548051, 0.6139158976014192, 0.6971268452721571, 0.652493446975426, 0.6737442250239498, 0.7079689701000293, 0.6724174924938003, 0.2529075279114523, 0.2667553404717051, 0.30005311277995683, 0.24755010207030792, 0.2845667084218033, 0.2585498664216668, 0.2974377273927191, 0.3255742605211347, 0.25654200168252383, 0.02153928667202276, 0.3998992301683032, 0.17234097756081668, 0.2845206746020925, 0.29606881917483885, 0.31200423335003125, 0.2993509220018271, 0.1810768377336266, 0.24225391371975813, 0.21289504626449596, 0.21147503032844894, 0.1856932759922605, 0.24486553034955516, 0.16754834650185824, 0.18648495762529382, 0.23060362922130995, 0.2186193834766812, 0.1964535300145429, 0.3122562267360518, 0.32381678632612887, 0.33556860450918324, 0.3790799939315087, 0.2679458078813285, 0.3665018314502506, 0.33114561273105725, 0.3986556921466081, 0.38561565971782696, 0.05756330716104785, 0.08651764605365553, 0.056192712267945755, 0.12233018884200397, 0.07653294629768659, 0.11350876714719438, 0.08485140987574236, 0.0759530639620567, 0.09352661838448073, 0.23142887351909514, 0.18908747138859427, 0.21814286921303871, 0.2017166995861176, 0.2152478473517765, 0.2264846743386968, 0.23880302134872577, 0.2103972523484443, 0.2079022838454394, 0.5994692872506202, 0.5684370235900764, 0.5542972681004366, 0.567802172144463, 0.585938982356851, 0.5709748444032167, 0.5932570310400422, 0.5654091986602909, 0.6090866421569159, 0.10006844335387777, 0.09773754860696537, 0.08872193377344595, 0.08128994414258595, 0.08583489723622284, 0.10016810862193759, 0.09170641362088827, 0.0873138842623492, 0.09613918465934423, 0.12772776004930908, 0.13859438794144885, 0.16021001631662235, 0.15301558054316888, 0.1435397881020084, 0.17364001943741603, 0.16934093372531, 0.1398207050330793, 0.13142249719523003, 0.29831475030077725, 0.3102221466048779, 0.32678549685472125, 0.28664781956007734, 0.30802431954496656, 0.28768016161963783, 0.3111661309998276, 0.35300001316709584, 0.3359718608636809, 0.2258595161494703, 0.2239963487953649, 0.2569166731066642, 0.2039962827645948, 0.24818990955989995, 0.21647840207632751, 0.25963676797610724, 0.2806754081518057, 0.258558735687059, 0.17244012639435546, 0.18485549226893805, 0.18482911081223796, 0.1996147831101306, 0.18367631466184398, 0.19235521853238313, 0.20244121331868914, 0.199803892149917, 0.1692727372863363, 0.18412767042787148, 0.19467425586961706, 0.17951981055765298, 0.17478809654549787, 0.17779010567395215, 0.18201892634179928, 0.18417237330339964, 0.18453935386353937, 0.1873078015795675, 0.16683399551169553, 0.7052894218031935, 0.5670746047070372, 0.25967951969375047, 0.1812123650259546, 0.6262635503477143, 0.43420539771754163, 0.3041105554124153, 0.5207407021262169, 0.5558579752687152, 0.16590017446203276, 0.19486476505031436, 0.1881302257665648, 0.19762083753542636, 0.1863946366975443, 0.20676708529634813, 0.14895083983503332, 0.209989394339548, 0.1840329236282845, 0.1757582120820611, 0.19034494336587648, 0.18096776063436737, 0.1894001925916987, 0.2004083197116201, 0.183029933840269, 0.18897366625294076, 0.17861649236742272, 0.07405543652559898, 0.0764573738894131, 0.07058264417974536, 0.06667599934317292, 0.06765795710769218, 0.07429336638591544, 0.07278750158030145, 0.08107631680691607, 0.06909450930993077]}, "mutation_prompt": null}
{"id": "02d8a529-d608-4f9a-b77a-4e50537744c5", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = self.orthogonal_initialization()\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def orthogonal_initialization(self):\n        base_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        orthogonal_matrix = np.linalg.qr(np.random.randn(self.dim, self.dim))[0]\n        orthogonal_population = np.dot(base_population, orthogonal_matrix)\n        return np.clip(orthogonal_population, self.lower_bound, self.upper_bound)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def orthogonal_exploration(self, idx):\n        orthogonal_vector = np.random.randn(self.dim)\n        orthogonal_vector /= np.linalg.norm(orthogonal_vector)\n        step_size = np.random.uniform(0.1, 0.5) * (self.upper_bound - self.lower_bound)\n        exploration_point = self.population[idx] + step_size * orthogonal_vector\n        return np.clip(exploration_point, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                if np.random.rand() < 0.2:  # 20% chance of orthogonal exploration\n                    trial = self.orthogonal_exploration(i)\n                else:\n                    mutant = self.mutate(i)\n                    trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Memory, Dynamic Niching, and Orthogonal Exploration enhances solution quality by combining synergistic strategies with orthogonal initialization and exploration.", "configspace": "", "generation": 24, "fitness": 0.27803488431967543, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.6313064661954851, 0.6705746189988766, 0.6420990477839454, 0.6405135929687704, 0.6555410021631215, 0.6728991858463054, 0.6476562019811145, 0.6580491416307986, 0.648996964543346, 0.4190653863554227, 0.41277218575614993, 0.3845066614899951, 0.374971467336185, 0.3947354271887802, 0.39378644258925, 0.39934297769589255, 0.42054340937870704, 0.4010721519350411, 0.09484787064299194, 0.0916891343980587, 0.08682816427958406, 0.09326263707586735, 0.09426525732857394, 0.09863804555408784, 0.1222590220166434, 0.11860083067657812, 0.10235166648731697, 0.08321361487987577, 0.09718110424905213, 0.09380986765142696, 0.11418750958213186, 0.10561810577156261, 0.08517566953808364, 0.09890448519278072, 0.08143273438899523, 0.08938849406991434, 0.9462165856790303, 0.9407558293254481, 0.919068944593513, 0.9456130317776332, 0.9547836780025605, 0.9332703461922602, 0.9467494150822284, 0.9516693691392879, 0.9574716375939694, 0.29600711122569767, 0.3032901858215882, 0.2776084722352311, 0.31579611519177364, 0.2979753980880099, 0.2716833079825819, 0.29683317697571676, 0.30514187755510025, 0.2957387277681719, 0.5375994799157575, 0.5881386891627983, 0.5915549763879933, 0.6601832021636355, 0.5619029235528837, 0.5127681249488644, 0.5229351651427638, 0.5783229513406769, 0.607919130539905, 0.21253955906141997, 0.20952133427749642, 0.22819619463823915, 0.23145327690522166, 0.1380589012046194, 0.18295553449863877, 0.2175346364896864, 0.22571697325557616, 0.21670559312259918, 0.21013790334715532, 0.16209137847651967, 0.11039818576394134, 0.17398333674916944, 0.1572009770594257, 0.19304953675517256, 0.18508085313576728, 0.19804212380922703, 0.17252233971290387, 0.14408058580887173, 0.1787415451588582, 0.1357997279100357, 0.19404479852495737, 0.1528740756007344, 0.14436308553638355, 0.1794720584501931, 0.15075472961765868, 0.13659980437029628, 0.34460754215478573, 0.28162372890204646, 0.28638574892312996, 0.23180097086306772, 0.24229543129615527, 0.2786635594650734, 0.31063327929042583, 0.280371085161204, 0.31450499384526476, 0.0625196111677524, 0.03139478664445827, 0.01794268942422972, 0.032536189926865466, 0.04080549351799467, 0.052534106358530175, 0.053487872923673185, 0.0915161371114025, 0.03571987613645433, 0.17505990853359654, 0.1731436432954372, 0.15040726310617847, 0.16805875205454301, 0.1887934542896974, 0.18896132567594848, 0.16265682584203311, 0.15713435009802834, 0.17187721313748605, 0.528461779956047, 0.4943974237756261, 0.5101071799338992, 0.490828742790713, 0.49875330296604203, 0.5133160925863826, 0.5072885726645898, 0.5419458779589539, 0.5169942248968078, 0.07630912024073966, 0.09837528475077484, 0.08707160875452191, 0.08982868687616796, 0.090877113074875, 0.09221304016781195, 0.0828839585472515, 0.08510579881035896, 0.09343438105816437, 0.15112527121361397, 0.14452887776938061, 0.17166462434717356, 0.1425518841061345, 0.1416033003178454, 0.19715635431638956, 0.13222487446757336, 0.1438612678662886, 0.1402976012239695, 0.29201850220362835, 0.2848257448660422, 0.3026175752707493, 0.2684935271019372, 0.26228910647999537, 0.29008391189264204, 0.2983500587744028, 0.30098727354460975, 0.2944648746336498, 0.20984320268773637, 0.21263404807543862, 0.22561193572381666, 0.2035837047721608, 0.2003280370964381, 0.20547356450275356, 0.22725224100468622, 0.23645357009914336, 0.23612001086584244, 0.19003187662078602, 0.1744797567799805, 0.18289461648843697, 0.16692493552105914, 0.18045858145161897, 0.18071230868037214, 0.1804544201698033, 0.18321658399228913, 0.21910846213028767, 0.1836082997909383, 0.18959114655328302, 0.1800424884291848, 0.18444817315570605, 0.17355336040943825, 0.18680139966304732, 0.17686761606656476, 0.1735638760540973, 0.17914541160146014, 0.5453904367847953, 0.5103229847827155, 0.5007150148268416, 0.48039675896902334, 0.180481472875906, 0.33919135850414683, 0.5133916278839044, 0.286594507779963, 0.5399835316124046, 0.5934962367746087, 0.1900482438121066, 0.19431339341636378, 0.3015865886450624, 0.18066829568338527, 0.32361575555111655, 0.20601187011716293, 0.14460977961620614, 0.19514373835746057, 0.18312229628290622, 0.17665830149323025, 0.18933024573202295, 0.1897051479930637, 0.17869832174024836, 0.1863738674612102, 0.19299958857047683, 0.19419191956303472, 0.20097230621749806, 0.06815313498408226, 0.06981224064004221, 0.07075817720421151, 0.07146225438611842, 0.07013905170125401, 0.06502537197054425, 0.06488401431712665, 0.06973857951890405, 0.08256886129660723]}, "mutation_prompt": null}
{"id": "ff92c36a-de41-4c6d-aa3b-8d9b8265490f", "solution": "import numpy as np\n\nclass SynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDE", "description": "Synergistic Differential Evolution with Adaptive Memory and Dynamic Niching optimizes black box functions by combining memory-based adaptation and niche preservation techniques.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.6903554453160837, 0.7062140570939492, 0.7291272372121838, 0.7496531622640143, 0.7229750455763522, 0.7141654852694004, 0.7326623915980632, 0.7095395915216246, 0.7182737898806518, 0.5394973254568955, 0.5116008720523528, 0.5536448919350395, 0.5258056406121385, 0.505870684574923, 0.5128285293611541, 0.5511064860420416, 0.518074489466418, 0.5186340311723445, 0.0956866868655627, 0.09588280728608845, 0.11865693166517577, 0.09395457427096754, 0.09947325464660839, 0.10612506548115164, 0.09554926140462561, 0.09313112108841692, 0.10503330945679223, 0.10667952083081922, 0.09657800485103474, 0.0885529156753111, 0.10107482009655211, 0.08817428395775606, 0.09179270912462689, 0.09112276580897538, 0.09307216699331078, 0.08566776449240099, 0.9185419803579278, 0.916395676840551, 0.9459083781361276, 0.9145179707573869, 0.9633186458764924, 0.935500805995964, 0.9558240649595785, 0.9368763173269852, 0.9164887256612223, 0.3650136380026956, 0.3516171411778294, 0.3479097916268351, 0.3502741127053216, 0.3789762531707914, 0.37424497825848313, 0.3632922992673302, 0.36233776672826934, 0.3656320406890238, 0.6742254543151591, 0.6430409472456828, 0.6803675206548051, 0.6139158976014192, 0.6971268452721571, 0.652493446975426, 0.6737442250239498, 0.7079689701000293, 0.6724174924938003, 0.2529075279114523, 0.2667553404717051, 0.30005311277995683, 0.24755010207030792, 0.2845667084218033, 0.2585498664216668, 0.2974377273927191, 0.3255742605211347, 0.25654200168252383, 0.02153928667202276, 0.3998992301683032, 0.17234097756081668, 0.2845206746020925, 0.29606881917483885, 0.31200423335003125, 0.2993509220018271, 0.1810768377336266, 0.24225391371975813, 0.21289504626449596, 0.21147503032844894, 0.1856932759922605, 0.24486553034955516, 0.16754834650185824, 0.18648495762529382, 0.23060362922130995, 0.2186193834766812, 0.1964535300145429, 0.3122562267360518, 0.32381678632612887, 0.33556860450918324, 0.3790799939315087, 0.2679458078813285, 0.3665018314502506, 0.33114561273105725, 0.3986556921466081, 0.38561565971782696, 0.05756330716104785, 0.08651764605365553, 0.056192712267945755, 0.12233018884200397, 0.07653294629768659, 0.11350876714719438, 0.08485140987574236, 0.0759530639620567, 0.09352661838448073, 0.23142887351909514, 0.18908747138859427, 0.21814286921303871, 0.2017166995861176, 0.2152478473517765, 0.2264846743386968, 0.23880302134872577, 0.2103972523484443, 0.2079022838454394, 0.5994692872506202, 0.5684370235900764, 0.5542972681004366, 0.567802172144463, 0.585938982356851, 0.5709748444032167, 0.5932570310400422, 0.5654091986602909, 0.6090866421569159, 0.10006844335387777, 0.09773754860696537, 0.08872193377344595, 0.08128994414258595, 0.08583489723622284, 0.10016810862193759, 0.09170641362088827, 0.0873138842623492, 0.09613918465934423, 0.12772776004930908, 0.13859438794144885, 0.16021001631662235, 0.15301558054316888, 0.1435397881020084, 0.17364001943741603, 0.16934093372531, 0.1398207050330793, 0.13142249719523003, 0.29831475030077725, 0.3102221466048779, 0.32678549685472125, 0.28664781956007734, 0.30802431954496656, 0.28768016161963783, 0.3111661309998276, 0.35300001316709584, 0.3359718608636809, 0.2258595161494703, 0.2239963487953649, 0.2569166731066642, 0.2039962827645948, 0.24818990955989995, 0.21647840207632751, 0.25963676797610724, 0.2806754081518057, 0.258558735687059, 0.17244012639435546, 0.18485549226893805, 0.18482911081223796, 0.1996147831101306, 0.18367631466184398, 0.19235521853238313, 0.20244121331868914, 0.199803892149917, 0.1692727372863363, 0.18412767042787148, 0.19467425586961706, 0.17951981055765298, 0.17478809654549787, 0.17779010567395215, 0.18201892634179928, 0.18417237330339964, 0.18453935386353937, 0.1873078015795675, 0.16683399551169553, 0.7052894218031935, 0.5670746047070372, 0.25967951969375047, 0.1812123650259546, 0.6262635503477143, 0.43420539771754163, 0.3041105554124153, 0.5207407021262169, 0.5558579752687152, 0.16590017446203276, 0.19486476505031436, 0.1881302257665648, 0.19762083753542636, 0.1863946366975443, 0.20676708529634813, 0.14895083983503332, 0.209989394339548, 0.1840329236282845, 0.1757582120820611, 0.19034494336587648, 0.18096776063436737, 0.1894001925916987, 0.2004083197116201, 0.183029933840269, 0.18897366625294076, 0.17861649236742272, 0.07405543652559898, 0.0764573738894131, 0.07058264417974536, 0.06667599934317292, 0.06765795710769218, 0.07429336638591544, 0.07278750158030145, 0.08107631680691607, 0.06909450930993077]}, "mutation_prompt": null}
{"id": "b67db05f-dba1-426a-9541-58f1f41f03ed", "solution": "import numpy as np\n\nclass QuantumSynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def quantum_superposition(self):\n        superposition_states = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        for i in range(self.population_size):\n            if np.random.rand() < 0.1:  # Quantum effect probability\n                self.population[i] += superposition_states[i] * (self.upper_bound - self.lower_bound) * 0.05\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            self.quantum_superposition()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "QuantumSynergisticDE", "description": "Quantum-Inspired Synergistic Differential Evolution introduces quantum computing principles to enhance exploration and exploitation in evolutionary search processes.", "configspace": "", "generation": 26, "fitness": 0.17418668232135276, "feedback": "The algorithm QuantumSynergisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.32793727736058276, 0.35054734311191404, 0.3168535530044966, 0.3396853368810566, 0.3597224816511876, 0.3813077767232911, 0.3162150942927321, 0.3728107068898193, 0.33246381640819056, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.086353689821564, 0.0863404875835615, 0.08331695427042396, 0.07521143182344514, 0.09391015802807834, 0.08129158856023588, 0.08889079384503729, 0.08581991646601295, 0.08837061727480777, 0.07085138169863181, 0.06771845405215549, 0.0673589048911537, 0.07573808154756534, 0.06986190265538295, 0.07467253038144495, 0.07003949498340312, 0.06556435814233208, 0.0779383951246766, 0.9256710559647576, 0.9570718754604332, 0.9064039154794487, 0.9610444439912094, 0.9391351907634372, 0.9178560581612256, 0.9212831529269466, 0.8969889916053777, 0.9027865147714982, 0.15698672941433012, 0.18253520980175597, 0.16649399557601807, 0.16663704369767895, 0.19519010212064436, 0.1829749887361889, 0.1880317368730834, 0.17402089259274822, 0.1743860968843115, 0.21452598306104287, 0.206477352765159, 0.2092610146958167, 0.2577129652340243, 0.2418709163381998, 0.2798302703115896, 0.2400278373947231, 0.24983519940773713, 0.24171347257421416, 0.10976077433595965, 0.11878666285219408, 0.13008096154913962, 0.10969755183660113, 0.0983680184937421, 0.10821877165944882, 0.12199140408005404, 0.11271923973595732, 0.10578223908778295, 0.08425715179734328, 0.10331795711579284, 0.08734103431371754, 0.14858368625810525, 0.10261754759998243, 0.11440061746465313, 0.09785111230480725, 0.09963137301715597, 0.1299495234360578, 9.999999999998899e-05, 0.009712678121660212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06157492268706122, 0.05616311615944414, 0.06372034357453082, 0.0339355113398675, 0.06556030998654805, 0.0591948875425824, 0.09033155382313052, 0.06559255225938354, 0.07902594586965783, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041235571443915764, 0.05874677357264879, 0.04462776255790124, 0.0450517289204001, 0.055320477845716254, 0.06228331220677352, 0.08299432550852215, 0.06550947827646292, 0.043225628256086, 0.31667776166033734, 0.31381259766413505, 0.3193449706628435, 0.345109654577037, 0.36532241341807825, 0.32303507488016525, 0.3180120798306586, 0.3105232823406534, 0.32429712489390927, 0.09655808901681973, 0.07966355667291669, 0.08977315778684059, 0.09014145988106503, 0.07665570529441845, 0.08634101535313543, 0.09774972343898858, 0.08521749107379017, 0.09814799748078817, 0.1404869530727867, 0.1499134259847955, 0.15221584560096146, 0.1597114736413141, 0.13126991201447513, 0.12975782969719463, 0.15955318800300378, 0.16898796013705908, 0.14172413634773895, 0.23091708043196124, 0.22377069987914178, 0.23060807237073688, 0.22168457329357427, 0.21924489266036506, 0.23636504973276684, 0.22373183991280987, 0.24078141393701136, 0.2307271689088637, 0.17286442122521584, 0.1694993761348984, 0.16917494538877087, 0.16968333661460477, 0.1695826911095426, 0.15200672413248995, 0.16836337136291346, 0.16613002221055906, 0.16967427481399933, 0.18257752583610432, 0.19511405462893205, 0.17742753164058755, 0.18637119678310132, 0.20248175054170614, 0.1652768471004218, 0.1792563269565851, 0.1782100524949648, 0.20970026376607076, 0.1908425311294525, 0.170869466185382, 0.19192608917528176, 0.17296777588355838, 0.17081289377484077, 0.17040143548133124, 0.16872917609556204, 0.1807010321608381, 0.16804621542073894, 0.16627988769668023, 0.3657757900062193, 0.14968946007992578, 0.17809707302990807, 0.16516195982238058, 0.15389673791919045, 0.1871850247435023, 0.22875840325820596, 0.2531942070715498, 0.20549632415882535, 0.16409057939892868, 0.19431825812347547, 0.2997970249307247, 0.16943245899236503, 0.1823998053261352, 0.20905958975398564, 0.30423749546445156, 0.20428122088495337, 0.18594226584296492, 0.18040746622823078, 0.18772397592341117, 0.17458687449882837, 0.1886323512089051, 0.19835126076813803, 0.17834320882316756, 0.19213520628610126, 0.18043463985352826, 0.06793820972115061, 0.07590514339689214, 0.06503705507282043, 0.07126269205529967, 0.06770182747515119, 0.07921460363382138, 0.07484607406988342, 0.07880407766042918, 0.0660711076629068]}, "mutation_prompt": null}
{"id": "2a20d9c7-876a-4f81-98c0-cc5f2f9defc7", "solution": "import numpy as np\n\nclass SynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDE", "description": "Synergistic Differential Evolution with Adaptive Memory and Dynamic Niching optimizes black box functions by combining memory-based adaptation and niche preservation techniques.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.6903554453160837, 0.7062140570939492, 0.7291272372121838, 0.7496531622640143, 0.7229750455763522, 0.7141654852694004, 0.7326623915980632, 0.7095395915216246, 0.7182737898806518, 0.5394973254568955, 0.5116008720523528, 0.5536448919350395, 0.5258056406121385, 0.505870684574923, 0.5128285293611541, 0.5511064860420416, 0.518074489466418, 0.5186340311723445, 0.0956866868655627, 0.09588280728608845, 0.11865693166517577, 0.09395457427096754, 0.09947325464660839, 0.10612506548115164, 0.09554926140462561, 0.09313112108841692, 0.10503330945679223, 0.10667952083081922, 0.09657800485103474, 0.0885529156753111, 0.10107482009655211, 0.08817428395775606, 0.09179270912462689, 0.09112276580897538, 0.09307216699331078, 0.08566776449240099, 0.9185419803579278, 0.916395676840551, 0.9459083781361276, 0.9145179707573869, 0.9633186458764924, 0.935500805995964, 0.9558240649595785, 0.9368763173269852, 0.9164887256612223, 0.3650136380026956, 0.3516171411778294, 0.3479097916268351, 0.3502741127053216, 0.3789762531707914, 0.37424497825848313, 0.3632922992673302, 0.36233776672826934, 0.3656320406890238, 0.6742254543151591, 0.6430409472456828, 0.6803675206548051, 0.6139158976014192, 0.6971268452721571, 0.652493446975426, 0.6737442250239498, 0.7079689701000293, 0.6724174924938003, 0.2529075279114523, 0.2667553404717051, 0.30005311277995683, 0.24755010207030792, 0.2845667084218033, 0.2585498664216668, 0.2974377273927191, 0.3255742605211347, 0.25654200168252383, 0.02153928667202276, 0.3998992301683032, 0.17234097756081668, 0.2845206746020925, 0.29606881917483885, 0.31200423335003125, 0.2993509220018271, 0.1810768377336266, 0.24225391371975813, 0.21289504626449596, 0.21147503032844894, 0.1856932759922605, 0.24486553034955516, 0.16754834650185824, 0.18648495762529382, 0.23060362922130995, 0.2186193834766812, 0.1964535300145429, 0.3122562267360518, 0.32381678632612887, 0.33556860450918324, 0.3790799939315087, 0.2679458078813285, 0.3665018314502506, 0.33114561273105725, 0.3986556921466081, 0.38561565971782696, 0.05756330716104785, 0.08651764605365553, 0.056192712267945755, 0.12233018884200397, 0.07653294629768659, 0.11350876714719438, 0.08485140987574236, 0.0759530639620567, 0.09352661838448073, 0.23142887351909514, 0.18908747138859427, 0.21814286921303871, 0.2017166995861176, 0.2152478473517765, 0.2264846743386968, 0.23880302134872577, 0.2103972523484443, 0.2079022838454394, 0.5994692872506202, 0.5684370235900764, 0.5542972681004366, 0.567802172144463, 0.585938982356851, 0.5709748444032167, 0.5932570310400422, 0.5654091986602909, 0.6090866421569159, 0.10006844335387777, 0.09773754860696537, 0.08872193377344595, 0.08128994414258595, 0.08583489723622284, 0.10016810862193759, 0.09170641362088827, 0.0873138842623492, 0.09613918465934423, 0.12772776004930908, 0.13859438794144885, 0.16021001631662235, 0.15301558054316888, 0.1435397881020084, 0.17364001943741603, 0.16934093372531, 0.1398207050330793, 0.13142249719523003, 0.29831475030077725, 0.3102221466048779, 0.32678549685472125, 0.28664781956007734, 0.30802431954496656, 0.28768016161963783, 0.3111661309998276, 0.35300001316709584, 0.3359718608636809, 0.2258595161494703, 0.2239963487953649, 0.2569166731066642, 0.2039962827645948, 0.24818990955989995, 0.21647840207632751, 0.25963676797610724, 0.2806754081518057, 0.258558735687059, 0.17244012639435546, 0.18485549226893805, 0.18482911081223796, 0.1996147831101306, 0.18367631466184398, 0.19235521853238313, 0.20244121331868914, 0.199803892149917, 0.1692727372863363, 0.18412767042787148, 0.19467425586961706, 0.17951981055765298, 0.17478809654549787, 0.17779010567395215, 0.18201892634179928, 0.18417237330339964, 0.18453935386353937, 0.1873078015795675, 0.16683399551169553, 0.7052894218031935, 0.5670746047070372, 0.25967951969375047, 0.1812123650259546, 0.6262635503477143, 0.43420539771754163, 0.3041105554124153, 0.5207407021262169, 0.5558579752687152, 0.16590017446203276, 0.19486476505031436, 0.1881302257665648, 0.19762083753542636, 0.1863946366975443, 0.20676708529634813, 0.14895083983503332, 0.209989394339548, 0.1840329236282845, 0.1757582120820611, 0.19034494336587648, 0.18096776063436737, 0.1894001925916987, 0.2004083197116201, 0.183029933840269, 0.18897366625294076, 0.17861649236742272, 0.07405543652559898, 0.0764573738894131, 0.07058264417974536, 0.06667599934317292, 0.06765795710769218, 0.07429336638591544, 0.07278750158030145, 0.08107631680691607, 0.06909450930993077]}, "mutation_prompt": null}
{"id": "3346bd3f-c19b-4ce3-ba29-e02e2ac2e7c5", "solution": "import numpy as np\n\nclass SynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "SynergisticDE", "description": "Synergistic Differential Evolution with Adaptive Memory and Dynamic Niching optimizes black box functions by combining memory-based adaptation and niche preservation techniques.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.6903554453160837, 0.7062140570939492, 0.7291272372121838, 0.7496531622640143, 0.7229750455763522, 0.7141654852694004, 0.7326623915980632, 0.7095395915216246, 0.7182737898806518, 0.5394973254568955, 0.5116008720523528, 0.5536448919350395, 0.5258056406121385, 0.505870684574923, 0.5128285293611541, 0.5511064860420416, 0.518074489466418, 0.5186340311723445, 0.0956866868655627, 0.09588280728608845, 0.11865693166517577, 0.09395457427096754, 0.09947325464660839, 0.10612506548115164, 0.09554926140462561, 0.09313112108841692, 0.10503330945679223, 0.10667952083081922, 0.09657800485103474, 0.0885529156753111, 0.10107482009655211, 0.08817428395775606, 0.09179270912462689, 0.09112276580897538, 0.09307216699331078, 0.08566776449240099, 0.9185419803579278, 0.916395676840551, 0.9459083781361276, 0.9145179707573869, 0.9633186458764924, 0.935500805995964, 0.9558240649595785, 0.9368763173269852, 0.9164887256612223, 0.3650136380026956, 0.3516171411778294, 0.3479097916268351, 0.3502741127053216, 0.3789762531707914, 0.37424497825848313, 0.3632922992673302, 0.36233776672826934, 0.3656320406890238, 0.6742254543151591, 0.6430409472456828, 0.6803675206548051, 0.6139158976014192, 0.6971268452721571, 0.652493446975426, 0.6737442250239498, 0.7079689701000293, 0.6724174924938003, 0.2529075279114523, 0.2667553404717051, 0.30005311277995683, 0.24755010207030792, 0.2845667084218033, 0.2585498664216668, 0.2974377273927191, 0.3255742605211347, 0.25654200168252383, 0.02153928667202276, 0.3998992301683032, 0.17234097756081668, 0.2845206746020925, 0.29606881917483885, 0.31200423335003125, 0.2993509220018271, 0.1810768377336266, 0.24225391371975813, 0.21289504626449596, 0.21147503032844894, 0.1856932759922605, 0.24486553034955516, 0.16754834650185824, 0.18648495762529382, 0.23060362922130995, 0.2186193834766812, 0.1964535300145429, 0.3122562267360518, 0.32381678632612887, 0.33556860450918324, 0.3790799939315087, 0.2679458078813285, 0.3665018314502506, 0.33114561273105725, 0.3986556921466081, 0.38561565971782696, 0.05756330716104785, 0.08651764605365553, 0.056192712267945755, 0.12233018884200397, 0.07653294629768659, 0.11350876714719438, 0.08485140987574236, 0.0759530639620567, 0.09352661838448073, 0.23142887351909514, 0.18908747138859427, 0.21814286921303871, 0.2017166995861176, 0.2152478473517765, 0.2264846743386968, 0.23880302134872577, 0.2103972523484443, 0.2079022838454394, 0.5994692872506202, 0.5684370235900764, 0.5542972681004366, 0.567802172144463, 0.585938982356851, 0.5709748444032167, 0.5932570310400422, 0.5654091986602909, 0.6090866421569159, 0.10006844335387777, 0.09773754860696537, 0.08872193377344595, 0.08128994414258595, 0.08583489723622284, 0.10016810862193759, 0.09170641362088827, 0.0873138842623492, 0.09613918465934423, 0.12772776004930908, 0.13859438794144885, 0.16021001631662235, 0.15301558054316888, 0.1435397881020084, 0.17364001943741603, 0.16934093372531, 0.1398207050330793, 0.13142249719523003, 0.29831475030077725, 0.3102221466048779, 0.32678549685472125, 0.28664781956007734, 0.30802431954496656, 0.28768016161963783, 0.3111661309998276, 0.35300001316709584, 0.3359718608636809, 0.2258595161494703, 0.2239963487953649, 0.2569166731066642, 0.2039962827645948, 0.24818990955989995, 0.21647840207632751, 0.25963676797610724, 0.2806754081518057, 0.258558735687059, 0.17244012639435546, 0.18485549226893805, 0.18482911081223796, 0.1996147831101306, 0.18367631466184398, 0.19235521853238313, 0.20244121331868914, 0.199803892149917, 0.1692727372863363, 0.18412767042787148, 0.19467425586961706, 0.17951981055765298, 0.17478809654549787, 0.17779010567395215, 0.18201892634179928, 0.18417237330339964, 0.18453935386353937, 0.1873078015795675, 0.16683399551169553, 0.7052894218031935, 0.5670746047070372, 0.25967951969375047, 0.1812123650259546, 0.6262635503477143, 0.43420539771754163, 0.3041105554124153, 0.5207407021262169, 0.5558579752687152, 0.16590017446203276, 0.19486476505031436, 0.1881302257665648, 0.19762083753542636, 0.1863946366975443, 0.20676708529634813, 0.14895083983503332, 0.209989394339548, 0.1840329236282845, 0.1757582120820611, 0.19034494336587648, 0.18096776063436737, 0.1894001925916987, 0.2004083197116201, 0.183029933840269, 0.18897366625294076, 0.17861649236742272, 0.07405543652559898, 0.0764573738894131, 0.07058264417974536, 0.06667599934317292, 0.06765795710769218, 0.07429336638591544, 0.07278750158030145, 0.08107631680691607, 0.06909450930993077]}, "mutation_prompt": null}
{"id": "b0a8861b-53c7-4c3e-ad00-45c22f1c08f2", "solution": "import numpy as np\n\nclass OptimizedSynergisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Initial differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.niches = np.random.uniform(self.lower_bound, self.upper_bound, (5, dim))\n        self.niche_radius = 1.0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b = np.random.choice(indices, 2, replace=False)\n        mutant = self.population[idx] + self.f * (self.population[best_idx] - self.population[idx]) + self.f * (self.population[a] - self.population[b])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self, generation):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        oscillation_factor = (1 + np.cos(2 * np.pi * generation / 50)) / 2\n        self.f = 0.6 + 0.2 * oscillation_factor\n\n    def dynamic_niche_preservation(self):\n        for idx in range(self.population_size):\n            distances = np.linalg.norm(self.niches - self.population[idx], axis=1)\n            if np.any(distances < self.niche_radius):\n                self.population[idx] += np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n\n    def fitness_based_scaling(self):\n        sorted_indices = np.argsort(self.population_values)\n        best_idx = sorted_indices[0]\n        worst_idx = sorted_indices[-1]\n        fitness_range = self.population_values[worst_idx] - self.population_values[best_idx]\n        if fitness_range != 0:\n            scaled_f = (self.population_values[worst_idx] - self.population_values) / fitness_range\n            self.f = 0.5 + 0.5 * scaled_f\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params(generation)\n            self.dynamic_niche_preservation()\n            self.fitness_based_scaling()\n            best_idx = np.argmin(self.population_values)\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                mutant = self.mutate(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            generation += 1\n        return self.best_solution", "name": "OptimizedSynergisticDE", "description": "Optimized Synergistic Differential Evolution with Adaptive Memory, Dynamic Niching, and Fitness-Based Adaptive Scaling, enhancing convergence by refining mutation strategies and parameter adaptation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,) (5,) ')", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {}, "mutation_prompt": null}
{"id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.3282607130728184, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "e972e5a1-b24c-4d43-b69d-7b9fe8724fb5", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "866a0d62-d740-4bb6-8892-920caea72ee5", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "a726822f-2d82-43f0-931d-9c799db4dfc3", "solution": "import numpy as np\n\nclass QuantumSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            direction = np.random.uniform(-1, 1, self.dim)\n            self.population[idx] = self.population[idx] + direction * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def swarm_update(self):\n        for i in range(self.population_size):\n            social_coefficient = np.random.rand() * 0.3\n            cognitive_coefficient = np.random.rand() * 0.3\n            inertia_weight = 0.7\n            new_velocity = inertia_weight * (self.population[i] - self.global_best) + \\\n                           cognitive_coefficient * (self.best_solution - self.population[i]) + \\\n                           social_coefficient * (self.global_best - self.population[i])\n            self.population[i] = np.clip(self.population[i] + new_velocity, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.swarm_update()\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "QuantumSwarmDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Swarm Dynamics enhances AQDE by integrating swarm intelligence principles for improved exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 32, "fitness": 0.2126608486578311, "feedback": "The algorithm QuantumSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.4955303433426763, 0.41791763043252383, 0.4229310827553835, 0.5225598726101992, 0.47806616852074924, 0.45974679277259844, 0.4729197430258809, 0.4441716507281437, 0.46796156358096175, 0.1888347762188347, 0.18869560410396802, 0.19824288220309771, 0.20653597574084193, 0.18226387211342177, 0.21330095342807043, 0.1993989316587188, 0.17971171473830727, 0.16376237951347083, 0.11089228538548945, 0.1033641284469462, 0.10246993522874126, 0.11332522426653946, 0.08761207323031162, 0.11397029876692066, 0.09645706341408278, 0.08868346747217581, 0.08487801150086494, 0.0759435565110318, 0.09325656942939242, 0.09912989179189169, 0.10029555598061268, 0.09961714070335315, 0.08369157388163917, 0.09173552632030701, 0.10218902076329128, 0.09906783684499165, 0.9227207751242252, 0.909576833551981, 0.9557811221556778, 0.9099920376250297, 0.9310900336831804, 0.9561251570060797, 0.8912801002949016, 0.9381930521254342, 0.9272867637818639, 0.24165314078266809, 0.20153355714852172, 0.2278063724920013, 0.24470316462992414, 0.22128245951996328, 0.2857722454277045, 0.23575965052271863, 0.23474195389255148, 0.23023317551333033, 0.24543692515559157, 0.26030842199221893, 0.2721362598435737, 0.5514214110295949, 0.44330449408687067, 0.48541355148083354, 0.39050928202737656, 0.26106716428121035, 0.35933925297273295, 0.15511454419104664, 0.1254364350515641, 0.21207720331559043, 0.12190839197281966, 0.12517157493632025, 0.13896933031488878, 0.1357979454190088, 0.15096032905999968, 0.1325884975564321, 0.1487212381448173, 0.09830456339845473, 0.10299346432707257, 0.131683504265095, 0.1649433754221198, 0.13917861096037687, 0.14263082647026115, 0.13292778735849242, 0.12997326431100176, 0.02178233887544956, 0.016722472888166195, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004918344448706646, 9.999999999998899e-05, 0.025033865913924647, 9.999999999998899e-05, 0.0015467804996668333, 0.11892245224325049, 0.06592713866833566, 0.12448118185626189, 0.07708335924902532, 0.07648202136530868, 0.04081979509844513, 0.10493112948757954, 0.11397919398768919, 0.05166909081331372, 0.01120577623662744, 0.005730693779467777, 0.013059275424793348, 0.042389897345668226, 0.012054025926390155, 0.024817746615311442, 0.018514863033734397, 0.013333426531274783, 0.030711364551264664, 0.06343985709444988, 0.07443375821991538, 0.062692943281897, 0.1149064811479601, 0.08002777657387106, 0.09929699932607017, 0.11566023754602539, 0.0852830570088361, 0.05256492276906699, 0.3972712028058998, 0.37597852598859727, 0.36399175555173746, 0.38149469783110945, 0.3997828111963756, 0.3859155981078263, 0.39583595583780795, 0.3748645016857072, 0.38500625884290973, 0.10885006157768207, 0.12866340141670773, 0.10520359482617492, 0.09380453374663267, 0.09353613839502617, 0.08633667423248959, 0.12010062311502823, 0.07353205918150851, 0.08724022427039313, 0.20401748655952157, 0.1534652592345379, 0.21919587870402824, 0.1947571640635961, 0.16984936905311365, 0.13592598171740988, 0.17104853538144038, 0.2316113161917489, 0.2363678930944746, 0.27857659187650874, 0.255184841384434, 0.2718105529024947, 0.2898857879347754, 0.2657817705380585, 0.2564956941026154, 0.26959990691541713, 0.2837156442742006, 0.2912560844000808, 0.21604218661166896, 0.17862272196287776, 0.20690685234066186, 0.2218609761274829, 0.19577734888492992, 0.19992887921741975, 0.2244519532131921, 0.2062232310783042, 0.22670651127743024, 0.18692924743024153, 0.18060198382742054, 0.18116786021305575, 0.19850337706474186, 0.18097868261941197, 0.18603600631111694, 0.2069992018956307, 0.19321419340195312, 0.19901274383329604, 0.20337209823228108, 0.18975444771992767, 0.1870382337279327, 0.1809377390923731, 0.1951160636833974, 0.20585265098637195, 0.2353958621248886, 0.18266137110928438, 0.18140967642532146, 0.19521983587813463, 0.5433127804301943, 0.18620183059424966, 0.1689986797199572, 0.18572650356601395, 0.15816800039984902, 0.17668909010256606, 0.17804629449327858, 0.16580882735026348, 0.1651514095530181, 0.1630063642980325, 0.24160078684072028, 0.19928825089261448, 0.2917857986948502, 0.3792379518910344, 0.19999117325341087, 0.2012551978326329, 0.20738256819951795, 0.1893524803220804, 0.1795747697827026, 0.2026557314449311, 0.17847646463695788, 0.201225465927096, 0.19027829030357257, 0.18019020725004897, 0.2119772088167884, 0.1805442331891587, 0.08062899969597437, 0.08684503502852436, 0.0726852365860301, 0.08611730528239914, 0.07263279307448733, 0.07100457829194762, 0.0819292249151653, 0.06545862796486657, 0.07546273638430323]}, "mutation_prompt": null}
{"id": "ac30aec0-9bbe-40d0-949e-eea65d0e2bf6", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "825e2184-13d1-4838-af31-2b2767f204d3", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "6961ad1a-c8fe-41ed-b9a9-494c8da01da3", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "a4cb9f6a-5877-45a3-aa40-bdcb99ed6880", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "dfe9846f-3d51-4792-808e-a3e8f630c03e", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "e2fd6c46-bf21-4dcc-960e-274538938b5f", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        if len(self.memory['f']) > 5:\n            self.f = np.mean(self.memory['f'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        generation = 0\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            generation += 1\n        return self.best_solution", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) enhances optimization by integrating quantum-inspired position updates and dynamic parameter adaptation for superior exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.8886952202116939, 0.8723569753473223, 0.894868004661298, 0.8905147347595037, 0.8828101035812805, 0.8988445004604568, 0.8794175946798992, 0.8706902597267872, 0.8998634598562913, 0.8117734598380366, 0.7585694624724769, 0.8163882975941102, 0.8035168724941506, 0.7672735463768049, 0.806939202973748, 0.8023353175699559, 0.7903553261254723, 0.7996821268583291, 0.1887787697621911, 0.7682525883798232, 0.12290800790738432, 0.12270857780714794, 0.18543740064337266, 0.1580513120543222, 0.1320217155403941, 0.157610767712819, 0.12345623758776769, 0.10846160802693516, 0.11375787127972004, 0.10861726940689276, 0.1073899621923936, 0.12157777226505184, 0.14043935934084706, 0.13113379505845857, 0.09355124269509507, 0.09056006131462546, 0.9736055175603301, 0.9567393538393518, 0.9333433867082119, 0.9701942701692243, 0.9394515452102837, 0.9704148412141658, 0.9789063132222636, 0.9278586010511443, 0.9072235942838599, 0.7161113427015287, 0.7320331270496844, 0.6995026553073109, 0.6755048467185034, 0.7014365105531731, 0.6937097382527972, 0.4851208816485517, 0.7079769690970175, 0.6818549083146409, 0.3312809861255761, 0.23490767945744218, 0.3566096279233455, 0.3761367384683827, 0.21116687718629468, 0.2752736780042968, 0.23128245559295257, 0.1769700677946594, 0.19473120749701778, 0.1688634117625497, 0.20898686808971056, 0.18402110495161783, 0.18686292912920677, 0.20882047647790114, 0.2181977060637601, 0.18868852780542889, 0.22343052025161658, 0.305794543307776, 0.12846013017350655, 0.22336171934994486, 0.18324986762743967, 0.16144743494136748, 0.1295829483262556, 0.2069920239747567, 0.20171529212427963, 0.10644991105467994, 0.2033384682507603, 0.06628008164166044, 9.999999999998899e-05, 0.04402673413478364, 0.060969074413254054, 9.999999999998899e-05, 0.05800973859620495, 0.002838554459471898, 0.0022156586612589457, 9.999999999998899e-05, 0.04725847060571009, 0.05315002989857709, 0.05590813024545882, 0.06059678146626957, 0.0304587924959987, 0.021325446499688816, 0.055725148059198704, 0.0974259317940549, 0.07887635700568518, 0.04826380252352169, 0.06298148364108236, 0.08266188077417469, 0.1188845604437383, 0.14562968697861156, 0.23846753793794428, 0.14131397558192949, 0.18704575143858682, 0.17675485592791806, 0.07166576461197782, 0.38100877577124015, 0.2923694498501672, 0.2953182028728437, 0.17692884906140227, 0.1293431972542558, 0.13228802591416677, 0.12597096414277853, 0.12239763613151622, 0.5631255000177522, 0.56528299158213, 0.5099234033412688, 0.5967788971710168, 0.5246726907778216, 0.6039390680636816, 0.563136617834388, 0.571432944199651, 0.6272206606673486, 0.13180395612071638, 0.15408249700861, 0.16114510311959562, 0.15807036379115724, 0.14088425526128157, 0.1850806380471367, 0.1425327717916498, 0.11340399272106638, 0.1153318511749234, 0.18104971316665852, 0.23713025084284167, 0.254533631213105, 0.2071500923189672, 0.36473568296187364, 0.23703475947784058, 0.1965681278637207, 0.20875337070339373, 0.2786543328240517, 0.40985158406457844, 0.4138485087683601, 0.2936756088436544, 0.39219173910530536, 0.3008886601261197, 0.25765656923841096, 0.5444978736851511, 0.17377774300845283, 0.4792481333096724, 0.2933311951903568, 0.25063625027677827, 0.31029469143635147, 0.2273278267270068, 0.25217898564695773, 0.31169476767982807, 0.3085679590576187, 0.302855464039663, 0.2279226668950327, 0.23326119172129045, 0.24566043127029147, 0.23530334064013836, 0.24479636328869825, 0.20787868578262725, 0.2764471365640955, 0.21035747921912162, 0.2462796429993157, 0.24289878829002054, 0.20650111117857683, 0.2074000673091454, 0.20669709032433725, 0.18725011648132772, 0.223498932870977, 0.1877846148738458, 0.19436054706910766, 0.18297157040946987, 0.17130995332440524, 0.16619335041130912, 0.8869947311201871, 0.16154480302957108, 0.8807844168912161, 0.1968959054412931, 0.1396377213282438, 0.8981545754185474, 0.9015766979890727, 0.1481768253010619, 0.5638168118049794, 0.2098094867562469, 0.19571274473131062, 0.3770665239963443, 0.16745514884101975, 0.16654890872738415, 0.5826443111734265, 0.16523762631775896, 0.6684222905380948, 0.224600810389729, 0.22620968475156988, 0.3131460929547998, 0.186786060677113, 0.20893465718573623, 0.2643911932996109, 0.21278292115206865, 0.23247105695469106, 0.2099111495961894, 0.07116382287330503, 0.08704589524297335, 0.08974360243785229, 0.11113592285847662, 0.06752104442177409, 0.1268917560966213, 0.10332897362952265, 0.09392883899621285, 0.0912064856011664]}, "mutation_prompt": null}
{"id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 39, "fitness": 0.33671463576512495, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "df2534af-4bfe-4708-9dd3-8f8a10fc2913", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "cd89fa67-929d-40d0-a50e-2c08f766731a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDEWithLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.levy_alpha = 1.5  # Parameter for Levy flights\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def levy_flight(self):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (abs(v) ** (1 / self.levy_alpha))\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n        \n        # Introduce Levy flight for global exploration\n        if np.random.rand() < 0.1:\n            levy_step = self.levy_flight()\n            self.population[idx] += levy_step\n            self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDEWithLevy", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution with Levy Flights introduces stochastic flights to enhance global search and avoid local minima.", "configspace": "", "generation": 40, "fitness": 0.17754695885097563, "feedback": "The algorithm EnhancedAdaptiveQuantumDEWithLevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.23171521967652242, 0.3731511117288595, 0.36256119696251643, 0.369551211188338, 0.39182949274999346, 0.5491796806932002, 0.33853577926458445, 0.5405311396888055, 0.28404821264611146, 0.02906634131304331, 0.04850205853579914, 9.999999999998899e-05, 0.22114853551456137, 0.011122595950518788, 0.09087612527508715, 0.04721069419662094, 0.015416710096468722, 0.08354722105950385, 0.07542949242056707, 0.0692333176226041, 0.078836309740003, 0.0726021578621574, 0.08104120638056278, 0.07870100148812709, 0.0810262766228671, 0.09483947159626549, 0.08523127019192911, 0.06670930943885944, 0.05287653382677093, 0.043359706848364876, 0.11977399538401201, 0.021407165016102958, 0.048764551153768876, 0.11794880691779086, 0.04107895384051985, 0.05028851261219702, 0.9546639184796537, 0.920844109347219, 0.9733309495817468, 0.8063631936806922, 0.9603066282236821, 0.9712937534428129, 0.929835204352222, 0.9697190937410263, 0.9588367889664446, 0.3665887322673874, 0.13672580092707265, 0.14882528104763093, 0.1594042047534422, 0.10733220259712506, 0.17087556991931674, 0.19558790415707372, 0.1527549933642275, 0.23392157568078986, 0.15798033338181283, 0.15719044878844124, 0.09601909309876411, 0.16713434741706512, 0.21096661745085377, 0.23026034257947248, 0.1778293862383269, 0.2012779710123751, 0.2275149120174379, 0.14396006294414454, 0.10193403937275036, 0.13653713600838835, 0.10925063460724527, 0.1306096879344042, 0.10512369040254488, 0.09223938352628169, 0.15349700896884622, 0.13461506614782304, 0.018856597279414022, 0.10252103480814478, 9.999999999998899e-05, 0.12680086565400706, 0.0751004531681514, 0.12894871910466577, 0.12243245445899087, 0.10724747753665631, 0.13052496592494067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03795218308867221, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019804067525444058, 0.028985763249045005, 0.08634234751747027, 0.016905832807753596, 0.09126213408955464, 0.05556697203975258, 0.06101857162393698, 0.049459727938142684, 0.19381210608907518, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0831249429615385, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021433827618487, 0.05189365913026123, 0.07078714985680468, 0.06673835747007395, 0.013045334727300184, 0.005061198402650402, 0.08734661985920666, 0.07712978047577912, 0.013004181792374059, 0.27372684921074675, 0.3472005077361846, 0.25098291510843773, 0.2555023608183328, 0.3118967220175175, 0.48129440012292557, 0.2920107430986254, 0.2841752349678873, 0.32714451608624784, 0.13636170149933258, 0.1042916068962626, 0.08523596354933438, 0.049953665916717904, 0.047228278156792314, 0.06981319443477929, 0.09833540629831439, 0.09454744236832446, 0.06515020677542727, 0.2390580032113555, 0.16063668182784918, 0.18858950675108732, 0.15530537349999707, 0.14299492666430758, 0.280157676746946, 0.1451721526153369, 0.30595714375925076, 0.20042306402340127, 0.22119578867408018, 0.21324578443644915, 0.1628627542410923, 0.20599277366390556, 0.1818766697157892, 0.20264461058132088, 0.17615012897739923, 0.17377774300845283, 0.23464482501732886, 0.14097598304660186, 0.20241146785169684, 0.2420214921248789, 0.20007869215323404, 0.13984363201867, 0.15294787694956613, 0.14434796262602345, 0.19329873707311285, 0.24088897702495227, 0.20624897347558535, 0.15201133362694996, 0.1795276185336474, 0.1828557198327584, 0.17474082645395084, 0.15547249717700307, 0.18560895529611698, 0.18470006499532943, 0.18078686867301275, 0.1773477761069827, 0.16587469191541382, 0.1639926024859909, 0.1637430139313184, 0.15039372391960937, 0.17987848274009322, 0.16687660453798658, 0.17200851382195015, 0.16717871783649152, 0.28465261280412746, 0.1608850577949148, 0.18413666955329877, 0.23944973578914064, 0.19730378782254632, 0.15682584043615766, 0.2961276336474391, 0.1574011937551253, 0.1394254483021503, 0.34388293287334504, 0.24692011072244235, 0.3546390893936213, 0.19584424314703952, 0.11093432393523472, 0.23332927883886911, 0.37864998604747324, 0.15321155393702246, 0.20654475467588307, 0.18188745364863734, 0.19574947317804747, 0.19098759982585833, 0.1927357568253042, 0.17947944208402766, 0.18144015123965118, 0.1896235259790402, 0.18780182600884698, 0.1829637501676924, 0.06602258968867847, 0.07724740012174847, 0.06376472888895701, 0.062260880114719974, 0.0581232257584654, 0.06393891948034103, 0.08062811635193556, 0.08547858138924258, 0.07504755074840175]}, "mutation_prompt": null}
{"id": "1ea42f3b-d36d-4fbd-9dd4-8d154e195308", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "123da278-45df-49df-98bd-9b50bd6271b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "ccf5d385-7f1e-46ab-a7b5-6a2e5d8d2ae1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "168fbf59-5469-4532-96e0-74b21c444e2f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "08a11caf-1224-4fe1-b60f-20f29cd5b351", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Initial crossover probability\n        self.f = 0.8   # Differential weight\n        self.dynamic_f_range = [0.5, 0.9]  # Range for dynamic scaling factor\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['cr']) > 5:\n            self.cr = np.mean(self.memory['cr'][-5:])\n        self.f = np.clip(self.f + np.random.normal(0, 0.1), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.uniform(-1, 1, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a random dynamic scaling factor and a novel adaptive crossover strategy to improve exploration and exploitation in complex search spaces.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.872106104746291, 0.8683202573501667, 0.8772355223106428, 0.8688869220881744, 0.8746740466221729, 0.8630670274378478, 0.8735599890263223, 0.8769306560216583, 0.8755498386232384, 0.7806746228948039, 0.775657612897771, 0.7830409696212626, 0.7813852791006822, 0.7666864437325298, 0.7720447586174319, 0.7457980119536411, 0.7792781936449752, 9.999999999998899e-05, 0.17782528173572076, 0.16050303831282386, 0.1813083067477974, 0.15603481640903138, 0.14186859172514288, 0.10922007978510095, 0.15641587419393277, 0.12184731289930384, 0.10436290476042998, 0.09000740864159795, 0.1088666952699523, 0.07614366178506482, 0.12965602161076917, 0.15287296440653209, 0.13163509842184173, 0.0883796736788649, 0.11337566385736553, 0.09375715489657066, 0.9650925537234019, 0.9371302711007214, 0.9093574725546957, 0.9335922054397172, 0.9515177051814301, 0.9428801498863175, 0.9626337633625228, 0.9447010594512333, 0.9186867263158603, 0.7191090957525195, 0.6544140616578086, 0.7017110034016579, 0.7523201775526398, 0.6569856256895463, 0.767289243034388, 0.7314120281253856, 0.6547554373575724, 0.7102302606687827, 0.8620302940413034, 0.22429427565243165, 0.22530662656063427, 0.8802778211018515, 0.27563396226287573, 0.20892285585005765, 0.23286173056162762, 0.8702679540332363, 0.1745554126150347, 0.17965216965786346, 0.1940527567466337, 0.20501790576368284, 0.1995286836640816, 0.18459091830984464, 0.18792809900042562, 0.19204361537220005, 0.12732684967402563, 0.21369856721031077, 0.20232587488010378, 0.2092644174836782, 0.2205981321429551, 0.1965749617402336, 0.24066392768053946, 0.2200942137262728, 0.22417722014130026, 0.12812676810062062, 0.23393780546845822, 0.04691492780083295, 0.01769706743112165, 0.013558457588867534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008959954375633461, 0.010077536981593194, 0.09572839913647913, 0.045995768609400134, 0.10894944595977618, 0.030641911947384304, 0.05443155866936722, 0.04937190767655142, 0.044157261770149114, 0.06374945928886044, 0.05656747154590047, 0.12171532206056124, 0.12375834773942884, 0.051602215933383766, 0.09776540005895817, 0.1292809144059791, 0.09976269188451847, 0.207754924501364, 0.08151553518344079, 0.1006460937836402, 0.07964020970277541, 0.11961480131001623, 0.2906946381521124, 0.12849013672063192, 0.4541067770605226, 0.27078582299683573, 0.12998484917113873, 0.2335796987843809, 0.09317572731412671, 0.5322599612196801, 0.5536037921460426, 0.5520908991301885, 0.6488795741634144, 0.6170430368651847, 0.5414815872578707, 0.547706989195905, 0.5679841229903235, 0.5734218911912836, 0.0942381861137166, 0.11519017081656058, 0.11552016910221863, 0.10882748376547335, 0.07196943871133354, 0.18513685945419533, 0.09494972974646532, 0.13938058614903115, 0.14108013061155977, 0.21823730857891788, 0.1695694484965885, 0.1774107904713681, 0.21984918738720438, 0.2252323703140976, 0.6151317430906849, 0.2651285544889671, 0.4053607653891623, 0.28805612081732046, 0.40724999734409784, 0.2595947431640325, 0.37853522905364057, 0.47495938726393716, 0.3357397629790748, 0.30931431924755526, 0.5222176700399521, 0.41556477422791915, 0.6953195073960166, 0.4112465713636996, 0.35511265420321525, 0.2025690586564729, 0.22634244963219385, 0.2012114363746912, 0.3030853035155938, 0.21306007231582846, 0.2852910288281588, 0.41494720728110945, 0.19381406359661935, 0.31505035389990965, 0.2236714993726745, 0.2394348121372304, 0.18632939769852186, 0.2510235015471991, 0.2223449501772805, 0.2986221272429188, 0.16326934945826066, 0.24479847775991703, 0.18764596728666094, 0.7944324112770876, 0.1952603032268696, 0.2486661030215489, 0.2068964603684985, 0.18704490531956108, 0.20925675050826498, 0.7835440739827364, 0.12664796423934732, 0.1885113773946958, 0.9116414228391396, 0.15768551488513294, 0.1207914665021157, 0.16617195997073408, 0.8904419987318256, 0.16262200442017716, 0.21143069641342316, 0.8149158419410286, 0.2106117199514973, 0.8293881253239846, 0.21100350320104655, 0.12733259309122624, 0.5508332253980082, 0.1672862953053853, 0.6670987048624208, 0.751870008370791, 0.2599616931521541, 0.21500587659726733, 0.2603611173432989, 0.20490404189920142, 0.21534970189804536, 0.2697333421642445, 0.2742207890124546, 0.2537951249957646, 0.19764424949103854, 0.08234145830722484, 0.0945635457389179, 0.09119433551831513, 0.09757220491892882, 0.10061316507531282, 0.10257324534007584, 0.10045855873808252, 0.07925491521744366, 0.09959725751185833]}, "mutation_prompt": null}
{"id": "667f2fa7-d317-49b2-bc62-eefc4ff2174b", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredDE_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "ImprovedQuantumInspiredDE_ADM", "description": "Improved Quantum-inspired Differential Evolution with Adaptive Memory (IQDE-AM) optimizes exploration and convergence by using historical success memory for parameter adaptation and enhanced quantum updating.", "configspace": "", "generation": 46, "fitness": 0.3374094999787119, "feedback": "The algorithm ImprovedQuantumInspiredDE_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "87ffa59b-1479-4131-a2cc-7cd7100a1fcb", "metadata": {"aucs": [0.8802100780785456, 0.8916776314811224, 0.8841693339234796, 0.8733616774716106, 0.884627145729924, 0.8906448791879941, 0.8864661229006046, 0.8937368585339954, 0.876820910042684, 0.7967725440946529, 0.7928132951506895, 0.7846900665650275, 0.801459248934257, 0.789737966742768, 0.8069440350206848, 0.8000334477820948, 0.8125814285709438, 0.7730863528091215, 0.15665886302458498, 0.11561221410030575, 0.15746066441037943, 0.1875655920135696, 0.1434529032388877, 0.12202438455081954, 0.1566011146771885, 0.12168709991371485, 0.14454382998040893, 0.10603895380340833, 0.11962446751683131, 0.108551184164697, 0.10942273935137126, 0.10286437423640205, 0.179532450649876, 0.1410697827788494, 0.12151559020986713, 0.11296062298308729, 0.9395290612624048, 0.9389075225433732, 0.896137825204589, 0.9421911374709576, 0.9551009105170951, 0.9332488353708182, 0.9407326101001092, 0.8745444479943523, 0.9479820862415536, 0.7136004573408528, 0.7168316613831283, 0.6969921716718834, 0.7310435899893879, 0.6944057731650166, 0.7207436177868213, 0.7366555841886776, 0.7106316865062086, 0.7195315888821332, 0.8917845039127953, 0.2270968979215795, 0.22535525893896924, 0.275812086165104, 0.37920719838245565, 0.9029444263946838, 0.9039258035012353, 0.23430992785683735, 0.3981870904234812, 0.1896773121873253, 0.12780837424772284, 0.1688464756303003, 0.20693232855954624, 0.22122229268620097, 0.12473202755665147, 0.21577283708017914, 0.20736149804909454, 0.18516065039819574, 0.18642919408818248, 0.11922079325713253, 0.20215305072414747, 0.1933146581629367, 0.12791461018686645, 0.13052466599098056, 0.19476821950551737, 0.22361359684654214, 0.2001133451518612, 9.999999999998899e-05, 0.11031393784296584, 0.007153453759251693, 0.176976620411883, 0.006194466720649716, 0.00627928453068094, 9.999999999998899e-05, 0.05236326933646274, 0.0029978141262583247, 0.08330904756866786, 0.05134447121451591, 0.07330039373835784, 0.0344123170683297, 0.05712085599014849, 0.041976555164506824, 0.04146297540306565, 0.038594309112975345, 0.0752372391177556, 0.1984120320335574, 0.05266901416245129, 0.08275008572723852, 0.10337114867609687, 0.14726671112622824, 0.23442459400152915, 0.1932094426371248, 0.20766155807548325, 0.29519381918436394, 0.2898800150605013, 0.12637814233909705, 0.1601185708655094, 0.18433522987706952, 0.12702309077682206, 0.1941077273965327, 0.16833849644414445, 0.12848281508658788, 0.12384439890343879, 0.5914419954146107, 0.6393293634196981, 0.6396824302283382, 0.5617120736981199, 0.5461043624406281, 0.549477662427232, 0.566803804330791, 0.5717239454981461, 0.5700454651031697, 0.11992504530979187, 0.15904577990081648, 0.15749778217540555, 0.12229997187148878, 0.10183373762445247, 0.18668531143620914, 0.11494815038027151, 0.15815134068861514, 0.1826355104641555, 0.20117438938518384, 0.23513321656384434, 0.23092001890928227, 0.34374544996799006, 0.5023862885113877, 0.3121797028777278, 0.16809402029414655, 0.1752083406513042, 0.21799587415351285, 0.5767170801126256, 0.3330885049925907, 0.45024561965484955, 0.38254243038870694, 0.6347347989081387, 0.39510678631447627, 0.6083902270810321, 0.42790559681387863, 0.5741816763084503, 0.23819885985776956, 0.31609638491473036, 0.33656544464062776, 0.22383315870803655, 0.20142593782297613, 0.2596221395577122, 0.27047021541659466, 0.23040899281636806, 0.3499190354857986, 0.2324474143585218, 0.2205674274918149, 0.22459305928610362, 0.26088821102571735, 0.2630714881523304, 0.2847772156157946, 0.2670316901563625, 0.17749931455065415, 0.2489522389728691, 0.19842817186165307, 0.21279465013940035, 0.1885779428326848, 0.176492499423051, 0.19441295071950093, 0.2274182104593755, 0.1760372744624623, 0.17538120271545354, 0.24829403658026328, 0.16406278830425858, 0.2096035995713622, 0.1853537625386672, 0.19863983589740908, 0.19874774155631403, 0.14709826056960917, 0.17645275192025311, 0.8890275328191337, 0.92850411655693, 0.46161927082188026, 0.2098474420209785, 0.12625073910379925, 0.20968506887870597, 0.16811081833546027, 0.20927481133545245, 0.21135717033601498, 0.20960746704473399, 0.8762316083683812, 0.24845705516561178, 0.2088370159125824, 0.2566971288300478, 0.21687307320629357, 0.4225380334539053, 0.35447082650473916, 0.2503508327336026, 0.3437516510580123, 0.28625737415817387, 0.11809875641566414, 0.08429120320478756, 0.108830509464519, 0.09211408931696152, 0.10325960566747983, 0.10971283200757698, 0.09502813709052005, 0.10658738778893018, 0.10479932558673699]}, "mutation_prompt": null}
{"id": "504a4623-0898-4ad7-b9ef-557773b40d15", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n                    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n    \n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if (prob * self.population_values[idx]) < self.best_value:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum Differential Evolution (EAQDE) refines convergence by integrating adaptive probability-based quantum updates with dynamic crossover strategies and success-based memory to improve parameter adaptation.", "configspace": "", "generation": 47, "fitness": 0.2659623668228004, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "667f2fa7-d317-49b2-bc62-eefc4ff2174b", "metadata": {"aucs": [0.9184994262449749, 0.920619609880932, 0.9172466460189436, 0.900362676737425, 0.9099176351365983, 0.9138575610912805, 0.7410434340760801, 0.7274800714242617, 0.7074373992547014, 0.5332492561292546, 0.49911510564854655, 0.5470045617283523, 0.5253294344152482, 0.5481846241153903, 0.5259913312861375, 0.5007458015631334, 0.5095119311696354, 9.999999999998899e-05, 0.10034692295898162, 0.09686567694601145, 0.1043847934729405, 0.11634751813759725, 0.18798418542871664, 0.11045683484160795, 0.18769449995995546, 0.12574019143143866, 0.08267976079358064, 0.09996562873713954, 0.08840801650564278, 0.08210084309407684, 0.06356192791608883, 0.12271818294631687, 0.09192366388291318, 0.12417722045195312, 0.08754773481632261, 0.09508972215836764, 0.9590000411026597, 0.958506837674627, 0.8884339066250617, 0.8951300888980616, 0.9376656594503602, 0.8052834897398393, 0.8891527341318144, 0.9497897537666069, 0.9488571555226317, 0.27538245921521876, 0.36834300793434516, 0.17332283417564087, 0.40178936002706966, 0.2630836214461434, 0.40174799280778273, 0.2900646878687744, 0.30104594873258617, 0.3133506538716908, 0.2294223014503387, 0.381111789276511, 0.35163304188270617, 0.2107184223009415, 0.3780789192974857, 0.20950541344614915, 0.231416998495099, 0.23302115794747436, 0.24222069360112897, 0.15440204960483206, 0.14312395224051178, 0.1264354649162711, 0.14101012213306585, 0.15268135122803272, 0.165351701315681, 0.12519507752674452, 0.1361555129287101, 0.13898743027007898, 0.14960343443822544, 0.172740577729397, 0.1647430391794653, 0.20508893766547265, 0.12741543712804526, 0.17114234248822835, 0.20062051166409023, 0.184800771362005, 0.17264049484831379, 9.999999999998899e-05, 0.05960407499762255, 0.04179061192274325, 0.08236900491385446, 0.03893513947949667, 0.030247312580205854, 0.016669771885834406, 9.999999999998899e-05, 0.00019993725941680474, 0.09418266936934072, 0.10903747314022816, 0.09118582339745462, 0.09304783680368278, 0.03262336330169746, 0.012818625306253884, 0.020897089955772552, 0.06087369756637451, 0.058272464574882776, 0.103664743215924, 0.08059734839506238, 0.08450625757148922, 0.06339643455481436, 0.07709055998561398, 0.08799334273340098, 0.25024806498377516, 0.12168919534482625, 0.09320257727136305, 0.11727739978454976, 0.22962337063261218, 0.08217109453335558, 0.14744298677130796, 0.11378321158707261, 0.1229695752473634, 0.13566621487451924, 0.09403749517724824, 0.09186111592714175, 0.45683958831345206, 0.4545981685703113, 0.4591386200272425, 0.4630825759725934, 0.457472310485074, 0.46691659103316685, 0.5499189619505052, 0.5678114609151002, 0.5820834416533315, 0.08537548012652874, 0.09997396001040615, 0.1615540138272803, 0.1446884312139871, 0.14314986972735022, 0.11182704273694977, 0.11630985397183158, 0.09568427633870702, 0.09663209404351925, 0.18588194237879252, 0.18158216602726884, 0.20757958187539416, 0.15272280067429345, 0.22798189798820812, 0.18227817194550144, 0.16892047070460592, 0.43120035877913854, 0.4470369087920948, 0.28924825634929185, 0.31403092609472794, 0.33514772056502395, 0.3085793291224692, 0.24256002290625933, 0.5546797532236534, 0.3155697518615186, 0.17377774300845283, 0.25807236490403207, 0.22144557009967447, 0.22338786929851673, 0.22417335826240614, 0.2292966732809706, 0.2680863169956941, 0.33922039340122023, 0.14006668689618362, 0.0997711199450243, 0.35757685425685215, 0.17650604720532825, 0.1809019140513084, 0.20306160122795502, 0.2798140757527807, 0.25443806067397634, 0.2275658516898007, 0.2804661823845448, 0.17227000503286216, 0.23895296388504617, 0.20471091329099267, 0.1747397445832417, 0.1843900572771512, 0.21024067382515654, 0.2092239763496706, 0.16853167252767964, 0.1646242442046314, 0.1886294561559395, 0.1703653287202922, 0.1860619197830451, 0.18556523858076235, 0.18614191192044205, 0.6902793007251466, 0.1207914665021157, 0.6669897516413987, 0.14912085552182563, 0.6048863102421094, 0.691309884472678, 0.16544572118851342, 0.1672090825662964, 0.18882078801905744, 0.1273545137314468, 0.21181335690047587, 0.11227014910171562, 0.12628686950000734, 0.20654984451290637, 0.20955903936036058, 0.21885700815239073, 0.2326049622813844, 0.35558294672940116, 0.22793738945923792, 0.20469702604084072, 0.37068519299063696, 0.1904862559140451, 0.17284774560238259, 0.20671068839165951, 0.10696735675503566, 0.10654581303210431, 0.09599004270116418, 0.09451745584704818, 0.10223367138379269, 0.1172033096636147, 0.11760423805836695, 0.09208854265043609, 0.08240816960530717]}, "mutation_prompt": null}
{"id": "ca7b0c3a-857f-47ee-a290-a5b0a0af00f4", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionQL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            direction = np.random.normal(0, 0.2, self.dim)\n            self.population[idx] += direction * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedDifferentialEvolutionQL", "description": "Enhanced Differential Evolution with Quantum Learning (EDE-QL) integrates adaptive parameter control, quantum-inspired learning, and differential evolution for robust exploration and exploitation across diverse optimization landscapes.", "configspace": "", "generation": 48, "fitness": 0.3374094999787119, "feedback": "The algorithm EnhancedDifferentialEvolutionQL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "667f2fa7-d317-49b2-bc62-eefc4ff2174b", "metadata": {"aucs": [0.8802100780785456, 0.8916776314811224, 0.8841693339234796, 0.8733616774716106, 0.884627145729924, 0.8906448791879941, 0.8864661229006046, 0.8937368585339954, 0.876820910042684, 0.7967725440946529, 0.7928132951506895, 0.7846900665650275, 0.801459248934257, 0.789737966742768, 0.8069440350206848, 0.8000334477820948, 0.8125814285709438, 0.7730863528091215, 0.15665886302458498, 0.11561221410030575, 0.15746066441037943, 0.1875655920135696, 0.1434529032388877, 0.12202438455081954, 0.1566011146771885, 0.12168709991371485, 0.14454382998040893, 0.10603895380340833, 0.11962446751683131, 0.108551184164697, 0.10942273935137126, 0.10286437423640205, 0.179532450649876, 0.1410697827788494, 0.12151559020986713, 0.11296062298308729, 0.9395290612624048, 0.9389075225433732, 0.896137825204589, 0.9421911374709576, 0.9551009105170951, 0.9332488353708182, 0.9407326101001092, 0.8745444479943523, 0.9479820862415536, 0.7136004573408528, 0.7168316613831283, 0.6969921716718834, 0.7310435899893879, 0.6944057731650166, 0.7207436177868213, 0.7366555841886776, 0.7106316865062086, 0.7195315888821332, 0.8917845039127953, 0.2270968979215795, 0.22535525893896924, 0.275812086165104, 0.37920719838245565, 0.9029444263946838, 0.9039258035012353, 0.23430992785683735, 0.3981870904234812, 0.1896773121873253, 0.12780837424772284, 0.1688464756303003, 0.20693232855954624, 0.22122229268620097, 0.12473202755665147, 0.21577283708017914, 0.20736149804909454, 0.18516065039819574, 0.18642919408818248, 0.11922079325713253, 0.20215305072414747, 0.1933146581629367, 0.12791461018686645, 0.13052466599098056, 0.19476821950551737, 0.22361359684654214, 0.2001133451518612, 9.999999999998899e-05, 0.11031393784296584, 0.007153453759251693, 0.176976620411883, 0.006194466720649716, 0.00627928453068094, 9.999999999998899e-05, 0.05236326933646274, 0.0029978141262583247, 0.08330904756866786, 0.05134447121451591, 0.07330039373835784, 0.0344123170683297, 0.05712085599014849, 0.041976555164506824, 0.04146297540306565, 0.038594309112975345, 0.0752372391177556, 0.1984120320335574, 0.05266901416245129, 0.08275008572723852, 0.10337114867609687, 0.14726671112622824, 0.23442459400152915, 0.1932094426371248, 0.20766155807548325, 0.29519381918436394, 0.2898800150605013, 0.12637814233909705, 0.1601185708655094, 0.18433522987706952, 0.12702309077682206, 0.1941077273965327, 0.16833849644414445, 0.12848281508658788, 0.12384439890343879, 0.5914419954146107, 0.6393293634196981, 0.6396824302283382, 0.5617120736981199, 0.5461043624406281, 0.549477662427232, 0.566803804330791, 0.5717239454981461, 0.5700454651031697, 0.11992504530979187, 0.15904577990081648, 0.15749778217540555, 0.12229997187148878, 0.10183373762445247, 0.18668531143620914, 0.11494815038027151, 0.15815134068861514, 0.1826355104641555, 0.20117438938518384, 0.23513321656384434, 0.23092001890928227, 0.34374544996799006, 0.5023862885113877, 0.3121797028777278, 0.16809402029414655, 0.1752083406513042, 0.21799587415351285, 0.5767170801126256, 0.3330885049925907, 0.45024561965484955, 0.38254243038870694, 0.6347347989081387, 0.39510678631447627, 0.6083902270810321, 0.42790559681387863, 0.5741816763084503, 0.23819885985776956, 0.31609638491473036, 0.33656544464062776, 0.22383315870803655, 0.20142593782297613, 0.2596221395577122, 0.27047021541659466, 0.23040899281636806, 0.3499190354857986, 0.2324474143585218, 0.2205674274918149, 0.22459305928610362, 0.26088821102571735, 0.2630714881523304, 0.2847772156157946, 0.2670316901563625, 0.17749931455065415, 0.2489522389728691, 0.19842817186165307, 0.21279465013940035, 0.1885779428326848, 0.176492499423051, 0.19441295071950093, 0.2274182104593755, 0.1760372744624623, 0.17538120271545354, 0.24829403658026328, 0.16406278830425858, 0.2096035995713622, 0.1853537625386672, 0.19863983589740908, 0.19874774155631403, 0.14709826056960917, 0.17645275192025311, 0.8890275328191337, 0.92850411655693, 0.46161927082188026, 0.2098474420209785, 0.12625073910379925, 0.20968506887870597, 0.16811081833546027, 0.20927481133545245, 0.21135717033601498, 0.20960746704473399, 0.8762316083683812, 0.24845705516561178, 0.2088370159125824, 0.2566971288300478, 0.21687307320629357, 0.4225380334539053, 0.35447082650473916, 0.2503508327336026, 0.3437516510580123, 0.28625737415817387, 0.11809875641566414, 0.08429120320478756, 0.108830509464519, 0.09211408931696152, 0.10325960566747983, 0.10971283200757698, 0.09502813709052005, 0.10658738778893018, 0.10479932558673699]}, "mutation_prompt": null}
{"id": "31792eeb-0bee-40ca-bf11-01c405dc895b", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredDE_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "ImprovedQuantumInspiredDE_ADM", "description": "Improved Quantum-inspired Differential Evolution with Adaptive Memory (IQDE-AM) optimizes exploration and convergence by using historical success memory for parameter adaptation and enhanced quantum updating.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "667f2fa7-d317-49b2-bc62-eefc4ff2174b", "metadata": {"aucs": [0.8802100780785456, 0.8916776314811224, 0.8841693339234796, 0.8733616774716106, 0.884627145729924, 0.8906448791879941, 0.8864661229006046, 0.8937368585339954, 0.876820910042684, 0.7967725440946529, 0.7928132951506895, 0.7846900665650275, 0.801459248934257, 0.789737966742768, 0.8069440350206848, 0.8000334477820948, 0.8125814285709438, 0.7730863528091215, 0.15665886302458498, 0.11561221410030575, 0.15746066441037943, 0.1875655920135696, 0.1434529032388877, 0.12202438455081954, 0.1566011146771885, 0.12168709991371485, 0.14454382998040893, 0.10603895380340833, 0.11962446751683131, 0.108551184164697, 0.10942273935137126, 0.10286437423640205, 0.179532450649876, 0.1410697827788494, 0.12151559020986713, 0.11296062298308729, 0.9395290612624048, 0.9389075225433732, 0.896137825204589, 0.9421911374709576, 0.9551009105170951, 0.9332488353708182, 0.9407326101001092, 0.8745444479943523, 0.9479820862415536, 0.7136004573408528, 0.7168316613831283, 0.6969921716718834, 0.7310435899893879, 0.6944057731650166, 0.7207436177868213, 0.7366555841886776, 0.7106316865062086, 0.7195315888821332, 0.8917845039127953, 0.2270968979215795, 0.22535525893896924, 0.275812086165104, 0.37920719838245565, 0.9029444263946838, 0.9039258035012353, 0.23430992785683735, 0.3981870904234812, 0.1896773121873253, 0.12780837424772284, 0.1688464756303003, 0.20693232855954624, 0.22122229268620097, 0.12473202755665147, 0.21577283708017914, 0.20736149804909454, 0.18516065039819574, 0.18642919408818248, 0.11922079325713253, 0.20215305072414747, 0.1933146581629367, 0.12791461018686645, 0.13052466599098056, 0.19476821950551737, 0.22361359684654214, 0.2001133451518612, 9.999999999998899e-05, 0.11031393784296584, 0.007153453759251693, 0.176976620411883, 0.006194466720649716, 0.00627928453068094, 9.999999999998899e-05, 0.05236326933646274, 0.0029978141262583247, 0.08330904756866786, 0.05134447121451591, 0.07330039373835784, 0.0344123170683297, 0.05712085599014849, 0.041976555164506824, 0.04146297540306565, 0.038594309112975345, 0.0752372391177556, 0.1984120320335574, 0.05266901416245129, 0.08275008572723852, 0.10337114867609687, 0.14726671112622824, 0.23442459400152915, 0.1932094426371248, 0.20766155807548325, 0.29519381918436394, 0.2898800150605013, 0.12637814233909705, 0.1601185708655094, 0.18433522987706952, 0.12702309077682206, 0.1941077273965327, 0.16833849644414445, 0.12848281508658788, 0.12384439890343879, 0.5914419954146107, 0.6393293634196981, 0.6396824302283382, 0.5617120736981199, 0.5461043624406281, 0.549477662427232, 0.566803804330791, 0.5717239454981461, 0.5700454651031697, 0.11992504530979187, 0.15904577990081648, 0.15749778217540555, 0.12229997187148878, 0.10183373762445247, 0.18668531143620914, 0.11494815038027151, 0.15815134068861514, 0.1826355104641555, 0.20117438938518384, 0.23513321656384434, 0.23092001890928227, 0.34374544996799006, 0.5023862885113877, 0.3121797028777278, 0.16809402029414655, 0.1752083406513042, 0.21799587415351285, 0.5767170801126256, 0.3330885049925907, 0.45024561965484955, 0.38254243038870694, 0.6347347989081387, 0.39510678631447627, 0.6083902270810321, 0.42790559681387863, 0.5741816763084503, 0.23819885985776956, 0.31609638491473036, 0.33656544464062776, 0.22383315870803655, 0.20142593782297613, 0.2596221395577122, 0.27047021541659466, 0.23040899281636806, 0.3499190354857986, 0.2324474143585218, 0.2205674274918149, 0.22459305928610362, 0.26088821102571735, 0.2630714881523304, 0.2847772156157946, 0.2670316901563625, 0.17749931455065415, 0.2489522389728691, 0.19842817186165307, 0.21279465013940035, 0.1885779428326848, 0.176492499423051, 0.19441295071950093, 0.2274182104593755, 0.1760372744624623, 0.17538120271545354, 0.24829403658026328, 0.16406278830425858, 0.2096035995713622, 0.1853537625386672, 0.19863983589740908, 0.19874774155631403, 0.14709826056960917, 0.17645275192025311, 0.8890275328191337, 0.92850411655693, 0.46161927082188026, 0.2098474420209785, 0.12625073910379925, 0.20968506887870597, 0.16811081833546027, 0.20927481133545245, 0.21135717033601498, 0.20960746704473399, 0.8762316083683812, 0.24845705516561178, 0.2088370159125824, 0.2566971288300478, 0.21687307320629357, 0.4225380334539053, 0.35447082650473916, 0.2503508327336026, 0.3437516510580123, 0.28625737415817387, 0.11809875641566414, 0.08429120320478756, 0.108830509464519, 0.09211408931696152, 0.10325960566747983, 0.10971283200757698, 0.09502813709052005, 0.10658738778893018, 0.10479932558673699]}, "mutation_prompt": null}
{"id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 50, "fitness": 0.34718339282078053, "feedback": "The algorithm EnhancedQuantumInspiredDE_ALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "667f2fa7-d317-49b2-bc62-eefc4ff2174b", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "713551b4-086e-4c5e-b3c0-01110b8bf987", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "938c0960-38c2-4f6d-bd3d-5162310bffae", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "c010d28f-cda7-480c-87e2-6435b325c31a", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "504830d9-c87d-48c8-96a6-61dc06688329", "solution": "import numpy as np\n\nclass QuantumEnhancedDE_DSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.3:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        elif prob < 0.6:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        else:\n            other = self.population[np.random.choice(np.delete(np.arange(self.population_size), idx))]\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.3, self.dim) * (other - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumEnhancedDE_DSA", "description": "Quantum-enhanced Differential Evolution with Dynamic Strategy Adaptation (QDE-DSA) introduces strategy adaptation based on success history and hybrid quantum-inspired exploration to enhance convergence over diverse optimization landscapes.", "configspace": "", "generation": 54, "fitness": 0.3257609062846831, "feedback": "The algorithm QuantumEnhancedDE_DSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8340331224881894, 0.8221057144947189, 0.8221773424844894, 0.7737259385101961, 0.8104231787217511, 0.8273486650465286, 0.8218861524265257, 0.80927986146102, 0.7935498590072909, 0.6372631027444844, 0.6658000689937538, 0.6361175547227855, 0.6385603861954017, 0.6332126872949637, 0.6546998107362758, 0.6400286095943495, 0.6171895703085033, 0.5895899116796115, 0.10903451485722948, 0.14983542393634508, 0.1355584598341637, 0.11209078168840736, 0.10469996015954619, 0.13473306570694132, 0.15149684280216302, 0.1118035293066123, 0.14705854613833724, 0.11344245821537913, 0.0948880894452222, 0.1347836445687277, 0.08898798160242383, 0.105965673042965, 0.12745774508498853, 0.10170365931235315, 0.13346892444950043, 0.14205657827250706, 0.9907300218762413, 0.8839938996713098, 0.8615721601622127, 0.8849118682560059, 0.9382300121099105, 0.8528128398229149, 0.9553576207233916, 0.9664489113415051, 0.8785345066013583, 0.5496025166819432, 0.5704442166870229, 0.5277114577012993, 0.5633937892624825, 0.5399873057922602, 0.5130732667722828, 0.5677614548735157, 0.427124887480792, 0.3851059453903186, 0.8059517452398098, 0.22204513019416716, 0.8199788077245656, 0.2754113454973295, 0.7780484799158716, 0.3186098372541847, 0.22914091898766087, 0.23052471586835244, 0.7495405795297898, 0.201331828074777, 0.20309966327044826, 0.19624377740772359, 0.2438134871865124, 0.18053158232181432, 0.21553944816346216, 0.19728936526339247, 0.18058040556769117, 0.278016697073466, 0.23261397892560742, 0.2271556957418437, 0.2140960826486249, 0.210804326763548, 0.20375963141184605, 0.1936132101189706, 0.24643625199593544, 0.20502372939925184, 0.2409595299394266, 0.11099719226990457, 0.046260949935007956, 0.030336654888084236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03055490983488962, 9.999999999998899e-05, 0.0027831888438879515, 0.07156643387993622, 0.09118981976076956, 0.05320167981854429, 0.07074746523217657, 0.14556557217034805, 0.021681280519515678, 0.07149757553350078, 0.04965063911881895, 0.15640322093205927, 0.07076922405845054, 0.08344288694086299, 0.15216112464775033, 0.07041449470985095, 0.10204340903467668, 0.13797632646234492, 0.20119725856348103, 0.1476183858055149, 0.10626055435218384, 0.15430546493139208, 0.22287311016850786, 0.13404970942536332, 0.11464915492461536, 0.18481758058909992, 0.11653076576638977, 0.20326545204494872, 0.10335762756929212, 0.2570829532523905, 0.5428582796413572, 0.4782227961762716, 0.5556424311074872, 0.5796126445019281, 0.5393714616187817, 0.5246351791850011, 0.5891202540156679, 0.5341873076959852, 0.5896763319794289, 0.13328946238755657, 0.09594973174020249, 0.13665911421095356, 0.13746071001029814, 0.14504553002384868, 0.17291957622021925, 0.09066499740171252, 0.10890108947120347, 0.11989788597895035, 0.21138127403460205, 0.48185492373147065, 0.13531713049965455, 0.3963177613102643, 0.13942944319648198, 0.1227315301803319, 0.4267086282212331, 0.5400235750030565, 0.29413498498554513, 0.44555810346664204, 0.2918968725926079, 0.3494281176179628, 0.5262668489592669, 0.5288738924369334, 0.5287308196582368, 0.5125666228075194, 0.47011823343678505, 0.4979297084774026, 0.38197267643686117, 0.21973930148809473, 0.248118379608243, 0.372700476994805, 0.2704598135686831, 0.303166874101349, 0.3326087254128992, 0.4070074896707502, 0.23204860408470662, 0.20039401846571558, 0.19799177842157178, 0.2030018466239668, 0.26488370276788054, 0.1824749087635884, 0.17020255409819296, 0.22526719286671615, 0.18241735502150236, 0.19930651190222726, 0.20338199843265092, 0.21058218209198876, 0.23528501247694167, 0.6455524029847073, 0.19813558076401316, 0.18646104881627135, 0.18629679767117235, 0.20658378919557185, 0.19590340026814734, 0.18411264746378053, 0.18466684159418123, 0.16202088844108353, 0.8607485475991721, 0.1965310953280549, 0.19572826298798596, 0.8555771393918213, 0.7953976860120636, 0.1766244465756408, 0.2885419926971664, 0.20950744154594847, 0.7542090825783812, 0.6411880177565772, 0.821376380501046, 0.7769899466931919, 0.11246231095007009, 0.10410409764178608, 0.7038024573769475, 0.2686123998211589, 0.17732590704205464, 0.17570955139837552, 0.19040804146217638, 0.23416947965428703, 0.20147401455681624, 0.18122380220595347, 0.18259947917585995, 0.21972905470453108, 0.07322220064346963, 0.0785443587178214, 0.09217550492925619, 0.0914029818949057, 0.08580679979045613, 0.10140776514639616, 0.08180041148965034, 0.08028706152993004, 0.0908735691994409]}, "mutation_prompt": null}
{"id": "cdc8fbc7-5193-4e8f-be1d-a752bc0ae478", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS_DDC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.diversity_threshold = 0.1  # Control parameter for diversity\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def calculate_population_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - centroid, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            diversity = self.calculate_population_diversity()\n            if diversity < self.diversity_threshold:\n                # Introduce diversity if below threshold\n                perturbation = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.population = np.where(np.random.rand(self.population_size, self.dim) < 0.1, perturbation, self.population)\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS_DDC", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search and Dynamic Diversity Control (EQDE-ALS-DDC) introduces diversity control to avoid premature convergence and further improves exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.3031737542640472, "feedback": "The algorithm EnhancedQuantumInspiredDE_ALS_DDC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.766199501082698, 0.5716960454587637, 0.45347254590377184, 0.8475117832992483, 0.5816712940574402, 0.8564559819384506, 0.8422214846837587, 0.5493561839357787, 0.8349255733714213, 0.5149345906082162, 0.46029163260776107, 0.46712169725981734, 0.31771911371128014, 0.34677842359902333, 0.6224340101986734, 0.45353129923475344, 0.674190428204906, 0.4152722012547715, 0.22632198803216974, 0.15079244147596016, 0.12871920886603183, 0.312417728229057, 0.5349256268687905, 0.3031390894493935, 0.2976453493840777, 0.1647508564839849, 0.14003699549147008, 0.133208795047001, 0.14707590502925705, 0.27141349003442805, 0.2860622051243902, 0.15756718517482837, 0.14354982772908553, 0.14590022144059478, 0.13762613586546413, 0.15407089198289836, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.3879539046739353, 0.317802706754468, 0.26712809213345035, 0.374951665191556, 0.3005301094212006, 0.37242606725764094, 0.38999561558307627, 0.35907771903130725, 0.3644411177155856, 0.38901375104344216, 0.8849169306166329, 0.861513505065772, 0.8880139500562098, 0.8888416773323315, 0.2745650954599681, 0.8774354611543508, 0.22576058803769894, 0.857129067288764, 0.15961005625260583, 0.18932323070720525, 0.1611818933685767, 0.1528892240147055, 0.1682401910490673, 0.1945360424624749, 0.15174580963229, 0.1553610714289111, 0.19920394855339618, 0.2055442367414183, 0.19674839736786798, 0.1408683277037195, 0.1510162129525754, 0.14854846896816432, 0.15682350670781686, 0.2260107040399264, 0.1870741224902417, 0.18498143356119146, 0.03815601242224509, 9.999999999998899e-05, 0.002912600405038379, 0.06319619569585921, 0.11220576194704512, 0.00022385759550946904, 0.04480452948140212, 0.10668114114452476, 0.07695461010783855, 0.06523899580922066, 0.23146227408756093, 0.11708974692029372, 0.07434162305737957, 0.046941568038025294, 0.053283313225561124, 0.13087842591553622, 0.10963955346006915, 0.07670710265243741, 0.17295293376423493, 0.06003118481570546, 0.07883772336279216, 9.999999999998899e-05, 0.21016519540648482, 0.055246473670400364, 9.999999999998899e-05, 0.20380851304585967, 0.09694688654449435, 0.142984446966538, 0.1320273067724934, 0.12856479866418757, 0.10451757764051761, 0.1306220866673451, 0.16503265466866957, 0.12679907950954894, 0.0820157701769405, 0.09491547760060115, 0.5187730505834365, 0.48963599694855064, 0.4039276393957142, 0.44066394415312404, 0.5224918759719688, 0.44357266348558366, 0.5023921002356064, 0.5338901823815876, 0.4512468412245755, 0.07722124684841714, 0.1394931324934261, 0.15596553223462628, 0.08186790653979992, 0.1206008547759444, 0.1411504078493464, 0.11323815934375558, 0.11678882402529511, 0.10124801999079569, 0.1490417535632781, 0.4135497286197415, 0.4531512013997925, 0.13844582924077653, 0.18307453480449543, 0.12939242716652843, 0.21725091106707528, 0.27375048722044837, 0.1795965949380648, 0.36083191674825166, 0.3148937338036015, 0.378435990266044, 0.30810096499089745, 0.3799864827406365, 0.33759479762537337, 0.31957046799056676, 0.43271488610277664, 0.2419464742100046, 0.26662238126486404, 0.2647465276095259, 0.3175361689017878, 0.24166102734646677, 0.25998560376393587, 0.26333305975207455, 0.22689009576235086, 0.3040786899999208, 0.3006492540968023, 0.19574647471934337, 0.23138000850578078, 0.22490229621398827, 0.23822085822987404, 0.20800410482988974, 0.21670219494368903, 0.24169707934809115, 0.22290139691722943, 0.20402481922458182, 0.21644719727451045, 0.19170002940417474, 0.2181046605018757, 0.23841273177080768, 0.22307224202597276, 0.22156928297731227, 0.21928805830105014, 0.18940230455297036, 0.4350105246640291, 0.15741609960250502, 0.8828414367925098, 0.19920299309027323, 0.7478236364527324, 0.19688046760958422, 0.16489127852421848, 0.7220890125908537, 0.15257040803029265, 0.7805505357752865, 0.6466930531168398, 0.21151191033670347, 0.4873885331399559, 0.21116779329320057, 0.20931022710171399, 0.16662930333888382, 0.16516782639813932, 0.41918545180399736, 0.49727109071691944, 0.20275752367240407, 0.19526344652202, 0.24354227315195398, 0.19460636244521734, 0.2131571065510166, 0.19016917148519785, 0.1904670713347718, 0.2235965937510478, 0.20290286691402026, 0.11387299520671934, 0.09719077629638073, 0.10071391196201984, 0.08001197187225828, 0.10739009977122127, 0.11955457827786775, 0.08329481708010611, 0.10924337582949106, 0.11089397853962346]}, "mutation_prompt": null}
{"id": "712eeb46-b8c9-4a1e-85a4-b1e4f6116582", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "c83eba39-7f17-44bb-8d96-3a232ea477a2", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "811b655a-6bf4-40eb-bddb-7b1daab93840", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "271a8e86-1475-42d5-97ad-b71013c50f12", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "a7155bfe-693d-425a-b17d-a4c6ddcd4686", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_AMP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best) + np.random.normal(0, 0.05, self.dim)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def perturbation(self):\n        if np.random.rand() < 0.1:  # Apply perturbation with a probability of 10%\n            worst_idx = np.argmax(self.population_values)\n            perturb_vector = np.random.normal(0, 0.1, self.dim)\n            self.population[worst_idx] += perturb_vector\n            self.population[worst_idx] = np.clip(self.population[worst_idx], self.lower_bound, self.upper_bound)\n            self.population_values[worst_idx] = float('inf')  # Re-evaluate this individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n            self.perturbation()\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_AMP", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Memory and Perturbation (EQDE-AMP) refines convergence by utilizing memory-enhanced parameter adaptation and stochastic perturbations to maintain diversity and escape local optima.", "configspace": "", "generation": 60, "fitness": 0.23474736700243248, "feedback": "The algorithm EnhancedQuantumInspiredDE_AMP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.44263279969232994, 0.4663855280275164, 0.46449507779776655, 0.4542399134740749, 0.4895937543900948, 0.4497857901293323, 0.44931235168513084, 0.4772623545935263, 0.46171099752566325, 0.057839475984407196, 0.09066954664305227, 0.04046492145593805, 0.1213601796158873, 0.06945558311144429, 0.06521496154039019, 0.04371181637060362, 0.08589697023500831, 0.05399475724825187, 0.12873946868172026, 0.14033940439162884, 0.08343846563077717, 0.1110139374638176, 0.12475405151839936, 0.11857747105240846, 0.10451045760425937, 0.1345967456988466, 0.09392277742839816, 0.08929302608173306, 0.0832084863382011, 0.08869211327967219, 0.12474487165559023, 0.09476809751126314, 0.12368957297242633, 0.09661842863389503, 0.07848325593147332, 0.1319874679097638, 0.9189098992166006, 0.9293922321859724, 0.3340498541085277, 0.8814493028290383, 0.9014970385044009, 0.9184644704782817, 0.9009455181517309, 0.958197036196303, 0.9363335414056178, 0.28131198599067375, 0.30320267899910447, 0.33616731656531307, 0.3142008118935471, 0.334188211266073, 0.3140683929892214, 0.3292792356553432, 0.3057138293850443, 0.33826003744307787, 0.1842052007547692, 0.8330874666808058, 0.8496300482219215, 0.27678949714659506, 0.2790427832059239, 0.3952301532939648, 0.3851906409042959, 0.2345224034590807, 0.23423734190622103, 0.15266981782115652, 0.21658028641184246, 0.16023268787392475, 0.13511862567695976, 0.15083127410855435, 0.17474045907077274, 0.16431177447788214, 0.14949921688039025, 0.18558213045718974, 0.1870903431280242, 0.1237186831103334, 0.14419551722912183, 0.155034905425101, 0.14683115271151415, 0.18136231397875346, 0.1697212419046944, 0.1939147942916759, 0.15871250503655843, 9.999999999998899e-05, 9.999999999998899e-05, 0.010234800658824317, 0.05495622993107341, 9.999999999998899e-05, 0.0021030831156764185, 9.999999999998899e-05, 9.999999999998899e-05, 0.1231668918693889, 0.09289314240507351, 0.08203214876847975, 0.11981358756521354, 0.10725838185839798, 0.06244341460021874, 0.09002271684336649, 0.13100916850007216, 0.1041969730258534, 0.07561200637858767, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12460351099925959, 0.08027416086891859, 0.10192439691717847, 0.1245907526965635, 0.10173016080741959, 0.12324826162092217, 0.11682060665481786, 0.10662090320409967, 0.10901397375080146, 0.4246690088836994, 0.4130869194501329, 0.45482531285833816, 0.4260810145956302, 0.4496467749531581, 0.4099187806526252, 0.42899634034453915, 0.3843481244242737, 0.4086557568846896, 0.08235932846734273, 0.09929759956250872, 0.13534693738111436, 0.10692693385410057, 0.09669767693130193, 0.08683758972515332, 0.09799821164899991, 0.13234067617053602, 0.10766024497056914, 0.19074770178304157, 0.27449108827569646, 0.31230794172562293, 0.2776385835450569, 0.29463014240227736, 0.2853203993333655, 0.17962261216910724, 0.29402033386011306, 0.34126878206230615, 0.29163912712152307, 0.2915093257569481, 0.3006460624549475, 0.2991836165647068, 0.29771242779885443, 0.31597691351132584, 0.28382593452649485, 0.3117945108695984, 0.28966787485507917, 0.1989652701795145, 0.2382641444395861, 0.23536599299797312, 0.23071736343224425, 0.2396081605155087, 0.21777883921929964, 0.20355233081643764, 0.24162036024839995, 0.2695280040954169, 0.2173867944901483, 0.20551086235823324, 0.1969359536056433, 0.2283824639680161, 0.24029070131491548, 0.2182863659062506, 0.23121829965739749, 0.20683314972642297, 0.2409499387217634, 0.19083139724325404, 0.17668851052113244, 0.19487365956018288, 0.1819178482210173, 0.2021775115253176, 0.2964678023582875, 0.24105162473263597, 0.19480484083861294, 0.196098955433458, 0.16665604716295201, 0.1982991948904701, 0.18656588455400902, 0.6472349379548819, 0.19606158912448923, 0.19675370883421628, 0.7084455372079648, 0.1663166787718039, 0.7693273177593069, 0.6273359555835465, 0.21089417683044465, 0.6069620660782442, 0.21033846666385037, 0.2095419279389482, 0.5103643449324203, 0.11200973579710005, 0.12724646413922325, 0.5938195769000754, 0.1862286750215112, 0.19257413688364777, 0.18269451232609502, 0.18472462422303992, 0.17964768539144238, 0.1857000738332295, 0.18791843875027625, 0.18376572063892316, 0.20088135129938411, 0.08966446103946946, 0.08445694865048448, 0.08961810838951056, 0.09258619077657726, 0.08141902475505469, 0.0867393396069136, 0.1176962408659814, 0.08633840508992541, 0.09571115658135132]}, "mutation_prompt": null}
{"id": "f6127743-3785-4fe7-8cc6-f860f1cb5eef", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "e5a49dc7-e5b4-46cc-a001-27623d8ad625", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution_AMP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.6, 1.0]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.2\n        self.phase_switch_threshold = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > self.phase_switch_threshold:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - self.phase_switch_threshold)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.standard_normal(self.dim) * 0.05\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def dynamic_phase_transition(self):\n        self.phase_switch_threshold -= 0.01 if self.phase_switch_threshold > 0.05 else 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            self.dynamic_phase_transition()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumDifferentialEvolution_AMP", "description": "Quantum Differential Evolution with Adaptive Multi-Phase Exploration boosts convergence through dynamic phase transitions and adaptive mutations.", "configspace": "", "generation": 62, "fitness": 0.33319135213730927, "feedback": "The algorithm QuantumDifferentialEvolution_AMP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8436099007078156, 0.8388805889017069, 0.8452725439203363, 0.836150861385695, 0.8443433364353294, 0.8558314803032789, 0.8329920837943512, 0.8401403472119195, 0.8532768717801964, 0.6892608482176006, 0.6503084226238307, 0.7324106370020228, 0.7083579618582645, 0.6841838623335297, 0.7010631799415921, 0.7187112668164151, 0.6873312527250296, 0.6900466353341753, 0.14133399139856961, 0.15560751341862322, 0.1570826909765759, 0.1569670006409951, 0.13002225508453014, 0.13142186903841535, 0.10915511849823833, 0.1516259546368054, 0.18441672891031857, 0.117740502289438, 0.10104525907313622, 0.1738512401035478, 0.10911995399652608, 0.11405339852654539, 0.09335771663632808, 0.10822880151526515, 0.10153546650245426, 0.11047351190008958, 0.9356532457670724, 0.9188970514780308, 0.9113031071870584, 0.9333267629269706, 0.8807645364477303, 0.8925430398986905, 0.9426482028455762, 0.9484854853417503, 0.9742094546322781, 0.6491472046614388, 0.6809888076412914, 0.5808995511818609, 0.662196837406394, 0.631378152659072, 0.6369099267002478, 0.46281771631776225, 0.6429318817362841, 0.5267787325686583, 0.8837134091633364, 0.8127818936702925, 0.37670114569045055, 0.2733492598135103, 0.272849887953172, 0.8351516568329436, 0.36201662806838053, 0.23364317540024848, 0.23756759127089166, 0.19584186866993247, 0.21869346111758614, 0.1284919148676238, 0.16072961575231892, 0.2633247511064104, 0.16013419676968355, 0.18032037840858506, 0.1810221958481283, 0.20623660572030766, 0.19219447309836502, 0.24948817882872787, 0.21697316797290855, 0.2139704213806526, 0.3595589489666269, 0.16406712607336904, 0.2378508390227385, 0.15824018613441915, 0.184805531012863, 9.999999999998899e-05, 0.07365727506601849, 0.015242360786068221, 0.029281137028331572, 0.18628945258704754, 0.033880087792670155, 0.06769291758969742, 0.06917731753888579, 0.061059605698356556, 0.1290069647542721, 0.11418082547442521, 0.11604959653495772, 0.07068424683967078, 0.0316214635486165, 0.09010476082808783, 0.18542935307671782, 0.08985903707422094, 0.15696281778072296, 0.07841379916375901, 0.19111161057686354, 0.08507855935506192, 0.16583122679704976, 0.09410310163251911, 0.15689263147379373, 0.11843664797447706, 0.2835192510407032, 0.2893549413208252, 0.13376724377279048, 0.27127088437077596, 0.17213249688917098, 0.2541843322796128, 0.29413070346903747, 0.3266706252676449, 0.17648539659429918, 0.18384734530375357, 0.0990883051256013, 0.5839856487299142, 0.6249472246384684, 0.571623383819094, 0.5478104422755338, 0.5347658262352437, 0.5408267870790273, 0.5550509531878529, 0.5838317073308612, 0.6089348366531557, 0.15536113040978583, 0.11773374587360597, 0.14055818508379492, 0.13884735649826252, 0.11156283230876218, 0.1422410800452948, 0.13873965200430016, 0.6803534957672188, 0.13854486812773137, 0.15324181299064754, 0.22945265774242185, 0.22987340641628584, 0.6387355357338973, 0.642945727576719, 0.48967003513077845, 0.24095631356641822, 0.2564712276131035, 0.23059806223550505, 0.35341461559480447, 0.4063520908213979, 0.29379752824838434, 0.34590949800168413, 0.34969671952332804, 0.34395954123517314, 0.6467307674318612, 0.43774376247750624, 0.43543758898502527, 0.30071849236095105, 0.31295306736471473, 0.3311241607572646, 0.18522961674398308, 0.43516334329377626, 0.3536651682682276, 0.35463065380138536, 0.30638997243803756, 0.19846841021931272, 0.28585027900410087, 0.2557872611892624, 0.2407366420318089, 0.22105250046071712, 0.23310589260380843, 0.196212149474432, 0.23335022021820484, 0.22744800017141187, 0.2010006588072868, 0.2187331526104488, 0.20646192072033354, 0.1848893397340564, 0.17715377085231032, 0.19765928571555158, 0.17955790713622977, 0.17131213054268157, 0.18570996375998405, 0.19808723713057064, 0.18622954697007588, 0.18551743908974794, 0.21178133278701894, 0.19771154059150053, 0.19769714868488852, 0.16770788435106754, 0.17068935332771962, 0.148236695804432, 0.8772397689003377, 0.8593037307967027, 0.207529132251695, 0.1675949482216731, 0.20713190666618153, 0.8567111576752513, 0.16606950171503576, 0.16628736153253454, 0.16540087710729656, 0.42989093354391084, 0.23640751049724007, 0.437509410228328, 0.26718754026967995, 0.24754290427847014, 0.22101532172943827, 0.25920610687413814, 0.24678324749083647, 0.25798477404567666, 0.2490378251848131, 0.08214607950691477, 0.10195656798091335, 0.08695979863044356, 0.09003432676863632, 0.12102144258382341, 0.09270906003621493, 0.09043181525846433, 0.1033792480169703, 0.11072399459837945]}, "mutation_prompt": null}
{"id": "8adfd26c-cc0c-46ad-8d21-a5c12b280297", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "e6b0c489-e4a1-4ae4-b8ce-1183ec79f6d9", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE_DPT:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.success_threshold = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.clip(np.random.normal(self.cr, 0.1), 0.1, 0.9)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 10:\n            recent_successes = self.memory['success'][-10:]\n            success_rate = np.mean(recent_successes)\n            if success_rate > self.success_threshold:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - self.success_threshold)), 0.1, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "AdaptiveQuantumInspiredDE_DPT", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Parameter Tuning (AQIDE-DPT) uses history-based parameter adaptation and enhanced local search to improve optimization efficiency by dynamically tuning parameters based on recent successes.", "configspace": "", "generation": 64, "fitness": 0.3457837412302198, "feedback": "The algorithm AdaptiveQuantumInspiredDE_DPT got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8697871362638162, 0.8575252243611039, 0.8805588997982153, 0.854967856823776, 0.8583096395000087, 0.8640992177663833, 0.8592840483640873, 0.8679258106282398, 0.8531472599742247, 0.7291455235650037, 0.7373014627841182, 0.7628389191657996, 0.7172809309911068, 0.7448395359333544, 0.7598964564658615, 0.7178427376483747, 0.7599033581757356, 0.7299039127037221, 0.07933724106109985, 0.15683361474096325, 0.09497340219053063, 0.13239230799767387, 0.707140307028389, 0.15868256934536729, 0.13349722701331124, 0.15314632675480222, 0.12182873279933626, 0.0943832774365192, 0.10215798417181265, 0.11689965581649264, 0.09702602796090487, 0.1286048537152188, 0.1292232290363392, 0.1289965522028027, 0.09345965859957306, 0.10277589710426527, 0.9028700834803917, 0.90898410180508, 0.9235643668362831, 0.9108445988158133, 0.9396356748935889, 0.9103829644554376, 0.9184408604098036, 0.9363031045343406, 0.9115031542538848, 0.6625157064713043, 0.6514817623243304, 0.6814459249396947, 0.6625369284932657, 0.658322290777815, 0.4688633167590267, 0.4451664170217887, 0.5973605915262192, 0.6258332498033895, 0.8863925311544313, 0.22527941622851955, 0.8694686236180732, 0.730720050973607, 0.8971367175055885, 0.6703486656486846, 0.38942720250797436, 0.24296873324986135, 0.8817912635041394, 0.2749319915183951, 0.18689463561822017, 0.16254003236355108, 0.13203179959809763, 0.2038154552430942, 0.19074602308009048, 0.17870752709550508, 0.1810687142237818, 0.18509832030878137, 0.2090352892042432, 0.20591162483443803, 0.12810845014667682, 0.16160719460862782, 0.15655796566735147, 0.18937962650348272, 0.21435752619866943, 0.15643134821257587, 0.19950105603906187, 0.08725531230855088, 0.0004206656780073592, 0.07706575165968244, 0.014223862294910017, 0.03446901226611876, 0.06030423061738799, 0.012946013732775818, 0.05873559572141007, 0.0423757798768698, 0.09493876258751532, 0.20738775630995976, 0.06329982405916634, 0.07919769132556465, 0.18769945306549052, 0.026908708971845607, 0.1049994377866047, 0.07315135617334889, 0.11568626084541833, 0.2235680910531479, 0.1349298956286331, 0.18455861748854763, 0.09132868769925429, 0.10411344039956238, 0.14176122322117757, 0.15509203214745704, 0.1473686858648534, 0.21053443306976083, 0.21351916266274396, 0.17980717545162572, 0.08378276964759224, 0.12721992792156567, 0.1972897240260414, 0.1490059846222126, 0.16451716668158245, 0.13122054998516142, 0.15132694150288317, 0.5706650539963876, 0.531077080453207, 0.4954849744305414, 0.6175768395012886, 0.5611863243799906, 0.60730278291912, 0.6170397177340903, 0.6002122501585473, 0.5599947375528409, 0.1404299027177105, 0.10827463476893395, 0.1421021529119324, 0.12216105303240643, 0.0797804174824891, 0.10812496495050195, 0.12210571616866406, 0.07768668263576473, 0.10937339711736493, 0.15516845841329163, 0.2734565275974793, 0.23136542246044856, 0.2728933266437883, 0.23116833941836334, 0.7574528566523892, 0.22128457098769672, 0.6666129475411103, 0.3388843380234131, 0.5196750023380463, 0.49037772459876583, 0.1613932299901244, 0.5566586856974507, 0.436587928088352, 0.5483397207907224, 0.5626477372582899, 0.5691465955542838, 0.4349617565452981, 0.3776726512233397, 0.3352845513023952, 0.30291937206812125, 0.26246193238689974, 0.28867777811509154, 0.33645132819296664, 0.4729648227344243, 0.30329450229637833, 0.35760095242313206, 0.22009451015523152, 0.2647767214470125, 0.25538979222117575, 0.20051332190677307, 0.2226804916187921, 0.2053899329823653, 0.30353371009810604, 0.18389088102196205, 0.2637708573324664, 0.18229658464141552, 0.20943538869798906, 0.19938456739204757, 0.20239158958533188, 0.200611493013658, 0.2075901881298936, 0.1961861308080366, 0.1970138649705203, 0.18810301032296095, 0.1870504144575187, 0.8820966641742544, 0.1993466965867977, 0.8808383457173479, 0.19609813914171437, 0.14728907100445354, 0.14221475982080267, 0.17881612380200873, 0.7677590836039349, 0.8965030364879536, 0.21029569184025698, 0.5908602511855057, 0.21118823562891975, 0.12662333302235385, 0.1544262782648248, 0.16269150304531454, 0.20834450357986523, 0.8326347524867388, 0.22792319753352375, 0.24186217067300053, 0.246164977910298, 0.2340716576625982, 0.19201005919705472, 0.25824194877189277, 0.2777156649929725, 0.26134961667027423, 0.2572246702074248, 0.09217410437972684, 0.08945194370640419, 0.09987294525619961, 0.09660011333037255, 0.09863688391809933, 0.10670261148910143, 0.09331197933786284, 0.09867920776049577, 0.08894302778029617]}, "mutation_prompt": null}
{"id": "0ef67eaf-00c2-4024-9ee5-c127885e38bc", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "a043695c-f8f3-41f6-842d-0260dd0c0fe4", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "37ad2342-1099-459d-b7ee-5cbe934a48ad", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS_DC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.diversity_threshold = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        self.population[idx] = 0.5 * (self.population[idx] + self.global_best) + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def diversity_control(self):\n        center = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - center, axis=1))\n        if diversity < self.diversity_threshold:\n            self.population += np.random.uniform(-0.5, 0.5, self.population.shape)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n            self.population_values.fill(float('inf'))\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.diversity_control()\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS_DC", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search and Diversity Control (EQDE-ALS-DC) introduces diversity control mechanisms to balance exploration and exploitation for improved convergence and robustness.", "configspace": "", "generation": 67, "fitness": 0.26085202356369114, "feedback": "The algorithm EnhancedQuantumInspiredDE_ALS_DC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.5092712611122738, 0.48153721989843734, 0.4957794490664533, 0.4800483546841937, 0.47947539694523267, 0.48814786348463346, 0.4846754903327043, 0.46456899499332827, 0.4535195715927758, 0.2443511977852667, 0.30695955301176603, 0.40887192399356054, 0.35309126593015727, 0.3466023872957168, 0.31851282261321157, 0.32242208919403015, 0.27193509530763027, 0.25287394867081026, 0.11022439992236854, 0.13988294322238504, 0.10535051746199153, 0.13833267486748624, 0.14176012590407738, 0.1433140247406387, 0.09494509658569927, 0.1143047230611468, 0.15405886432245297, 0.13400371075737094, 0.11994268448873424, 0.13929151518441862, 0.13079178582903828, 0.11274196945367998, 0.1075553854614929, 0.1115879000118799, 0.12877064220265655, 0.11851172611400052, 0.9512321010714494, 0.9270567679586825, 0.8864832537571707, 0.8099685607194483, 0.9524168852212277, 0.9442964704577749, 0.812258269195755, 0.905360199180746, 0.9276734108932341, 0.28330434140933203, 0.2939216823351194, 0.2935147417085414, 0.29866942707373434, 0.2875679184384913, 0.29790942352687266, 0.27210511028925144, 0.28319327163831676, 0.2883902550326324, 0.6238532585932364, 0.3205258704094843, 0.74533863517664, 0.2799442217390491, 0.4329137034300665, 0.7554044742556604, 0.3106820584123544, 0.5422749297120827, 0.3105697466028975, 0.15993204180527987, 0.16126624736560957, 0.18379505498820503, 0.16925928673655222, 0.18388968937018924, 0.18683465853959946, 0.16731903373017232, 0.2172645857653538, 0.22272496529018515, 0.22776321914569775, 0.13943644344213135, 0.18544718322500375, 0.15131590979879295, 0.18866234194960907, 0.20055385045993668, 0.21511703818386385, 0.19372424306198066, 0.20845168061912167, 0.005171323712091946, 0.07254184976234479, 0.07173711610332933, 0.034502024208241, 0.034386110027102235, 0.0020771842460084455, 0.039466555046617446, 0.0684336747031481, 0.021232838507533214, 0.18820036343029967, 0.11522600869892341, 0.10184666426445854, 0.10820773420345509, 0.09841809252392308, 0.0651473552402776, 0.1238536497481062, 0.09700235328622353, 0.08301047191292277, 0.0008050164285418049, 9.999999999998899e-05, 0.00026747758294620727, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005562160772464297, 9.999999999998899e-05, 9.999999999998899e-05, 0.1069241603913581, 0.1420718935182913, 0.13918482935564314, 0.10988298941486341, 0.13652196111525716, 0.08900362072405332, 0.12285936817088916, 0.12512200892093917, 0.12113645051225663, 0.4376319411519932, 0.4285130225986509, 0.4577282468516759, 0.4985670005414783, 0.4543238524146558, 0.44330269515982623, 0.46817632657725883, 0.4979930190362304, 0.47146562240167833, 0.1544788491304615, 0.13960572916446912, 0.09657853342351264, 0.10334395019097464, 0.17582111042087167, 0.14001676038166422, 0.1600384988722071, 0.11166517977341994, 0.11501830689828418, 0.2889430195330387, 0.18578905804490142, 0.3371111886574574, 0.2734202219272408, 0.3441280162038204, 0.27103934030237553, 0.3046098830427172, 0.29934270578334643, 0.3258586689651177, 0.29750374601514906, 0.3224773086680328, 0.25657393912957815, 0.3161868230233891, 0.3309172301399368, 0.310735395434772, 0.3214786378140062, 0.3189638488375178, 0.29259322403799437, 0.19290225077968992, 0.23902913039901663, 0.26430274970271783, 0.2671897482686473, 0.23737079496850155, 0.2572582496073246, 0.20456693462556397, 0.16543803122557188, 0.19997429443276282, 0.22468524651422073, 0.22534998697437614, 0.2288708153663117, 0.21527344081053734, 0.1912271185810538, 0.24695351480332461, 0.21835609224852892, 0.2289755090125406, 0.21405064931519313, 0.21869359291705326, 0.22432068134177285, 0.21651129438994832, 0.23671548211692317, 0.20924378741385485, 0.20373702936064186, 0.2283541888778936, 0.21221726886080983, 0.2567121126994806, 0.18717927968578185, 0.18845993541993267, 0.15356466913279843, 0.16978594439169992, 0.15160915331206215, 0.11502443063880052, 0.19776409325726596, 0.7651436804874338, 0.7333998299349915, 0.6768226747435235, 0.5581418838465558, 0.1231914392746376, 0.5861791146559239, 0.10482537700301131, 0.6559170095460582, 0.5839929837680788, 0.16711421599489584, 0.64095265756285, 0.19055059388260165, 0.1755901120431792, 0.18578849038236422, 0.18029072848468441, 0.1961615636904771, 0.20148308819698169, 0.18408407781267833, 0.2082282096200535, 0.17650378993199045, 0.07812942343622575, 0.10604328059713863, 0.09730748053877092, 0.08379708029599608, 0.0913391195616543, 0.1273806710018247, 0.11124694183857042, 0.09111271386859299, 0.08671205669570425]}, "mutation_prompt": null}
{"id": "65b45a01-23a5-4381-b9e0-1b20bd6cf694", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "8aec4f54-e50f-452d-bf94-d7628f37f6cc", "solution": "import numpy as np\n\nclass HybridAdaptiveDE_Quantum_Local:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.clip(np.random.normal(self.cr, 0.1), 0.1, 0.9)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.15:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.05 * (success_rate - 0.15)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.05 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def enhanced_local_search(self, idx, func):\n        best_local_value = self.population_values[idx]\n        best_local_solution = np.copy(self.population[idx])\n        for _ in range(5):\n            candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate)\n            self.function_evals += 1\n            if candidate_value < best_local_value:\n                best_local_value = candidate_value\n                best_local_solution = np.copy(candidate)\n                if candidate_value < self.best_value:\n                    self.best_value = candidate_value\n                    self.best_solution = np.copy(candidate)\n        self.population[idx] = best_local_solution\n        self.population_values[idx] = best_local_value\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.enhanced_local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "HybridAdaptiveDE_Quantum_Local", "description": "Hybrid Adaptive Differential Evolution with Quantum-Inspired Mechanisms and Enhanced Local Search integrates adaptive control of parameters with a quantum-inspired update strategy and enhanced local search for improved global exploration and local exploitation.", "configspace": "", "generation": 69, "fitness": 0.31897965188333016, "feedback": "The algorithm HybridAdaptiveDE_Quantum_Local got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.7408636884528852, 0.7505183042214526, 0.7714439677793918, 0.7697792649414137, 0.7771970463963499, 0.7731999660816044, 0.7587483998823724, 0.7698234407211355, 0.7712446664872454, 0.49244206116874734, 0.5367796518211829, 0.5187165251864122, 0.5264370768183833, 0.5336010700891882, 0.5342908813529978, 0.5291451438993242, 0.5052906295914804, 0.29482951433981375, 0.14743849950780963, 0.12620811805401477, 0.146370892544199, 0.11651628917353751, 0.11095910908586881, 0.15477700093201452, 0.1094335171312687, 0.1494437348476948, 0.14875278270052572, 0.10388550358968618, 0.11140742639142609, 0.08221434664812388, 0.1378343034421039, 0.10374181651630865, 0.11908296845872823, 0.10646755163403054, 0.10145338854536734, 0.08917166158762269, 0.9424531102148003, 0.808176516471993, 0.8735242720044777, 0.9343871895523727, 0.8769176841160189, 0.8853338629290235, 0.8972190227171615, 0.8907812634116052, 0.8820914887752509, 0.47365901573315605, 0.40445310622473885, 0.40387931906110686, 0.4332391401543543, 0.4712988758847996, 0.39913373203410996, 0.40327373526503374, 0.4560556133880289, 0.41952121131394793, 0.8120188249044432, 0.7859487213176342, 0.8191083813047939, 0.8225119687086015, 0.2732865329583044, 0.8456179165969719, 0.8516371400490688, 0.22911636460634743, 0.778837855896667, 0.18176774073525126, 0.15646016543136487, 0.17248773413307827, 0.35598568057241997, 0.19414305299714874, 0.15730865219638834, 0.15448799294319704, 0.20606819899418394, 0.1956282252457029, 0.47705753347812463, 0.13808996658816997, 0.18132496738244985, 0.17608538011599617, 0.2228608024650116, 0.1646465391234544, 0.20253256268384934, 0.2463666852101959, 0.17657826666549403, 0.029915726402906517, 0.05279618101928574, 0.015167590207895598, 9.999999999998899e-05, 0.031150881848034828, 0.019572504672014324, 0.0028566387710267094, 0.02880104781713455, 0.059314038425137605, 0.10972928574636776, 0.12503132852249343, 0.08875560230395751, 0.06273363491185613, 0.042200956250443955, 0.10576421396106306, 0.1353572278055286, 0.09457811050308229, 0.13956394060158017, 0.07074355934711418, 0.10855433939263404, 0.03598548549313452, 0.10561475985577928, 0.11557539283158569, 0.14655898109573284, 0.07753261260864563, 0.21451676899094496, 0.21522100570283387, 0.0835003184899411, 0.19226178115484804, 0.22913555108253836, 0.2732434892729829, 0.20283838534462983, 0.2250801394811669, 0.2558984532840294, 0.13590085610950486, 0.11887022979918072, 0.5232492365189993, 0.4996957467191978, 0.5129029590212035, 0.5601874116815662, 0.5286169443928905, 0.5981142607230651, 0.555333134404832, 0.5449338721095262, 0.5885866324286901, 0.15301261615375283, 0.1305461324388807, 0.11042970768736704, 0.11841484325892593, 0.11115235329426199, 0.1696251497127641, 0.1506585818494468, 0.14021761890278817, 0.12128144064278734, 0.3687232201335473, 0.5229677403594368, 0.27015397624636617, 0.1666523755361604, 0.2095509162825946, 0.25411626661287245, 0.21708975333939262, 0.3721099513656183, 0.17583077129872016, 0.4452766011072312, 0.45251321936250843, 0.44123350550241847, 0.4274491372947009, 0.4636661174812138, 0.3662470941940331, 0.4849845715799196, 0.48425400766121407, 0.4485165708696581, 0.26684959423684385, 0.324897439738985, 0.2507769873406319, 0.2523238991691642, 0.28402823230882934, 0.3657877937705003, 0.2396890050698417, 0.2381879413923369, 0.22021327134972823, 0.21540803540275855, 0.21319673590317, 0.22557495555388618, 0.2524155821423155, 0.2593591018099429, 0.24619072268739062, 0.2397315098133661, 0.19270266375602418, 0.2341495024515029, 0.21662359890251304, 0.19403072283596978, 0.18189071781247046, 0.1947682661187241, 0.17147986615616595, 0.19372700317965563, 0.16802668902938245, 0.2000592643570428, 0.20061762484383616, 0.1827590756946602, 0.7854505692334687, 0.1843624525894051, 0.7838445344639742, 0.1995110048830886, 0.792724863201596, 0.1404777164554729, 0.8203557091615538, 0.1642866969789265, 0.5981518436699034, 0.2092736190671156, 0.8272694638345108, 0.6411428524469807, 0.6621525097112869, 0.2033320910556301, 0.1638065394841891, 0.20605429588040725, 0.09384447508215055, 0.23659147398358027, 0.23299087329231072, 0.18508434134252794, 0.30282860991324556, 0.2450434704333313, 0.27025364827126164, 0.23702302156101807, 0.2115069451671996, 0.2457341762676135, 0.10073131650598044, 0.07284348489892312, 0.09488132264277394, 0.09696787592914802, 0.1026782463310375, 0.09646830131297301, 0.09040934651070165, 0.08815861613099463, 0.09631501642380769]}, "mutation_prompt": null}
{"id": "4fd3ec1c-e04b-4211-b067-d685bae222b4", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "879d58c9-abef-4496-9a9b-abe5687cda42", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "3e49412b-c896-4abb-8cbf-5476929d09f9", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "68136197-90c6-4a1e-87c4-f905f6b245e1", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "f32033d3-5488-4618-a220-357459652c73", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "7305f8fa-3911-49d8-ae29-bab62354b6d7", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "472a5615-d76d-4f0a-868b-251484fe233b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "3aae109a-c0e5-4bc9-bd6b-9246c3d14cae", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "6ccc8deb-c30b-4e04-8992-9309ca9d4490", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "73098b97-83f4-4001-95d9-ced4da4a5369", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "687330ed-d669-400a-903a-d18522ea558f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS_DPR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_population_size = 10 * dim\n        self.population_size = self.init_population_size\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def dynamic_population_reduction(self):\n        if self.function_evals > 0.5 * self.budget and self.population_size > 10:\n            new_size = max(10, int(self.population_size * 0.9))\n            sorted_indices = np.argsort(self.population_values)\n            self.population = self.population[sorted_indices[:new_size]]\n            self.population_values = self.population_values[sorted_indices[:new_size]]\n            self.population_size = new_size\n            self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            self.dynamic_population_reduction()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS_DPR", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search and Dynamic Population Reduction (EQDE-ALS-DPR) integrates population size adaptation technique to balance exploration and exploitation dynamically improving convergence.", "configspace": "", "generation": 80, "fitness": 0.3447138597781, "feedback": "The algorithm EnhancedQuantumInspiredDE_ALS_DPR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643998081, 0.1418976704868119, 0.12174427390789044, 0.1410766942726186, 0.18112227938980607, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.0878234882066663, 0.10184287578489892, 0.15363748526557652, 0.11379661853977052, 0.09725260035001704, 0.08937807098369033, 0.10167258329819762, 0.09053263325454808, 0.15458926964250552, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.5861075607499859, 0.5269611538149057, 0.5505967651086398, 0.3549594680489654, 0.5695742052210977, 0.4720585855365047, 0.5425691644935053, 0.4730937815437005, 0.4445986411321574, 0.5178887262271048, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1794753438424701, 0.22943402882485908, 0.17380565180181784, 0.17333330742841735, 0.21625520747156302, 0.2375880252994621, 0.17915809575800068, 0.19660853791507438, 0.13143290709776034, 0.2850312396849053, 0.23827469070314344, 0.15491122692978787, 0.16970244344545393, 0.2035722739871666, 0.19803579218898548, 0.3021733844874379, 0.2235797069177996, 0.2168136495928228, 0.049505566961553615, 9.999999999998899e-05, 0.014387317602664762, 0.0835454176557594, 0.2981939169506569, 0.0005732034324366087, 0.04618209416585195, 0.13861988851878537, 0.08718862260367188, 0.0697713349345398, 0.23731502573948082, 0.08855551226820368, 0.08184445693198594, 0.028922477008068603, 0.04963100231836837, 0.13977962175391911, 0.1013555477083109, 0.08111215764246937, 0.18260111556669634, 0.08410802754298896, 0.08528332432811281, 0.15567073162508405, 0.27139499153282, 0.14840531029947868, 0.21545534867812333, 0.2230806900267165, 0.14648261241282723, 0.18061264108967656, 0.167195140966802, 0.14102594162416315, 0.11771257583319639, 0.15129217470557033, 0.22119580632258418, 0.1384690839799707, 0.10554537373912354, 0.09648583744979444, 0.6185889740924648, 0.5508896795048369, 0.5371810067864313, 0.5641166699654286, 0.5851287921714021, 0.5737606308857073, 0.6053607238067977, 0.557217944750171, 0.6384227632839868, 0.07842064408162563, 0.13951300442112258, 0.156498413446158, 0.08191458511622407, 0.13057279237846053, 0.1428414754236632, 0.11521809522291604, 0.1170355242733262, 0.10149577286699096, 0.15600624765261295, 0.4249021928651645, 0.6278637322493874, 0.09855305120349966, 0.20038423392849936, 0.10798713552628325, 0.22965998032104795, 0.27405322101159435, 0.19998624234223894, 0.5670404302387757, 0.5467963898556538, 0.4562820268376043, 0.46370461041364486, 0.5460051873961541, 0.44161219792483064, 0.6702062764321585, 0.6909055651614374, 0.2635286851933023, 0.5322233032858419, 0.2871979172858652, 0.36311220707212777, 0.2619442555560175, 0.28772919493250537, 0.403508482456587, 0.2552621673273585, 0.3957097084774286, 0.32418689577070814, 0.1963278723315962, 0.24012391195199023, 0.20191868847902905, 0.24352285392705875, 0.21518983080157283, 0.23438073493243106, 0.2384266945189264, 0.22331083355641035, 0.20293542228872652, 0.18988573298003297, 0.1768272042526543, 0.18630484382659473, 0.19659652692306273, 0.223257629134474, 0.22203250405287622, 0.18687400856289438, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244578, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6025875173974569, 0.21117749145010656, 0.20931089018327242, 0.16663200638100883, 0.1651838157839951, 0.4824701372202982, 0.7911920286313672, 0.20183811419601994, 0.2804485769355074, 0.43926510165787247, 0.2417893726454513, 0.2187003967854524, 0.20859003335410098, 0.27217699619411573, 0.2538920002165239, 0.2929975788343857, 0.12341369260961288, 0.09711306128050656, 0.08747673411452961, 0.0846960309677337, 0.11590556729152035, 0.13024475711963457, 0.08441542973985561, 0.1095092190657091, 0.11089908114213398]}, "mutation_prompt": null}
{"id": "c5a784f1-ff63-4d46-9a99-32fb1e1d0fea", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "a3887a76-f30c-43b5-9c22-30d998f192fd", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "b1b7e3c7-e779-441b-8178-833d49e7678b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "fd6212bd-e4cf-4c0d-82ac-d5bb23603f73", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALS", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Local Search (EQDE-ALS) incorporates local search with adaptive mutation and crossover to improve convergence and escape local optima.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8659679257105333, 0.8530771925804718, 0.8726790323052228, 0.8644591329482919, 0.8513374148133181, 0.8665309376866961, 0.857261458570368, 0.8716562609675167, 0.8491430758078322, 0.7438116363054269, 0.73503131727711, 0.7551449317420817, 0.7291364763037509, 0.7183956969050164, 0.7793439708940663, 0.7598998289578287, 0.7364373833681405, 0.715414785634263, 0.10371366643997204, 0.1418976704868119, 0.12174427390788367, 0.14107669427255953, 0.18112227938945258, 0.14111470925748448, 0.14146086289853954, 0.1817889980028079, 0.13077296291295493, 0.08782348820666175, 0.10184287578483786, 0.15363748525520948, 0.11379661853975098, 0.09725260034989858, 0.08937807098540029, 0.10167258329814688, 0.09053263325454808, 0.1545892696454646, 0.9137986143372175, 0.9045682461064655, 0.933586312776991, 0.9072309659582118, 0.9077168794276711, 0.9636186451701646, 0.9515491010958992, 0.9373045026925149, 0.9626539860269818, 0.6493384784831653, 0.5606374134046206, 0.6012532945004205, 0.4621058993526296, 0.6612877927604021, 0.47510585003110317, 0.5849821154713306, 0.4817808045856071, 0.5008941042875226, 0.48481980629826693, 0.8849169306166329, 0.3946788588361413, 0.8880139500562098, 0.8888416773323315, 0.2746032072022082, 0.8774354611543508, 0.22576058803769894, 0.8590911164369317, 0.1835271192486494, 0.2295223283575447, 0.186458576151042, 0.17355077184650292, 0.2207250023238123, 0.23739272308930903, 0.1811938218497966, 0.1980298215597016, 0.13143680913810407, 0.2860974485366351, 0.2398517681535418, 0.16199013973028253, 0.17581194408040413, 0.20778545782644398, 0.1994256895422042, 0.30333370273180427, 0.22410849909406938, 0.21957654174762964, 0.05004350936555635, 9.999999999998899e-05, 0.011276044460942658, 0.0840911156209233, 0.2989264656647863, 0.0005831745071592787, 0.046312948721153546, 0.13921039624507392, 0.08756331338737833, 0.0685575309565164, 0.24303103509964163, 0.0867197018657998, 0.08362965963409674, 0.030398422043453888, 0.05187331457193045, 0.1399724783391484, 0.10388087699524495, 0.08502182425653082, 0.18260303914723075, 0.08410940976639847, 0.08529173949390079, 0.1556709878902096, 0.27139583721626237, 0.1484058922922935, 0.2154581023807618, 0.22308204798015552, 0.14648370189678883, 0.18061452662329824, 0.1671945390309032, 0.1410262251767188, 0.11771928806625787, 0.15135602708256812, 0.2211956379268396, 0.13846759124865748, 0.10554605451019905, 0.09648853442325256, 0.6212998086400858, 0.5522932502572082, 0.5376888400239902, 0.5645864263555915, 0.5852362253775508, 0.5742156378085269, 0.6029449998924216, 0.5578863410362515, 0.6418063877198733, 0.07842064408162563, 0.1395130044210986, 0.15649841344612647, 0.08191458511622407, 0.13057279237845454, 0.14284147542376813, 0.1152180952229328, 0.1170355242733262, 0.10149577369444485, 0.15600624851846367, 0.42490215800615727, 0.628389621365475, 0.09855305120349966, 0.20038466249262388, 0.10798713552628325, 0.2296631059987182, 0.27405312628305956, 0.19999100022773042, 0.5672107411786089, 0.5464780376966312, 0.4565324125807704, 0.4636284754416614, 0.5459053638564266, 0.44212660716736485, 0.6944349264030616, 0.6898882471990013, 0.263524872879656, 0.5358748788026431, 0.28718337124983473, 0.36308380849389177, 0.2619313919127425, 0.28752319237255775, 0.4034915122451004, 0.255268150845232, 0.3957133420339526, 0.3241602438967368, 0.19632872141520874, 0.24022140806561787, 0.20193867749455108, 0.24353421868869485, 0.21518983079582188, 0.2343807349332263, 0.23858980521619189, 0.22331083352384384, 0.20293542231843076, 0.18988573298003297, 0.1768272042526543, 0.18441109988441617, 0.19659652692305918, 0.223257629134474, 0.22203250405286556, 0.18249599794058413, 0.18946978218360178, 0.1829000640265367, 0.15741781989852788, 0.8743056644205526, 0.19920643985911102, 0.17164227711922542, 0.19688100151744792, 0.1648914102869916, 0.9062274126701154, 0.15257455113244012, 0.9180785446948594, 0.8512030237169717, 0.21151706351739863, 0.6059199353679792, 0.21117749145010656, 0.20931089018322702, 0.16663200638100883, 0.1651838157839951, 0.4958249150990559, 0.7911920286313672, 0.20183814599913497, 0.2815121470135937, 0.436953599511677, 0.2417819288239209, 0.2187030172479989, 0.208595335710548, 0.27217537043404816, 0.25388515072337703, 0.2929970604289831, 0.12341369261126256, 0.0971130612815605, 0.0874767341142495, 0.08469603163550332, 0.11590556750176106, 0.13025190100401174, 0.08441544518703437, 0.10950921906742284, 0.1108990813834072]}, "mutation_prompt": null}
{"id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 85, "fitness": 0.3555547629785226, "feedback": "The algorithm QuantumInspiredDE_ADS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "68819bb8-ce65-4824-9d5b-93db5ddd99cc", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "08e3fe40-f7b7-48c2-8bfc-2f3920303daf", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "9c6666d1-f113-43e2-a479-abfb87b11d92", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "3b7de305-394f-4d21-825a-e9bc2ed58d79", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "88c89397-d61e-4265-8a91-4bcb6b26e2bc", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "60f1cd03-d27f-44f3-aca6-d342ef9de0fe", "solution": "import numpy as np\n\nclass QuantumInspiredDE_AQW_GS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        if trial_value < self.population_values[target_idx]:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n            return True\n        return False\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def greedy_selection(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.05, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx] or np.random.rand() < 0.1:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n                self.greedy_selection(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_AQW_GS", "description": "Quantum-Inspired Differential Evolution Enhanced by Adaptive Quantum Walks and Greedy Selection (QIDE-AQW-GS) integrates adaptive quantum walks with greedy selection to improve convergence speed and solution accuracy.", "configspace": "", "generation": 90, "fitness": 0.2895376466208414, "feedback": "The algorithm QuantumInspiredDE_AQW_GS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.7411429052037206, 0.7132140929543077, 0.5981875251083084, 0.6125138878266088, 0.6931459306444195, 0.6301654554169234, 0.6692560640253371, 0.5776502058727947, 0.6742924679578053, 0.22524664991507626, 0.2855264232722292, 0.1363610151884852, 0.314685040467081, 0.2388581151489686, 0.2937109772785168, 0.22724587594190238, 0.27998557583965544, 0.19594081183277523, 0.11209207479990202, 0.11501856819253753, 0.13418568511122053, 0.14948382356185086, 0.11023830442774485, 0.11526870683089618, 0.14357345380830044, 0.13125993944596903, 0.13672743664274734, 0.08856902469775196, 0.09350270603283739, 0.07152562859850908, 0.1096592195956817, 0.11706308415353306, 0.11569607294412854, 0.08695564317141358, 0.07235337992730206, 0.09895926816523093, 0.8831233985526177, 0.8745651059370513, 0.8888283304742355, 0.8377400716338165, 0.8401727257613527, 0.8406235715157272, 0.8574841096833101, 0.870048532677275, 0.9495567085707842, 0.38020364839608056, 0.3667701181237947, 0.4424017975657858, 0.4112225173438141, 0.4025651094500189, 0.3896652009001199, 0.34677130112911003, 0.40630110888017656, 0.3944537980433077, 0.8548968476308075, 0.7843528608561543, 0.8155197247087856, 0.6469616840900243, 0.27225083684241236, 0.26787667771963763, 0.8463451482854759, 0.22878436912416478, 0.8471048905652043, 0.19515525873859518, 0.17533966126829692, 0.17802665805757856, 0.1930874252547493, 0.2665363849530431, 0.1266072148245173, 0.20257738773319445, 0.19137233167485568, 0.28986371216463935, 0.20498227626897902, 0.16669843309698917, 0.18036733128442173, 0.21633648561402918, 0.13142853670885857, 0.16439125294521617, 0.2035621458889233, 0.17434344792303746, 0.21514969459722744, 0.013623912095493185, 0.00010784151171716605, 9.999999999998899e-05, 0.054744288734036695, 0.050515303435103354, 0.00013488082463863904, 0.06818991810292574, 0.05192712950614098, 0.05032658404493218, 0.21578191737980046, 0.1485615963973287, 0.12998563471609437, 0.08586019092650443, 0.049270883660173626, 0.020654043335428973, 0.08458591314275743, 0.11292498197290313, 0.11420440511288488, 0.1237881620785738, 0.17406773595255998, 0.11098044305707133, 0.09009653630223458, 0.08275835961993017, 0.11346153992515828, 0.11547630273903997, 0.08541538279030503, 0.13649695787873328, 0.12026658854551875, 0.16365146656051388, 0.17585538464186334, 0.19925905894036056, 0.21149732801563315, 0.1571021692698914, 0.08200388109475953, 0.15997033076557887, 0.1467671080458295, 0.5265689915957388, 0.5258009286941245, 0.5184957290769135, 0.5057878897348801, 0.5339802280786842, 0.5311977230893492, 0.5272752432167671, 0.5443212224424518, 0.5562943773615487, 0.08934937917444508, 0.11528517066106891, 0.13754031180969484, 0.13896990752005733, 0.09148553636021206, 0.13965862898485848, 0.11038978921730014, 0.1309247668547423, 0.14239952901713093, 0.42521344545835904, 0.2080705787158741, 0.1821220157770601, 0.2043089327242874, 0.20338691548656407, 0.2208625038748706, 0.19287330271987901, 0.2998823592477774, 0.16052258226390892, 0.2975627930391884, 0.37373037101453166, 0.34982057757254004, 0.3407340424153438, 0.38194164927835317, 0.3105579940464748, 0.4300224980613654, 0.38373599385643575, 0.38945534773510193, 0.23234407122080114, 0.2771930995729295, 0.20935355686110868, 0.20700671928908398, 0.24369013726103117, 0.28852775960500354, 0.19323326437992105, 0.2520947424433576, 0.2508884656370698, 0.2464055271033666, 0.2356476129577827, 0.2347777478341636, 0.2225976885771842, 0.22117037468722478, 0.22910878214875707, 0.22267460892058233, 0.2197711822008821, 0.2627097398141611, 0.18296757095095606, 0.2218902910503774, 0.20668357039181795, 0.18818694028776295, 0.18098188731990672, 0.24392280434601898, 0.19503738680033333, 0.1929811029249815, 0.18339570042644682, 0.18637594131182733, 0.20706900922726845, 0.1824567353615566, 0.8806736066414022, 0.19656093951885123, 0.883232063351039, 0.8153903231000487, 0.10997509755832469, 0.16745623440966717, 0.767733101080767, 0.2063289348093641, 0.15437213949239958, 0.8276527081969232, 0.8540869785615185, 0.1987200723456376, 0.8323603400730899, 0.15304737817113656, 0.6675602357216737, 0.21128304959867528, 0.20344124063462954, 0.21238207613641336, 0.19155281923399614, 0.20054832634692077, 0.19340086194888417, 0.21745437451718697, 0.24185788848030565, 0.20526855884213302, 0.11947214739551604, 0.08446830875510425, 0.0993230430056865, 0.09426970092577214, 0.10718295216597362, 0.1201834809648511, 0.08115599700400167, 0.08179317722717838, 0.0861792022120329]}, "mutation_prompt": null}
{"id": "fa9298d2-ebf2-49ea-8421-061dc26568ff", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "e0a7543c-5f81-482e-b4f5-8228c006372d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.alpha = 0.98  # for adaptive strategy\n        self.levy_scale = 0.1  # scale for Levy flight\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n    \n    def levy_flight(self, size):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1/beta)\n        return self.levy_scale * step\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant += self.levy_flight(self.dim)  # Introduce Levy flight perturbation\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            self.local_search_prob = self.alpha * self.local_search_prob + (1 - self.alpha) * (0.5 if success_rate > 0.5 else 0.1)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def stochastic_ranking(self, idx, func):\n        perturbed = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n        perturbed_value = func(perturbed)\n        self.function_evals += 1\n        if perturbed_value < self.population_values[idx]:\n            self.population[idx] = perturbed\n            self.population_values[idx] = perturbed_value\n            if perturbed_value < self.best_value:\n                self.best_value = perturbed_value\n                self.best_solution = np.copy(perturbed)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n                if np.random.rand() < 0.05:  # Apply stochastic ranking with low probability\n                    self.stochastic_ranking(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution (EQIDE) incorporates adaptive Lévy flight for dynamic exploration and integrates stochastic ranking to balance exploration-exploitation and handle constraints efficiently.", "configspace": "", "generation": 92, "fitness": 0.2608273841743936, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.5252426161613983, 0.47950290060848244, 0.5122474938680062, 0.5149849230060981, 0.515759134491889, 0.5738878033877721, 0.5865298730252464, 0.5272563737699094, 0.5943750811672961, 0.1533120991385134, 0.07590139067144186, 0.24244045329338182, 0.1668369999559074, 0.20487136179735743, 0.12925661481240713, 0.10922363807128899, 0.23543005255174076, 0.22916726358544282, 0.13101976197746112, 0.16848117002579333, 0.16922679441406563, 0.14909463931188005, 0.11477390273399812, 0.13997988563932162, 0.1129258759441738, 0.13550908691644492, 0.16383599932101223, 0.12905786453500878, 0.12667058558881694, 0.1265845944560282, 0.1283482920524197, 0.14136893821668806, 0.11187768659811337, 0.12347632105224526, 0.11898346523806103, 0.10582384535565104, 0.9458827733640528, 0.9169446857409431, 0.9259526019747089, 0.9307722173523405, 0.9268017671875164, 0.8932682440791638, 0.8986594247631052, 0.9436884266722756, 0.9200542289134135, 0.32400144460675107, 0.36338604442414113, 0.3292088076388332, 0.3617140611617855, 0.34598521541400384, 0.39029907884343173, 0.3415020865371179, 0.3551489654970197, 0.36013707528460137, 0.829581553966593, 0.22479563971078664, 0.8581288386329046, 0.5510050633305486, 0.7403290794911872, 0.2744107748740917, 0.23227071969743718, 0.23396542222992434, 0.7270971309747771, 0.1658388572783579, 0.16526305983851053, 0.16917385571807975, 0.16086471963222793, 0.19286856887082526, 0.1693875149053674, 0.15694210539889586, 0.1826922793511555, 0.17013015408841348, 0.1612668784023613, 0.12766584680230986, 0.18696898183299426, 0.3011141583984186, 0.17906403633439882, 0.1534421015854307, 0.22160317314789924, 0.17421411334497594, 0.21465654817076663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04271824377201572, 0.0363125791583252, 0.06488047091198001, 0.02375806829004201, 9.999999999998899e-05, 0.015871389192340435, 0.15485772129524922, 0.17155723982492077, 0.09579849431829646, 0.07957390066176706, 0.014268177721630804, 0.08695523420226525, 0.12154303323060944, 0.06286612686820425, 0.08385963566226551, 0.0056234237520741415, 0.08157533465635258, 0.0013790810215025262, 9.999999999998899e-05, 0.006549577933796846, 0.022941306571954923, 0.001522756243985679, 0.0031191722656073173, 9.999999999998899e-05, 0.08959245481519607, 0.15680394686216492, 0.11763090604439075, 0.16215988920339042, 0.13519701487103208, 0.16531975661081766, 0.12909423445002954, 0.1294484169990059, 0.11528518878629379, 0.4401059021349527, 0.44101692727933073, 0.45424415259066986, 0.46272800121319224, 0.449159384472959, 0.4411999786059486, 0.46783856076848995, 0.4948941153532368, 0.47136766709508104, 0.11034176190336642, 0.14861606884168577, 0.17931176315822162, 0.10469195723852809, 0.14694664017908454, 0.10544756095659635, 0.11331058240393777, 0.1549591526907157, 0.11336761600436984, 0.17692061944139315, 0.29587296426165, 0.19249259835412824, 0.15169432373235558, 0.292399518094698, 0.23666871586882576, 0.2191196175812279, 0.18471130837851935, 0.3647906581565461, 0.29108511254228464, 0.32723233489272285, 0.31660819759377257, 0.3194406449338518, 0.32071511692089494, 0.3200728317169167, 0.32411230587628004, 0.3239691527268943, 0.33573670854865667, 0.2580896711565356, 0.22921322760147722, 0.2473182481472802, 0.2210065478526656, 0.2252475946762248, 0.27814233304854596, 0.21311160832380105, 0.24215846672120211, 0.28263176078897523, 0.22929492510066662, 0.20357172489900222, 0.2369758473197675, 0.21670452708178223, 0.18752967995930936, 0.21621468124131316, 0.232752682114582, 0.21780607196204538, 0.20205266830071433, 0.19759237360176318, 0.24201520545907107, 0.19902587771097413, 0.19614731943943686, 0.2016404982362736, 0.1808810370154561, 0.2046868587460362, 0.2005330117149441, 0.2546639935985191, 0.18719979237797613, 0.18615725535929795, 0.7948014964613803, 0.7832078710097237, 0.19936335984260067, 0.16555988871462302, 0.776421577574194, 0.14214445739614878, 0.15162866269788378, 0.7423470049633989, 0.12790560105978055, 0.5690099807667579, 0.48403347788766404, 0.7320307763359095, 0.1521788562918568, 0.15564060094652865, 0.1668572403291384, 0.4077133771049892, 0.19165757310234255, 0.19307472784461577, 0.18903374258373673, 0.1851486730948696, 0.19385476888186204, 0.20592384069021896, 0.18266846787344693, 0.17744177321479948, 0.20173064012950137, 0.08186148916564473, 0.09822351662385409, 0.09307231511926983, 0.10264210711582089, 0.08982083094996307, 0.08894093436050154, 0.08966260573023177, 0.09482509066617162, 0.0946557586688479]}, "mutation_prompt": null}
{"id": "295b5dfe-e8df-406d-9636-2f9d5c196454", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "9664638d-c999-4859-9b16-a091c16ec691", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "986c0f25-1920-43d5-a835-24e8c5930ce8", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "651ed59e-e6f7-4c6a-a120-1afe3c90fcb7", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
{"id": "79e948db-cc41-4e00-9fdb-84110f988e94", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EQIDE_CS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.num_clusters = max(2, self.dim // 2)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def clustered_local_search(self, func):\n        cluster_data = KMeans(n_clusters=self.num_clusters).fit(self.population)\n        for cluster_idx in range(self.num_clusters):\n            cluster_indices = np.where(cluster_data.labels_ == cluster_idx)[0]\n            for idx in cluster_indices:\n                candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate)\n                self.function_evals += 1\n                if candidate_value < self.population_values[idx]:\n                    self.population[idx] = candidate\n                    self.population_values[idx] = candidate_value\n                    if candidate_value < self.best_value:\n                        self.best_value = candidate_value\n                        self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n            if np.random.rand() < self.local_search_prob:\n                self.clustered_local_search(func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EQIDE_CS", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Strategy and Clustered Local Search (EQIDE-CS) integrates clustering techniques into local searches for more efficient exploration and exploitation, balancing convergence speed and solution quality.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {}, "mutation_prompt": null}
{"id": "53ab1adf-302a-4cdc-9018-d96126655a74", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE_ALF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n        self.step_size = 0.1\n        self.rl_alpha = 0.05\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            self.cr = np.clip(self.cr + self.rl_alpha * (success_rate - 0.2), 0.3, 0.9)\n            self.f = np.clip(self.f + self.rl_alpha * success_rate, 0.4, 0.9)\n            self.local_search_prob = np.clip(self.local_search_prob + self.rl_alpha * (success_rate - 0.3), 0.1, 0.5)\n            self.step_size = np.clip(self.step_size + self.rl_alpha * (0.5 - success_rate), 0.01, 0.2)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, self.step_size, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "EnhancedQuantumInspiredDE_ALF", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Learning and Focused Local Search (EQIDE-ALF) adaptively learns parameters using reinforcement learning for dynamic exploration-exploitation balance and employs a more effective local search strategy with adaptive step size to further improve convergence.", "configspace": "", "generation": 98, "fitness": 0.3435443586782288, "feedback": "The algorithm EnhancedQuantumInspiredDE_ALF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8465839511464859, 0.8383758026126209, 0.8500858783355291, 0.8447471577980105, 0.8487472788052024, 0.8643934717740833, 0.8639317267879976, 0.8563611479580743, 0.8391436226986206, 0.6934907201645577, 0.709797821695394, 0.7140525213864486, 0.7039598793674611, 0.7030601912290466, 0.6958691842061409, 0.7139368622211779, 0.693799046045231, 0.6915158567207261, 0.08575301208017372, 0.1555859077187961, 0.1569690718207265, 0.1421272480502097, 0.1126497921483468, 0.12945166309101064, 0.14065923241901512, 0.11926060148142992, 0.11594172672893255, 0.1297043205075239, 0.07803668720451673, 0.08838419055523883, 0.10858507302922937, 0.12886172805262253, 0.08053178001745365, 0.11412835797989918, 0.11031231852399048, 0.10667478253227691, 0.8859934885662903, 0.8881706719027057, 0.8986504218200235, 0.9307685574032605, 0.878343436600539, 0.9011683208394283, 0.8996065550592374, 0.9413930923662829, 0.9303312941431567, 0.6385688484754402, 0.623580722902093, 0.6085469389148631, 0.6623590766735055, 0.6171971773449676, 0.6111900767077747, 0.5958273752369838, 0.6210641265335883, 0.6598145060098637, 0.22732132973113794, 0.8793659086857659, 0.22314414218418954, 0.3812714253908961, 0.34757911048937296, 0.19830874904962026, 0.8718813226971511, 0.24129842408346225, 0.23447450400305814, 0.18505790803673694, 0.22956200975070706, 0.12394996933578495, 0.13354497693131884, 0.21039561401139384, 0.22188963245434, 0.31872864657846145, 0.17355040047819092, 0.23066195195559003, 0.21323067157674191, 0.1346973977991589, 0.23919129804629224, 0.1777966998015712, 0.17257628558508964, 0.20637590648815585, 0.20388454068238382, 0.22393720727766242, 0.1311385807412484, 0.012506961262414573, 0.1350098270797676, 0.045717673060892916, 0.11610040037667224, 0.006275289020851282, 0.08059476319568715, 0.13430678504922577, 0.173561122979068, 0.09991919731154197, 0.23137396022945755, 0.08991858594353308, 0.13710593242636038, 0.06603299339044644, 0.0938260114283701, 0.05461275147277733, 0.10972978202333328, 0.0682069259789787, 0.1159000604463255, 0.057743230855994754, 0.4531718911433531, 0.11021689125259049, 0.1632332580578224, 0.1665590443909779, 0.08851577201960537, 0.2610173590380668, 0.19769539537256275, 0.09082219107743916, 0.09531364607541759, 0.1374120673433057, 0.19939278543620453, 0.24227218207793744, 0.15378741178703625, 0.259949473874873, 0.1451359182853339, 0.2503553576471931, 0.23466777273807382, 0.5404266107772708, 0.5563702561274015, 0.6309514524090464, 0.5719528708278039, 0.6103460162186024, 0.5900855410466458, 0.633901109865038, 0.631508141404159, 0.5876015258228008, 0.12225663396894493, 0.15578578044982483, 0.1535088796510823, 0.12968793292390768, 0.09984503724167515, 0.09211929664487672, 0.13836915563801633, 0.12221554016208669, 0.11005776343348606, 0.7131676055618678, 0.2744217648146132, 0.28641587138342306, 0.32573556674666826, 0.4247364323515316, 0.7805215470338579, 0.23779794679122201, 0.4144964536919723, 0.2267718287368118, 0.5509649538264486, 0.581161184701376, 0.5113916350895102, 0.5426723581422161, 0.4631436053254786, 0.26111920315666604, 0.6888769286278733, 0.5682408051966262, 0.6379501832330439, 0.307525039100199, 0.28192507608619977, 0.45943405584218977, 0.3476700405117651, 0.321775880052548, 0.36433878176762347, 0.308742969779103, 0.39198126453526905, 0.28986282291566223, 0.2083713083509724, 0.20452812054802771, 0.20977462216966636, 0.25865756088697234, 0.23979600081064223, 0.2578436467385409, 0.23313259842750544, 0.22463211268015593, 0.22771914147226702, 0.20861268407595357, 0.2090094331114457, 0.20616547939471763, 0.19733687990037574, 0.18522349467230337, 0.24665276549597315, 0.20515363478637838, 0.22203195805036824, 0.2205217858905415, 0.18639813494989088, 0.1868942614512369, 0.1996795955055649, 0.8804571807523072, 0.1207914665021157, 0.16474262578743748, 0.1418736927184685, 0.1782603869346554, 0.8912405716546339, 0.7317672416911816, 0.21056981589810653, 0.8050216218745192, 0.21040768521559972, 0.1266738590776093, 0.15421150174984743, 0.8246165067082025, 0.2094524768941768, 0.8171257667877754, 0.23201790251595, 0.22262241671276473, 0.23106680029600035, 0.2781004797862132, 0.20897563931443308, 0.23467311817170067, 0.24645814312657421, 0.25281765290550373, 0.28720388658929186, 0.08354794283996048, 0.1253978054024486, 0.12092388376805752, 0.0713110147664876, 0.10428430270037792, 0.08675598486534875, 0.09796598663226574, 0.10671129668224588, 0.0887486608020488]}, "mutation_prompt": null}
{"id": "97d7ca7d-ba78-4633-8247-aca59c1b8e8b", "solution": "import numpy as np\n\nclass QuantumInspiredDE_ADS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.dynamic_f_range = [0.5, 0.9]\n        self.best_solution = None\n        self.best_value = float('inf')\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.population_values = np.full(self.population_size, float('inf'))\n        self.function_evals = 0\n        self.memory = {'cr': [], 'f': [], 'success': []}\n        self.global_best = np.copy(self.population[np.argmin(self.population_values)])\n        self.local_search_prob = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.population_values[i] == float('inf'):\n                self.population_values[i] = func(self.population[i])\n                self.function_evals += 1\n                if self.population_values[i] < self.best_value:\n                    self.best_value = self.population_values[i]\n                    self.best_solution = np.copy(self.population[i])\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_f = np.random.uniform(self.dynamic_f_range[0], self.dynamic_f_range[1])\n        mutant = self.population[a] + dynamic_f * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_cr = np.random.normal(self.cr, 0.1)\n        crossover_mask = np.random.rand(self.dim) < adapt_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.function_evals += 1\n        improvement = trial_value < self.population_values[target_idx]\n        if improvement:\n            self.population[target_idx] = trial\n            self.population_values[target_idx] = trial_value\n            if trial_value < self.best_value:\n                self.best_value = trial_value\n                self.best_solution = np.copy(trial)\n        return improvement\n\n    def adapt_params(self):\n        if len(self.memory['success']) > 0:\n            success_rate = np.mean(self.memory['success'][-5:])\n            if success_rate > 0.2:\n                self.cr = np.clip(self.cr + np.random.normal(0, 0.1 * (success_rate - 0.2)), 0.3, 0.9)\n            self.f = np.clip(self.f + np.random.normal(0, 0.1 * success_rate), 0.4, 0.9)\n            if success_rate > 0.5:\n                self.local_search_prob = np.clip(self.local_search_prob + 0.1, 0.1, 0.5)\n            else:\n                self.local_search_prob = np.clip(self.local_search_prob - 0.1, 0.1, 0.5)\n\n    def quantum_inspired_update(self, idx):\n        prob = np.random.rand()\n        if prob < 0.5:\n            self.population[idx] = 0.5 * (self.population[idx] + self.global_best)\n        else:\n            self.population[idx] = self.population[idx] + np.random.normal(0, 0.2, self.dim) * (self.global_best - self.population[idx])\n        self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def local_search(self, idx, func):\n        candidate = self.population[idx] + np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n        candidate_value = func(candidate)\n        self.function_evals += 1\n        if candidate_value < self.population_values[idx]:\n            self.population[idx] = candidate\n            self.population_values[idx] = candidate_value\n            if candidate_value < self.best_value:\n                self.best_value = candidate_value\n                self.best_solution = np.copy(candidate)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.function_evals < self.budget:\n            self.adapt_params()\n            for i in range(self.population_size):\n                if self.function_evals >= self.budget:\n                    break\n                self.quantum_inspired_update(i)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                success = self.select(i, trial, func)\n                self.memory['success'].append(success)\n                if success:\n                    self.memory['cr'].append(self.cr)\n                    self.memory['f'].append(self.f)\n                if np.random.rand() < self.local_search_prob:\n                    self.local_search(i, func)\n            self.global_best = self.population[np.argmin(self.population_values)]\n        return self.best_solution", "name": "QuantumInspiredDE_ADS", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Dynamic Local Search (QIDE-ADS) fine-tunes mutation and crossover rates dynamically and employs a more focused local search strategy based on success history to enhance convergence efficacy.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b37dcdc8-b9de-4eed-9668-0a1c4443edd8", "metadata": {"aucs": [0.8506929698340344, 0.8607073569948529, 0.8581973694375515, 0.8514827137149799, 0.8682511799594307, 0.8676010659117577, 0.889843036812296, 0.8576691892967582, 0.871571967368041, 0.7326796885515363, 0.753325310848362, 0.7261784396936097, 0.7493226449219241, 0.7154959381335866, 0.7308838421789176, 0.7608239931940067, 0.7329178962622827, 0.7181708572991525, 0.15542742390684705, 0.13172173950773558, 0.18473898333299954, 0.11645213538075183, 0.14615667117215614, 0.1834698187645465, 0.15776926447563022, 0.11358283368035149, 0.12232647556820775, 0.09799814008856522, 0.11442625934591921, 0.12972003539915344, 0.09879831590195098, 0.13552968653118946, 0.08100123835984685, 0.15312001423640031, 0.12055902185034517, 0.11499815054480955, 0.8982496011192201, 0.8925631500755338, 0.8918563432864174, 0.8992742291584316, 0.910096923205868, 0.9638183226768599, 0.906988990705789, 0.890364909190016, 0.9119529758885622, 0.681053501419199, 0.5627264051513078, 0.6402686875713544, 0.7046372414369064, 0.6776221913397404, 0.4155291804958986, 0.6320803106338331, 0.48239375440754806, 0.5557844567890329, 0.8959469907710071, 0.8969345526611049, 0.8679380332543658, 0.8913249757166195, 0.3771412660383602, 0.21740084820827688, 0.23530252040187694, 0.23099156581696645, 0.9033635098613828, 0.24396493345268755, 0.16514395534057835, 0.21317150618900094, 0.16924234864266197, 0.27271643298563464, 0.2101580936811397, 0.16241875537928085, 0.18075955506244423, 0.16465414740539996, 0.2704563885807243, 0.23158407531423852, 0.20624353948313678, 0.14372610178241685, 0.20291503614060946, 0.1288146760039801, 0.4223968703834844, 0.21835518948578614, 0.13229414089985803, 0.12070849893027624, 9.999999999998899e-05, 9.999999999998899e-05, 0.17172131114726452, 9.999999999998899e-05, 0.004473408627364228, 0.02328298632779935, 0.07074786449263615, 0.11065687707329075, 0.05972697163154406, 0.10881542352166229, 0.18341497971893206, 0.05583239281588337, 0.13928055618888668, 0.07757986351931268, 0.1213381905918901, 0.09800567050124065, 0.2894720723693389, 0.19250613700080177, 0.20185906817232924, 0.18934612614241964, 0.1483342203544209, 0.18982847984668982, 0.12231160536360453, 0.11398299753644747, 0.1735665559366102, 0.09376370093907738, 0.31082058135605195, 0.15496180960652195, 0.16517736328304256, 0.12473698939736844, 0.15701955853317018, 0.06570505794358328, 0.2803909836645171, 0.3458075063918361, 0.15955274235471228, 0.6303772593023013, 0.5693493622695154, 0.6485622768845959, 0.5754197551729664, 0.5013851882191911, 0.5938468081623713, 0.5843107758637569, 0.5619894641037195, 0.594285253957415, 0.12207548438118787, 0.13005739596075416, 0.1328161753203616, 0.09954211330777085, 0.14161354379724123, 0.12459691708156606, 0.1597440412928841, 0.10633052589470349, 0.1862894141475786, 0.20641899757157411, 0.2118680787419328, 0.40668701842128296, 0.21381334548360287, 0.20333282668936625, 0.3197380612193047, 0.751346483622384, 0.24901595720227798, 0.3246149182439245, 0.48976515786678587, 0.49550691332337105, 0.5450195742602968, 0.5677520622235267, 0.28186610721542316, 0.529205922349606, 0.4850718225331224, 0.4689420903718592, 0.6179032171691412, 0.3578982729821244, 0.3109038662448138, 0.38071885291093854, 0.21449441338539266, 0.3282695388261342, 0.3094967145763968, 0.48364415041945585, 0.29400979072880795, 0.34184036672806983, 0.2628168317037125, 0.2111139515720123, 0.23765405317060817, 0.20804200111679072, 0.2362740291435682, 0.25799267807391923, 0.216567612206498, 0.22266721711468862, 0.2860332095939885, 0.24895811854224403, 0.17940035793807196, 0.18451842414584818, 0.2428384410227472, 0.18160531447081707, 0.1909583731274046, 0.1731075119229636, 0.19801677943822926, 0.1984631952883299, 0.18617792419217416, 0.20927472708604644, 0.20006157878303732, 0.9057066146057771, 0.19825363091900328, 0.1658855733769744, 0.14244720285698553, 0.16222090265139943, 0.875319441125693, 0.8964465798921731, 0.21108819899359432, 0.20714251160892805, 0.21082672786950818, 0.8532667312003155, 0.7891245150338161, 0.21059952372683888, 0.7773435718490191, 0.86812410964155, 0.20368076188960726, 0.31963392212121444, 0.33999713139656773, 0.22704197681375815, 0.2539769701076682, 0.22826971495035853, 0.2539159181975449, 0.22933737601261972, 0.49686968882268734, 0.12213030574269323, 0.07679382953059843, 0.10767402092365996, 0.10855716902869739, 0.09815709837362652, 0.14837978214371383, 0.1720910865941725, 0.11643803091544447, 0.0875481751246161]}, "mutation_prompt": null}
