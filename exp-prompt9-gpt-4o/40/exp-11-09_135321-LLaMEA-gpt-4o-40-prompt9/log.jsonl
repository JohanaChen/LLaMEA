{"id": "cfd7b269-60fa-47e1-a7ab-9e05e2610fdc", "solution": "import numpy as np\n\nclass PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "PSO_ADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (PSO-ADE) for enhanced exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": 0.1540336912776463, "feedback": "The algorithm PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.45936492150707187, 0.31774088598173644, 0.30276005565193786, 0.162078571186272, 0.5401151522138108, 0.1937538559687444, 0.6161235100938793, 0.2781370294515053, 0.3129096217833208, 9.999999999998899e-05, 0.0512565655789573, 9.999999999998899e-05, 9.999999999998899e-05, 0.031696377022832345, 9.999999999998899e-05, 0.0015561915351252065, 0.03766747014644167, 0.027100360769341747, 0.08115136730833161, 0.06282040566998326, 0.0874331370304704, 0.022369758857182398, 0.06759863101041519, 0.054044624404605224, 0.04605857975180938, 0.053684710631647814, 0.08265580900046754, 0.04559890842031222, 0.05621834879527687, 0.0683976115635403, 0.036180642135180796, 0.06450395649386775, 0.031480454832190086, 0.06442952588753581, 0.025365895313483655, 0.043141438127333065, 0.9808900916337966, 0.9816417125057213, 0.9855942004638056, 0.975644530813293, 0.9806892958271443, 0.9809872543239565, 0.9864273295073362, 0.9853583153996571, 0.9805956194903139, 0.058979477634143795, 0.143196312447869, 0.08541830338988643, 0.13346169034760658, 0.13432273613379908, 0.12324036780102743, 0.0814122638112571, 0.08813701576616073, 0.08576474724112138, 0.16952798169262373, 0.2163066208753508, 0.12233898241155783, 0.21244852715793494, 0.11647321038051628, 0.17380700655226988, 0.15061171557769848, 0.2042372363741094, 0.16451922294694887, 0.13788160089643353, 9.999999999998899e-05, 0.027792301065681535, 0.10540458838277411, 0.04906848779109152, 9.999999999998899e-05, 9.999999999998899e-05, 0.025053547307728352, 0.04596994048885206, 0.1616903020786976, 0.010075724763358496, 0.14514188036735665, 0.1374771126892057, 0.059252755832618687, 0.07229717785878842, 0.06603145242021236, 0.022848884025951532, 0.07511217045554619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04704958311548035, 0.010597004440528912, 0.05290325538643903, 0.04519230812040209, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274052641770556, 0.024027908564323686, 0.08588687021589247, 0.002950413975140842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005850256016060262, 0.03416385558357471, 0.004308905560051035, 9.999999999998899e-05, 0.06691239238988655, 0.014613083585375719, 9.999999999998899e-05, 9.999999999998899e-05, 0.06560609546084739, 0.1526880259375042, 0.35614968711744754, 0.36483492058256684, 0.1818414303299608, 0.18155233814870697, 0.208132347915868, 0.3281204576078154, 0.3235811214209895, 0.3378826184415259, 0.08406658470851236, 0.06874284440748979, 0.02465244723683646, 0.07397249435415798, 0.08506592834395055, 0.06295003703120239, 0.040960629146491234, 0.0722757486636556, 0.09014157957018343, 0.14046829945849082, 0.15836674642876492, 0.14115951824154926, 0.15769760240544328, 0.15312999209637423, 0.1243240181904719, 0.16904747995984604, 0.14345372502010523, 0.1346093061770487, 0.15522636840475934, 0.16151140382703377, 0.24276667040881483, 0.2838851321200163, 0.17442882595931153, 0.2013810590620968, 0.17060138113625012, 0.2042284884471024, 0.16958880529644393, 0.15099113964043476, 0.1309855696303821, 0.12684103769487887, 0.15281035343516947, 0.1299030220111872, 0.15735411285254564, 0.1126397929320605, 0.147971812184989, 0.10727580825697591, 0.18009651847607544, 0.13942584640870193, 0.1739550969948649, 0.16813706341881884, 0.1453893695987175, 0.16405572379591737, 0.1773928285414702, 0.16021689364425207, 0.17959475272664693, 0.16470981729658962, 0.16637415118804388, 0.16154931859385235, 0.1658712805800696, 0.18298382017379022, 0.1682261550255324, 0.1889506607639423, 0.21464641493819914, 0.16556836175107603, 0.21560947238184403, 0.1806488341496011, 0.15280004396409164, 0.40085657431321264, 0.18277280782530325, 0.16014946231045246, 0.09026726472094082, 0.16878534172465387, 0.25039640210583325, 0.1633986385129751, 0.15512794491249993, 0.15080302979862303, 0.11002951236529912, 0.16756883844528114, 0.27409462583289457, 0.18980405833976588, 0.1962309328652304, 0.1727091730952065, 0.19040684632709803, 0.1860337533574109, 0.1764326099142388, 0.17593323320578114, 0.17694700203204938, 0.18317551864213344, 0.19186597246146653, 0.1813281571553771, 0.1695235163466341, 0.05336958506895695, 0.06103368128162712, 0.07031023345225007, 0.06818254546852853, 0.07175438856098826, 0.056589593885052136, 0.06602246362248132, 0.06502417043302045, 0.04366177304530916]}, "mutation_prompt": null}
{"id": "ed543508-edcc-4e77-9ebb-f1fb55b0a14f", "solution": "import numpy as np\n\nclass PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "PSO_ADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (PSO-ADE) for enhanced exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cfd7b269-60fa-47e1-a7ab-9e05e2610fdc", "metadata": {"aucs": [0.45936492150707187, 0.31774088598173644, 0.30276005565193786, 0.162078571186272, 0.5401151522138108, 0.1937538559687444, 0.6161235100938793, 0.2781370294515053, 0.3129096217833208, 9.999999999998899e-05, 0.0512565655789573, 9.999999999998899e-05, 9.999999999998899e-05, 0.031696377022832345, 9.999999999998899e-05, 0.0015561915351252065, 0.03766747014644167, 0.027100360769341747, 0.08115136730833161, 0.06282040566998326, 0.0874331370304704, 0.022369758857182398, 0.06759863101041519, 0.054044624404605224, 0.04605857975180938, 0.053684710631647814, 0.08265580900046754, 0.04559890842031222, 0.05621834879527687, 0.0683976115635403, 0.036180642135180796, 0.06450395649386775, 0.031480454832190086, 0.06442952588753581, 0.025365895313483655, 0.043141438127333065, 0.9808900916337966, 0.9816417125057213, 0.9855942004638056, 0.975644530813293, 0.9806892958271443, 0.9809872543239565, 0.9864273295073362, 0.9853583153996571, 0.9805956194903139, 0.058979477634143795, 0.143196312447869, 0.08541830338988643, 0.13346169034760658, 0.13432273613379908, 0.12324036780102743, 0.0814122638112571, 0.08813701576616073, 0.08576474724112138, 0.16952798169262373, 0.2163066208753508, 0.12233898241155783, 0.21244852715793494, 0.11647321038051628, 0.17380700655226988, 0.15061171557769848, 0.2042372363741094, 0.16451922294694887, 0.13788160089643353, 9.999999999998899e-05, 0.027792301065681535, 0.10540458838277411, 0.04906848779109152, 9.999999999998899e-05, 9.999999999998899e-05, 0.025053547307728352, 0.04596994048885206, 0.1616903020786976, 0.010075724763358496, 0.14514188036735665, 0.1374771126892057, 0.059252755832618687, 0.07229717785878842, 0.06603145242021236, 0.022848884025951532, 0.07511217045554619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04704958311548035, 0.010597004440528912, 0.05290325538643903, 0.04519230812040209, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274052641770556, 0.024027908564323686, 0.08588687021589247, 0.002950413975140842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005850256016060262, 0.03416385558357471, 0.004308905560051035, 9.999999999998899e-05, 0.06691239238988655, 0.014613083585375719, 9.999999999998899e-05, 9.999999999998899e-05, 0.06560609546084739, 0.1526880259375042, 0.35614968711744754, 0.36483492058256684, 0.1818414303299608, 0.18155233814870697, 0.208132347915868, 0.3281204576078154, 0.3235811214209895, 0.3378826184415259, 0.08406658470851236, 0.06874284440748979, 0.02465244723683646, 0.07397249435415798, 0.08506592834395055, 0.06295003703120239, 0.040960629146491234, 0.0722757486636556, 0.09014157957018343, 0.14046829945849082, 0.15836674642876492, 0.14115951824154926, 0.15769760240544328, 0.15312999209637423, 0.1243240181904719, 0.16904747995984604, 0.14345372502010523, 0.1346093061770487, 0.15522636840475934, 0.16151140382703377, 0.24276667040881483, 0.2838851321200163, 0.17442882595931153, 0.2013810590620968, 0.17060138113625012, 0.2042284884471024, 0.16958880529644393, 0.15099113964043476, 0.1309855696303821, 0.12684103769487887, 0.15281035343516947, 0.1299030220111872, 0.15735411285254564, 0.1126397929320605, 0.147971812184989, 0.10727580825697591, 0.18009651847607544, 0.13942584640870193, 0.1739550969948649, 0.16813706341881884, 0.1453893695987175, 0.16405572379591737, 0.1773928285414702, 0.16021689364425207, 0.17959475272664693, 0.16470981729658962, 0.16637415118804388, 0.16154931859385235, 0.1658712805800696, 0.18298382017379022, 0.1682261550255324, 0.1889506607639423, 0.21464641493819914, 0.16556836175107603, 0.21560947238184403, 0.1806488341496011, 0.15280004396409164, 0.40085657431321264, 0.18277280782530325, 0.16014946231045246, 0.09026726472094082, 0.16878534172465387, 0.25039640210583325, 0.1633986385129751, 0.15512794491249993, 0.15080302979862303, 0.11002951236529912, 0.16756883844528114, 0.27409462583289457, 0.18980405833976588, 0.1962309328652304, 0.1727091730952065, 0.19040684632709803, 0.1860337533574109, 0.1764326099142388, 0.17593323320578114, 0.17694700203204938, 0.18317551864213344, 0.19186597246146653, 0.1813281571553771, 0.1695235163466341, 0.05336958506895695, 0.06103368128162712, 0.07031023345225007, 0.06818254546852853, 0.07175438856098826, 0.056589593885052136, 0.06602246362248132, 0.06502417043302045, 0.04366177304530916]}, "mutation_prompt": null}
{"id": "f23987de-3794-4430-a5d7-18e6d2f85007", "solution": "import numpy as np\n\nclass PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "PSO_ADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (PSO-ADE) for enhanced exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cfd7b269-60fa-47e1-a7ab-9e05e2610fdc", "metadata": {"aucs": [0.45936492150707187, 0.31774088598173644, 0.30276005565193786, 0.162078571186272, 0.5401151522138108, 0.1937538559687444, 0.6161235100938793, 0.2781370294515053, 0.3129096217833208, 9.999999999998899e-05, 0.0512565655789573, 9.999999999998899e-05, 9.999999999998899e-05, 0.031696377022832345, 9.999999999998899e-05, 0.0015561915351252065, 0.03766747014644167, 0.027100360769341747, 0.08115136730833161, 0.06282040566998326, 0.0874331370304704, 0.022369758857182398, 0.06759863101041519, 0.054044624404605224, 0.04605857975180938, 0.053684710631647814, 0.08265580900046754, 0.04559890842031222, 0.05621834879527687, 0.0683976115635403, 0.036180642135180796, 0.06450395649386775, 0.031480454832190086, 0.06442952588753581, 0.025365895313483655, 0.043141438127333065, 0.9808900916337966, 0.9816417125057213, 0.9855942004638056, 0.975644530813293, 0.9806892958271443, 0.9809872543239565, 0.9864273295073362, 0.9853583153996571, 0.9805956194903139, 0.058979477634143795, 0.143196312447869, 0.08541830338988643, 0.13346169034760658, 0.13432273613379908, 0.12324036780102743, 0.0814122638112571, 0.08813701576616073, 0.08576474724112138, 0.16952798169262373, 0.2163066208753508, 0.12233898241155783, 0.21244852715793494, 0.11647321038051628, 0.17380700655226988, 0.15061171557769848, 0.2042372363741094, 0.16451922294694887, 0.13788160089643353, 9.999999999998899e-05, 0.027792301065681535, 0.10540458838277411, 0.04906848779109152, 9.999999999998899e-05, 9.999999999998899e-05, 0.025053547307728352, 0.04596994048885206, 0.1616903020786976, 0.010075724763358496, 0.14514188036735665, 0.1374771126892057, 0.059252755832618687, 0.07229717785878842, 0.06603145242021236, 0.022848884025951532, 0.07511217045554619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04704958311548035, 0.010597004440528912, 0.05290325538643903, 0.04519230812040209, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274052641770556, 0.024027908564323686, 0.08588687021589247, 0.002950413975140842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005850256016060262, 0.03416385558357471, 0.004308905560051035, 9.999999999998899e-05, 0.06691239238988655, 0.014613083585375719, 9.999999999998899e-05, 9.999999999998899e-05, 0.06560609546084739, 0.1526880259375042, 0.35614968711744754, 0.36483492058256684, 0.1818414303299608, 0.18155233814870697, 0.208132347915868, 0.3281204576078154, 0.3235811214209895, 0.3378826184415259, 0.08406658470851236, 0.06874284440748979, 0.02465244723683646, 0.07397249435415798, 0.08506592834395055, 0.06295003703120239, 0.040960629146491234, 0.0722757486636556, 0.09014157957018343, 0.14046829945849082, 0.15836674642876492, 0.14115951824154926, 0.15769760240544328, 0.15312999209637423, 0.1243240181904719, 0.16904747995984604, 0.14345372502010523, 0.1346093061770487, 0.15522636840475934, 0.16151140382703377, 0.24276667040881483, 0.2838851321200163, 0.17442882595931153, 0.2013810590620968, 0.17060138113625012, 0.2042284884471024, 0.16958880529644393, 0.15099113964043476, 0.1309855696303821, 0.12684103769487887, 0.15281035343516947, 0.1299030220111872, 0.15735411285254564, 0.1126397929320605, 0.147971812184989, 0.10727580825697591, 0.18009651847607544, 0.13942584640870193, 0.1739550969948649, 0.16813706341881884, 0.1453893695987175, 0.16405572379591737, 0.1773928285414702, 0.16021689364425207, 0.17959475272664693, 0.16470981729658962, 0.16637415118804388, 0.16154931859385235, 0.1658712805800696, 0.18298382017379022, 0.1682261550255324, 0.1889506607639423, 0.21464641493819914, 0.16556836175107603, 0.21560947238184403, 0.1806488341496011, 0.15280004396409164, 0.40085657431321264, 0.18277280782530325, 0.16014946231045246, 0.09026726472094082, 0.16878534172465387, 0.25039640210583325, 0.1633986385129751, 0.15512794491249993, 0.15080302979862303, 0.11002951236529912, 0.16756883844528114, 0.27409462583289457, 0.18980405833976588, 0.1962309328652304, 0.1727091730952065, 0.19040684632709803, 0.1860337533574109, 0.1764326099142388, 0.17593323320578114, 0.17694700203204938, 0.18317551864213344, 0.19186597246146653, 0.1813281571553771, 0.1695235163466341, 0.05336958506895695, 0.06103368128162712, 0.07031023345225007, 0.06818254546852853, 0.07175438856098826, 0.056589593885052136, 0.06602246362248132, 0.06502417043302045, 0.04366177304530916]}, "mutation_prompt": null}
{"id": "c6448a85-f99c-411b-ac2b-016c47e6d442", "solution": "import numpy as np\n\nclass PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "PSO_ADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (PSO-ADE) for enhanced exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cfd7b269-60fa-47e1-a7ab-9e05e2610fdc", "metadata": {"aucs": [0.45936492150707187, 0.31774088598173644, 0.30276005565193786, 0.162078571186272, 0.5401151522138108, 0.1937538559687444, 0.6161235100938793, 0.2781370294515053, 0.3129096217833208, 9.999999999998899e-05, 0.0512565655789573, 9.999999999998899e-05, 9.999999999998899e-05, 0.031696377022832345, 9.999999999998899e-05, 0.0015561915351252065, 0.03766747014644167, 0.027100360769341747, 0.08115136730833161, 0.06282040566998326, 0.0874331370304704, 0.022369758857182398, 0.06759863101041519, 0.054044624404605224, 0.04605857975180938, 0.053684710631647814, 0.08265580900046754, 0.04559890842031222, 0.05621834879527687, 0.0683976115635403, 0.036180642135180796, 0.06450395649386775, 0.031480454832190086, 0.06442952588753581, 0.025365895313483655, 0.043141438127333065, 0.9808900916337966, 0.9816417125057213, 0.9855942004638056, 0.975644530813293, 0.9806892958271443, 0.9809872543239565, 0.9864273295073362, 0.9853583153996571, 0.9805956194903139, 0.058979477634143795, 0.143196312447869, 0.08541830338988643, 0.13346169034760658, 0.13432273613379908, 0.12324036780102743, 0.0814122638112571, 0.08813701576616073, 0.08576474724112138, 0.16952798169262373, 0.2163066208753508, 0.12233898241155783, 0.21244852715793494, 0.11647321038051628, 0.17380700655226988, 0.15061171557769848, 0.2042372363741094, 0.16451922294694887, 0.13788160089643353, 9.999999999998899e-05, 0.027792301065681535, 0.10540458838277411, 0.04906848779109152, 9.999999999998899e-05, 9.999999999998899e-05, 0.025053547307728352, 0.04596994048885206, 0.1616903020786976, 0.010075724763358496, 0.14514188036735665, 0.1374771126892057, 0.059252755832618687, 0.07229717785878842, 0.06603145242021236, 0.022848884025951532, 0.07511217045554619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04704958311548035, 0.010597004440528912, 0.05290325538643903, 0.04519230812040209, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274052641770556, 0.024027908564323686, 0.08588687021589247, 0.002950413975140842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005850256016060262, 0.03416385558357471, 0.004308905560051035, 9.999999999998899e-05, 0.06691239238988655, 0.014613083585375719, 9.999999999998899e-05, 9.999999999998899e-05, 0.06560609546084739, 0.1526880259375042, 0.35614968711744754, 0.36483492058256684, 0.1818414303299608, 0.18155233814870697, 0.208132347915868, 0.3281204576078154, 0.3235811214209895, 0.3378826184415259, 0.08406658470851236, 0.06874284440748979, 0.02465244723683646, 0.07397249435415798, 0.08506592834395055, 0.06295003703120239, 0.040960629146491234, 0.0722757486636556, 0.09014157957018343, 0.14046829945849082, 0.15836674642876492, 0.14115951824154926, 0.15769760240544328, 0.15312999209637423, 0.1243240181904719, 0.16904747995984604, 0.14345372502010523, 0.1346093061770487, 0.15522636840475934, 0.16151140382703377, 0.24276667040881483, 0.2838851321200163, 0.17442882595931153, 0.2013810590620968, 0.17060138113625012, 0.2042284884471024, 0.16958880529644393, 0.15099113964043476, 0.1309855696303821, 0.12684103769487887, 0.15281035343516947, 0.1299030220111872, 0.15735411285254564, 0.1126397929320605, 0.147971812184989, 0.10727580825697591, 0.18009651847607544, 0.13942584640870193, 0.1739550969948649, 0.16813706341881884, 0.1453893695987175, 0.16405572379591737, 0.1773928285414702, 0.16021689364425207, 0.17959475272664693, 0.16470981729658962, 0.16637415118804388, 0.16154931859385235, 0.1658712805800696, 0.18298382017379022, 0.1682261550255324, 0.1889506607639423, 0.21464641493819914, 0.16556836175107603, 0.21560947238184403, 0.1806488341496011, 0.15280004396409164, 0.40085657431321264, 0.18277280782530325, 0.16014946231045246, 0.09026726472094082, 0.16878534172465387, 0.25039640210583325, 0.1633986385129751, 0.15512794491249993, 0.15080302979862303, 0.11002951236529912, 0.16756883844528114, 0.27409462583289457, 0.18980405833976588, 0.1962309328652304, 0.1727091730952065, 0.19040684632709803, 0.1860337533574109, 0.1764326099142388, 0.17593323320578114, 0.17694700203204938, 0.18317551864213344, 0.19186597246146653, 0.1813281571553771, 0.1695235163466341, 0.05336958506895695, 0.06103368128162712, 0.07031023345225007, 0.06818254546852853, 0.07175438856098826, 0.056589593885052136, 0.06602246362248132, 0.06502417043302045, 0.04366177304530916]}, "mutation_prompt": null}
{"id": "95e281ab-e9af-48ec-ad14-867de99c47a2", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.5  # Reduced inertia weight for faster convergence\n        self.cognitive_coeff = 2.0  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.6  # Slightly increased scaling factor\n        self.CR = 0.8  # Reduced crossover probability for diversity\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution incorporating Lévy flights for improved stochastic exploration.", "configspace": "", "generation": 4, "fitness": 0.2236725079173784, "feedback": "The algorithm Enhanced_PSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.23.", "error": "", "parent_id": "cfd7b269-60fa-47e1-a7ab-9e05e2610fdc", "metadata": {"aucs": [0.6266647870857971, 0.42694644591192676, 0.7602354571624472, 0.8146668667730509, 0.787443779599293, 0.7709764020049897, 0.7409312495930851, 0.7611359998311044, 0.7241820017067363, 0.44648462956734447, 0.028356216362226072, 9.999999999998899e-05, 9.999999999998899e-05, 0.4543063775482914, 0.4220715169343653, 0.05658430283741889, 0.48759494236128953, 0.4050175834981248, 0.06153205822902996, 0.08483626725472637, 0.09460226291312523, 0.0725489159476641, 0.06590649055110154, 0.10829954347659732, 0.08527896783186661, 0.15952916384220572, 0.07968198558676343, 0.06848107368227552, 0.06963518213694098, 0.06712286612661278, 0.08425566380415916, 0.08830689162400163, 0.06247760167903793, 0.058047656534165215, 0.0896254776619968, 0.08808081234711385, 0.9824294814326809, 0.981160606763165, 0.9779193152238363, 0.9770456168494212, 0.9807622558877748, 0.9648764211797036, 0.975677996557061, 0.9807384383259458, 0.975466483965964, 0.05992552608085622, 0.19851902039149982, 0.3141910070197512, 0.21423685720420704, 0.13247142257491473, 0.3673278805901361, 0.08865326075071711, 0.2748392961428683, 0.17191217946174797, 0.2916498204518233, 0.34721268697924645, 0.2188538514361582, 0.2755137937440024, 0.1907504219557502, 0.2687469211600042, 0.2492510968080467, 0.3032531244025739, 0.5357022631811736, 0.20424545083186751, 0.13573494827219323, 0.12411955091414706, 0.07262685437294081, 0.09298549963171576, 0.17278887466721626, 0.1357977447990284, 0.17020811955948723, 0.10547346681788072, 0.19365063150181672, 0.05349478834389643, 0.2049763591440873, 0.1272117342798017, 0.11593005833669945, 0.17347366606770154, 0.19012947162287352, 0.03411960088809207, 0.12916295147668555, 0.00040816200044069273, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023804807887883195, 9.999999999998899e-05, 9.999999999998899e-05, 0.05860100568200888, 0.03884286770172507, 0.06778844246611937, 0.08670380398058097, 9.999999999998899e-05, 0.022692491805378134, 0.03301251708868824, 0.026913078457179496, 0.04065622318844231, 0.04248662558948291, 0.03194676515390271, 9.999999999998899e-05, 0.0664517916052193, 0.20951062406912446, 0.13989025644579856, 0.07240392447519439, 0.07925916521146081, 0.06569563665600198, 0.1426701573878919, 9.999999999998899e-05, 0.009230533318992262, 0.07835437377065468, 0.13069988763945983, 0.006319601309650147, 0.042359462628104305, 0.05442623092189314, 0.08048559898873897, 0.3642245254414246, 0.432876247861652, 0.5145315344291584, 0.5024756300785762, 0.44624229876492816, 0.3321129238421857, 0.5063784585155303, 0.3529491943759393, 0.5079892919061568, 0.060355401126510166, 0.05212925408626745, 0.07828103142664478, 0.08563382710503464, 0.08337133373157635, 0.08429079805384332, 0.10533116206149606, 0.06426166132235867, 0.0751554222270866, 0.1811392266333347, 0.14127810821133158, 0.1385394048759041, 0.142146864179869, 0.19184299121259996, 0.11422905959796514, 0.26171009306276793, 0.15694010209374298, 0.15215804024586776, 0.3561327931664954, 0.2601086845560481, 0.2823019226281501, 0.2838744300319358, 0.24827087999111663, 0.31443154715566035, 0.28703390350358515, 0.29807579942814344, 0.3508286223855889, 0.20117587307289353, 0.1330960160406055, 0.19979211435144506, 0.16359567991749446, 0.1458120410492495, 0.16577687804194263, 0.1354574561784313, 0.17471745001826422, 0.12489809174049626, 0.18631164780456677, 0.17914843888080723, 0.19290179346520542, 0.1742289860097217, 0.1626831748369988, 0.171562146816427, 0.17032556526052045, 0.1922742876843624, 0.17571310738499246, 0.18759096775459072, 0.1862320734320212, 0.19182431580107606, 0.16665623896319526, 0.19468928671036145, 0.18450847334883325, 0.1732795170844038, 0.16296577992930328, 0.2036556155089082, 0.6715766414639133, 0.15903687166689595, 0.1245728489210085, 0.8551151830320008, 0.20056993637727338, 0.1313910708732856, 0.1299258344175298, 0.1695864200942787, 0.20713099569467364, 0.4058008918498731, 0.15298626514698865, 0.20688520623177575, 0.45052309306775373, 0.16868294508473625, 0.2509729551260256, 0.19660576336363178, 0.20395355805463045, 0.1981578473940837, 0.17807880849635782, 0.18459058420048147, 0.21013631268212984, 0.1957093188265463, 0.20356193023959768, 0.18521311701050125, 0.18496689259859045, 0.179283568587839, 0.17831479525930738, 0.07221903347066161, 0.07524699049423744, 0.06166809822353603, 0.07441806486363733, 0.06275322338700295, 0.07180185411549755, 0.068548901405031, 0.07156742618221323, 0.071324682360559]}, "mutation_prompt": null}
{"id": "090d5316-3114-4315-8ce7-c0a4c60e4687", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.9  # Dynamic inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.5\n        self.CR = 0.9\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def update_inertia_weight(self, evals):\n        return 0.9 - (0.5 * evals / self.budget)\n\n    def adaptive_mutation(self, target, best, r1, r2):\n        mutant_vector = np.clip(target + self.F * (best - r1) + self.F * (r2 - target), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            self.inertia_weight = self.update_inertia_weight(evals)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with adaptive strategy\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2 = self.positions[np.random.choice(indices, 2, replace=False)]\n                mutant_vector = self.adaptive_mutation(self.positions[i], self.global_best_position, x1, x2)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n\n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE_V2", "description": "Enhanced PSO-ADE with Adaptive Mutation Strategy and Dynamic Inertia Weight for Improved Convergence.", "configspace": "", "generation": 5, "fitness": 0.14069370868855943, "feedback": "The algorithm Enhanced_PSO_ADE_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "95e281ab-e9af-48ec-ad14-867de99c47a2", "metadata": {"aucs": [0.421639299496832, 0.2954157984286552, 0.2993887673966127, 0.15984848061999313, 0.1817503806618782, 0.2065692334006789, 0.17610648818259556, 0.173864652783019, 0.1489990541962135, 0.012503209795391212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025939180928952865, 9.999999999998899e-05, 0.003577249987826825, 0.0332300034817139, 9.999999999998899e-05, 0.059562193835126176, 0.043703108288427606, 0.05046394644344432, 0.061512782480650285, 0.03895645979184903, 0.04518957216334896, 0.07814763726906948, 0.062484418784317985, 0.048907695212115465, 0.04059022475357543, 0.03742824169886372, 0.03258673186739247, 0.03167003182985373, 0.022435958611881857, 0.039716357730204654, 0.02792800384161842, 0.01858818010039265, 0.00816432217354246, 0.975027547146508, 0.9817241479019255, 0.9833434141364804, 0.9690629782589165, 0.974763791637573, 0.9593673407515905, 0.9748164278497823, 0.9795685429269718, 0.9784776939394321, 0.08411210255586798, 0.10266778248955766, 9.999999999998899e-05, 0.12523444656733973, 0.09971828040458841, 0.12528391271466188, 0.08032337055156291, 0.08757196694312841, 0.08343341306520191, 0.15793751584761717, 0.13808461565661168, 0.13042092769162994, 0.19048087913484457, 0.15938648634562724, 0.17057456995561338, 0.06781578306302394, 0.10474956541372304, 0.10747079415050576, 0.1299742990829461, 0.07121494223903369, 0.014722662258585317, 9.999999999998899e-05, 0.14005602308208331, 9.999999999998899e-05, 9.999999999998899e-05, 0.03205990777550993, 0.1556290845516507, 0.08971309118673321, 0.05508385143402994, 0.021983327342418257, 0.1297129693694795, 0.10759568764438476, 0.05583873147401319, 0.0970979916793, 0.022285789595509198, 0.018077664479652755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0528258576189341, 0.015242745447359596, 0.04493629071605587, 0.06124837833412489, 9.999999999998899e-05, 0.011041135218037179, 0.05847555562656581, 0.004780248558381883, 0.023347463295442683, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014302177551573925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02097523384612343, 0.0022214742065774784, 9.999999999998899e-05, 0.04405397588169546, 0.0030743685083409744, 0.04116221192251923, 0.030764857249899635, 0.040861279506525516, 9.999999999998899e-05, 0.045329015342559065, 0.28915940437071297, 0.30103143372755226, 0.2650915198068011, 0.20362840742509847, 0.13756788792229524, 0.19783804462459254, 0.22843040181015983, 0.3754906784798222, 0.27921297485785757, 0.0643326852746704, 0.044461849367340434, 0.036321191387368335, 0.0787432391846945, 0.048272531472837055, 0.08260976603061898, 0.053759833615709574, 0.054429335330866135, 0.06141164173704605, 0.13532786208826564, 0.10636904277213566, 0.16227109756437963, 0.13615106941921917, 0.1392952876063217, 0.127247197267358, 0.15464070400379748, 0.1921075598371763, 0.14076247775966366, 0.21029116004411785, 0.2062524928641235, 0.19564418362487446, 0.192259523576635, 0.1518658003705945, 0.22661677799431612, 0.16646716385023597, 0.23979712080567372, 0.18507297406894685, 0.12116039017392943, 0.14859417017968768, 0.15506336019938682, 0.09741942026596029, 0.08124232453579461, 0.18719987099655677, 0.14205733384067332, 0.17776606097153003, 0.1689572917200226, 0.17555248541962498, 0.12240604826437773, 0.1754491119255921, 0.18732037301426885, 0.13296236316682775, 0.1867335344429778, 0.16335122259898038, 0.1547801902672058, 0.16848300541854022, 0.1594922146630623, 0.18985885401274105, 0.1769292662439017, 0.16882735401470217, 0.1526296315932335, 0.17732639468462952, 0.16760083121764036, 0.13921002923087467, 0.17510977820343965, 0.10860211553278509, 0.16577140878823415, 0.12858566698649154, 0.18334315257037848, 0.17385246292892664, 0.16137872660703545, 0.1630491156826458, 0.16525275335235823, 0.34780924311742767, 0.18140675386967364, 0.16501280441344968, 0.07588851755408943, 0.10882072866197978, 0.10839494141293393, 0.09943469905849123, 0.17027258201881923, 0.1662654186086946, 0.17858240760526967, 0.1985843797573923, 0.18342576586451997, 0.17207416032119893, 0.19957772018077657, 0.17438401813522453, 0.17504188686096545, 0.19363976063571386, 0.17727648973122545, 0.17966464702821594, 0.0538165107550832, 0.043684052564511355, 0.05035403952131279, 0.03749982082505465, 0.042365198194658116, 0.06058866152462106, 0.04038049657226839, 0.03875712769705575, 0.06938531301336259]}, "mutation_prompt": null}
{"id": "e8a2fa93-1688-46e8-b203-ba1f8e116983", "solution": "import numpy as np\n\nclass Enhanced_PSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 30\n        self.inertia_weight = 0.5  # Reduced inertia weight for faster convergence\n        self.cognitive_coeff = 2.0  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.6  # Slightly increased scaling factor\n        self.CR = 0.8  # Reduced crossover probability for diversity\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_PSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution incorporating Lévy flights for improved stochastic exploration.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95e281ab-e9af-48ec-ad14-867de99c47a2", "metadata": {"aucs": [0.6266647870857971, 0.42694644591192676, 0.7602354571624472, 0.8146668667730509, 0.787443779599293, 0.7709764020049897, 0.7409312495930851, 0.7611359998311044, 0.7241820017067363, 0.44648462956734447, 0.028356216362226072, 9.999999999998899e-05, 9.999999999998899e-05, 0.4543063775482914, 0.4220715169343653, 0.05658430283741889, 0.48759494236128953, 0.4050175834981248, 0.06153205822902996, 0.08483626725472637, 0.09460226291312523, 0.0725489159476641, 0.06590649055110154, 0.10829954347659732, 0.08527896783186661, 0.15952916384220572, 0.07968198558676343, 0.06848107368227552, 0.06963518213694098, 0.06712286612661278, 0.08425566380415916, 0.08830689162400163, 0.06247760167903793, 0.058047656534165215, 0.0896254776619968, 0.08808081234711385, 0.9824294814326809, 0.981160606763165, 0.9779193152238363, 0.9770456168494212, 0.9807622558877748, 0.9648764211797036, 0.975677996557061, 0.9807384383259458, 0.975466483965964, 0.05992552608085622, 0.19851902039149982, 0.3141910070197512, 0.21423685720420704, 0.13247142257491473, 0.3673278805901361, 0.08865326075071711, 0.2748392961428683, 0.17191217946174797, 0.2916498204518233, 0.34721268697924645, 0.2188538514361582, 0.2755137937440024, 0.1907504219557502, 0.2687469211600042, 0.2492510968080467, 0.3032531244025739, 0.5357022631811736, 0.20424545083186751, 0.13573494827219323, 0.12411955091414706, 0.07262685437294081, 0.09298549963171576, 0.17278887466721626, 0.1357977447990284, 0.17020811955948723, 0.10547346681788072, 0.19365063150181672, 0.05349478834389643, 0.2049763591440873, 0.1272117342798017, 0.11593005833669945, 0.17347366606770154, 0.19012947162287352, 0.03411960088809207, 0.12916295147668555, 0.00040816200044069273, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023804807887883195, 9.999999999998899e-05, 9.999999999998899e-05, 0.05860100568200888, 0.03884286770172507, 0.06778844246611937, 0.08670380398058097, 9.999999999998899e-05, 0.022692491805378134, 0.03301251708868824, 0.026913078457179496, 0.04065622318844231, 0.04248662558948291, 0.03194676515390271, 9.999999999998899e-05, 0.0664517916052193, 0.20951062406912446, 0.13989025644579856, 0.07240392447519439, 0.07925916521146081, 0.06569563665600198, 0.1426701573878919, 9.999999999998899e-05, 0.009230533318992262, 0.07835437377065468, 0.13069988763945983, 0.006319601309650147, 0.042359462628104305, 0.05442623092189314, 0.08048559898873897, 0.3642245254414246, 0.432876247861652, 0.5145315344291584, 0.5024756300785762, 0.44624229876492816, 0.3321129238421857, 0.5063784585155303, 0.3529491943759393, 0.5079892919061568, 0.060355401126510166, 0.05212925408626745, 0.07828103142664478, 0.08563382710503464, 0.08337133373157635, 0.08429079805384332, 0.10533116206149606, 0.06426166132235867, 0.0751554222270866, 0.1811392266333347, 0.14127810821133158, 0.1385394048759041, 0.142146864179869, 0.19184299121259996, 0.11422905959796514, 0.26171009306276793, 0.15694010209374298, 0.15215804024586776, 0.3561327931664954, 0.2601086845560481, 0.2823019226281501, 0.2838744300319358, 0.24827087999111663, 0.31443154715566035, 0.28703390350358515, 0.29807579942814344, 0.3508286223855889, 0.20117587307289353, 0.1330960160406055, 0.19979211435144506, 0.16359567991749446, 0.1458120410492495, 0.16577687804194263, 0.1354574561784313, 0.17471745001826422, 0.12489809174049626, 0.18631164780456677, 0.17914843888080723, 0.19290179346520542, 0.1742289860097217, 0.1626831748369988, 0.171562146816427, 0.17032556526052045, 0.1922742876843624, 0.17571310738499246, 0.18759096775459072, 0.1862320734320212, 0.19182431580107606, 0.16665623896319526, 0.19468928671036145, 0.18450847334883325, 0.1732795170844038, 0.16296577992930328, 0.2036556155089082, 0.6715766414639133, 0.15903687166689595, 0.1245728489210085, 0.8551151830320008, 0.20056993637727338, 0.1313910708732856, 0.1299258344175298, 0.1695864200942787, 0.20713099569467364, 0.4058008918498731, 0.15298626514698865, 0.20688520623177575, 0.45052309306775373, 0.16868294508473625, 0.2509729551260256, 0.19660576336363178, 0.20395355805463045, 0.1981578473940837, 0.17807880849635782, 0.18459058420048147, 0.21013631268212984, 0.1957093188265463, 0.20356193023959768, 0.18521311701050125, 0.18496689259859045, 0.179283568587839, 0.17831479525930738, 0.07221903347066161, 0.07524699049423744, 0.06166809822353603, 0.07441806486363733, 0.06275322338700295, 0.07180185411549755, 0.068548901405031, 0.07156742618221323, 0.071324682360559]}, "mutation_prompt": null}
{"id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "solution": "import numpy as np\n\nclass Hybrid_DQPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.4  # Dynamic inertia weight for adaptive balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F = 0.7  # Adjusted scaling factor\n        self.CR = 0.9  # Increased crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_DQPSO_ADE", "description": "Hybrid DQPSO-ADE: A hybrid of Dynamic Quantum Particle Swarm and Adaptive Differential Evolution with Lévy flights for rapid convergence.", "configspace": "", "generation": 7, "fitness": 0.3202664714163003, "feedback": "The algorithm Hybrid_DQPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "95e281ab-e9af-48ec-ad14-867de99c47a2", "metadata": {"aucs": [0.8684018429441183, 0.8616555624014703, 0.8871553260048956, 0.8775386149537622, 0.8527949425795994, 0.8772856393733616, 0.88391899300397, 0.8749664854393696, 0.8743286688626355, 0.7647400050577433, 0.6259180642761535, 0.7554311288137997, 0.6729733770183758, 0.49786907770012034, 0.7547066937430259, 0.7806866540887984, 0.7111997233972764, 0.7577781012617886, 0.11234317941548777, 0.13034505079925274, 0.14183325810226777, 0.12479510711411645, 0.1147532841947817, 0.14247137153155653, 0.09943578328259717, 0.09912782360058159, 0.12635999964191635, 0.10851148191169269, 0.10185741861935915, 0.11959826681126529, 0.12981231342566046, 0.10822708973957174, 0.1097573627189109, 0.09683448163455399, 0.11408725414018861, 0.08830726434717162, 0.9461735840155766, 0.9618970970175093, 0.9505448803381455, 0.963404112937843, 0.9421967558315836, 0.926562729859534, 0.9392267198401457, 0.9326232788049902, 0.9590818414524247, 0.6882714586454848, 0.7221297178606805, 0.2697667491407013, 0.7682583551648534, 0.74514795534809, 0.15239212305733085, 0.45647627216737285, 0.367087168005651, 0.6237312715553543, 0.3833960695903692, 0.22531268786803338, 0.22102199979063664, 0.3828188023718475, 0.8826937675468733, 0.21210720184883003, 0.23223205722940676, 0.22188464742678538, 0.36010208318888903, 0.1478514993958715, 0.15681854668730544, 0.16434012494630001, 0.18225096190265988, 0.4181929988708065, 0.15283928597785212, 0.16351521237507183, 0.18872222878738376, 0.1639889660782301, 0.12764701768680242, 0.18550842136478318, 0.1650954491446175, 0.16096047859327778, 0.18082329389638985, 0.1275552499783309, 0.14311660137803972, 0.3520316197126606, 0.16467124631445018, 9.999999999998899e-05, 0.01462487148637015, 9.999999999998899e-05, 0.002032718469894612, 9.999999999998899e-05, 0.008731682310085698, 0.025477312910376693, 9.999999999998899e-05, 0.0010752244818198475, 0.0938189203864036, 0.14948030612759378, 0.06884110719668846, 0.08312106305815103, 0.04226317921938094, 0.037172189903893926, 0.09472883376898622, 0.15603165656146378, 0.08247485803853438, 0.12861208203867014, 0.13084085465013418, 0.15626243481121416, 0.1053902838823737, 0.10810430576641816, 0.15527180777885552, 0.2035139985250256, 0.24050389138888928, 0.07333428609745007, 0.17584890341039228, 0.11913782637012604, 0.17631557135841924, 0.02654507377268689, 0.09215979311339084, 0.08964786030639948, 0.14450834620111142, 0.17263878432826663, 0.1085993605278952, 0.510954293312877, 0.5453258639071814, 0.5099324766476584, 0.587988169010351, 0.5128929996307758, 0.5401167988451663, 0.6763907952215489, 0.5419406630295125, 0.5638287047840174, 0.12285437452190506, 0.1281563082625049, 0.09749758498780736, 0.12636528770753153, 0.1058785117805141, 0.13021171590637337, 0.0906233776571973, 0.15218388267472238, 0.14403097452022406, 0.28933205678208596, 0.2625729667746455, 0.2095502786471849, 0.2652799410489207, 0.1591092308777381, 0.431354456523925, 0.18541174209266242, 0.15040892701413577, 0.20312570956862663, 0.2873207132219012, 0.5190737726893779, 0.39581732873572195, 0.4706081605002692, 0.4661233284814613, 0.3524346704899174, 0.6172114182705171, 0.5853590526137424, 0.5834105376830188, 0.27301964961666825, 0.2872961984053627, 0.44497707802781883, 0.25149497417745637, 0.3398618360973755, 0.3531817984021246, 0.24541141203883832, 0.4248644356984119, 0.28992285655184613, 0.21134218691275586, 0.30252588919592904, 0.20086825342050996, 0.2271934628302532, 0.21172048590361525, 0.22808004837468265, 0.22855767133446303, 0.21481683158672582, 0.21263555520104382, 0.22138531413339102, 0.18058918609499053, 0.191992464262547, 0.19047311541726908, 0.1852081479658254, 0.20721607290176425, 0.20243629685621456, 0.20165686530042326, 0.18249703406704243, 0.8345720735364273, 0.8971106378588505, 0.15216132846020414, 0.8819562256101345, 0.19990325255317232, 0.8573321491666108, 0.17218982065165367, 0.12341397255648878, 0.89341101821022, 0.8976906685587154, 0.211514411198665, 0.7408100179330832, 0.21029455777575923, 0.16785208792952977, 0.15464495102449838, 0.3731000458143572, 0.2601173705792943, 0.21049853329699886, 0.17802161904422753, 0.1874998039136354, 0.20241713215708823, 0.19022587240394884, 0.17779943340817206, 0.18114258318398935, 0.1784357204149426, 0.1759241962441036, 0.18551456744649908, 0.08228819918165609, 0.0738677000463227, 0.09318873912930936, 0.08482247454613479, 0.08632329875844558, 0.07362176847812729, 0.08047641002405292, 0.08870331324012115, 0.08902300519201967]}, "mutation_prompt": null}
{"id": "33336ba6-ab1e-4072-b804-17f917505364", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Quantum Particle Swarm parameters\n        self.num_particles = 50  # Increased to enhance exploration\n        self.inertia_weight = 0.5  # Fine-tuned inertia weight\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted for more aggressive search\n        self.CR = 0.85  # Fine-tuned crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def chemotaxis(self, position, func):\n        step_size = 0.01\n        direction = np.random.uniform(-1, 1, self.dim)\n        new_position = position + step_size * direction\n        new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n        new_score = func(new_position)\n        return new_position if new_score < func(position) else position\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                \n                # Bacterial Foraging-inspired chemotaxis\n                self.positions[i] = self.chemotaxis(self.positions[i], func)\n                scores[i] = func(self.positions[i])\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_Optimizer", "description": "Adaptive Hybrid Optimizer: Integrates a Bacterial Foraging-inspired approach with Quantum Particle Swarm and Differential Evolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.225326495908225, "feedback": "The algorithm Adaptive_Hybrid_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.5793563803585975, 0.6022045314939373, 0.6043766766536939, 0.5894735848229617, 0.6040042956277458, 0.6122195653673803, 0.5756088522999476, 0.5688401977007314, 0.5870523555693403, 0.20579667795633227, 0.2015873274078912, 0.09974681892790738, 0.164223516008297, 0.24147268620637619, 0.29241893769711136, 0.2266180547566431, 0.1460237854764901, 0.09732800244526352, 0.09493848734720978, 0.09588147328248775, 0.09975584321020614, 0.10486208488362314, 0.089390548930671, 0.10016734849788067, 0.08644408151568717, 0.08873804817567943, 0.09140298996375529, 0.059679660962314696, 0.07241900528186107, 0.10076769895881188, 0.08263609397958549, 0.0803123128926212, 0.09502362152624955, 0.08558052505934688, 0.1014160771596535, 0.08803679106188989, 0.9330436703228969, 0.9070579423610152, 0.9469115944051132, 0.8751667078517177, 0.9218177544213121, 0.9070428849046015, 0.9314598242889576, 0.9051928076513271, 0.877749437492236, 0.3117259534088834, 0.28462671139785245, 0.26677618144124726, 0.3377665835801458, 0.300220105775886, 0.17037619871522747, 0.23625308831748626, 0.2198756588974783, 0.32026321711350725, 0.20623401448319523, 0.17189557828864888, 0.16514021883126062, 0.20370918298487117, 0.6162153573780051, 0.31769930986336725, 0.16741494169004267, 0.15686822732535843, 0.29011943319032696, 0.10860901497605624, 0.1441209279973753, 0.09663804166538215, 0.15166984572962106, 0.10828531161299382, 0.09745156471668814, 0.10527010475470067, 0.14479421968667305, 0.13936400534598992, 0.1439728892488894, 0.19729085345675734, 0.13301180384666145, 0.11606134133172674, 0.15438829561601397, 0.1695662229942554, 0.13156874766228865, 0.1453594436538539, 0.10033016550742468, 0.005159766269744459, 0.03186112197063662, 0.00011870300142768908, 0.033108516187524084, 0.0002746292307823639, 9.999999999998899e-05, 0.0001015144241806043, 9.999999999998899e-05, 9.999999999998899e-05, 0.08376657957214761, 0.061946091757109745, 0.081637021021984, 0.09262214872894892, 0.02912717291711464, 0.027303458526025448, 0.10330431153524933, 0.13545951930357392, 0.05122417710206395, 0.10347203994973986, 0.07540460059768395, 0.07079072829443922, 0.04284187407178319, 0.05059423654555084, 0.04246222856284909, 0.10642979793361196, 0.06779674306660233, 0.0668533119557515, 0.13809910221432797, 0.18091530156247937, 0.06120974970126314, 0.03121725959103494, 0.09176717999873141, 0.16548210516090933, 0.09339611587158092, 0.06986391451229024, 0.11096035820281303, 0.453682346645532, 0.44663150905634097, 0.4316315946023115, 0.43409631647623914, 0.4524605227944517, 0.4167679306980676, 0.4729266550398027, 0.46489786259608934, 0.48263351581781855, 0.06717359388273403, 0.10619513322558816, 0.10051854079188938, 0.08355021871291923, 0.07739346019287208, 0.11518983469194266, 0.07652842175602892, 0.11156839171013322, 0.08453379840464603, 0.14335185137926942, 0.15509294979427846, 0.1686763909636324, 0.20830047795716933, 0.11746058997280595, 0.15046903666890743, 0.2428166313359178, 0.1173928379127196, 0.13803220430544405, 0.2930962006655482, 0.31442204766943893, 0.31565200539648786, 0.26180238849753756, 0.3075045937949932, 0.33600072598335506, 0.3383320832017359, 0.34594776554785944, 0.32942464892463663, 0.23127705132411047, 0.22045552470641783, 0.2533163934946442, 0.2337537834773813, 0.18254586644420567, 0.2829804528160833, 0.21747973484473881, 0.24628289152744376, 0.21993455367129866, 0.20825389254753734, 0.17512417193290186, 0.19900454357573572, 0.22278796894571773, 0.194869134155235, 0.19994749698559644, 0.20344815200976374, 0.1959876150624822, 0.19174768459288194, 0.18718758696718718, 0.20157218465671067, 0.1776547687417548, 0.21327199395368046, 0.17916208201711237, 0.1919604459113481, 0.16714075428727704, 0.19784474129836438, 0.1870263785066243, 0.17129053935604666, 0.17625494230862881, 0.14906469845889492, 0.7086031439039434, 0.18776538368775564, 0.1887610411895102, 0.12158209169206435, 0.5224026029565108, 0.6357039003051199, 0.4949091127231594, 0.1851875560211691, 0.27151210806811255, 0.1993640100880545, 0.16472659198255957, 0.16127324093233963, 0.20032244482739214, 0.4612755244122416, 0.30035763556703665, 0.17865032147135573, 0.18164551708679666, 0.17313281593696628, 0.1812776155064847, 0.17582735532870952, 0.1982219038381512, 0.16974164414159554, 0.1771256456697784, 0.19720184802340124, 0.08504748984949817, 0.07243462893290731, 0.08864920500011664, 0.07974335717713088, 0.0799959105934861, 0.07665520473252585, 0.08855214449714799, 0.07666380357223679, 0.08637550582293807]}, "mutation_prompt": null}
{"id": "ec29e757-f326-456f-893f-26b38722fdaa", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_DQPSO_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.6  # Increased for enhanced exploration\n        self.cognitive_coeff = 2.0  # Adjusted for better balance\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Increased scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def local_search(self, position):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)  # Adjusted range\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                else:\n                    # Apply local search if DE trial is not successful\n                    local_vector = self.local_search(self.positions[i])\n                    local_score = func(local_vector)\n                    if local_score < scores[i]:\n                        self.positions[i] = local_vector\n                        scores[i] = local_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_DQPSO_LS", "description": "Enhanced Hybrid DQPSO with Local Search: Integrates adaptive learning rates and strategic local search to expedite convergence speed.", "configspace": "", "generation": 9, "fitness": 0.2860519594194328, "feedback": "The algorithm Enhanced_Hybrid_DQPSO_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.7955706231564244, 0.7780448198579035, 0.7968254494576542, 0.7381624291625957, 0.7613647540004128, 0.7851714099956777, 0.7687576655382714, 0.7795469505071779, 0.7734616448022331, 0.492297001381939, 0.4422727075264137, 0.4475236302781197, 0.43740737712578925, 0.5229579303595018, 0.5201138575577191, 0.5555771729364771, 0.5040889209556556, 0.4682571857130424, 0.10570403392983385, 0.12629179114987388, 0.09118664076660765, 0.12068769294822446, 0.10480335582408085, 0.08821416714805741, 0.13175316893361055, 0.09375272995897499, 0.11489223198511012, 0.0989741664588637, 0.11012376005709246, 0.08808542831104837, 0.10167711211883068, 0.08958254577407065, 0.10101316570781749, 0.09142192660787984, 0.08191175748410806, 0.09704622291630915, 0.954208374917642, 0.9549234790171379, 0.9687627525535384, 0.9463732620250703, 0.9570829662251136, 0.9259987082596144, 0.9591993084335881, 0.9485914660444361, 0.961433993012023, 0.2035360816124857, 0.4040988770044619, 0.377889037361842, 0.46814669098687134, 0.4266036212923051, 0.34584290140848417, 0.2726346610272302, 0.4837965085129864, 0.4449638508360966, 0.659743017114422, 0.7194780207965539, 0.7943863412953678, 0.21241361830967254, 0.44744131106272267, 0.7743687271144399, 0.22904031845214767, 0.5904669970683195, 0.22883216869451795, 0.1972769321297425, 0.12471565888872449, 0.21559749197191147, 0.1917528879559005, 0.12585542666881921, 0.11082613256681273, 0.19155006719040002, 0.08592864189841853, 0.2058390487829156, 0.19148061147848416, 0.19288979708075304, 0.21140610525204762, 0.23137638392374082, 0.27142345165658177, 0.20939322115082504, 0.20024132299028174, 0.16333567552731165, 0.12669307471386093, 9.999999999998899e-05, 0.005269261831254868, 0.04858407531901554, 0.016779559611629025, 0.003302614833513906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008563112821042496, 0.07593231507590714, 0.07491942949520602, 0.15217044454318585, 0.05150085938473059, 0.04026226328168303, 0.06447010085328908, 0.10050902229493708, 0.1494680638484528, 0.04359287763650044, 0.04753535912557638, 0.2635419133081557, 0.052983589150707444, 0.06657393145443946, 0.062980132754765, 0.12458078320367916, 0.10480966404890224, 0.08452057107649358, 0.1532043674731125, 0.2467430081194103, 0.15488632266283098, 0.14179729401019303, 0.03626803242296428, 0.05615740000410974, 0.10100670520607236, 0.07881561205000731, 0.1353269784100899, 0.085928871370346, 0.5345187547484695, 0.5113269911644309, 0.5749535596819206, 0.5533985648494293, 0.5229568472695153, 0.5335730868129138, 0.5402520428443947, 0.5342435966519692, 0.5138284442613766, 0.08174546636494273, 0.12168090555304056, 0.10818090594081953, 0.14246896979747492, 0.07406257639101299, 0.09315817170353202, 0.08872535207163024, 0.1129341585481074, 0.09159410621351616, 0.146458705528557, 0.1603677298863373, 0.15503277670107707, 0.14961383131244566, 0.14698385305137363, 0.14185306202396675, 0.13312885798905605, 0.14474229918878523, 0.20585602965705507, 0.39731681258131246, 0.3391507437434328, 0.32885531972887583, 0.38003999940860167, 0.3989692011787923, 0.3373514946993753, 0.43212767083602155, 0.3844448879706226, 0.40220960072623424, 0.2742525962313622, 0.24446769298542304, 0.2129951774494533, 0.32389476543408746, 0.21574227531345236, 0.23858940064670042, 0.23278823784834046, 0.2972088653496481, 0.22406107458314617, 0.21230591221420225, 0.17342046680847778, 0.20594298519731558, 0.20424394720675632, 0.2114078106098446, 0.19895217973597068, 0.21283190282560904, 0.1951046604109158, 0.19039710723467596, 0.18845437265390175, 0.21782477540830392, 0.20077076783752545, 0.180495361293442, 0.23453355747103644, 0.5574186040668121, 0.1832800839234605, 0.46376329781782766, 0.2015857990158666, 0.8280839349170376, 0.17179596425568167, 0.1597079025549023, 0.8530672850282254, 0.19810649262638258, 0.14775276359207823, 0.14127516356655634, 0.16712404726350594, 0.8293382340098983, 0.7295595615779649, 0.2088546129598382, 0.5237756003213676, 0.6033125602588247, 0.1685625613721342, 0.15325842330219297, 0.20774996066070983, 0.12569045398372802, 0.2104692839660388, 0.17936982636291343, 0.18973642270162083, 0.184949777010591, 0.17506183139667575, 0.18131503665349114, 0.18517267637183654, 0.1731806633492824, 0.20914952449664492, 0.18047663676153547, 0.08453263263110422, 0.07492748047038056, 0.07946534854553466, 0.08205739157702063, 0.08664492331219265, 0.08722527486054643, 0.08387384004284903, 0.07053682691833674, 0.0914763029216531]}, "mutation_prompt": null}
{"id": "dc2d0ecc-3ad0-4570-a9bb-7b319b0cce69", "solution": "import numpy as np\n\nclass Quantum_Enhanced_APSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # APSO parameters\n        self.num_particles = 50  # Increased number of particles\n        self.inertia_weight = 0.5  # Adjusted dynamic inertia weight\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.8\n\n        # Crossover mutation parameters\n        self.mutation_rate = 0.1  # Lower mutation rate\n        self.mutation_scale = 0.5  # Reduced scale for crossover\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform crossover mutation\n            for i in range(self.num_particles):\n                if np.random.rand() < self.mutation_rate:\n                    donor_idx = np.random.randint(0, self.num_particles)\n                    donor_vector = self.positions[donor_idx]\n                    self.positions[i] = (1 - self.mutation_scale) * self.positions[i] + self.mutation_scale * donor_vector\n                    self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Enhanced_APSO", "description": "Quantum-Enhanced Adaptive Particle Swarm Optimization with Crossover Mutation for accelerated convergence.", "configspace": "", "generation": 10, "fitness": 0.2576606479236738, "feedback": "The algorithm Quantum_Enhanced_APSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8470338335979298, 0.8541854448494379, 0.8215368605533846, 0.6149580377644679, 0.8629968970486157, 0.1803724711682131, 0.7958220885398466, 0.7494952074347903, 0.49570085922008744, 0.6413921612427299, 0.516764148966162, 9.999999999998899e-05, 0.0420517572917104, 0.4098760672792966, 0.4630329040759471, 0.6206739850418979, 0.45954485874914974, 0.6328451934411718, 0.15287759819905555, 0.14168521521081034, 0.12321195708223731, 0.15464061992543887, 0.1474982865783837, 0.08317784130048134, 0.04842471148995808, 0.11460744333278394, 0.1372753770839803, 0.13560367831150566, 0.10625294054451351, 0.10875717954905373, 0.0944722036718122, 0.05882665593335501, 0.1400384873719791, 0.1308403436081932, 0.10255453688234228, 0.10492323283090532, 0.9860534547505603, 0.9818173312388881, 0.9838956130322557, 0.9773341285164472, 0.9845414448484546, 0.9818013885285395, 0.9818129232628813, 0.9850939116404894, 0.9767473938418808, 0.6144804002062294, 0.6618056005236694, 0.6043673418634437, 0.14517383325898392, 0.152743598926652, 0.4341942087209363, 0.12716652459965916, 0.4947206434377982, 0.5633745558068763, 0.17207252224815617, 0.6282878380568423, 0.2163862909933737, 0.19734270677879684, 0.3234524925147052, 0.185123129570113, 0.1320151966785632, 0.7860086755936662, 0.1300862323542482, 0.2270740554879891, 0.16584958488626522, 0.11797652645840151, 0.22506880098512327, 0.12164562282419178, 0.10389222961881228, 0.216683708301455, 0.12760042336813715, 0.19394434552480277, 0.10217350196135155, 0.120711550648818, 0.23427591945062787, 0.21906324086880435, 0.16730240749855185, 0.20169361261863228, 0.13178161860629167, 0.2248955218572657, 0.32742246289751364, 9.999999999998899e-05, 0.04591512900221917, 9.999999999998899e-05, 0.00024340226911678808, 9.999999999998899e-05, 9.999999999998899e-05, 0.010600194990975753, 9.999999999998899e-05, 0.03130783607662324, 0.07242642133416832, 0.02126764667168246, 0.07059673959186497, 0.1188798647768694, 0.008479843953748012, 0.0075056720522553855, 0.046020848627981836, 0.04732524927832915, 0.07689586244924662, 0.08011591191505263, 9.999999999998899e-05, 0.048540742206541476, 0.07392672815472778, 0.09795782356199667, 0.0684439038393595, 0.059610259635481055, 0.15251377497785468, 0.2532156628566511, 0.16728832987625597, 9.999999999998899e-05, 0.21688318848847077, 0.03143727077369951, 0.17394894954831397, 0.05556024041931851, 0.20038656216639705, 0.049885226614854616, 0.07355960640044978, 0.511637276369505, 0.49922293069734947, 0.5031181363402423, 0.520288563954971, 0.5026550172265369, 0.2078946660160178, 0.5577299231984983, 0.4205310294312158, 0.43955100416173976, 0.08370070684072528, 0.07667758500644273, 0.06326728241832424, 0.12893183241875228, 0.09750751788576051, 0.06604509107912582, 0.0774031154078677, 0.11067302562105852, 0.12179025616835482, 0.1553782582540334, 0.31631149536472125, 0.18656590219177438, 0.24938447660896057, 0.2538292542352787, 0.15983828516419107, 0.3428506374759358, 0.18957126857332252, 0.22416089842280051, 0.3675058358711375, 0.4139848529744956, 0.2517320896014694, 0.30425383816461327, 0.41531129753717355, 0.22153516029840714, 0.1902412916646079, 0.28956933905240234, 0.37048379154064637, 0.16179174998023882, 0.22163577156783398, 0.2750711123972026, 0.20422555706602397, 0.16447240228941917, 0.09594021076644876, 0.3010497566701835, 0.26706028481235167, 0.3230758811829678, 0.1737409594545326, 0.13726348683346146, 0.19135141898142638, 0.19476991216029604, 0.18807451858899427, 0.22793892719005626, 0.22109504581332295, 0.17595916902282183, 0.21296523551435698, 0.16885248591810864, 0.19456843576699445, 0.19591712490054247, 0.22741325044088834, 0.21941881791430284, 0.19696028001492627, 0.22056333051994437, 0.20064380551802918, 0.18582337940311155, 0.14687556423729053, 0.10959621028172495, 0.12342060417812806, 0.8572765535239426, 0.20059456673241827, 0.16415939932999823, 0.14203911274763104, 0.17812844968634434, 0.20474941919408618, 0.7305933124412027, 0.20615296562921692, 0.07215166767379966, 0.4490345507199799, 0.22393556901997258, 0.15465518852198834, 0.10511357331280924, 0.10394386552968149, 0.504671449900659, 0.19095494673372637, 0.18289996001223108, 0.1859579270948618, 0.17467315041370368, 0.20153028792829597, 0.19579496999909207, 0.19018938465836577, 0.20071912498961542, 0.18166211888770634, 0.08275573832573568, 0.08265296350137219, 0.08693362947122718, 0.08902943652845097, 0.07901927817716092, 0.060201984001310826, 0.08166476968670955, 0.09542043149038126, 0.08432808968720507]}, "mutation_prompt": null}
{"id": "3e7621f0-4e50-496b-8e81-5939b8c06140", "solution": "import numpy as np\n\nclass Quantum_Adaptive_Guided_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Particle Swarm Optimization with Quantum-Inspired and Adaptive Guidance\n        self.num_particles = 50\n        self.inertia_weight = 0.6  # Dynamically adjusted\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.4\n\n        # Differential Evolution with Variable Control Parameters\n        self.F_min, self.F_max = 0.5, 0.9\n        self.CR_min, self.CR_max = 0.7, 1.0\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_parameters(self, progress):\n        \"\"\"Adaptively adjust parameters based on optimization progress.\"\"\"\n        F = self.F_min + (self.F_max - self.F_min) * progress\n        CR = self.CR_max - (self.CR_max - self.CR_min) * progress\n        return F, CR\n\n    def quantum_particle_update(self, r1, r2, i):\n        \"\"\"Update velocity using quantum-inspired adaptation.\"\"\"\n        alpha = np.random.uniform(0.5, 1.0)\n        return alpha * (self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                        self.social_coeff * r2 * (self.global_best_position - self.positions[i]))\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Quantum-Inspired PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            for i in range(self.num_particles):\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + self.quantum_particle_update(r1[i], r2[i], i)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with variable F and CR\n            progress = evals / self.budget\n            F, CR = self.adaptive_parameters(progress)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Adaptive_Guided_PSO_DE", "description": "Quantum-Inspired Adaptive Guided PSO-DE: Incorporating quantum-inspired adaptive guidance and variable control parameters for enhanced exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.25201533709449825, "feedback": "The algorithm Quantum_Adaptive_Guided_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.7107947628829231, 0.6866193441673485, 0.7447693175973692, 0.7202543737129918, 0.6738186240856454, 0.7518344675655457, 0.6464320977354256, 0.680565321011436, 0.6707355234375068, 0.4141023037918029, 0.3582797458359378, 0.3390914123387401, 0.36833323446340904, 0.31902823208796394, 0.2673742975782093, 0.3491964253045001, 0.47424752019010075, 0.42381199201070063, 0.10203263329549828, 0.11796486844592469, 0.0996111771230952, 0.11197011239167243, 0.13021204384449048, 0.08423167853758295, 0.10052008941819945, 0.12870661313883502, 0.09450763005659502, 0.08156043118444178, 0.09965837215565532, 0.10479834805894994, 0.10904453245228574, 0.07644908347721935, 0.07414442037526059, 0.10311376202076139, 0.0973205241368349, 0.13175158214421023, 0.9775408152144097, 0.976298757267743, 0.9692501197893997, 0.9671541534587941, 0.9701247423090827, 0.9680337271807603, 0.9677386690338894, 0.9614075669246473, 0.9634264331271561, 0.28109823057193073, 0.21160207500878614, 0.10189742556465387, 0.1952686011664828, 0.3120649905507743, 0.19793130497340716, 0.2748388304028331, 0.222574095664004, 0.26045097821519925, 0.5259181059795465, 0.22095976200807432, 0.4340172053804986, 0.19096982984071809, 0.2834191264576368, 0.20664117813284055, 0.24059162376298937, 0.4912691526960331, 0.4080521507727114, 0.1741598760672779, 0.13872007796059405, 0.11682676218221455, 0.12619913756519563, 0.12791510917664306, 0.18259317723441648, 0.15264503060279022, 0.19317450088212296, 0.15376055173231995, 0.18012874612960073, 0.11886414520133026, 0.18614027393805277, 0.16132484631178445, 0.12347913046064096, 0.18791958940292997, 0.22921978464592652, 0.18835437719263604, 0.2184249660211498, 9.999999999998899e-05, 9.999999999998899e-05, 0.018854262459941706, 0.0565228400135247, 0.010600656054635338, 9.999999999998899e-05, 0.01511665242549276, 0.0030150652073929196, 0.043249747098400126, 0.05436066598393141, 0.13784060016351996, 0.08130639301759568, 0.07325824461345687, 0.04328429069698814, 0.026684406137759797, 0.08078926965108035, 0.06685544311184388, 0.04165709143147778, 0.026585722494716135, 0.025370174622351582, 0.026609925368808907, 0.05100812776905117, 0.06479966611915222, 0.05369819530462394, 0.07637612599519539, 0.05952846668158507, 0.07673536737270625, 0.23858994727922556, 0.10844717493419997, 0.12774847463794214, 0.06993967422364111, 0.10495372286482052, 0.23265618491364493, 0.07469514646377917, 0.12373242735432832, 0.07962726507259066, 0.4866598889065432, 0.47932702118349824, 0.48958530041989057, 0.20746475505914153, 0.4766216895472809, 0.3841910497312425, 0.5035277664417348, 0.4916474657246195, 0.5259781956317529, 0.09221864704405014, 0.09800636828057996, 0.0731731061390275, 0.0900005954596208, 0.09635504680173745, 0.0928768227885074, 0.09328763378576099, 0.10523440736607559, 0.07980983423199872, 0.15989323094361008, 0.1346173307350329, 0.16276823485959813, 0.15930308904838386, 0.25569930309285105, 0.23886547053432527, 0.26404008315288807, 0.13075059503156716, 0.2075865185543837, 0.3234222062994586, 0.2266769506266999, 0.3045488811595404, 0.30927981810471317, 0.281515384797943, 0.3099434726717686, 0.33237946037309307, 0.3590516594383516, 0.3374176442434297, 0.26569038240648035, 0.23676899268647478, 0.2644623996170281, 0.23674975510543794, 0.22967355692464475, 0.2389546647310814, 0.24242624590070094, 0.2618377455494073, 0.2904782932965153, 0.21816129341205703, 0.18207227131200454, 0.1719686437472836, 0.19172300802300346, 0.1729201317698038, 0.20413404382866351, 0.2069871238478148, 0.18816742957216404, 0.20460964582320307, 0.18650568593563865, 0.17424496505855058, 0.1914071318027447, 0.1736673467850296, 0.20851409778553442, 0.19543797173141553, 0.34701248121064643, 0.42740411592480765, 0.18350067220018973, 0.8002991229963949, 0.18313106848894145, 0.15046113550212048, 0.17240067644732338, 0.193873991330059, 0.7786300536576624, 0.7645381458036067, 0.16302912801961666, 0.7341662531777843, 0.5314832220448209, 0.20674983691967197, 0.4067709573265964, 0.2087457649937231, 0.1678481755506951, 0.14966848895560836, 0.21001237544103724, 0.1042784966371404, 0.16293458749656597, 0.18136829782370467, 0.18100946925835248, 0.20500855665437268, 0.1879211301445043, 0.18237744194375405, 0.17680481677468884, 0.18149401134906995, 0.17197714295144417, 0.178313956190713, 0.08797585156788079, 0.06862820589543539, 0.07302359344950415, 0.0800429675012414, 0.08066341606433014, 0.08236868990563473, 0.07336535172155256, 0.06254542576662625, 0.07012393270331718]}, "mutation_prompt": null}
{"id": "9e47e324-3327-4a3f-a9eb-3228041d5fa9", "solution": "import numpy as np\n\nclass Adaptive_Quantum_Differential_Swarm_Memory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Adjusted parameters\n        self.num_particles = 50  # Increased number of particles\n        self.inertia_weight = 0.5  # More adaptive inertia for balance\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted scaling factor\n        self.CR = 0.85  # Adjusted crossover probability\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n        # Memory for historical global best\n        self.memory = []\n\n    def adaptive_inertia(self, evals):\n        max_evals = self.budget\n        return 0.9 - 0.5 * (evals / max_evals)\n\n    def memory_update(self):\n        if len(self.memory) > 5:\n            self.memory.pop(0)\n        if self.global_best_score not in self.memory:\n            self.memory.append(self.global_best_score)\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            self.memory_update()\n\n            # Update velocities and positions\n            self.inertia_weight = self.adaptive_inertia(evals)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion with memory influence\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Quantum_Differential_Swarm_Memory", "description": "Adaptive Quantum Differential Swarm with Memory: Fuses adaptive swarm intelligence and memory-enhanced differential evolution for accelerated convergence.", "configspace": "", "generation": 12, "fitness": 0.20849859800020204, "feedback": "The algorithm Adaptive_Quantum_Differential_Swarm_Memory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.6062054825822819, 0.5655046598474543, 0.5677596746064335, 0.529263350734311, 0.5747738131826783, 0.19021454729213727, 0.6123758340599093, 0.6636426304698062, 0.21394336768275812, 0.14001105335345743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044733682368257144, 9.999999999998899e-05, 0.323249107983145, 9.999999999998899e-05, 9.999999999998899e-05, 0.09896922430305022, 0.1061205554545881, 0.08444477505793313, 0.08126966360489019, 0.09122962960741166, 0.08152412304936518, 0.08774282442290626, 0.09523979489491252, 0.0959641988422325, 0.07496356438385443, 0.0903434282061859, 0.09506567094012153, 0.07799592283344714, 0.08524355259538219, 0.09413406124698853, 0.09137005364503037, 0.0694228529429094, 0.09041122452522976, 0.9625691079717579, 0.9533357474693754, 0.9680088248589066, 0.9585315017203602, 0.9498871943192028, 0.9586397227756822, 0.951487742738092, 0.9623571651626782, 0.9663784466996914, 0.29830664725850486, 0.27700060732267906, 0.10758092127429786, 0.13784669968552865, 0.13627141684556066, 0.13690407243180358, 0.360706739483419, 0.08602044092622052, 0.30898747069749144, 0.16894127065326392, 0.37322588554063874, 0.5839062146370545, 0.18873384516810765, 0.19043956310337484, 0.19123441037887867, 0.2102094208821942, 0.14755831379939466, 0.4973781202647449, 0.1840316329612518, 0.09322576636786983, 0.1504442190777856, 0.09461905112059887, 0.15243586584839175, 0.08439046208034684, 0.14491862080230855, 0.14785871544407747, 0.13866127346702428, 0.17155166974850522, 0.16845792429465578, 0.140820023560703, 0.15541293721410498, 0.10774293173996607, 0.14317018415507976, 0.19045469287878514, 0.12992527764230344, 0.13941546893699774, 9.999999999998899e-05, 9.999999999998899e-05, 0.0277211984711363, 9.999999999998899e-05, 0.00011020152248042425, 9.999999999998899e-05, 0.010527865892862809, 9.999999999998899e-05, 9.999999999998899e-05, 0.07280900471618257, 0.08146257631469922, 0.13146058393749427, 0.09874156626949093, 0.0598758476232264, 0.002117531655842164, 0.052343619232000815, 0.06251840298475886, 0.059162442741839016, 0.034520699613106776, 9.999999999998899e-05, 0.02537649576928358, 0.046303398111538496, 9.999999999998899e-05, 0.022129999179058668, 0.023511342882418518, 0.016034918636701367, 0.06009491209993889, 0.12432130245884487, 0.13644864309871774, 0.07398828335649865, 0.06868896052712004, 0.031425121785500276, 0.1109023080957453, 0.10594062977525576, 0.04102993645641795, 0.06599461905544646, 0.4284107918237131, 0.4619731938400826, 0.3223817436576967, 0.44299894179700217, 0.3567175957592972, 0.4690529513043288, 0.44912064147608133, 0.37625791346506976, 0.463738514332817, 0.1014061148953378, 0.04863648061559778, 0.05769442710681649, 0.08001773876254814, 0.16137026410557376, 0.09253625822378342, 0.09720603530431127, 0.09021191390407934, 0.09551463310423314, 0.1148208204338893, 0.15110778704560346, 0.15773721832694976, 0.1644129278694243, 0.16799347736326564, 0.17955962845867213, 0.25702002772092114, 0.12776933030821314, 0.16736648034306723, 0.3502529942934448, 0.18075192728233358, 0.23595650996860018, 0.3336480015905061, 0.30842519889661646, 0.334235530266384, 0.38742849829958026, 0.2505200072081365, 0.3673388252521528, 0.24623585935905468, 0.21658193317031504, 0.18303828417397583, 0.21422252500453243, 0.20503738897028323, 0.24501236193820541, 0.2311099414792489, 0.2398986964241474, 0.22559689652191472, 0.19627911480142524, 0.19767145538385333, 0.1825540890155537, 0.2091264493787276, 0.18724065711731674, 0.20219950065969639, 0.19170746744471423, 0.19914958274297534, 0.19741994618170744, 0.18783420323616606, 0.1741509769162598, 0.17896605445460068, 0.1898610039380374, 0.1786262313921434, 0.1738550540442313, 0.16843375466860033, 0.34654561014074636, 0.18113480398957027, 0.17540697629813662, 0.18032067245595007, 0.13464398100098296, 0.5610800877606519, 0.19371515453343058, 0.11872260914425281, 0.14017579844854555, 0.19159329229776012, 0.6409851497052212, 0.5461651987789933, 0.20529709435902888, 0.10914004385179199, 0.2433452862590132, 0.16554834796072304, 0.13699085853779236, 0.1816943069744027, 0.19102426810845174, 0.39188104817956404, 0.19440171421330288, 0.20208033808974657, 0.17799420055323245, 0.19564432868233483, 0.1761367185246554, 0.17557568862776463, 0.17582039197702037, 0.1852192814651873, 0.1868203673490083, 0.06713012049269473, 0.06345559047988969, 0.07592016868475215, 0.06130020962819105, 0.06583114561024683, 0.08217528456821732, 0.07133265331393579, 0.07373825652592403, 0.07623037925637777]}, "mutation_prompt": null}
{"id": "4768dffd-748c-431e-8b05-766bc540df74", "solution": "import numpy as np\n\nclass Hybrid_DQPSO_EDA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.5  # Increased for better exploration\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Estimation of Distribution parameters\n        self.alpha = 0.1  # Learning rate for distribution update\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Estimation of Distribution (EDA)\n            mean = np.mean(self.positions, axis=0)\n            stddev = np.std(self.positions, axis=0)\n            new_samples = np.random.normal(mean, stddev, self.positions.shape)\n            new_samples = np.clip(new_samples, self.lower_bound, self.upper_bound)\n\n            # Update positions based on EDA samples\n            for i in range(self.num_particles):\n                if evals < self.budget:\n                    trial_score = func(new_samples[i])\n                    evals += 1\n                    if trial_score < scores[i]:\n                        self.positions[i] = new_samples[i]\n                        scores[i] = trial_score\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_DQPSO_EDA", "description": "Hybrid DQPSO-EDA: Combines Dynamic Quantum Particle Swarm with Estimation of Distribution Algorithms and adaptive parameter tuning for improved convergence.", "configspace": "", "generation": 13, "fitness": 0.23566966099078868, "feedback": "The algorithm Hybrid_DQPSO_EDA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8874135154447722, 0.8874725988508358, 0.8982152491124195, 0.8926575200292849, 0.4478532366831266, 0.8814395269843336, 0.8857688628181893, 0.30135216302653556, 0.8910335240001556, 0.0074087975258964045, 0.10256640213450063, 0.12790689915624753, 0.18310960466180426, 0.08990958028360996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11551315523656991, 0.14028289734763943, 0.14271513795248192, 0.08512802206573611, 0.13103891760855546, 0.10878389786058829, 0.131379530551614, 0.13161493070198937, 0.15739980053812397, 0.13265994376533286, 0.08088768036095384, 0.08768632269204191, 0.10949643457707048, 0.057660361403912286, 0.09196811188167608, 0.17507102950630105, 0.10367053518067171, 0.10383547403546711, 0.11324956665071806, 0.9299752001235939, 0.8637007951900979, 0.13257971070968866, 0.15726077485445877, 0.14445796538999855, 0.16432708866942813, 0.9157218754003543, 0.19602394642038345, 0.260565862928983, 0.24415315020752515, 0.08527380211673741, 0.28196699314756024, 0.11319487568126374, 0.2997410965395353, 0.17534050965654024, 0.1293679003235535, 0.15440327307910773, 0.22949983507340344, 0.14947707057505544, 0.8980673567822328, 0.2134716019132048, 0.21264380058202792, 0.381202177791362, 0.15548954541887183, 0.1520759748521443, 0.18072294753881923, 0.1341320471601446, 0.1292927666284175, 0.14108773917864037, 0.14032314955059644, 0.12736104482951982, 0.3307026761114479, 0.1585177841987605, 0.127563904826006, 0.14244239816388782, 0.2076388908383151, 0.22302326349167934, 0.3177584331384228, 0.14864050183640598, 0.1282507866509479, 0.12568556597207647, 0.13120916185726095, 0.1093843819371858, 0.1341524417742096, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07984837965984404, 9.999999999998899e-05, 0.02210162312521302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09217689800129902, 0.06481783380913364, 0.11972576997478301, 0.06339563709379492, 0.03801132339899482, 0.012987772686697152, 0.05162383539347881, 0.14438182736401728, 0.07590309477592927, 0.08134126788236828, 0.1030859408523811, 0.22275642631018144, 9.999999999998899e-05, 0.1152771290360739, 0.1984293675846608, 0.21211794548432916, 0.13342202330287423, 0.11316163582509975, 0.17341813955028773, 0.2825887870841407, 0.09965681074093391, 0.07457575045888643, 0.17530610408365788, 0.08879739789091035, 0.12568826985027226, 0.2285275498679349, 0.08273049048986891, 0.5286430160103492, 0.5252697124195342, 0.4326043082023019, 0.3613966256384301, 0.47891944031962064, 0.5048029548059791, 0.5482435873115448, 0.5162185051542834, 0.5518648743342611, 0.11686046342299539, 0.08660008619969617, 0.09028182922617856, 0.11519568980038386, 0.08986257548823884, 0.08761853043351298, 0.11641002056664584, 0.15908554918251994, 0.12756370675411632, 0.2332457670073821, 0.18665417966513353, 0.20555616353991335, 0.3067089636921544, 0.2955859547392997, 0.22273463081960132, 0.4032494387134863, 0.18386454271258745, 0.18290515009954345, 0.2906550019045071, 0.37942626752381226, 0.40291680681564723, 0.5346140365998033, 0.28715502089900224, 0.2568596612250722, 0.23719408046111057, 0.42328720237650985, 0.750394242111846, 0.24077545961989633, 0.1813348337622923, 0.24988545922634586, 0.35927244966676564, 0.2245377188268869, 0.26656171259964745, 0.14236604571275002, 0.2649897793214907, 0.2023259460104886, 0.21249713476888688, 0.20184336234087652, 0.21081603093888102, 0.20043957616330343, 0.18590614854638898, 0.231646234729753, 0.24964674958218858, 0.21208426468917008, 0.2110766486238197, 0.18497626145677737, 0.1860392496195652, 0.17940192236668517, 0.19085459561334828, 0.19081860185688837, 0.20983968374474993, 0.19308596385370314, 0.25353482393585347, 0.16999510528935735, 0.6220503838732767, 0.1660726576674968, 0.18370975092319208, 0.9101611473009347, 0.9107445314053654, 0.1476942744207529, 0.7920514335257194, 0.8954781725538844, 0.9173702111921472, 0.3650529477146951, 0.20555172926061316, 0.3145283232878068, 0.3549507977320875, 0.16812963227252564, 0.15424619171256604, 0.10473083497993008, 0.25167546704893295, 0.2018370401210916, 0.1996878585906292, 0.17912027484983994, 0.21000497385732697, 0.187149421414593, 0.18472246174777684, 0.18653510714960797, 0.17727177988850873, 0.173938965399002, 0.1889181996687791, 0.09449237295455204, 0.08239475680975816, 0.09812675611517041, 0.08317371851167066, 0.10074343549283515, 0.07786668442852929, 0.0667822569611799, 0.09581356082093484, 0.08579198199582239]}, "mutation_prompt": null}
{"id": "4ef9d673-368d-40e6-a116-adf1680c21f4", "solution": "import numpy as np\n\nclass Hybrid_DQPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.4  # Dynamic inertia weight for adaptive balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F = 0.7  # Adjusted scaling factor\n        self.CR = 0.9  # Increased crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_DQPSO_ADE", "description": "Hybrid DQPSO-ADE: A hybrid of Dynamic Quantum Particle Swarm and Adaptive Differential Evolution with Lévy flights for rapid convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8684018429441183, 0.8616555624014703, 0.8871553260048956, 0.8775386149537622, 0.8527949425795994, 0.8772856393733616, 0.88391899300397, 0.8749664854393696, 0.8743286688626355, 0.7647400050577433, 0.6259180642761535, 0.7554311288137997, 0.6729733770183758, 0.49786907770012034, 0.7547066937430259, 0.7806866540887984, 0.7111997233972764, 0.7577781012617886, 0.11234317941548777, 0.13034505079925274, 0.14183325810226777, 0.12479510711411645, 0.1147532841947817, 0.14247137153155653, 0.09943578328259717, 0.09912782360058159, 0.12635999964191635, 0.10851148191169269, 0.10185741861935915, 0.11959826681126529, 0.12981231342566046, 0.10822708973957174, 0.1097573627189109, 0.09683448163455399, 0.11408725414018861, 0.08830726434717162, 0.9461735840155766, 0.9618970970175093, 0.9505448803381455, 0.963404112937843, 0.9421967558315836, 0.926562729859534, 0.9392267198401457, 0.9326232788049902, 0.9590818414524247, 0.6882714586454848, 0.7221297178606805, 0.2697667491407013, 0.7682583551648534, 0.74514795534809, 0.15239212305733085, 0.45647627216737285, 0.367087168005651, 0.6237312715553543, 0.3833960695903692, 0.22531268786803338, 0.22102199979063664, 0.3828188023718475, 0.8826937675468733, 0.21210720184883003, 0.23223205722940676, 0.22188464742678538, 0.36010208318888903, 0.1478514993958715, 0.15681854668730544, 0.16434012494630001, 0.18225096190265988, 0.4181929988708065, 0.15283928597785212, 0.16351521237507183, 0.18872222878738376, 0.1639889660782301, 0.12764701768680242, 0.18550842136478318, 0.1650954491446175, 0.16096047859327778, 0.18082329389638985, 0.1275552499783309, 0.14311660137803972, 0.3520316197126606, 0.16467124631445018, 9.999999999998899e-05, 0.01462487148637015, 9.999999999998899e-05, 0.002032718469894612, 9.999999999998899e-05, 0.008731682310085698, 0.025477312910376693, 9.999999999998899e-05, 0.0010752244818198475, 0.0938189203864036, 0.14948030612759378, 0.06884110719668846, 0.08312106305815103, 0.04226317921938094, 0.037172189903893926, 0.09472883376898622, 0.15603165656146378, 0.08247485803853438, 0.12861208203867014, 0.13084085465013418, 0.15626243481121416, 0.1053902838823737, 0.10810430576641816, 0.15527180777885552, 0.2035139985250256, 0.24050389138888928, 0.07333428609745007, 0.17584890341039228, 0.11913782637012604, 0.17631557135841924, 0.02654507377268689, 0.09215979311339084, 0.08964786030639948, 0.14450834620111142, 0.17263878432826663, 0.1085993605278952, 0.510954293312877, 0.5453258639071814, 0.5099324766476584, 0.587988169010351, 0.5128929996307758, 0.5401167988451663, 0.6763907952215489, 0.5419406630295125, 0.5638287047840174, 0.12285437452190506, 0.1281563082625049, 0.09749758498780736, 0.12636528770753153, 0.1058785117805141, 0.13021171590637337, 0.0906233776571973, 0.15218388267472238, 0.14403097452022406, 0.28933205678208596, 0.2625729667746455, 0.2095502786471849, 0.2652799410489207, 0.1591092308777381, 0.431354456523925, 0.18541174209266242, 0.15040892701413577, 0.20312570956862663, 0.2873207132219012, 0.5190737726893779, 0.39581732873572195, 0.4706081605002692, 0.4661233284814613, 0.3524346704899174, 0.6172114182705171, 0.5853590526137424, 0.5834105376830188, 0.27301964961666825, 0.2872961984053627, 0.44497707802781883, 0.25149497417745637, 0.3398618360973755, 0.3531817984021246, 0.24541141203883832, 0.4248644356984119, 0.28992285655184613, 0.21134218691275586, 0.30252588919592904, 0.20086825342050996, 0.2271934628302532, 0.21172048590361525, 0.22808004837468265, 0.22855767133446303, 0.21481683158672582, 0.21263555520104382, 0.22138531413339102, 0.18058918609499053, 0.191992464262547, 0.19047311541726908, 0.1852081479658254, 0.20721607290176425, 0.20243629685621456, 0.20165686530042326, 0.18249703406704243, 0.8345720735364273, 0.8971106378588505, 0.15216132846020414, 0.8819562256101345, 0.19990325255317232, 0.8573321491666108, 0.17218982065165367, 0.12341397255648878, 0.89341101821022, 0.8976906685587154, 0.211514411198665, 0.7408100179330832, 0.21029455777575923, 0.16785208792952977, 0.15464495102449838, 0.3731000458143572, 0.2601173705792943, 0.21049853329699886, 0.17802161904422753, 0.1874998039136354, 0.20241713215708823, 0.19022587240394884, 0.17779943340817206, 0.18114258318398935, 0.1784357204149426, 0.1759241962441036, 0.18551456744649908, 0.08228819918165609, 0.0738677000463227, 0.09318873912930936, 0.08482247454613479, 0.08632329875844558, 0.07362176847812729, 0.08047641002405292, 0.08870331324012115, 0.08902300519201967]}, "mutation_prompt": null}
{"id": "283f04fe-27f3-43ce-b0a8-1b6b089d6114", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_DQPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO-ADE parameters\n        self.num_particles = 50  # Increased number of particles for diverse exploration\n        self.inertia_weight_bounds = (0.9, 0.4)  # Adaptive inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F_bounds = (0.5, 0.9)  # Adaptive F for flexibility\n        self.CR = 0.9\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def adaptive_inertia_weight(self, evals):\n        alpha = evals / self.budget\n        return self.inertia_weight_bounds[1] + (self.inertia_weight_bounds[0] - self.inertia_weight_bounds[1]) * (1 - alpha)\n\n    def adaptive_F(self, evals):\n        alpha = evals / self.budget\n        return self.F_bounds[0] + (self.F_bounds[1] - self.F_bounds[0]) * alpha\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            inertia_weight = self.adaptive_inertia_weight(evals)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights and FDRS\n            F = self.adaptive_F(evals)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_DQPSO_ADE", "description": "Enhanced Hybrid DQPSO-ADE: Incorporates adaptive inertia weight and FDRS-based mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.21637583475570604, "feedback": "The algorithm Enhanced_Hybrid_DQPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.6453139642583738, 0.6575009632155469, 0.6530576572402281, 0.17906797459918977, 0.19817816154902468, 0.6486820931153618, 0.7002208535865402, 0.6183996993312949, 0.20752779840820235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2690332647469251, 0.005406016395098079, 0.300492182478884, 0.39083805917885295, 0.1817983542037217, 9.999999999998899e-05, 0.11234641595078099, 0.0739955995678323, 0.06549179238035518, 0.06820082908283931, 0.1008801902156512, 0.10364902505365847, 0.1124345978371244, 0.09563591790086012, 0.10482398103796109, 0.10110258910228054, 0.043743895697919144, 0.08242450958242187, 0.06960606755229237, 0.08588489133210164, 0.07074248126325478, 0.07560623669849187, 0.11709114849694202, 0.10837007032355128, 0.9573305297618242, 0.9400734871552509, 0.9526375781688964, 0.9523922258368099, 0.9503309298553487, 0.9558708844748214, 0.9515588245609712, 0.9527962542484345, 0.942177643684605, 0.38145319031126323, 0.231053598427302, 0.31267947314173605, 0.38939478960448193, 0.14486287899379147, 0.14400021888190673, 0.12148739175969092, 0.08344564396898857, 0.3165211169838412, 0.20757591173925583, 0.3210819759428343, 0.16692505780969058, 0.20813206036003717, 0.18691367419815874, 0.18951875137225593, 0.5312417794947961, 0.12433987314882311, 0.5186409493959575, 0.14926085414807855, 0.014240043110086642, 0.18159435442969596, 0.1436869949428896, 0.17330347434082072, 0.14889870834578378, 0.16468961634711665, 0.1457298935934901, 0.12655385904696448, 0.17523471287672387, 0.14078797271551247, 0.16338946356876038, 0.18216414087789912, 0.1761625362317183, 0.15898658883299854, 0.17925485533845198, 0.15272380269446528, 0.13905326840197962, 0.0008593644814028911, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04200402538401482, 0.030624136511574584, 0.05887124136924071, 0.019187422338782012, 0.0038470102936100092, 0.07057349040296157, 0.03563973150830735, 0.059953874133009455, 0.05121697519913382, 0.028194364073126255, 9.999999999998899e-05, 0.021189078719612398, 0.04906119434051348, 0.04089136194234344, 0.053160069770716856, 0.050147857348647684, 0.07313784711642002, 0.0656902398716136, 0.1180364741726656, 0.13015527404603544, 0.07555902034493323, 0.13110877316901148, 0.15635977793803124, 0.1900944579495385, 0.02934441692619838, 0.006847343729513344, 0.06648078430747939, 0.47861609416683937, 0.4380936853992812, 0.3627959539673452, 0.5064145040048675, 0.452496946760341, 0.40021594703165153, 0.3391875769090623, 0.288718993833474, 0.4936014198811227, 0.08015880443833234, 0.06809296910480267, 0.07097205231588666, 0.09823418652939275, 0.09486535280478714, 0.09056939859527136, 0.10477432297177058, 0.09005511329173099, 0.08486529116833696, 0.13063045815032526, 0.15597823058303784, 0.16027739071551572, 0.15762785926300604, 0.15226712348888416, 0.15322571702783994, 0.17202820127490837, 0.12948993479210036, 0.19422240286058667, 0.2979159095754188, 0.2767255289927034, 0.32116897607163597, 0.4074892164425312, 0.39386911879265574, 0.3209385696618444, 0.20669797978794446, 0.2602384662807067, 0.2968222614842473, 0.2513349447130947, 0.2701357500216085, 0.22096707549922678, 0.26066028903944427, 0.23190063121117943, 0.21489228564220564, 0.22642266221296992, 0.21940768984494186, 0.14898515266104062, 0.18260229326577293, 0.1689070092199123, 0.2027778482917323, 0.195726399637833, 0.22313621366665648, 0.1787707795606397, 0.20249015850293317, 0.194587856560823, 0.1984401182771558, 0.18230446162600056, 0.20685797163260167, 0.17302839394680536, 0.17236505375590683, 0.17630953853535503, 0.17700361081132632, 0.1808380248495739, 0.1780535512502791, 0.18187464949863785, 0.7347974839306078, 0.18376579774576374, 0.14634001327209956, 0.7032636132375063, 0.1797735438436655, 0.16240524069531204, 0.1186540593597003, 0.16415914473015325, 0.5105189832670727, 0.642203813300783, 0.16462665690744183, 0.5349013003035168, 0.2004356491638104, 0.16561588786488757, 0.21503987601110108, 0.1988093853505707, 0.1603348714386662, 0.21722170355168602, 0.19076665415862737, 0.18527363820092868, 0.20564749226016155, 0.18184517282693757, 0.21340573253641382, 0.1809610333272652, 0.18396592583238403, 0.19099068046220857, 0.18626038349992002, 0.08232532969015938, 0.07580032203177578, 0.07295327605000534, 0.07586072085530671, 0.07285269942922912, 0.083838542052324, 0.0831551007863196, 0.07897246427193638, 0.08108102093320524]}, "mutation_prompt": null}
{"id": "e6250848-49ee-48ef-998d-448e65db7731", "solution": "import numpy as np\n\nclass Dynamic_Adaptive_Swarm_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters for dynamic swarm\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia with adaptive decay\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor for diversity\n        self.CR = 0.85  # Balanced crossover probability\n\n        # Initialize particles randomly\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.6, 0.6, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def stochastic_perturbation(self, vector):\n        perturbation = np.random.normal(0, 0.1, vector.shape)\n        return vector + perturbation\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Dynamic Swarm)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * np.random.uniform(0.1, 0.6, self.positions.shape)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with adaptive perturbation\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Introduce stochastic perturbation\n                trial_vector = self.stochastic_perturbation(trial_vector)\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Dynamic_Adaptive_Swarm_DE", "description": "Dynamic Adaptive Swarm-DE: An enhanced hybrid of Dynamic Swarm Intelligence and Differential Evolution with adaptive step sizes and stochastic perturbations for improved exploration and convergence speed.", "configspace": "", "generation": 16, "fitness": 0.2607069619702064, "feedback": "The algorithm Dynamic_Adaptive_Swarm_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8100612307359599, 0.5716505615151358, 0.8622226953521787, 0.541834115212586, 0.597964569322146, 0.867721548497908, 0.5946596872016361, 0.6322971775372543, 0.7133878091679007, 9.999999999998899e-05, 0.06458501131600092, 0.11107146449427763, 0.04257143517045536, 0.08320700564571093, 0.025955948575901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12959807542139934, 0.12616644312202385, 0.1285838462815294, 0.1296203868024426, 0.1273387683815448, 0.15400834990876444, 0.12967182216145412, 0.13937692672463342, 0.1512795072635017, 0.10706031660459625, 0.10267446329595042, 0.13901157927149854, 0.1150692791551895, 0.09442509926694365, 0.0911768392239084, 0.11292742937107247, 0.09802508311602909, 0.139641925069649, 0.9125339590018628, 0.9395167176963591, 0.922715558925608, 0.9110837403172548, 0.8696333212970748, 0.8742798758365105, 0.9004491757697358, 0.9390673746327941, 0.8909398763049052, 0.32564217267631046, 0.33263034382858736, 0.31375029863030424, 0.331208354263395, 0.3437859391491467, 0.3606881096594, 0.3531371665155776, 0.2944634668728332, 0.3203939184735256, 0.40101781182999763, 0.38071737214637014, 0.5296721041047614, 0.2725796006412644, 0.27651445883239034, 0.2726501089553296, 0.23294367718525943, 0.31221791659242226, 0.8733491124195469, 0.2572655624208481, 0.19795458061770155, 0.15986740357160834, 0.14203202841721685, 0.15839673418557487, 0.16335567051120925, 0.16072695533246983, 0.18846248262413312, 0.2135754706564269, 0.1523843810901926, 0.13924811458397213, 0.33703517307725095, 0.18907479750827894, 0.19002935744113025, 0.15297719015212974, 0.16831913812351684, 0.15542935150424086, 0.12588097620353833, 0.0014349582702402053, 0.023944728375550173, 0.008255987749300808, 9.999999999998899e-05, 0.002565271382269696, 0.01939778009709847, 9.999999999998899e-05, 9.999999999998899e-05, 0.06032261309208076, 0.15818187035986775, 0.07175512171164433, 0.18937426260636403, 0.10873360263109222, 0.028551330475053094, 0.0789850094222182, 0.09788825482320607, 0.17700760407241434, 0.1167730678924398, 0.12469161525122963, 0.1080217556756845, 0.07140507272408214, 0.17125897546717805, 0.14347332367715826, 0.08331318845066393, 0.14655275735572382, 0.08805413174882903, 0.08532147002093171, 0.11499037653608501, 0.09093664513812905, 0.2164371124983494, 0.12866466668071697, 0.12628820184626033, 0.2693188089761266, 0.18519034639433007, 0.09089585749392459, 0.09231459546104703, 0.4540276494356582, 0.514221244157222, 0.5096730255295179, 0.41789477202927683, 0.5224324806831622, 0.4959773200041242, 0.4668882648507334, 0.47750165025407965, 0.4512336535169784, 0.12802284520007057, 0.08386864517165538, 0.1067220206201972, 0.12801994120721993, 0.11343311248985011, 0.14514728670518218, 0.1508271483571687, 0.1468041125486922, 0.11315006870202271, 0.2100920217909098, 0.15230716248671816, 0.3346969537247484, 0.2046489709699697, 0.3231115810702063, 0.1577451624721925, 0.19822427741094917, 0.17619604736919814, 0.27280606575645006, 0.30247796751686373, 0.40387824371114645, 0.29947233301566434, 0.3352008933591879, 0.30769716798033697, 0.3662316763668997, 0.35447125043341043, 0.3330981227034877, 0.2811353429627371, 0.25594487035118485, 0.2879294282620083, 0.296717428051426, 0.24075541654832744, 0.2789062010535288, 0.3158954837713981, 0.22809297634205816, 0.27124542145583574, 0.2197242935906204, 0.204348157571132, 0.2025190940027346, 0.20570749566856417, 0.2508198149086246, 0.20814935916745514, 0.20645380131009006, 0.23338756015112916, 0.25840265391668005, 0.2591765150374262, 0.2393583174812276, 0.17627925209860118, 0.18897301149787105, 0.20810850159765337, 0.20398185436552252, 0.18039110594843477, 0.19531134063752742, 0.17604078831124226, 0.1837442910766255, 0.794102719825872, 0.16465472193727004, 0.16094801014971383, 0.7709961054672827, 0.1995783187628989, 0.6313146347471327, 0.17460263032701528, 0.15651274235190327, 0.7455086103125386, 0.7687010721418271, 0.2104313007225147, 0.5828332418659146, 0.2077357311030681, 0.16705258266557887, 0.1633763537194498, 0.12615014349478293, 0.3337138618120489, 0.6515139080114343, 0.18650352728617137, 0.19090603695984787, 0.17048421016625348, 0.19063858214374163, 0.19002156651739865, 0.1867611338394427, 0.18840796083206524, 0.20476933583114187, 0.18105599195119182, 0.10642582845706128, 0.09194320119912014, 0.09890632893840157, 0.08334120119345223, 0.0982389087379626, 0.0915663748336949, 0.1024032367857759, 0.08430938859781978, 0.08514970001252731]}, "mutation_prompt": null}
{"id": "b834df27-c2d1-45ae-82d3-97d74c3a69de", "solution": "import numpy as np\n\nclass Hybrid_QPSO_GA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # QPSO parameters\n        self.num_particles = 50\n        self.inertia_weight = 0.5  # Increased inertia weight\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Genetic Algorithm parameters\n        self.mutation_rate = 0.1  # New mutation rate\n        self.crossover_rate = 0.8  # Crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_mutation(self, x):\n        mutation_strength = np.random.uniform(0.01, 0.1, size=x.shape)\n        return x + mutation_strength * np.random.normal(size=x.shape)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (QPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Genetic Algorithm operations\n            for i in range(self.num_particles):\n                if np.random.rand() < self.crossover_rate:\n                    partner_idx = np.random.randint(self.num_particles)\n                    partner = self.positions[partner_idx]\n                    cross_point = np.random.randint(self.dim)\n                    trial_vector = np.concatenate((self.positions[i][:cross_point], partner[cross_point:]))\n                else:\n                    trial_vector = np.copy(self.positions[i])\n\n                if np.random.rand() < self.mutation_rate:\n                    trial_vector = self.adaptive_mutation(trial_vector)\n\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n\n                # Acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_QPSO_GA", "description": "Hybrid QPSO-GA: A hybrid of Quantum Particle Swarm Optimization and Genetic Algorithm with adaptive mutation for faster convergence.", "configspace": "", "generation": 17, "fitness": 0.22106940700406827, "feedback": "The algorithm Hybrid_QPSO_GA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8542223923524623, 0.7258331972848396, 0.8405233234735421, 0.8231146349666308, 0.8468492455701675, 0.8534890564891927, 0.8559281889630971, 0.6252227885176894, 0.8479852438087945, 0.07914281283703328, 0.031796712303652, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699074522888991, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0467988943420693, 0.0958507686987854, 0.1387855965332515, 0.10327297668943392, 0.10933688078048509, 0.11534087576382313, 0.0871613703439279, 0.07405464247128479, 0.15486886780645748, 0.08376129748242989, 0.056488169422433954, 0.05655615455500451, 0.09852249811657077, 0.10791173362625872, 0.14205910827550838, 0.08909575116420232, 0.06828790644443128, 0.12031308561424015, 0.08554366768410215, 0.5457028571008014, 0.7910600896941509, 0.9242147400024606, 0.12632416470298335, 0.1469461913151523, 0.591567129007571, 0.5355026963919856, 0.8595766382103663, 0.43223397512455275, 0.31363537067371283, 0.2218341728112676, 0.16658430555168124, 0.2784290223035325, 0.23015805374032938, 0.1946221516352713, 0.18425095920284262, 0.15304712152065236, 0.4021948910463996, 0.8806124183708117, 0.22723709812697634, 0.17027039994977744, 0.9215431059804817, 0.17410125271438393, 0.3531298291661047, 0.19388308874158322, 0.23205293606276722, 0.1846631862315966, 0.14484014928900524, 0.12937875835188528, 0.12404942532687924, 9.999999999998899e-05, 0.162259398439225, 0.13461193002275307, 0.1806729196435346, 0.14432128664111876, 0.1444684612028796, 0.1312918019941568, 0.19175003565459792, 0.12290216639566354, 0.1648269090341904, 0.19421178654942706, 0.14109502310639133, 0.20015621931211536, 0.12407744702901213, 0.09010617109473384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04621791497345962, 9.999999999998899e-05, 9.999999999998899e-05, 0.007956023924966527, 9.999999999998899e-05, 9.999999999998899e-05, 0.1276695585193922, 0.03056095419245941, 0.06614456484820275, 0.03838486224425486, 0.02042402379570396, 0.047984828007303304, 0.07591802356239163, 0.05920881135873102, 0.08058405909207611, 0.026764293940818917, 0.14478739703906396, 0.17661207321122596, 0.08087543645592354, 0.03614608533530683, 0.07996572965505733, 0.2823135493800156, 0.156620032454174, 0.12469027505563612, 0.21534993661823254, 0.187437866087376, 0.2180588146370196, 0.22187718180247684, 0.13306509105684616, 0.12232846153425947, 0.14064371884697924, 0.10476993272518031, 0.10410955353951501, 0.460270200226259, 0.41493999836406914, 0.5090328428080124, 0.5861461664673614, 0.44851034923316513, 0.44388221819602447, 0.45115217405979025, 0.4449883160689537, 0.48271455776597716, 0.11979801329080131, 0.11418327538005346, 0.07631530840983192, 0.09462598236355024, 0.09040642956368172, 0.1404891209172665, 0.1546943472175022, 0.08864355962844461, 0.06895921115130621, 0.1321207131118477, 0.25550048710376994, 0.18917664892126218, 0.2799971490034313, 0.5022997498003097, 0.17643761001273217, 0.23283350898244948, 0.3343096812002474, 0.4453965181102022, 0.41614717408053437, 0.21549751291002806, 0.31124689771110525, 0.27248413937817517, 0.1782894812434539, 0.23182969652488195, 0.32331591600380705, 0.3415222789191078, 0.2110101735529336, 0.16472171103476707, 0.12077999575471932, 0.2703698125610271, 0.21901158760744222, 0.15101959785800667, 0.26993146412824676, 0.22269729707195718, 0.29064495710989535, 0.31446261421227517, 0.23380677781883774, 0.1970115205363303, 0.1818819413362407, 0.2149931455323555, 0.2173723578286676, 0.22246362947558762, 0.20742366351383035, 0.20736140127694536, 0.21134993781057487, 0.18866178208193418, 0.18931721465078089, 0.1941410420834161, 0.20449106390322203, 0.2008029443661209, 0.17351030545801893, 0.18035227345843707, 0.16546743952841148, 0.19536728093367717, 0.18664352702781672, 0.18843236156124388, 0.1849684363417058, 0.17112744916385159, 0.19909259447347916, 0.11931691566760438, 0.14198804445996394, 0.16457975338517516, 0.12199233147058608, 0.3651915882093375, 0.20854186469825498, 0.3298103764168714, 0.31761564674672493, 0.16824105011963275, 0.15271415846734604, 0.2696712449472167, 0.4793345624073746, 0.35362367163947406, 0.17950397759171377, 0.18587423302577377, 0.1779472276947457, 0.1837709930501643, 0.1797025248924552, 0.1850643536214851, 0.18054420343577604, 0.1864216834466258, 0.1753754181318018, 0.06709893222759078, 0.10172752969545584, 0.08824827617297526, 0.07430936474588201, 0.08758092266356976, 0.08869234711137775, 0.0928164168927933, 0.07306291148329014, 0.08750747720505336]}, "mutation_prompt": null}
{"id": "c7c89f2c-aea7-4fcd-8898-aad3a15cbb2e", "solution": "import numpy as np\n\nclass Quantum_Evolutionary_Swarm_Optimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # QPSO parameters\n        self.num_particles = 30  # Reduced number of particles for faster convergence\n        self.inertia_weight = 0.5  # Adjusted dynamic inertia weight\n        self.cognitive_coeff = 1.2\n        self.social_coeff = 1.6\n\n        # Genetic Algorithm parameters\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def strategic_mutation(self, individual):\n        return individual + self.mutation_rate * np.random.normal(size=self.dim)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (QPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Apply Genetic Algorithm-inspired mutation and crossover\n            for i in range(self.num_particles):\n                if np.random.rand() < self.crossover_rate:\n                    partner_idx = np.random.randint(self.num_particles)\n                    partner = self.positions[partner_idx]\n                    crossover_point = np.random.randint(1, self.dim)\n                    trial_vector = np.concatenate((self.positions[i][:crossover_point], partner[crossover_point:]))\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    \n                    if np.random.rand() < self.mutation_rate:\n                        trial_vector = self.strategic_mutation(trial_vector)\n                        trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    \n                    trial_score = func(trial_vector)\n\n                    # Acceptance criterion\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial_vector\n                        scores[i] = trial_score\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Evolutionary_Swarm_Optimization", "description": "Quantum Evolutionary Swarm Optimization (QESO): A novel hybrid of Quantum Particle Swarm Optimization with strategic mutation and crossover inspired by Genetic Algorithms for enhanced convergence speed.", "configspace": "", "generation": 18, "fitness": 0.2587628449053347, "feedback": "The algorithm Quantum_Evolutionary_Swarm_Optimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8494276317997392, 0.7873407195309275, 0.811467827399696, 0.8085056417432539, 0.37521419627544905, 0.16407974361329603, 0.8660041891915661, 0.8720080854032142, 0.7412897850258205, 0.0, 0.2086581448493534, 0.05958055429304254, 0.6848840882166106, 0.6100574024112764, 0.3107976529344124, 0.13850208166434963, 0.6415376975920963, 0.6879150118314035, 0.11860525597410565, 0.0712075940621415, 0.10554569708962369, 0.03915110849120629, 0.10751680168303523, 0.09309122320694496, 0.1448601927819111, 0.09769171256474496, 0.07617915314368551, 0.1164770382015986, 0.11586912363352897, 0.0660701129027993, 0.07761373904388036, 0.08617343710251657, 0.049487685643029855, 0.12520935841983172, 0.10131768248089879, 0.0863923105611657, 0.9687682565764243, 0.9874431000563997, 0.9821220722151426, 0.9498657417626131, 0.9738315841203979, 0.9781133171476006, 0.9779786821645867, 0.9729303920657373, 0.9786578818939732, 0.6747308735678461, 0.32475971020517447, 0.64252818404136, 0.6482051398388842, 0.5968000302802388, 0.37769342404623263, 0.5753463755806807, 0.639693586831088, 0.6985132929559023, 0.1584435599757228, 0.22311568289781236, 0.14851926396531367, 0.20733256167729863, 0.19232422686586637, 0.18538971317962383, 0.12015163980121635, 0.10940089825024224, 0.16280852355715247, 0.19676696645330327, 0.21984974028477144, 0.11462812876222683, 0.1306036533467303, 0.08210277221499185, 0.1612926245779165, 0.11782637439160792, 0.1819830566545294, 0.16302767730529288, 0.16453481327885966, 0.09221208435643091, 0.22736462310402694, 0.20803318067475352, 0.14973970875226494, 0.1462942637679493, 0.1796056124570805, 0.0, 0.08859572111360525, 0.0, 0.0, 0.0, 0.017838321380540534, 0.009761969150087091, 0.00889249035389783, 0.0, 0.0, 0.087616454224836, 0.0482139486928469, 0.03388420605341702, 0.061753032258628604, 0.08091775618387587, 0.0, 0.0, 0.07440419950049293, 0.0462793592354559, 0.021825935604326885, 0.0456043312132548, 0.034173724958211804, 0.18069436862973076, 0.07466961075842371, 0.0, 0.0, 0.09421651466103087, 0.27560597429384026, 0.06445176376347794, 0.14069863815337724, 0.07956523759429657, 0.2242605069681014, 0.021588034228252395, 0.005778073856447574, 0.11190463891133218, 0.047676415260635485, 0.05120991596410818, 0.04276949793996687, 0.43651771346423607, 0.5495387671325019, 0.5214775216669844, 0.5738291275061802, 0.5451844785384661, 0.533402977453433, 0.5382502281834566, 0.12760373088232735, 0.5749477223600965, 0.1762337780679749, 0.06892066695581656, 0.07121781541412797, 0.05939341577079815, 0.04875743987006664, 0.07002157332105685, 0.06676045411758402, 0.08861616511951798, 0.08845929523540763, 0.2619200784763436, 0.20519542762921417, 0.2076995470169929, 0.2167275106505957, 0.544664148148892, 0.19374491616180334, 0.18799255519894598, 0.15562904180030435, 0.15894635199373552, 0.23236739524726602, 0.30726030232162216, 0.30072370816943506, 0.22882482858084952, 0.2004990090670079, 0.2955039349253926, 0.3893674411891256, 0.41242882242729373, 0.3356963298686605, 0.15829758804312877, 0.235335693398532, 0.27037014362743517, 0.2795961196829059, 0.2015879929364751, 0.22819851795392676, 0.19570695450113795, 0.17946826597302223, 0.29902410218933917, 0.21073660748099943, 0.1698994738842302, 0.198164370222087, 0.15585316541303362, 0.1439815661634819, 0.20374208772842362, 0.2610102080108647, 0.19404487698096595, 0.21584015389788647, 0.2067804727372009, 0.2014782968334463, 0.24554727103253182, 0.19616234105324293, 0.22512531642696154, 0.19077189124116845, 0.22877554263215993, 0.2405528835669013, 0.18035057761366335, 0.8542989482854764, 0.17704976572468967, 0.14644922123488413, 0.9117625555461001, 0.2007412855136388, 0.16950673051338927, 0.13096521901829017, 0.17005906284247507, 0.9148772951815853, 0.4757460368922827, 0.15662683719755255, 0.18940833481679542, 0.5129154372135099, 0.3385157678330928, 0.16452361075580924, 0.10524534346223213, 0.1664118114733366, 0.596207762210757, 0.17789807893552512, 0.19685555743714822, 0.17814429971946177, 0.1817017780282908, 0.184192543899796, 0.18539277017494682, 0.182065724909091, 0.18877732841475914, 0.18569280502972274, 0.09409761089226287, 0.08768929485062094, 0.08721379164273346, 0.07192098805119718, 0.09701677696919231, 0.09271128418728658, 0.11192950995701234, 0.07666699232191854, 0.07885631968484252]}, "mutation_prompt": null}
{"id": "5beb584c-3fb8-40b0-8001-9f1fdd357aa4", "solution": "import numpy as np\n\nclass Hybrid_DQPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # DQPSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.4  # Dynamic inertia weight for adaptive balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F = 0.7  # Adjusted scaling factor\n        self.CR = 0.9  # Increased crossover probability\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (DQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    \n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_DQPSO_ADE", "description": "Hybrid DQPSO-ADE: A hybrid of Dynamic Quantum Particle Swarm and Adaptive Differential Evolution with Lévy flights for rapid convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8684018429441183, 0.8616555624014703, 0.8871553260048956, 0.8775386149537622, 0.8527949425795994, 0.8772856393733616, 0.88391899300397, 0.8749664854393696, 0.8743286688626355, 0.7647400050577433, 0.6259180642761535, 0.7554311288137997, 0.6729733770183758, 0.49786907770012034, 0.7547066937430259, 0.7806866540887984, 0.7111997233972764, 0.7577781012617886, 0.11234317941548777, 0.13034505079925274, 0.14183325810226777, 0.12479510711411645, 0.1147532841947817, 0.14247137153155653, 0.09943578328259717, 0.09912782360058159, 0.12635999964191635, 0.10851148191169269, 0.10185741861935915, 0.11959826681126529, 0.12981231342566046, 0.10822708973957174, 0.1097573627189109, 0.09683448163455399, 0.11408725414018861, 0.08830726434717162, 0.9461735840155766, 0.9618970970175093, 0.9505448803381455, 0.963404112937843, 0.9421967558315836, 0.926562729859534, 0.9392267198401457, 0.9326232788049902, 0.9590818414524247, 0.6882714586454848, 0.7221297178606805, 0.2697667491407013, 0.7682583551648534, 0.74514795534809, 0.15239212305733085, 0.45647627216737285, 0.367087168005651, 0.6237312715553543, 0.3833960695903692, 0.22531268786803338, 0.22102199979063664, 0.3828188023718475, 0.8826937675468733, 0.21210720184883003, 0.23223205722940676, 0.22188464742678538, 0.36010208318888903, 0.1478514993958715, 0.15681854668730544, 0.16434012494630001, 0.18225096190265988, 0.4181929988708065, 0.15283928597785212, 0.16351521237507183, 0.18872222878738376, 0.1639889660782301, 0.12764701768680242, 0.18550842136478318, 0.1650954491446175, 0.16096047859327778, 0.18082329389638985, 0.1275552499783309, 0.14311660137803972, 0.3520316197126606, 0.16467124631445018, 9.999999999998899e-05, 0.01462487148637015, 9.999999999998899e-05, 0.002032718469894612, 9.999999999998899e-05, 0.008731682310085698, 0.025477312910376693, 9.999999999998899e-05, 0.0010752244818198475, 0.0938189203864036, 0.14948030612759378, 0.06884110719668846, 0.08312106305815103, 0.04226317921938094, 0.037172189903893926, 0.09472883376898622, 0.15603165656146378, 0.08247485803853438, 0.12861208203867014, 0.13084085465013418, 0.15626243481121416, 0.1053902838823737, 0.10810430576641816, 0.15527180777885552, 0.2035139985250256, 0.24050389138888928, 0.07333428609745007, 0.17584890341039228, 0.11913782637012604, 0.17631557135841924, 0.02654507377268689, 0.09215979311339084, 0.08964786030639948, 0.14450834620111142, 0.17263878432826663, 0.1085993605278952, 0.510954293312877, 0.5453258639071814, 0.5099324766476584, 0.587988169010351, 0.5128929996307758, 0.5401167988451663, 0.6763907952215489, 0.5419406630295125, 0.5638287047840174, 0.12285437452190506, 0.1281563082625049, 0.09749758498780736, 0.12636528770753153, 0.1058785117805141, 0.13021171590637337, 0.0906233776571973, 0.15218388267472238, 0.14403097452022406, 0.28933205678208596, 0.2625729667746455, 0.2095502786471849, 0.2652799410489207, 0.1591092308777381, 0.431354456523925, 0.18541174209266242, 0.15040892701413577, 0.20312570956862663, 0.2873207132219012, 0.5190737726893779, 0.39581732873572195, 0.4706081605002692, 0.4661233284814613, 0.3524346704899174, 0.6172114182705171, 0.5853590526137424, 0.5834105376830188, 0.27301964961666825, 0.2872961984053627, 0.44497707802781883, 0.25149497417745637, 0.3398618360973755, 0.3531817984021246, 0.24541141203883832, 0.4248644356984119, 0.28992285655184613, 0.21134218691275586, 0.30252588919592904, 0.20086825342050996, 0.2271934628302532, 0.21172048590361525, 0.22808004837468265, 0.22855767133446303, 0.21481683158672582, 0.21263555520104382, 0.22138531413339102, 0.18058918609499053, 0.191992464262547, 0.19047311541726908, 0.1852081479658254, 0.20721607290176425, 0.20243629685621456, 0.20165686530042326, 0.18249703406704243, 0.8345720735364273, 0.8971106378588505, 0.15216132846020414, 0.8819562256101345, 0.19990325255317232, 0.8573321491666108, 0.17218982065165367, 0.12341397255648878, 0.89341101821022, 0.8976906685587154, 0.211514411198665, 0.7408100179330832, 0.21029455777575923, 0.16785208792952977, 0.15464495102449838, 0.3731000458143572, 0.2601173705792943, 0.21049853329699886, 0.17802161904422753, 0.1874998039136354, 0.20241713215708823, 0.19022587240394884, 0.17779943340817206, 0.18114258318398935, 0.1784357204149426, 0.1759241962441036, 0.18551456744649908, 0.08228819918165609, 0.0738677000463227, 0.09318873912930936, 0.08482247454613479, 0.08632329875844558, 0.07362176847812729, 0.08047641002405292, 0.08870331324012115, 0.08902300519201967]}, "mutation_prompt": null}
{"id": "b56e4434-e7ba-49fc-ae46-b87079fd2b5a", "solution": "import numpy as np\n\nclass Quantum_Enhanced_Dual_Swarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Swarm parameters\n        self.num_particles = 50\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.8\n\n        # Dual-swarm setup\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / abs(v) ** (1 / beta)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            inertia_weight = self.inertia_weight_final + (self.inertia_weight_initial - self.inertia_weight_final) * ((self.budget - evals) / self.budget)\n            \n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n\n            self.positions += self.velocities\n            quantum_step = self.levy_flight((self.num_particles, self.dim))\n            self.positions += 0.001 * quantum_step * (self.global_best_position - self.positions)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Enhanced_Dual_Swarm", "description": "Quantum-Enhanced Dual-Swarm Optimization: Integrates quantum-inspired Levy flights with an enhanced dual-swarm update mechanism for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.1439540973735205, "feedback": "The algorithm Quantum_Enhanced_Dual_Swarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.20.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.30943338607546533, 0.14566367090241694, 0.3389299814926444, 0.15375233249442044, 0.18618701824423023, 0.18822644318154802, 0.14196099418977282, 0.14909656816321226, 0.1665313523801073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019917486689231878, 9.999999999998899e-05, 0.009914364185988567, 9.999999999998899e-05, 0.045612571048197936, 0.08354785974554346, 0.05701425367823687, 0.054598838473640665, 0.04190884180180965, 0.05613301601392995, 0.07311268526088954, 0.07518379884215176, 0.04176737697009869, 0.0591066631096252, 0.07156377198027841, 0.03775268533947396, 0.04130018273603797, 0.03627487923034789, 0.035573699991069185, 0.09807492125457606, 0.04924005377588714, 0.029468249067221897, 0.9885299370815243, 0.9861210183608321, 0.9900371631879313, 0.9597571315743071, 0.9853318735135657, 0.9810183248404019, 0.986349587535131, 0.9901890445340255, 0.9809172034413737, 0.16360422433193111, 0.10907142126412361, 0.02790909340058967, 0.062180388280730914, 0.043884015434557444, 0.12406012047393955, 0.08170290222359056, 0.049548533733139055, 0.08103465275328148, 0.13197557595248344, 0.1369681832848364, 0.13631726999978433, 0.190066467565559, 0.16883369659356906, 0.168286991591299, 0.06436666544017156, 0.11446081448203571, 0.12027413648184193, 0.10418394802251385, 0.07431711018562204, 0.09882529599864487, 0.04160602141934666, 0.028615668735214372, 9.999999999998899e-05, 9.999999999998899e-05, 0.0302465838048096, 0.12130039145956129, 0.07228669563250878, 0.07792096528708659, 0.07920987112659172, 0.0627674463413197, 0.10576731764233227, 0.09663314044035543, 0.08103843780872322, 9.999999999998899e-05, 0.06301022912430343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03975976074954646, 0.0002384579444340007, 0.03294553383696508, 0.05124424571959263, 9.999999999998899e-05, 9.999999999998899e-05, 0.05285832680762248, 0.012107861273188192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015831829486071314, 0.024807578395468544, 0.0411591653077501, 9.999999999998899e-05, 0.01625419507292214, 0.02082045872293692, 0.0030428640089718018, 0.047459534724987096, 9.999999999998899e-05, 9.999999999998899e-05, 0.06681334279457118, 0.020526564088496846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05639863389476918, 0.31441354238015706, 0.24754193214140907, 0.31619006147725515, 0.28549189044072953, 0.1982013926143409, 0.16666993206598946, 0.2583937115712204, 0.13796591286048754, 0.32507984263840306, 0.05197385657572995, 0.055492144232332286, 0.05785509568357594, 0.04922340106734158, 0.02998741630543955, 0.07400883630072708, 0.08656437576905807, 0.039740542022115966, 0.058059062691224295, 0.13803007495391262, 0.13210197969362747, 0.1526965772113108, 0.211003471726944, 0.1499639665692274, 0.1350177800810467, 0.17009858046596205, 0.14576967578399325, 0.11621411141509774, 0.1288623507083585, 0.16564178615455116, 0.18986969871934956, 0.19115194628574206, 0.22133297567185173, 0.19604763274162373, 0.15811922301978665, 0.26855726091482635, 0.15903701754156463, 0.13912339615428992, 0.1301096310727129, 0.11726190568978201, 0.13485312767040836, 0.15654470710291912, 0.15668868752552567, 0.10572292843350883, 0.17133729210294313, 0.11806859787480317, 0.15730923638415695, 0.18725291082747164, 0.188795300022514, 0.17467168037432024, 0.15489933262683864, 0.15694321549502543, 0.15613577945277535, 0.15475590833938646, 0.20197622624226874, 0.15699523278356264, 0.20250845308672316, 0.1885937691938202, 0.1863362430833191, 0.15754952782913645, 0.17105565968868863, 0.17365118473474828, 0.19257823184741252, 0.16524088570297513, 0.1097214656535469, 0.1521548190486257, 0.12087254154094629, 0.13801848087789081, 0.5068426478964951, 0.15778525273866018, 0.14592704141502055, 0.12126168928472658, 0.5934788456145104, 0.23160903551692813, 0.15614702658505297, 0.09863465416485329, 0.1868785886535348, 0.1947633735097294, 0.1207373138362755, 0.1791776892390473, 0.1770944043870848, 0.15439187099570006, 0.17770879224112468, 0.17958558419093096, 0.1843152605088061, 0.18156351528215586, 0.17194157024201218, 0.17930409580878237, 0.18287714178861225, 0.18534127620488838, 0.17507197449576073, 0.0470082224514321, 0.05555309070692438, 0.05051650261026386, 0.06884610416336168, 0.0816388098015568, 0.047034442545104915, 0.050382149532395504, 0.07779259656937287, 0.05013719320812471]}, "mutation_prompt": null}
{"id": "a27836e2-d1c4-451f-aaa2-dae9d103ea7c", "solution": "import numpy as np\n\nclass Enhanced_QPSO_ADE_SD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # QPSO parameters\n        self.num_particles = 50\n        self.inertia_weight = 0.9  # Dynamic inertia weight for better exploration\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted scaling factor for diversity\n        self.CR = 0.8  # Crossover probability for exploration-exploitation balance\n\n        # Initialize particles in quantum space\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def spiral_dynamics(self, position, best_position):\n        r = np.random.rand(self.dim)\n        return position + r * (best_position - position) * np.sin(r * np.pi)\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (QPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.7, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Spiral Dynamics\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                trial_vector = self.spiral_dynamics(trial_vector, self.global_best_position)\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_QPSO_ADE_SD", "description": "Enhancing convergence by incorporating a hybrid of Quantum Particle Swarm Optimization and Adaptive Differential Evolution with Spiral Dynamics and dynamic parameter tuning.", "configspace": "", "generation": 21, "fitness": 0.146773999387401, "feedback": "The algorithm Enhanced_QPSO_ADE_SD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.31132316671056015, 0.13974870072666468, 0.1781526164293753, 0.26445232686658793, 0.1884690048955301, 0.19758181661854934, 0.19101220934667873, 0.1815097221180073, 0.33213244180181123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008874660121441447, 9.999999999998899e-05, 9.999999999998899e-05, 0.055487862343438055, 0.0031971852897122455, 0.08319455503872764, 0.07804902318800633, 0.05682022429995881, 0.09051561439773681, 0.0464054826029322, 0.0669267189440057, 0.04275975401052878, 0.07303558053072445, 0.08120451017967045, 0.055579616433565904, 0.03795564973494292, 0.06507105110142497, 0.07162411842714467, 0.06351210658760498, 0.02161982614302671, 0.05682137161148493, 0.028383072869088255, 0.07266296435727104, 0.9688327421983093, 0.9610068385954325, 0.9539421000211713, 0.9155450560419884, 0.9586665496210132, 0.9591679672792448, 0.9554903700152317, 0.9353575835922948, 0.9512913524320569, 0.12684195052664293, 0.14231634821300487, 0.05366650151710983, 0.12720415313192024, 0.12558186735751875, 0.12906914722542695, 0.1444238056913002, 0.05775173152925328, 0.1143576101026943, 0.18009041068710252, 0.16967592381942087, 0.18509183488849879, 0.16448653537959013, 0.12826754436181598, 0.17615199944170035, 0.20485455722951096, 0.12334991533602602, 0.16157624302946683, 0.11445471493836756, 0.05251208328636037, 0.021279679894455117, 0.06806579771654941, 9.999999999998899e-05, 0.06873644224698072, 0.08206112485072536, 0.05752315083577486, 0.05396465762611313, 0.05922139928246184, 0.02792983953778072, 0.1000134312996035, 0.08097632523260223, 0.006901202682645269, 0.0663515682310497, 0.05404259853786786, 0.010375799025767574, 0.018155090808387286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11080514488493576, 0.02382723457596636, 0.05442925749043459, 0.05286401489603754, 9.999999999998899e-05, 0.028735725646441446, 0.05631014549031699, 0.03304269595346199, 0.03673007656290117, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03967793110636719, 0.016927999193673715, 0.0243049498025093, 0.023712502434333094, 9.999999999998899e-05, 0.005590684070263752, 0.0035215162533304145, 0.2424092538581798, 0.3335950773003117, 0.20493247074222232, 0.2077058383427285, 0.28649000712049355, 0.314826598978567, 0.365355231896084, 0.2550258511035002, 0.2521512046075304, 0.06738701526730162, 0.04255505587068564, 0.049479194581072417, 0.09134570716445922, 0.09688375674433447, 0.058871129707513736, 0.08928202871088142, 0.0652985442962356, 0.10069507307004166, 0.1299501818819786, 0.12113370627483167, 0.12459099729965895, 0.1583463801153524, 0.1522450639077777, 0.13299341585909719, 0.14716387664219888, 0.12048408631700203, 0.15903850276868703, 0.1975261637007515, 0.225206947208754, 0.19227586094722948, 0.19528613280148188, 0.21284779713200397, 0.20433208723013618, 0.23303657937963385, 0.22613953483316318, 0.18111750321069953, 0.17652857558003487, 0.12428520397960796, 0.17079703544226688, 0.10840698372663304, 0.14473325517065683, 0.12083419367414627, 0.1367467794955206, 0.1674939466283344, 0.15696374209572828, 0.17584872193194712, 0.13403972816034126, 0.19389531683675965, 0.177769241343103, 0.17852256513996267, 0.1828880865607051, 0.16801550747495586, 0.17057096288050888, 0.15609091733752334, 0.16478665607429954, 0.16404799579670692, 0.1735600958338993, 0.17503979377561496, 0.1360488586272266, 0.16826117055905943, 0.1736650503018291, 0.16973972454236086, 0.16688265754128206, 0.22443598773930695, 0.22049733111140735, 0.12367431744051771, 0.2953922660972049, 0.19202512749304457, 0.1952415297713187, 0.1158091575029988, 0.11750602596788617, 0.2528387721226725, 0.19454130988489926, 0.15877672371570983, 0.13201870069407873, 0.2061057877359075, 0.22109840357594301, 0.13085420111505952, 0.10324366001528562, 0.1838442366138585, 0.17287979722677116, 0.16072691836677766, 0.1975913947461596, 0.18270166185159764, 0.17499858931948187, 0.18264690712277765, 0.17164458011845396, 0.18502933864315096, 0.17788397339438966, 0.19967100876764354, 0.04625342347942529, 0.08197640720160615, 0.06499729247508224, 0.06613710394564165, 0.0684402656254175, 0.0428930634438488, 0.07033586328371566, 0.06505554025553506, 0.07486419904502362]}, "mutation_prompt": null}
{"id": "d75fec88-b300-45e9-9500-876be05e5f06", "solution": "import numpy as np\nimport random\n\nclass Enhanced_Hybrid_Adaptive_Algorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Parameters\n        self.num_particles = 50\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.8\n        self.learning_rate = 0.6\n        \n        # Chaotic Initialization\n        self.positions = self.chaotic_initialization(self.num_particles, self.dim)\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_initialization(self, num_particles, dim):\n        # Logistic map-based initialization for diversity\n        x0 = random.random()\n        positions = np.zeros((num_particles, dim))\n        for i in range(num_particles):\n            for j in range(dim):\n                x0 = 4.0 * x0 * (1.0 - x0)\n                positions[i][j] = self.lower_bound + (self.upper_bound - self.lower_bound) * x0\n        return positions\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.learning_rate * self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution\n            F = 0.5 + np.random.rand() * 0.5\n            CR = 0.8 + np.random.rand() * 0.2\n\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.positions[i])\n\n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_Adaptive_Algorithm", "description": "Enhanced Hybrid Adaptive Algorithm: Introduces adaptive learning rates and chaotic maps for improved diversity and convergence.", "configspace": "", "generation": 22, "fitness": 0.26297455057222874, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Algorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.8271125870009283, 0.8057044730823031, 0.8036912008848892, 0.2650143555244263, 0.8232429392032089, 0.7471098747693936, 0.8241033111017235, 0.8025407984735142, 0.7464125348956635, 0.051706332756917606, 0.5754076514759661, 0.581102754888638, 0.5172347604920452, 9.999999999998899e-05, 0.5338082413075419, 0.05742552984168925, 0.5145165422908164, 0.014197880555966602, 0.10079818116409078, 0.15229699071628633, 0.09262402285927163, 0.07480623953004784, 0.13637765752298914, 0.11506453110873227, 0.040653667180697295, 0.11076389899923944, 0.10622040650514064, 0.10628481286921376, 0.10079602771240226, 0.14599471288109778, 0.08345279560403163, 0.10308880652922758, 0.12595869469156773, 0.1222210695259609, 0.0919034237237133, 0.08937983238061575, 0.9693950563362693, 0.9684531538753707, 0.9682741847567989, 0.9919598106270525, 0.971075518118073, 0.9755831101575456, 0.9757045393465051, 0.9775567676827036, 0.9763889850736378, 0.37425011065500646, 0.6123644295197493, 0.34266192025266495, 0.14988870257436826, 0.5548862626820676, 0.4110405273606289, 0.44497043276110837, 0.5757673951202249, 0.08614976196082658, 0.22191270786777073, 0.8214315779493446, 0.3708461040176544, 0.18885958691005478, 0.20743082546975433, 0.19084530077557404, 0.14857062008722588, 0.7816085936062782, 0.162196059889672, 0.1833251051197552, 0.20980200041277763, 0.11460340826184578, 0.09435116996426007, 0.12337758431371126, 0.12354933322566808, 0.10849500437246151, 0.11961146222610919, 0.20114031530089493, 0.12578503576099243, 0.018110332208501667, 0.20908023882156712, 0.1776143201958934, 0.21562288573558808, 0.19075193061614504, 0.21654802604091594, 0.20050475101985743, 0.12384246106394725, 0.004696514050212874, 9.999999999998899e-05, 0.039196831543940824, 0.05209241837933676, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007405204186853198, 0.00010475987486002758, 0.1079845388975973, 0.01804426188006658, 0.0007031294837217539, 0.07626502076478081, 0.07312943526963644, 0.005029907601584838, 0.05722280826946413, 0.07532185642116562, 0.050695203748365336, 0.15815986906515667, 0.00941792428907573, 9.999999999998899e-05, 0.06845509007702189, 0.07000664067402318, 0.07214157395866316, 9.999999999998899e-05, 0.2305820083495017, 0.06574217723870046, 0.05554641450421405, 0.03807498842766288, 0.30120307563332116, 0.06004059970114539, 0.19954712851491097, 0.036728100456235535, 0.05392679527826727, 0.04438487800411617, 0.07575423341228815, 0.5498890616227226, 0.5138611963912866, 0.5606751786733313, 0.5238624831534047, 0.4588426119531194, 0.5359022397937236, 0.5475056126493686, 0.5351158659011903, 0.5675884130451029, 0.10409343754728029, 0.10889705310512177, 0.10810960684500026, 0.10682611670789555, 0.1119965504110938, 0.13955652276094022, 0.05563922395692755, 0.08659026454155827, 0.08623372547860053, 0.15172208039444413, 0.40430672028132175, 0.13085438530279936, 0.15062469166883952, 0.1320650243323418, 0.2870781927993863, 0.1442098860277552, 0.16282461572907836, 0.14062014528992828, 0.45081160569548573, 0.5076942836298595, 0.18697252757896343, 0.21767908663186364, 0.19343117585359892, 0.21429516231957468, 0.5685742205974589, 0.21148180431115282, 0.4502802784793274, 0.2288196026497823, 0.15847802950348922, 0.2645668467843524, 0.16148355098879508, 0.1648417579425273, 0.26718065644994393, 0.31652795153056457, 0.26295602075909896, 0.27153023903933204, 0.21012965057764288, 0.17463841322816787, 0.17647886602263063, 0.20510411280459762, 0.17403971923121975, 0.21011882689070294, 0.19127467286403022, 0.18186838490222967, 0.1933021080111238, 0.19882938523494553, 0.2032956127040575, 0.2002528991580319, 0.19098550870493514, 0.5544909947435299, 0.19321605380569207, 0.23960886662637115, 0.19477331337870762, 0.4641412790203494, 0.1570900683920432, 0.15767586963415348, 0.8778874123991177, 0.8825699060353982, 0.12173805205277755, 0.1041424802578147, 0.8652111579271482, 0.748182569179651, 0.1683941336634085, 0.1676148403950385, 0.1530938975256113, 0.16572009049656922, 0.1670916150174293, 0.8018601656278607, 0.12655824870551224, 0.15572618474514033, 0.11056555845963756, 0.15479919984597146, 0.17704692690935353, 0.18856780885150115, 0.17484820569342652, 0.16934613871806037, 0.200345276831574, 0.19484730274072593, 0.18038761434329176, 0.17668649697233818, 0.1900024338063775, 0.06777668028521677, 0.06965434300143947, 0.08079192569903915, 0.08236874562354679, 0.08106233596322143, 0.08981155350108205, 0.08429947246452307, 0.10350455381974277, 0.07208094489829031]}, "mutation_prompt": null}
{"id": "324f7a5d-b9af-45bc-b668-736509540733", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 23, "fitness": 0.32284694549347853, "feedback": "The algorithm Enhanced_AQPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "141ab289-63d6-4afc-a0d3-a1b76a1d5248", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "d2e56eb4-ae9f-45e6-98cd-257a1ad9b8d8", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "3ef4bd08-567f-4117-8d7f-b87e583c7623", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 60  # Increased particle count for enhanced diversity\n        self.inertia_weight = 0.4  # Adjusted inertia weight for varying exploration\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for more robust search\n        self.CR = 0.7  # Adjusted crossover probability for better diversity\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_levy_flight(self, L):\n        alpha = np.random.uniform(0.5, 1.5)\n        return np.random.standard_cauchy(size=L) * alpha\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Adaptive Levy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Adaptive Levy flights for better exploration\n                levy_steps = self.adaptive_levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE_Adaptive", "description": "Hybrid Quantum PSO and Differential Evolution with Adaptive Levy and Chaotic Dynamics for faster convergence.", "configspace": "", "generation": 25, "fitness": 0.30600964441962675, "feedback": "The algorithm Enhanced_AQPSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7782765590010036, 0.7712098117773939, 0.7738106468410025, 0.7707121736379317, 0.7558901719087008, 0.7731842726585918, 0.783450792966297, 0.7656148829446839, 0.7628544014175499, 0.550186914071007, 0.5570360979514188, 0.5686486924416361, 0.5024522823529016, 0.5290598504757873, 0.5957616894130626, 0.5589825067381659, 0.5467422021381808, 0.564646732292063, 0.15079294487998762, 0.13797694660040338, 0.13685296487717935, 0.10816744791915789, 0.14248404436786477, 0.10360737625218486, 0.14753273283136004, 0.1461594648783363, 0.15978785616249502, 0.09831265406444922, 0.12324009457072604, 0.10080869137990545, 0.10454949262516078, 0.11952261413048859, 0.3122525053178986, 0.12154878263618174, 0.11619432988651623, 0.12975289605781903, 0.9154069866408437, 0.9120050424182613, 0.8598241727663729, 0.8876439352753108, 0.807485730473412, 0.918594584795525, 0.8927085958519049, 0.8469448142554715, 0.8804966169029333, 0.4543894457354243, 0.4711884405523873, 0.38679001152381876, 0.39591934590185485, 0.44016017796783957, 0.37817988068332264, 0.36595910761557193, 0.33213462784711933, 0.3758138179509348, 0.35005160428762916, 0.7916402815033726, 0.23111279707308208, 0.35508618519882984, 0.2557845151937228, 0.3474368530135523, 0.769005556726682, 0.6931050000500669, 0.7949313466103026, 0.11982622941515242, 0.16470513137239484, 0.14482787012377607, 0.15703272210699382, 0.15259029408488511, 0.14533750438464743, 0.16755562048091666, 0.2561938065858136, 0.14703692549715452, 0.3264243229006175, 0.2018635534122034, 0.20882711392468178, 0.1369521141724217, 0.12935786925444737, 0.14602872939434386, 0.29025037856164815, 0.12210971805752435, 0.1424653294552769, 9.999999999998899e-05, 0.01052649501136349, 0.0875667717351456, 0.038599850788460066, 0.044837228370528615, 0.029314858650968723, 0.08747870118099144, 9.999999999998899e-05, 0.06653728600574649, 0.2333160202220279, 0.11059145028611328, 0.13924950582212514, 0.19181645190173335, 0.14958144422717645, 0.17436867958379754, 0.16807894514812083, 0.12457235777594555, 0.08616273399301078, 0.11977402900340661, 0.071472503131777, 0.03521249813636784, 0.09999203367716436, 0.12746845050497546, 0.31233694738613127, 0.17303505109277006, 0.18057894907352434, 0.06857596104421904, 0.09943739200976853, 0.19115924268903317, 0.15808658259966946, 0.22220337863051842, 0.15432322473456772, 0.13821254827381435, 0.2435474209789521, 0.18795485799429867, 0.10423940214420946, 0.5210171452292331, 0.5119134983350311, 0.4710845658070745, 0.5216206704791495, 0.4985357327003547, 0.44968796180953496, 0.49271261537607347, 0.5668034428503429, 0.5373026557923236, 0.12582811233219438, 0.11642467736592732, 0.1390808177732844, 0.10107348438458308, 0.11192892847498459, 0.14690191289743848, 0.15886239202415564, 0.12623297833414815, 0.12656500829095418, 0.184220508760222, 0.27109837928012415, 0.2233629900888504, 0.17727887231771888, 0.20684091186778863, 0.17684886539913036, 0.2821957959672795, 0.22144069526656696, 0.29914822729599133, 0.3348797941653834, 0.31069681283683426, 0.36905811113707687, 0.44578562848659553, 0.43618425425136287, 0.3184632108232075, 0.4553872367044164, 0.4749037723101551, 0.4291284129628091, 0.2915339575786179, 0.32565193101875944, 0.31228824040793923, 0.3013095706516169, 0.23094009961981055, 0.2412624772222054, 0.2111026077312378, 0.24924452466120572, 0.21719087815728222, 0.21607210373828745, 0.20902171661069224, 0.2029352935804708, 0.21625274352944956, 0.210359167203095, 0.2269676650917133, 0.21125082632739878, 0.2024932713481341, 0.22424877341495975, 0.19060759070194733, 0.19024931482868224, 0.19225568604378385, 0.18730546253382996, 0.2146146386472224, 0.18064791815365056, 0.21663652479431217, 0.18701117286974345, 0.18451133200661274, 0.8440746346205183, 0.1867289659717113, 0.18285486127795503, 0.8090254981090971, 0.19847698970272099, 0.837770510009479, 0.1700284141260483, 0.7222799318950025, 0.8353623660399694, 0.5929845907785892, 0.20910811291011322, 0.4179613536689545, 0.1268641309860612, 0.15216890437271235, 0.4867865272780575, 0.14949239454989005, 0.6531696683302856, 0.6234202745966986, 0.1808757389184159, 0.1907917724777226, 0.1849129514864979, 0.181914115505314, 0.1735119133517108, 0.18062084978520743, 0.19455857244586894, 0.18958603010690178, 0.18892474050205454, 0.08006671242570085, 0.08458855340204596, 0.09569767162083731, 0.08411750705162535, 0.0915202665162902, 0.07958481936557471, 0.0842327354567124, 0.0873093020599246, 0.09458776201176866]}, "mutation_prompt": null}
{"id": "0a95de8c-b187-4d7f-8081-00e96045ec6e", "solution": "import numpy as np\n\nclass Hybrid_QS_ADE_CP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid Quantum Swarm parameters\n        self.num_particles = 60  # Increased particle count for better convergence\n        self.inertia_weight = 0.4  # Adjusted for balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_min, self.F_max = 0.5, 0.9  # Adaptive scaling factor range\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def adaptive_scaling_factor(self, evals):\n        return self.F_min + (self.F_max - self.F_min) * (1 - evals / self.budget)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid QS)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Adaptive Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                F = self.adaptive_scaling_factor(evals)\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_QS_ADE_CP", "description": "Hybrid Quantum Swarm with Adaptive Differential Evolution and Chaotic Perturbations for Enhanced Convergence.", "configspace": "", "generation": 26, "fitness": 0.29743618111639875, "feedback": "The algorithm Hybrid_QS_ADE_CP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.8299193525671882, 0.8086100856223031, 0.8310986997466343, 0.8097808894801491, 0.813770547402627, 0.7852769229133943, 0.803763923365719, 0.8006747908830669, 0.7880643884726029, 0.6099675934351065, 0.137029789394438, 0.6480393634573198, 0.671165946133976, 0.6052915109401913, 0.694317279804337, 0.42634184569176226, 0.616624522918948, 0.6895512629720375, 0.14620726183079402, 0.14903007540762336, 0.11812213825287543, 0.1308301222343049, 0.12981879814870045, 0.15057824689262655, 0.14451647431778236, 0.12256287931287224, 0.10856762478743531, 0.11806984159690859, 0.11279125109927812, 0.10578475655950148, 0.11346325205170593, 0.10460276833325222, 0.13340402802402018, 0.1051892647669238, 0.12666091223730525, 0.09639254852125179, 0.9289159188303021, 0.9739634756550088, 0.9207373915460672, 0.9347601515609902, 0.9168336608967793, 0.9216904521510464, 0.9242690135173397, 0.9623640053426602, 0.9603629759086615, 0.6298953137987896, 0.3993656653157318, 0.25224116270724783, 0.5914412151728365, 0.5838996665479397, 0.634536338127434, 0.5226886911918359, 0.5519327742882506, 0.4056912710543096, 0.8079812041473988, 0.8279525515453122, 0.3676825580562295, 0.21125652057709765, 0.20941344907514148, 0.2696637265809513, 0.18911465794527071, 0.22221539874499852, 0.23334091239440113, 0.1713094190702774, 0.13412454179407685, 0.10334575291093206, 0.10176372720279747, 0.1254912363037296, 0.1416743530834903, 0.2974342152600702, 0.2176307508944031, 0.12838399583477567, 0.16022112603734218, 0.12176560196793185, 0.12708154034181318, 0.12966557581702742, 0.18568719872207917, 0.1757541134802859, 0.18573097210567047, 0.18429256288425322, 0.20062393888809216, 9.999999999998899e-05, 0.006515615988169299, 9.999999999998899e-05, 0.0401005227636837, 9.999999999998899e-05, 0.010678697484383326, 0.010897698414747525, 0.009018059487401309, 0.03269633571412811, 0.1060610720970826, 0.10552392313920222, 0.18286161286874214, 0.06616691867288316, 0.1320469500111765, 0.14042167832102037, 0.12086286339158536, 0.13352631737554188, 0.11930725152485333, 0.04568290163482602, 0.06523465847105292, 0.18853294912376395, 0.07896558516572838, 0.21686685319359877, 0.16844877146751347, 0.10580395861986014, 0.21595021564803685, 0.13230549392974533, 0.0471516063297539, 0.1639577511069057, 0.1806055422075491, 0.23236743554342498, 0.12822161022077272, 0.08812854801901282, 0.19732696757051937, 0.29887145273412274, 0.08714780541255207, 0.5310731490190607, 0.5639529499154592, 0.6015123330429606, 0.5669329098219738, 0.5559137419739337, 0.558552720137528, 0.5716078437706839, 0.5800071757187676, 0.5445633799526117, 0.09089449918895498, 0.10505635800983015, 0.11133994256077973, 0.13684960469053187, 0.09748335877683967, 0.13798513679115476, 0.09352429431244347, 0.13950368712763028, 0.11851830841753341, 0.1525835215613326, 0.13222114113090178, 0.18520149681891618, 0.18871700287186022, 0.14679207433449049, 0.2290252664987653, 0.16802752529155063, 0.2188826837417035, 0.21235481208341445, 0.3422210603947483, 0.23829782357217477, 0.4238401137913934, 0.48785002662677057, 0.42426750943939573, 0.3696015530203338, 0.5314877152491578, 0.39189003345447093, 0.3734364841932647, 0.21949373133303285, 0.2564983368053313, 0.28320619727478646, 0.20813709026285254, 0.19181032485989558, 0.20481158837715574, 0.34376552698506524, 0.339135634034351, 0.24154947710576535, 0.22160618392091302, 0.2024105376500931, 0.2237518103715498, 0.1985748758984841, 0.19414196708777876, 0.1980625157630741, 0.20228325207774067, 0.22590882083287245, 0.2053260446979006, 0.20748926778185994, 0.21704296677664503, 0.23891110994695797, 0.17907742942367333, 0.19608021184947821, 0.19670600681330586, 0.2346430173701769, 0.6689304486171891, 0.19540660810842214, 0.8935111656543095, 0.18687231064572307, 0.1670736906450676, 0.16274820966236003, 0.19915968202828704, 0.14675854331730243, 0.7624170172737466, 0.1710198220039938, 0.8697966567629195, 0.5374778950195204, 0.20836199003074696, 0.19791909060285884, 0.3578554462298066, 0.34815352068594396, 0.15221446894642032, 0.09410003732272176, 0.21031061984132637, 0.7083126910436116, 0.17752394303980745, 0.19604338959149958, 0.17558407373947116, 0.17967704900168668, 0.184354328799622, 0.18565186613454576, 0.17490567370859877, 0.1753916869287261, 0.19106185877618487, 0.0825848619725511, 0.0837822240509184, 0.0863939516502471, 0.07397966007675805, 0.07691274975361251, 0.0874143369426571, 0.07497210966921775, 0.08355763289900875, 0.07500331885128741]}, "mutation_prompt": null}
{"id": "0d440106-c4ab-414f-90e3-6171e8fb083c", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "de2b1654-e2e7-40d7-9fd2-4057973196b8", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "a3e6b8dc-233a-41d2-8d46-1ac0e89a66ca", "solution": "import numpy as np\n\nclass Hybrid_QPSO_GA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        # Parameters\n        self.num_particles = 50\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.8\n        \n        # Genetic Algorithm parameters\n        self.mutation_rate = 0.02  # Adaptive mutation rate\n        self.crossover_rate = 0.9\n        \n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        \n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def adaptive_mutation(self, particle, global_best):\n        if np.random.rand() < self.mutation_rate:\n            mutation_vector = np.random.standard_normal(size=self.dim)\n            return np.clip(particle + mutation_vector * (global_best - particle), self.lower_bound, self.upper_bound)\n        return particle\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n            \n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced QPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            \n            # Genetic Algorithm crossover and mutation\n            for i in range(0, self.num_particles, 2):\n                if i + 1 < self.num_particles and np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    self.positions[i, crossover_point:], self.positions[i + 1, crossover_point:] = (\n                        self.positions[i + 1, crossover_point:], self.positions[i, crossover_point:]\n                    )\n\n            for i in range(self.num_particles):\n                mutated_particle = self.adaptive_mutation(self.positions[i], self.global_best_position)\n                mutated_score = func(mutated_particle)\n                if mutated_score < scores[i]:\n                    self.positions[i] = mutated_particle\n                    scores[i] = mutated_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_QPSO_GA", "description": "Hybridized Quantum Swarm and Genetic Algorithm with adaptive mutation for enhanced convergence and exploration.", "configspace": "", "generation": 29, "fitness": 0.20399008791209797, "feedback": "The algorithm Hybrid_QPSO_GA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.510488002445328, 0.7796736200919668, 0.4978501851963756, 0.7705811974805856, 0.7871166543026102, 0.5028116080563373, 0.7185785054104263, 0.3514180517352905, 0.785314935763134, 0.04562271040767851, 0.31156075744863776, 0.10710854425271121, 0.02117076480483282, 0.09821814979490695, 9.999999999998899e-05, 0.04000416872733148, 9.999999999998899e-05, 0.05219151054102167, 0.07818566311463693, 0.12880499142161828, 0.12643091462468126, 0.09977683335110799, 0.07311285312765681, 0.0607752942924803, 0.08514947321080857, 0.07950233595878475, 0.10499136787900065, 0.07080725910448471, 0.10890806344047887, 0.0896648706870985, 0.07604222879136213, 0.050680178543287324, 0.06601245376526799, 0.11000132392992257, 0.0929365206752143, 0.11072613898743078, 0.9087966403953359, 0.8917705289997386, 0.9494496664401512, 0.861524879092592, 0.8477125032581707, 0.9419164588339822, 0.8766625693791421, 0.8429652526414286, 0.9096034121808287, 0.1678092732303721, 0.07428245632129726, 0.05442376848341479, 0.3461877570499253, 0.44396949903391303, 0.14904003013412292, 0.20971778392455964, 0.08319399355031598, 0.23010010722509755, 0.20755656185213311, 0.20972145036130085, 0.22553188570400318, 0.22006058200140322, 0.27095885442314316, 0.20446028603850297, 0.21730445965948642, 0.1480371663777389, 0.18962840262228464, 0.143398681239428, 0.10167501042436033, 0.14263612577524032, 9.999999999998899e-05, 0.14534536994612113, 0.12570130180334615, 0.13311456958943924, 0.09451784048735878, 0.13879361943480706, 0.19477687849444192, 0.12300116845366083, 9.999999999998899e-05, 0.15562764381648253, 0.1545512142643407, 9.999999999998899e-05, 0.18706253181614674, 0.12606776222606464, 0.10520282368478417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03721346965754202, 0.07899336341158492, 0.028793494349775184, 0.05760135512388298, 0.07933602434015974, 0.0641423912606629, 0.001268598277009203, 0.07054540428376754, 0.11161393993221569, 0.027489928893414062, 0.07103746842724434, 0.043002531269298205, 9.999999999998899e-05, 0.06768862795756703, 9.999999999998899e-05, 0.027372434029611203, 0.08669825338274417, 0.17499787300324554, 0.0340823359159842, 0.045477448950779986, 9.999999999998899e-05, 0.06814788863097232, 0.032358549661269165, 0.11833320860672014, 0.06510712887624925, 0.1435889743075508, 0.15778409260801396, 0.07844493158909771, 0.5221293140186242, 0.40752629551490505, 0.5409550475661267, 0.4322406753904011, 0.3989678614522916, 0.5002489570538409, 0.3951519854922926, 0.49112074705900444, 0.312873265862338, 0.07912399574850337, 0.04839793268240267, 0.06377156479553592, 0.09255074344523329, 0.08945056307689903, 0.08364974848399853, 0.08928731362337516, 0.1043350404282335, 0.06554728923379083, 0.1681291737629348, 0.18008106105567934, 0.18690581227142888, 0.23541428900881634, 0.22795095902114937, 0.17935199411671032, 0.22336124489437925, 0.1360607032929978, 0.14498299833178896, 0.2599034380399682, 0.31251677797935673, 0.23432628800694866, 0.20649888254762816, 0.34657001497118967, 0.2848421477288555, 0.2736486220072022, 0.31819736121363307, 0.15820101878221882, 0.20495385763573115, 0.17938520438144168, 0.17555164406625445, 0.18067458163388495, 0.20010055638013424, 0.26979992407778774, 0.17514213092134145, 0.26300859826714973, 0.2633517171685976, 0.19030165037926372, 0.22076880211532257, 0.17030439683766818, 0.2050789717113628, 0.1853663310139284, 0.15803095060574046, 0.2007057831277994, 0.19293587998330264, 0.19994464395416411, 0.1813599060191614, 0.183722977952807, 0.1847556639693394, 0.19237176098892894, 0.19288131179540846, 0.18905446726898478, 0.186334829535588, 0.1751788277303935, 0.17740449915953027, 0.6189696775923831, 0.23818613557959, 0.152913289984569, 0.1721364719106292, 0.1976606333336296, 0.17069501410234567, 0.13879166436116952, 0.1383957412794492, 0.7522245058162673, 0.4883499261581924, 0.1487268222807384, 0.07303746518724907, 0.20547589733870586, 0.10745696378913394, 0.14891682610378154, 0.10343584905667325, 0.10278932095769056, 0.1390866210080277, 0.17590379608494822, 0.17331437623160195, 0.17965405370254084, 0.16961708190556635, 0.2121525016032182, 0.18776565283805768, 0.19434823864372452, 0.18845888063988347, 0.18508235545324536, 0.06346036954393164, 0.08209474071222289, 0.08437983621471534, 0.0778303913896754, 0.07071463925875798, 0.0650935294770747, 0.09846998217790592, 0.07319751350353532, 0.07153460836936665]}, "mutation_prompt": null}
{"id": "213c8424-3820-4acf-a91d-edd04a6a7a53", "solution": "import numpy as np\n\nclass Hybrid_GIQS_ES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced parameters\n        self.num_particles = 60  # Adjusted particle count\n        self.inertia_weight = 0.6  # Tuned inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Evolution Strategy parameters\n        self.step_size = 0.5  # Adaptive step size\n        self.decay_rate = 0.99  # Decay for adaptive step size\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid GIQS)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * self.step_size\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Evolutionary Strategy with adaptive step size\n            for i in range(self.num_particles):\n                candidate_position = self.positions[i] + self.step_size * np.random.normal(0, 1, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n\n                # Acceptance criterion\n                if candidate_score < scores[i]:\n                    self.positions[i] = candidate_position\n                    scores[i] = candidate_score\n\n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            self.step_size *= self.decay_rate  # Decay step size\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_GIQS_ES", "description": "Hybrid Gradient-Informed Quantum Swarm and Evolutionary Strategy with adaptive step scaling for enhanced convergence.", "configspace": "", "generation": 30, "fitness": 0.21869382851483868, "feedback": "The algorithm Hybrid_GIQS_ES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.4447804608595398, 0.3882477126991174, 0.5741615449711059, 0.5335916133418881, 0.5360881254923424, 0.449543696901067, 0.548973033803867, 0.6104393149642788, 0.7870481773657527, 0.06688888237138979, 0.06098867754211457, 0.04335200515694704, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12736734335736655, 0.11738916089760243, 0.12989471984051637, 0.12070345207653776, 0.11891264178486749, 0.09621830034844026, 0.13410415838263, 0.1288655867071744, 0.1162744695888398, 0.0938696989415081, 0.07578394485182816, 0.11522587197066136, 0.10855365899792546, 0.09816342764800523, 0.08577326170586697, 0.1092359164352702, 0.10280586256065904, 0.07686737452168813, 0.6937206114676455, 0.760163994978743, 0.729751379517324, 0.5492888156430734, 0.6323393869558248, 0.6340017232403039, 0.7465954499330222, 0.8187268436789266, 0.739165403073131, 0.23269556492320975, 0.21669615943586484, 0.19704910254228236, 0.23557547269294554, 0.2479016017803487, 0.2424293009555284, 0.21466490003738004, 0.2113412489597375, 0.23272096320337576, 0.22448729457612038, 0.3235698882135035, 0.22375761285337714, 0.2706754943947196, 0.2644622856711606, 0.31425602757627413, 0.17034187714214222, 0.2226600318258365, 0.3163778876922735, 0.11530367245430384, 0.09792435753354367, 0.14015485057980182, 0.14623861680080552, 0.14935758365786644, 0.12388514222744473, 0.14235354448836957, 0.10976805361766728, 0.16940263542403788, 0.09865121237781149, 0.3296873068034871, 0.12242464131145481, 0.13078752766955493, 0.14296492930393578, 0.15443414633558916, 0.1456257650412759, 0.12960682828131687, 0.1813585244234439, 0.013922336068156405, 0.006536714893856099, 0.00013112839899043216, 0.01989071545537935, 9.999999999998899e-05, 0.011602602045753696, 9.999999999998899e-05, 9.999999999998899e-05, 0.029403332468748156, 0.11954072080094014, 0.04125767064733521, 0.09498841784320133, 0.09159841680582448, 0.04812007450975053, 0.045287808492620374, 0.1616418884173325, 0.10196255404431598, 0.09617999804554767, 0.21905888064268475, 0.09702886403171929, 0.1826484157936391, 0.017703233758277426, 0.11630796068057703, 0.02356056811010354, 0.09013342273106939, 0.0767877591104229, 0.11236147146258446, 0.13230901432902553, 0.2267356767616059, 0.14218551470661023, 0.06854889352733118, 0.10668565229840588, 0.08701494327724013, 0.07658392289906191, 0.173172927868125, 0.11516657844372624, 0.43041541002049244, 0.5314863160779095, 0.40925279849251506, 0.4929849143996854, 0.45932296639324666, 0.4226158784240155, 0.4628799627916005, 0.4290973102975367, 0.35449996716818655, 0.12323994411158423, 0.1177991298641049, 0.10316417374738962, 0.11166173481334829, 0.07322690352451833, 0.12824380355536946, 0.1361423134250659, 0.13883406609071958, 0.08725309553627902, 0.21144987005674232, 0.2755426417049486, 0.38800647930305443, 0.23017315565578944, 0.19963388072539567, 0.26392640177377047, 0.2271595218064707, 0.19809481246930494, 0.23737425252794597, 0.35643908776327726, 0.2005800314572237, 0.284964863442416, 0.3338336732380407, 0.28961292361172286, 0.2765717841897335, 0.24519900515396642, 0.32826923052744383, 0.2386795735639965, 0.19956323232029394, 0.2088090723388465, 0.24071719787260704, 0.27041147301025326, 0.18919043733048768, 0.22598222305399374, 0.24693218568078157, 0.22442482633506866, 0.2151045170582181, 0.22107980050801612, 0.20860524797065239, 0.19565286114011626, 0.2157611181548501, 0.21746630204591222, 0.21242874523089117, 0.20148646302610296, 0.20673121916223813, 0.21533355725782088, 0.1793370354382834, 0.1898793043484317, 0.18032125085620787, 0.18605614492701217, 0.2008702995931141, 0.22909873874892417, 0.25838419519000266, 0.24785644113729377, 0.18919279728296812, 0.18501431225119624, 0.18770760019720423, 0.8149815050204648, 0.5029877998757821, 0.19964950339845178, 0.7731067049714804, 0.142008881401414, 0.1529470634736061, 0.17081139852672445, 0.4158224406027766, 0.2076350299791513, 0.46388771414557095, 0.46448821127260675, 0.16528402479367088, 0.14392891806553876, 0.2877823043556461, 0.31153661812673394, 0.34961694770913043, 0.19198627666782464, 0.18489830485332026, 0.18284758325100836, 0.19972461945541808, 0.17118318320059167, 0.17476679064409129, 0.19016327684726675, 0.17895368322048866, 0.18196700863756987, 0.09807872171923682, 0.0916269382012781, 0.0903890021408712, 0.09353706520855631, 0.08525918455756132, 0.09720661298181821, 0.09906254169181083, 0.08965387842941541, 0.08064090785313327]}, "mutation_prompt": null}
{"id": "203dca33-505a-41b7-8091-c009d429b49c", "solution": "import numpy as np\n\nclass Hybrid_QSAE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid parameters\n        self.num_agents = 60  # Increased agent count for diversity\n        self.inertia_weight = 0.6  # More dynamic inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.9  # Enhanced learning from best\n        self.memory_coeff = 0.5  # New memory component for adaptive learning\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Higher scaling factor for diversity\n        self.CR = 0.8  # More balanced crossover\n\n        # Initialize positions and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_agents, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_agents, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_agents, np.inf)\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_agents, self.dim))\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic exploration\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate agents\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_agents\n\n            # Update personal and global bests\n            for i in range(self.num_agents):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_agents, self.dim), np.random.rand(self.num_agents, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            memory_component = self.memory_coeff * (self.memory - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component + memory_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Adaptive Evolution with Lévy flights\n            for i in range(self.num_agents):\n                indices = [idx for idx in range(self.num_agents) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for diverse exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # Evolution acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    self.memory[i] = trial_vector  # Update memory with successful vectors\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor\n            evals += self.num_agents\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_QSAE", "description": "Hybrid Quantum Swarm and Adaptive Evolution with Dynamic Memory for accelerated convergence.", "configspace": "", "generation": 31, "fitness": 0.30843145090588286, "feedback": "The algorithm Hybrid_QSAE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7269148810847279, 0.7083025738757308, 0.6789514837549944, 0.7378827133723165, 0.7127295622486638, 0.701574872392114, 0.7388580999763286, 0.7190818287580127, 0.6811383589546005, 0.4993186021638012, 0.44378134710250605, 0.4137302254553169, 0.5056108748501169, 0.4660021908725642, 0.42953664312913264, 0.4727257354529619, 0.45744482970917366, 0.41249760521961953, 0.15537743010142202, 0.1449010319699544, 0.1398457195262841, 0.13399989783331945, 0.1827983296180813, 0.13920985293441868, 0.12820727228915096, 0.15471664590227696, 0.17213407418025184, 0.08890675154380223, 0.10098719133193568, 0.08456637988268123, 0.12570958514038444, 0.10664698846181486, 0.09875476559874241, 0.10563596455039403, 0.11810818012119673, 0.097577859862359, 0.9094542864057762, 0.9279129235517541, 0.7825249725576088, 0.90461122109875, 0.850097420135559, 0.8179365995094232, 0.9610741422153607, 0.9257873277402561, 0.8570665418412581, 0.40097546836916254, 0.39587695163661607, 0.3268143065367237, 0.37045176709418093, 0.3605114816503263, 0.36721414013577036, 0.40584308403991287, 0.39869627343183356, 0.3508107506883219, 0.7670677701599853, 0.7185210328243008, 0.6884468803436977, 0.670542966894875, 0.7141332516262398, 0.6508812564570319, 0.6689934707755467, 0.7224827249572995, 0.6069868812514392, 0.15674519617909466, 0.12642669478395852, 0.15213035000560649, 0.18261560182862768, 0.15260825164374126, 0.14767365138707678, 0.15113047137094038, 0.15446854468870974, 0.1608708333565977, 0.16645708527411496, 0.11969601250461381, 0.18420403369246452, 0.2042553617268451, 0.18839524713116385, 0.1767479538627985, 0.18660120874799502, 0.16856171910027862, 0.09836741133861937, 0.02255538128898371, 0.1009968625842419, 0.02235831279455358, 0.0001496428291888341, 9.999999999998899e-05, 0.02216944045771907, 0.11108738279437114, 0.01695180718390854, 0.06600238257164215, 0.2026093373115263, 0.21700072702200945, 0.12025324446261898, 0.10831715644849305, 0.07321100316075568, 0.15085861905524867, 0.15939702204271666, 0.09937601286975772, 0.1760157649628371, 0.10346652463274053, 0.0958837649994212, 0.15019270791404038, 0.16889234309994283, 0.072961260626908, 0.06697243840839706, 0.11057773508802404, 0.07938812498390502, 0.1007719557380733, 0.1279399004211751, 0.16927204023780595, 0.12794931137078147, 0.15901256451414525, 0.11765731537545343, 0.15647487159870066, 0.19654091979637978, 0.13978798610256926, 0.20923045669521412, 0.4878561463385679, 0.4839098717333201, 0.5083159277133501, 0.5440956641064487, 0.5134869414678422, 0.5104206591465825, 0.5311497069295466, 0.5375996124207862, 0.5220366785711286, 0.10663360686873513, 0.1814302217633913, 0.15716174834004193, 0.14179316001743258, 0.12053763109646276, 0.10380095297736847, 0.09975211355746483, 0.12454319121364155, 0.16923908239406515, 0.25765552113965073, 0.14821655495217023, 0.2673697220436281, 0.15719931442894508, 0.14957952123330565, 0.14551410224993766, 0.13836092059692218, 0.1350678797027809, 0.16359534201288284, 0.37379024226846547, 0.36748873646729585, 0.3335933283415098, 0.3952108590828668, 0.3997483908060442, 0.38689471853056434, 0.4271513647994367, 0.379017156619192, 0.38205755772263816, 0.28338549367642285, 0.2507800997100911, 0.2960353471541145, 0.28165380208080437, 0.21284885279673338, 0.22496501626519017, 0.3039434513058016, 0.29458602293892144, 0.2954984496914479, 0.2145167084482782, 0.21596117274908044, 0.2025573611023237, 0.22306915544795625, 0.19733176261376917, 0.2384556323812722, 0.2774870011596341, 0.1926047007543098, 0.21283684426338778, 0.2051911130875419, 0.17941087221189955, 0.1822073054737764, 0.2142977223271617, 0.22965845607712698, 0.23258125141284547, 0.22633717420079225, 0.20826912520305563, 0.23210804778367733, 0.7798859845073197, 0.18446838284433875, 0.7522751112929408, 0.7936031287582499, 0.19738563579328794, 0.1938554373170518, 0.8146508464474966, 0.15510505264740782, 0.764307518846964, 0.7282501006439457, 0.6055332603951604, 0.6440929527280993, 0.6826105258255897, 0.16371848199740413, 0.2000444546277611, 0.6284592861951915, 0.7107336813670084, 0.7301867826234778, 0.17788571600506642, 0.1780446515303895, 0.17537529918830896, 0.19088376603506474, 0.1849908351519639, 0.21502977140128954, 0.1966306168902765, 0.18450819106365202, 0.18683506284019813, 0.10460141426815195, 0.09453344996861812, 0.07926457078300586, 0.0792686942284121, 0.09394558677782283, 0.08500363708142888, 0.1021503232666584, 0.09592825574857067, 0.08107464339364556]}, "mutation_prompt": null}
{"id": "3f0d0620-e597-4625-9e7b-70065d163fb4", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "cec886fe-754a-4da4-b26e-70c5e96642bb", "solution": "import numpy as np\n\nclass Hybrid_PSO_SA_CLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # PSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Simulated Annealing parameters\n        self.initial_temp = 1000.0\n        self.alpha = 0.99\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_lattice(self, x):\n        return np.cos(np.pi * x)  # Chaotic map for lattice search\n\n    def simulated_annealing(self, score, new_score, temperature):\n        if new_score < score:\n            return True\n        return np.exp((score - new_score) / temperature) > np.random.rand()\n\n    def __call__(self, func):\n        evals = 0\n        temperature = self.initial_temp\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Simulated Annealing with Chaotic Lattice Search\n            for i in range(self.num_particles):\n                candidate_position = self.positions[i] + self.chaotic_lattice(np.random.rand(self.dim))\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n\n                if self.simulated_annealing(scores[i], candidate_score, temperature):\n                    self.positions[i] = candidate_position\n                    scores[i] = candidate_score\n\n            temperature *= self.alpha  # Reduce temperature for simulated annealing\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_PSO_SA_CLS", "description": "Hybrid Particle Swarm Optimization with Simulated Annealing and Chaotic Lattice-Aided Search for enhanced convergence.", "configspace": "", "generation": 33, "fitness": 0.12515254145893373, "feedback": "The algorithm Hybrid_PSO_SA_CLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.17650959516919285, 0.2103732273863027, 0.1628099895362788, 0.21153804302306212, 0.2552846563650083, 0.2380153763988686, 0.2491207970541779, 0.21769266687632005, 0.20051036354110074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04762997672268443, 0.0446517209115338, 0.04858489173128455, 0.053099350345064855, 0.03101907650457436, 0.046239088621532254, 0.05346455967064745, 0.06605315462944439, 0.0393825219198195, 0.04637902904439939, 0.042269701303325746, 0.037032683120710175, 0.03197369734491562, 0.019998516013274847, 0.03631876070519191, 0.01743550905436586, 0.045269970312455055, 0.028936369968578624, 0.9736837450224567, 0.9687116055818512, 0.9745909801458184, 0.9252622402762819, 0.9575655180898565, 0.9604937722214087, 0.9748055872069212, 0.9717529522600042, 0.9742477461495349, 0.0627667308318931, 0.08322506146475572, 9.999999999998899e-05, 0.10508033991129484, 0.10832113516547304, 0.1062137362204505, 0.0856533389582037, 0.0945650851896277, 0.11273167434842057, 0.15389314951476352, 0.05757635478034684, 0.12886492181788145, 0.12977476458218495, 0.11112819480761571, 0.2032041260231724, 0.10364924595214253, 0.12278245334211191, 0.1517958513311658, 0.008338934486045058, 0.0016179872948212104, 0.016815180794739315, 0.010874888726339127, 9.999999999998899e-05, 0.0065965895532628105, 0.05926654664449105, 9.999999999998899e-05, 9.999999999998899e-05, 0.004086538127906381, 0.019013675761230142, 0.013852849746535112, 0.00205797336399427, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033769875441130526, 0.038829113278047056, 0.021277708353541147, 0.03826285588839784, 0.004135213163486751, 0.01956660628931972, 0.017672855884227956, 0.008416353907943819, 0.031132042251555858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004506315930632221, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022406555624469138, 0.018516172099407258, 0.020692584262688052, 0.1605800747221745, 0.19921448640285822, 0.20557712776231207, 0.20855863560229915, 0.22729012770709844, 0.20657187638206065, 0.19291878521082018, 0.19019101807348404, 0.19547174887838148, 0.0591087760130562, 0.06247127319219925, 0.06558342309122911, 0.05237697298269772, 0.042907477206820865, 0.046948510227414975, 0.03741479298996786, 0.040395666909509464, 0.04396874273092166, 0.14280147619377093, 0.13845672649037644, 0.14823268505250853, 0.13962304436007922, 0.13901880571241743, 0.11224802062378891, 0.12928443291622826, 0.1535125869259406, 0.12449276616107419, 0.15077906139314112, 0.1467592997950009, 0.16784904417936464, 0.16087968891518378, 0.15639601121645885, 0.13419126917846336, 0.18143695688761752, 0.19217381707423864, 0.18367218606034308, 0.08044892590184449, 0.11066796861292083, 0.11550128976568397, 0.10147257736458837, 0.09571553930987864, 0.11438112914854814, 0.12141329865425399, 0.13083291103489225, 0.12051109550920247, 0.15991400428282998, 0.15050695439024653, 0.15536278952251725, 0.16762342851048395, 0.15382146561518095, 0.14214996150992032, 0.152932205440794, 0.1688996416993721, 0.16354976147937472, 0.16196965386083118, 9.999999999998899e-05, 0.1339476476024707, 0.14975757405548373, 0.1638419716805627, 0.17473502342880642, 0.1512088310030737, 0.14294559800694173, 0.15216686640673893, 0.13151470900272288, 0.16187149332060524, 0.15268686151441813, 0.15221595401237942, 0.15633449088775686, 0.15539247517494548, 0.12478998359619431, 0.1430766948568013, 0.14567702149985728, 0.17245224554733996, 0.1678103779445752, 0.14905353670190102, 0.12551004527515852, 0.16848836713850646, 0.15268662604369398, 0.1755926322033985, 0.17770143366174018, 0.10837103797116199, 0.17587073011160714, 0.17841791621644043, 0.17944547705965874, 0.1850767507440726, 0.17971938960284373, 0.19183685195858735, 0.15849339374557347, 0.18593591886757954, 0.16820815318119708, 0.058510543372621404, 0.05015621111229107, 0.053250030115198244, 0.03850213816681758, 0.07195813964417952, 0.03988115928596636, 0.038183990911606625, 0.06778763408059763, 0.029014010236980137]}, "mutation_prompt": null}
{"id": "a77611cd-8970-4637-8f1c-5e97d1c93735", "solution": "import numpy as np\n\nclass Enhanced_AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced AQPSO parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight adjusted\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Enhanced scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_AQPSO_DE", "description": "Enhanced Adaptive Quantum Swarm and Differential Evolution with chaotic perturbations for rapid convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7610025936248883, 0.7498049774234518, 0.7717566337079791, 0.7615512586595703, 0.7697907312144359, 0.7775190726552604, 0.7355913142042871, 0.758296659156062, 0.771266880148437, 0.5315595187003066, 0.5778765375491499, 0.5634981270296897, 0.5403054105031836, 0.588507967092297, 0.6388209191101094, 0.573086826238392, 0.581425306645597, 0.5994884707250955, 0.1634228552343182, 0.13975371492318522, 0.14087004690095872, 0.4795511455820616, 0.47026135949018166, 0.14049558062589207, 0.12696261000246034, 0.14068828648772125, 0.13818740427404264, 0.11717629834340038, 0.1094391753308015, 0.09106851858621234, 0.12132800070184147, 0.12110140414819703, 0.12184454684473855, 0.11142838478136219, 0.12367638215409393, 0.1125689913995973, 0.8238074515804483, 0.8766996498782301, 0.8299941712728001, 0.8585102436096799, 0.8542011637150426, 0.8676610869267205, 0.8865874106448078, 0.7926815549676133, 0.8958433584982538, 0.4668788811152653, 0.3807912307506667, 0.4549307027506829, 0.4181732443240457, 0.4153611572429411, 0.4502663520347946, 0.4947178141045172, 0.40630819591205014, 0.46004019394175444, 0.8083480380299477, 0.35790823075421585, 0.7612404996970193, 0.7932130024477568, 0.7867978928227106, 0.26728622939528424, 0.7256859641909144, 0.7281107423605364, 0.8014604897112821, 0.23267331934886526, 0.151332863116298, 0.19049111885596282, 0.1548059382051924, 0.16688730437928623, 0.19121356783676713, 0.17686912031523028, 0.1556718859402101, 0.15316013648807913, 0.1806907665404176, 0.10440823679899114, 0.20686513455571698, 0.24194882705458975, 0.20045093699228544, 0.16766792095819638, 0.19358167232810253, 0.1656060773796062, 0.1256679197696834, 9.999999999998899e-05, 0.04504368665073322, 0.007251238457765208, 0.007411383504275726, 0.03864539338198625, 0.023505860869318496, 0.021282030172180222, 9.999999999998899e-05, 0.044675279085709785, 0.19531662815812567, 0.12589765989043822, 0.1542029836905181, 0.11334392715389696, 0.09110714972068601, 0.12063596043611702, 0.1203758755267097, 0.13198987102184911, 0.09922571453138318, 0.16176216647593078, 0.10106821375396335, 0.05218939449289972, 0.2547457960029873, 0.07109963424530519, 0.1991791369494006, 0.14745991961911253, 0.15140443456638264, 0.30596504618744014, 0.20057623233158595, 0.10654509957655778, 0.09099771104508148, 0.21989655802277797, 0.20146928025301336, 0.17393041130902298, 0.15033472878238863, 0.15024349525083946, 0.19274308346877322, 0.5258791205169191, 0.6001760391019759, 0.5510279067891768, 0.5509681477692607, 0.6005067330490512, 0.5193854424621487, 0.5579331315759373, 0.5869561639385242, 0.5591757839292961, 0.12941073569932104, 0.1130909255833229, 0.15304389919941275, 0.13821224230400964, 0.13825910938791908, 0.14032708072893474, 0.1420639726072761, 0.14002470525522326, 0.11561118135023685, 0.18946007790255837, 0.30053458207877326, 0.31430033135477853, 0.14466419530400365, 0.22322669468784861, 0.16337693817206567, 0.17691367612872022, 0.12197094642524298, 0.13501448493413049, 0.46538976143741084, 0.3962440615923821, 0.4702344730061332, 0.4615442513760024, 0.41532514121603203, 0.3984699777791202, 0.47521419124620257, 0.490317455548958, 0.4829589722922879, 0.35406169445817737, 0.3468473984384146, 0.26859645946099, 0.2233547950990482, 0.3512125892070065, 0.2516662234767899, 0.3447411064315564, 0.36793290990063665, 0.33633371117305777, 0.2108405247182037, 0.19983138568119385, 0.21499592523419075, 0.20437599591670508, 0.18777793672318455, 0.2181501693980279, 0.21143650886064025, 0.19532002784027602, 0.22427959853811452, 0.21116509431089447, 0.19756839841422957, 0.19806790690786924, 0.18092423237654442, 0.20374872478319395, 0.5235352590951978, 0.21088113409547615, 0.23049797402598327, 0.1976832690289455, 0.7677357451533999, 0.1579211127785617, 0.1445422179845215, 0.8043929539317333, 0.19459485924003617, 0.1646344313837642, 0.8278162895286703, 0.16165650602331083, 0.16955943576695787, 0.7518729449912066, 0.15051400362046896, 0.8183583710254925, 0.6563789261594803, 0.20132481395830915, 0.5244086388986319, 0.7724236932936378, 0.20684391491116694, 0.7136736749343895, 0.19063567584516727, 0.18331373612300117, 0.20267706218703507, 0.17970256418589592, 0.18871534100960197, 0.18234998533017932, 0.20355740758270213, 0.17189194450274103, 0.18930702748127182, 0.07914219625089336, 0.09249357464123531, 0.07937995229589012, 0.08676140858105541, 0.09136396474607378, 0.08366355703718686, 0.10406072707011149, 0.0876582345554745, 0.08038125192907841]}, "mutation_prompt": null}
{"id": "c599d696-ae80-465d-a63c-90049c96c2cc", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_Swarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Swarm parameters\n        self.num_particles = 60  # Increased population for diversity\n        self.inertia_weight = 0.7  # Dynamic inertia weight for balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Higher scaling factor for stronger perturbation\n        self.CR = 0.9  # Increased crossover probability\n\n        # Initialize particles, velocities and memory\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        self.memory = np.copy(self.positions) # Memory for quantum-inspired update\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(size=L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid Swarm)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.2, 0.4, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Quantum-inspired Memory Update\n            quantum_update = self.memory + np.random.uniform(-1, 1, (self.num_particles, self.dim)) * (self.positions - self.memory)\n            self.positions = np.where(np.random.rand(self.num_particles, self.dim) < 0.5, quantum_update, self.positions)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_Swarm", "description": "Adaptive Hybrid Swarm with Memory and Quantum-Inspired Operations for Enhanced Optimization.", "configspace": "", "generation": 35, "fitness": 0.12041753924879749, "feedback": "The algorithm Adaptive_Hybrid_Swarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.2270077921301683, 0.20377080345414966, 0.35311925440747327, 0.20389764971196334, 0.21627048147106842, 0.2207737557485263, 0.20190062858051783, 0.1883015398582577, 0.26774641144498224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04906106708437252, 0.0508089052807138, 0.0719547815243976, 0.04760451575943658, 0.06968314411779208, 0.0580541279247796, 0.052804654587366495, 0.054859187496622, 0.05060988475975847, 0.047123338862006814, 0.03664513401083058, 0.0333443298928402, 0.05416183376401673, 0.048906705183345056, 0.04954657064439705, 0.04540588481693553, 0.04618463357596014, 0.03741204043599733, 0.49678149499860824, 0.19658729337918734, 0.40834558557921974, 0.2029492463229119, 0.7821253222931897, 0.3620956439995624, 0.6936508506400825, 0.7944210154539701, 0.22690150341998605, 0.09776248563001988, 0.10259389562040033, 0.08704641218101916, 0.11279186833011845, 0.08134405674175793, 0.11709330190526257, 0.09732899246931592, 0.08738210981036187, 0.09316017180453195, 0.16663688959048484, 0.1741118532841227, 0.1531598387806853, 0.16196787058427708, 0.218247055136238, 0.1435238427639639, 0.14488136586817368, 0.1844871812997736, 0.14753415171620377, 0.016628277196798824, 0.00866293682462893, 0.04575405063711602, 0.051847372464195574, 0.0519556093283261, 0.00016977827413522384, 0.04631713826652739, 0.011665391549971704, 0.0668084503682459, 0.033988248777636176, 0.03523205757292491, 0.040950494727407416, 0.015579189623074696, 0.04101566429891412, 0.041321544975304825, 0.02825275188623322, 0.07731977714196803, 0.07574175862256904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08795418756286233, 0.0586960361023694, 0.10488701628912567, 0.03620175131577674, 0.09641820008962498, 0.1115458724826296, 0.045305572909929315, 0.05491548962040238, 0.041867989543857065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021242498822054978, 9.999999999998899e-05, 0.004633719859910901, 9.999999999998899e-05, 0.0010254967320353359, 9.999999999998899e-05, 0.007364855228190081, 9.999999999998899e-05, 0.005691491015247685, 0.24820715702506213, 0.22659214710536613, 0.22707969383328686, 0.21166654631926207, 0.22386353044742602, 0.2152654762216052, 0.24359369789846586, 0.20343813991016624, 0.23331825183657273, 0.05686210259851654, 0.05505748638171959, 0.06731039367753766, 0.06855432855587784, 0.05774758480228681, 0.06795632799362317, 0.0559676666204052, 0.0455435143848919, 0.057449219456740086, 0.15048858616265537, 0.1396456382618475, 0.12818258102878333, 0.16109541197321464, 0.14479532529775152, 0.15833923415367213, 0.1325249303588093, 0.1313830025088759, 0.13572931874418703, 0.16728684775914682, 0.1805082542088854, 0.18203806493088126, 0.17821197017571178, 0.16616320989048639, 0.1939221457748308, 0.19444491234024763, 0.19608441371285035, 0.18205294965286634, 0.12330525697576689, 0.11915716483288474, 0.13442899138630837, 0.11414110927050114, 0.15462520856232964, 0.14835094417790895, 0.11880591447044919, 0.14274433071158732, 0.12819032888481974, 0.1615190476005509, 0.16763751362292278, 0.1677164322981074, 0.2073051470504491, 0.16257709878742443, 0.1541139430424049, 0.1868002452857841, 0.16016611742741005, 0.17250748594535148, 0.14441325553118511, 0.16108224684781502, 0.1679728100097887, 0.1534476538880677, 0.15944660012507006, 0.14870737236371712, 0.14497514382910215, 0.15295006090678565, 0.15314012418368161, 0.17398596883534934, 0.1783965510571336, 0.23248200439577993, 0.23580090165715506, 0.18560154063357026, 0.20407337571407003, 0.16431554110171198, 0.16739175988602273, 0.1930572108269908, 0.15868538548614708, 0.18091311981797964, 0.16162669555553189, 0.18633055493775053, 0.14254438227187238, 0.22325934465006503, 0.1668600597687977, 0.2014106302505677, 0.16681843250192996, 0.17511638098566384, 0.1806489289816111, 0.17576147979803503, 0.18427617074482605, 0.19075158311525564, 0.18583799920054422, 0.18505255174533752, 0.18641206878081584, 0.18875614144696473, 0.07909938209655143, 0.06573517340236923, 0.0564658529800941, 0.05113058633714629, 0.06021504002015243, 0.052037068804619, 0.057388456723700965, 0.057852153547972573, 0.0635693634153851]}, "mutation_prompt": null}
{"id": "524f96de-e5d5-4c6d-88ea-04571c160926", "solution": "import numpy as np\n\nclass Hybrid_QPSO_EM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid QPSO parameters\n        self.num_particles = 60  # Increased particle count for better exploration\n        self.inertia_weight = 0.7  # Slightly increased inertia weight for more exploration\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Evolutionary Mutation parameters\n        self.F = 0.9  # Improved scaling factor\n        self.CR = 0.9  # Increased crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1/beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        return u / np.abs(v)**(1/beta)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_QPSO_EM", "description": "Adaptive Hybrid Quantum Particle Swarm Optimization and Evolutionary Mutation with Dynamic Strategy for Enhanced Convergence.", "configspace": "", "generation": 36, "fitness": 0.31260659437777405, "feedback": "The algorithm Hybrid_QPSO_EM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.7461624353204848, 0.7300302770597212, 0.7322044144829757, 0.7179847714421144, 0.7299045617985986, 0.7456480171597417, 0.7274697499129162, 0.7373399738000759, 0.7338462308541482, 0.47884720270950465, 0.47873044785401375, 0.5371220667189714, 0.500780530488006, 0.4893774536328511, 0.551367223844558, 0.4490390570510163, 0.47354688113943566, 0.53457032940652, 0.10132971740893715, 0.12486249391940751, 0.14031948724836407, 0.13645796654249898, 0.11243878236421712, 0.1243250872444649, 0.14162111596661253, 0.13417184289931905, 0.12997186845335507, 0.1141295162716418, 0.11913024291137841, 0.10824429304330774, 0.10983451220361473, 0.10440349867294663, 0.10054876513840805, 0.09965450607400073, 0.1231708082984021, 0.11008791021838038, 0.9050798929010666, 0.9615778605319014, 0.8816172662268836, 0.9347176913821044, 0.9022106893315784, 0.9513607139923923, 0.8502294267122417, 0.929861000069686, 0.929309490769681, 0.42512716176216836, 0.43462248077256993, 0.48633060666970807, 0.36085970342156504, 0.41677007592428106, 0.46265848948673405, 0.4026245661142065, 0.3807239421430174, 0.41950344069857715, 0.7530121149248522, 0.749439242897934, 0.7835717379693375, 0.668368078577771, 0.7752331631566158, 0.6993782453680369, 0.7641041021302979, 0.2303812837341226, 0.702759354234038, 0.18788998933040346, 0.20413661735601807, 0.20338703961350824, 0.18429373547232852, 0.21247192445146734, 0.16238699161034476, 0.18984670225799682, 0.3562048505195132, 0.2026060494781986, 0.25289304771749344, 0.10880672142643177, 0.1868214544224257, 0.22341681013815662, 0.17659306447723433, 0.18498724859651083, 0.2166266679222092, 0.177900420374828, 0.1924650292634491, 0.03583258383132326, 0.030985743425950396, 0.006528840471712649, 0.11381957263109488, 0.0231790544346846, 0.03473277081520232, 0.02560005273470456, 0.025636103930054, 0.05181011808973912, 0.1447433015614048, 0.11018423885351059, 0.1445239283368388, 0.10979673250021149, 0.06202704300734507, 0.0736235647066189, 0.08769968971221165, 0.13325375963375097, 0.10717572663812391, 0.051926323870643554, 0.026552551324972917, 0.02697010145250822, 0.07274218797301113, 0.08719269021184739, 0.191168164707605, 0.07527086726168741, 0.16788220074501026, 0.08407444926760599, 0.14970185289338622, 0.14622678685471469, 0.17469575912897073, 0.13667038200164283, 0.16081049610176523, 0.12702100648756753, 0.18348676395315966, 0.13396497757028447, 0.1484037553839065, 0.49248777472519956, 0.5095632977585746, 0.514182064426822, 0.5067432820812922, 0.5099224209584563, 0.5525685144477162, 0.5544408605135855, 0.5449280129632847, 0.5740355363764239, 0.12592012649507578, 0.11672500602331859, 0.08885346586907328, 0.12269779932106595, 0.09814390144629337, 0.14391611766163748, 0.13417305900797905, 0.22005272868970815, 0.11976603558041132, 0.19396663962053606, 0.18246766769971812, 0.15737592061516592, 0.15122428784725728, 0.2536713196793171, 0.1745946087068151, 0.15718311257765016, 0.15149976777718943, 0.13682242222745933, 0.39785755454741145, 0.39090244063463586, 0.4351787664739243, 0.401484383795092, 0.40496529145685145, 0.3832062953446941, 0.4148440960897276, 0.4300605362852349, 0.43330946688949623, 0.268576623149539, 0.24372752536355058, 0.2849573900793604, 0.2818984973230677, 0.27030534943341156, 0.22992351835125724, 0.26863463700946555, 0.30897000986716183, 0.34263902149833136, 0.19766020084028968, 0.18699998971649845, 0.18654508352451504, 0.21332709573298236, 0.19882571496079315, 0.20837547093451259, 0.21136816532668867, 0.19508444849649675, 0.21130785803671315, 0.18317262424082859, 0.18450310331561592, 0.20376862583831867, 0.43774534084965167, 0.31274513444301744, 0.18129216979300244, 0.20294334559705474, 0.1828681007379226, 0.19868977472328653, 0.706929948306882, 0.18432694368861802, 0.7973748459411915, 0.19299157020807112, 0.19788553032693312, 0.7702920997213731, 0.7514139160058917, 0.7400476111188965, 0.6066111612079302, 0.6595255303736746, 0.20878708437314486, 0.19472379771765735, 0.685447925934817, 0.7076050005498284, 0.2014899460541304, 0.5778082652451884, 0.149607365023664, 0.6821385959200834, 0.18869297766023796, 0.1785559031875209, 0.17923777801053453, 0.19786954852444627, 0.21172524704190254, 0.1718956991204179, 0.2000234444497122, 0.18488651168667236, 0.179606522874885, 0.08137230120051375, 0.08360112084505622, 0.09600409744183269, 0.0783996604400341, 0.08750532963413038, 0.08300303734550929, 0.08030868432505833, 0.09317380890263716, 0.07581180500113804]}, "mutation_prompt": null}
{"id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 37, "fitness": 0.32791951616661635, "feedback": "The algorithm Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "324f7a5d-b9af-45bc-b668-736509540733", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "7c4392bd-89dd-42c3-99ab-cb435309947e", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "66aedf3d-3dbd-4846-b9a3-8f0f32c7b2cb", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 50  # Increased particle count for diversity\n        self.inertia_weight = 0.9  # Dynamic inertia weight adjusted during iterations\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0  # Increased social influence for faster convergence\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Slightly reduced scaling factor for more refined exploration\n        self.CR = 0.85  # Adjusted crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return np.sin(np.pi * x)  # Sinusoidal map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update inertia weight dynamically\n            self.inertia_weight = 0.5 + (0.4 * (1 - evals / self.budget))\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for exploratory jumps\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Hybrid APSO and DE with chaotic maps and adaptive parameters for improved exploration and convergence.", "configspace": "", "generation": 39, "fitness": 0.3037422294400124, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.7922006747286788, 0.8036953498529875, 0.779186604065654, 0.7778149643316139, 0.808046835137336, 0.8097230204376272, 0.7886163646514155, 0.6193914241348293, 0.7992183716164324, 0.5800893270488379, 0.6176956611150215, 0.6274005206939686, 0.5880140609512325, 0.5400921861777744, 0.5044693825047791, 0.5740766948255513, 0.5687249932556382, 0.5305814512684214, 0.1257926145401158, 0.10821089477847368, 0.11516961560975447, 0.11559424877450963, 0.12384477026714957, 0.14108702956910146, 0.1453241105059807, 0.1485700097792052, 0.14059480608130437, 0.10047377143654357, 0.11893110467244628, 0.1072539026653323, 0.12236995308852516, 0.1659422133335221, 0.1083058699327808, 0.10692229899744665, 0.09830752511130614, 0.11084674839190978, 0.9460051848883687, 0.940873652258084, 0.9598165321491869, 0.9134958796716859, 0.9166811239017654, 0.959887966893044, 0.9121007734585446, 0.9399484884763778, 0.9597634867696827, 0.5383877013715588, 0.5687821568607436, 0.5831624448691082, 0.5849988347967935, 0.5377352423193265, 0.38259109558279614, 0.5253617379376216, 0.6266022971510326, 0.4662176847107504, 0.7744403446281242, 0.23301016338245273, 0.21213212084219712, 0.6624798898977078, 0.2701213687012124, 0.25522191274787476, 0.2279650343743621, 0.17013559215984553, 0.3363986903884607, 0.23147465446086735, 0.09721539777216981, 0.17148992125989826, 0.16434377493654517, 0.2023299169134012, 0.16515086063714313, 0.1704503094386015, 0.34968131396467583, 0.15306892808458428, 0.1734254369746896, 0.013644071686392145, 0.20002289383052285, 0.1586032707876186, 0.19976369900834556, 0.126790464455662, 0.1972490254809608, 0.19367908161570668, 0.22379208216127822, 0.04356814149636179, 0.04188596161327318, 9.999999999998899e-05, 0.043731836418473224, 0.001143729981459396, 9.999999999998899e-05, 9.999999999998899e-05, 0.026256184928019843, 0.05296829962590488, 0.1602646924811394, 0.1214725013014486, 0.19678392245302812, 0.05008131262718529, 0.05050833086396378, 0.04774178364760684, 0.13550523800221748, 0.07230026822999025, 0.10163374620479515, 0.07281899533444447, 0.06395646216686779, 0.1549934038121048, 0.14832656048409476, 0.07118858252846405, 0.23021940037357558, 0.08606950782119527, 0.13579197644277652, 0.08034641388117691, 0.10586333393951242, 0.04820547565435229, 0.08799669769595497, 0.13474547087148314, 0.20867217993076048, 0.24709750077887738, 0.13437290858389683, 0.07004222737694477, 0.07912254763627624, 0.5478726187780858, 0.5414054703662763, 0.5222458682941034, 0.5338952059039684, 0.5977780910422307, 0.6052482562131387, 0.5752190719174302, 0.5680155929052483, 0.6081890116747837, 0.11136957303269901, 0.0759262595463781, 0.14237078186955499, 0.12246875696119242, 0.16574654878645922, 0.11857946102790962, 0.10875677199394629, 0.10110948678740572, 0.10339737381607628, 0.2276744090004681, 0.29366316207769483, 0.18685405181107262, 0.13652805693521985, 0.1474816712948961, 0.12700066035488178, 0.36505422105056307, 0.17671796388029437, 0.19193497791777436, 0.5229810918369264, 0.46485170780862917, 0.28680501590206875, 0.33677060136057557, 0.3943586793231121, 0.33830474540873023, 0.5379941847015256, 0.5362821076943098, 0.499352663694829, 0.22057645448490037, 0.27986581247506237, 0.2664753519561689, 0.3531019265850798, 0.33169993366796835, 0.2698346990395043, 0.423819795339056, 0.32939326539349767, 0.3372278885128651, 0.2215196733274235, 0.23804961695401372, 0.23248961847290706, 0.21600756497162277, 0.1925303455337093, 0.22815628528412857, 0.2005867452942679, 0.20735653763526107, 0.20136681795675904, 0.19850315161459198, 0.18348756940385125, 0.2026942000848584, 0.20364945033942172, 0.1996751377985826, 0.18443226492375075, 0.57695675689906, 0.19164871379279058, 0.19724426352135283, 0.1565612571613224, 0.1246325177630424, 0.15109288344750915, 0.859201930551424, 0.19732610616342772, 0.8832295856990309, 0.8160024517696663, 0.1700761736119848, 0.14689348021844417, 0.8095794123057577, 0.15454563686586376, 0.4410916170729027, 0.20265088369519768, 0.6991272054869881, 0.1525673015228387, 0.8240113513653322, 0.20911814435551168, 0.15468550837755468, 0.18403373636991194, 0.17879710730271203, 0.18181239169143826, 0.17797814662493805, 0.19347036966412356, 0.18022675143870615, 0.18004908811328002, 0.17956916066656237, 0.17713627339399185, 0.07988627259710668, 0.07743259159378502, 0.08768958474401711, 0.0880124154850348, 0.09439607679780015, 0.08166616982776798, 0.08379256181553152, 0.12209030162256129, 0.08428762344808605]}, "mutation_prompt": null}
{"id": "22b117d1-60b7-45ec-adc1-987e509a5d4d", "solution": "import numpy as np\n\nclass Hybrid_APSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 30  # Reduced particle count for faster convergence\n        self.inertia_weight = 0.8  # Adjusted inertia weight for more exploration\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n\n        # Adaptive Differential Evolution parameters\n        self.F_min = 0.4\n        self.F_max = 0.9  # Adaptive scaling for better search\n        self.CR = 0.9\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return np.sin(np.pi * x)  # Sinusoidal map for better randomness\n\n    def levy_flight(self, L):\n        beta = 1.5\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.abs(v) ** (1 / beta)\n\n    def adapt_F(self, current_eval):\n        return self.F_min + (self.F_max - self.F_min) * (1 - current_eval / self.budget)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.15, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Adaptive Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                F_adapted = self.adapt_F(evals)\n                mutant_vector = np.clip(x1 + F_adapted * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n\n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_ADE", "description": "Hybrid PSO with Adaptive Differential Evolution and Chaotic Maps for enhanced convergence.", "configspace": "", "generation": 40, "fitness": 0.3223263226742304, "feedback": "The algorithm Hybrid_APSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.889768152486503, 0.8585103308388089, 0.8631768355467115, 0.8581642713043822, 0.8480008594900448, 0.8447255233852802, 0.8695247674238641, 0.8665814736712871, 0.8614889240117346, 0.7568966927239325, 0.729858061222701, 0.7141165242538505, 0.7481772483655705, 0.7417474848556053, 0.735560050832442, 0.6474852691520274, 0.7458020473566689, 0.7397046533673889, 0.14985748514305874, 0.17615257990138122, 0.10700408930035787, 0.1396418077631424, 0.17286407021057804, 0.1059868608874136, 0.14813519322747093, 0.1419364628217309, 0.1672640243004604, 0.06393832325498683, 0.104841712115751, 0.11230756755588578, 0.11694481977388183, 0.123928920334885, 0.10976960027490201, 0.15358810015001223, 0.09983833227762495, 0.1315474547919534, 0.9545349547962475, 0.9191277147639964, 0.9598246644523252, 0.9640441785962066, 0.9367596422786797, 0.9510580684299891, 0.9622273257752283, 0.9372844295102631, 0.9614281545336012, 0.4355719287535319, 0.24408231909653355, 0.5725163475434064, 0.6934930226608818, 0.7324989041440454, 0.5152389302447609, 0.4179503813960842, 0.5621157145572488, 0.08793426493979173, 0.2269808070745456, 0.20423343446213882, 0.8253824678339474, 0.21445226589687627, 0.273599910797485, 0.8246766175098683, 0.20852127204383664, 0.8465710416406478, 0.8530186736997893, 0.1955684864944286, 0.12940280885602584, 0.15303193847099517, 0.17262005128366908, 0.17574384535355025, 0.1309892905612431, 0.13120995024322235, 0.18906309928587917, 0.17367588301815362, 0.16541797535678382, 0.11890874520565142, 0.19741521524575678, 0.2075675751087469, 0.15889604914325628, 0.19952933568012965, 0.21567829679957273, 0.16177110994111532, 0.23139036276659652, 9.999999999998899e-05, 9.999999999998899e-05, 0.014560315548531766, 0.000537331015938225, 9.999999999998899e-05, 0.02940497052067037, 0.0005698647731893214, 0.007961884606039527, 0.0018817814279762368, 0.06948470304528387, 0.14920142113995805, 0.09301457013230319, 0.027434992103881672, 0.019304710887804166, 0.028807150257689873, 0.11966786991308176, 0.07397469770547527, 0.18479151961151807, 0.11243107178944733, 0.11745127672100264, 0.11066140598855256, 0.1353712217959574, 0.2170036922551054, 0.1546084029471071, 0.09630922236494532, 0.11328527693581869, 0.3072731351159864, 0.15279694211326156, 0.10222812770480927, 0.2242769124225965, 0.17052582571908748, 0.14906905789140112, 0.19006292382170542, 0.2333651638144114, 0.18625780174547735, 0.08324598138052186, 0.5652245562498035, 0.61186572999393, 0.4828473819230593, 0.541927756847521, 0.5313932000081771, 0.6127214014505897, 0.6074482326376712, 0.6267716975570508, 0.5971772208994848, 0.1358337059071293, 0.13006878006578448, 0.1230204211043392, 0.12047135642346096, 0.1665342171882669, 0.12865256932153057, 0.14239251246208784, 0.15153681880797976, 0.11320156728150066, 0.25601174175716923, 0.6459117827916561, 0.30120399281574906, 0.14663722067747564, 0.49142085549859216, 0.2790575699718154, 0.14820251642343463, 0.24471721863667695, 0.40380381779517505, 0.5867761904142388, 0.42273240092273456, 0.3537768269701752, 0.39316417072696974, 0.5693291277612683, 0.3576323456373507, 0.6185585797325628, 0.4971731632887971, 0.5452506026602564, 0.27144645740195417, 0.28276095407297663, 0.2709005345875305, 0.26386577463173344, 0.37352164086011896, 0.27117332305109576, 0.2875287588281812, 0.3312073896903075, 0.22755711010884694, 0.22474637238807083, 0.2253095080405626, 0.251470322911616, 0.1938464387876394, 0.22116414535790552, 0.21950012280510123, 0.22108836162562717, 0.21344486436866195, 0.21848472632278104, 0.21500703968150103, 0.22064157153640152, 0.1877763147042898, 0.17780022386324945, 0.20587395863381452, 0.20975960007049133, 0.1883843618369111, 0.2414210519718072, 0.19892298984053802, 0.16455278459996658, 0.18392528654299045, 0.15209999621453574, 0.8953697203675454, 0.8555780896820561, 0.888503615919679, 0.1614650617199006, 0.13029709599908423, 0.2091296057565113, 0.633762121154649, 0.7890999413341311, 0.15352490551767717, 0.20961419603303144, 0.33575582642582613, 0.20716212277668677, 0.10424110979884194, 0.11257562462280768, 0.15522816760768654, 0.20704989572421473, 0.19270160689004567, 0.17219626434275437, 0.17417106654801173, 0.1801229514694529, 0.20242192051098962, 0.1766803876652766, 0.18191118040688004, 0.19260908961996648, 0.08431285938059796, 0.09268803295333528, 0.08225815094133526, 0.08842428544471681, 0.09820850993085783, 0.10956834967325124, 0.09605898325650086, 0.08285344995833221, 0.08634501641490022]}, "mutation_prompt": null}
{"id": "48f6ce6b-62d7-45be-8e98-565b5a5b0b6e", "solution": "import numpy as np\n\nclass Enhanced_HCPSO_ALM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 50  # Increased particle count for diversity\n        self.inertia_weight = 0.6  # Adjusted inertia for adaptive learning\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.4\n\n        # Mutation parameters\n        self.mutation_rate = 0.2  # Introduced mutation for enhanced exploration\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions with mutation\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n\n            # Mutation\n            mutations = np.random.rand(self.num_particles, self.dim) < self.mutation_rate\n            mutation_steps = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n            self.positions += self.velocities + mutations * mutation_steps\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = x1 + self.inertia_weight * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_HCPSO_ALM", "description": "Enhanced Hybrid Chaotic PSO with Adaptive Learning and Mutation for accelerated convergence and robustness.", "configspace": "", "generation": 41, "fitness": 0.19828052458483572, "feedback": "The algorithm Enhanced_HCPSO_ALM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.3896546816090579, 0.3784211782453438, 0.43787794905496624, 0.3662415718344417, 0.3827876854332891, 0.3997232080770172, 0.3676333728862091, 0.3958526109037891, 0.371317031708449, 0.036595542276603776, 0.034498786395299574, 0.0026485782673127956, 0.029799959183079094, 9.999999999998899e-05, 0.005788765203805779, 0.006892940537458481, 9.999999999998899e-05, 0.019718568599626285, 0.10458438878313903, 0.10185407487918097, 0.10286610691937148, 0.10003939908433801, 0.09626825506795089, 0.12471033947542487, 0.09662435380689094, 0.08381197492886217, 0.09224386645642313, 0.09602272798472022, 0.08144230177564937, 0.09572277355488934, 0.08037819338512431, 0.08900746694442674, 0.09432901149521344, 0.08159105781738252, 0.10993899480211256, 0.10651223316178349, 0.8907357629056889, 0.974754669845847, 0.9502113171077713, 0.9090058668856748, 0.956932930544895, 0.9529895317154868, 0.9671946786418216, 0.87872972027278, 0.9185645280446952, 0.21674933016881626, 0.22258586172568562, 0.19927386305494132, 0.2037004137642704, 0.24677019592315175, 0.2161073413170631, 0.2352433815171634, 0.21963378825126834, 0.19824869175970794, 0.2971476051108758, 0.27540787353996654, 0.26548388278044455, 0.2593682197365561, 0.30088828259599554, 0.2605583520647762, 0.24567034798878462, 0.2588259382263808, 0.3017599195613109, 0.1130165746958901, 0.10545433617593591, 0.10120848216974532, 0.1371582262677954, 0.12022561518758867, 0.12611816403101406, 0.1038302130932991, 0.1309207413702499, 0.145956272970037, 0.13674159674394237, 0.11395760620592132, 0.14113502517759247, 0.1389695890131648, 0.15199633918687283, 0.171673354047141, 0.14339103504294493, 0.14200900016444362, 0.11868975651048785, 9.999999999998899e-05, 9.999999999998899e-05, 0.007973149543690883, 9.999999999998899e-05, 0.0002555391746287272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036916737643947206, 0.08676278837250173, 0.11160054705966416, 0.12438589643519093, 0.13150741823405876, 0.026906204303868808, 0.06428645919575049, 0.08351673381577152, 0.0688313391667581, 0.07168492139624671, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07859405213841963, 0.08835811960860851, 0.07068802278929398, 0.04907836242168673, 0.06378120723274983, 0.07558502705460945, 0.08179695812701226, 0.06027450534698531, 0.06999560722896536, 0.3734556972418088, 0.3442487930674235, 0.3544513759746565, 0.3933593619741751, 0.39525695305304354, 0.34307383237173483, 0.38315141079113113, 0.3528216077795342, 0.3911476262630066, 0.08677772891450275, 0.08456279168328984, 0.08610016710006152, 0.10578469057831696, 0.09305247488907609, 0.09924333501036797, 0.0801262808554708, 0.09732086506576798, 0.10249091892061968, 0.18328974616442084, 0.1409231462800804, 0.1938397623698962, 0.13660954317631946, 0.12967208441954603, 0.15612199226790013, 0.15891588576769977, 0.1902771338551168, 0.15683392485909187, 0.25602300296539815, 0.24889727946392193, 0.23185011581854698, 0.26554452589820965, 0.2723376836048794, 0.2550248652983297, 0.2422389351404023, 0.2749151307133403, 0.27740355766982416, 0.16681705623396936, 0.13819304354864104, 0.19660091429407478, 0.20716991037550891, 0.16859946266275694, 0.1951467909612008, 0.20874956618492824, 0.19920459601774632, 0.2012956974419413, 0.1954185193423389, 0.2187167015226943, 0.20751186251761045, 0.19424420548163512, 0.19713266669791196, 0.20024776503735675, 0.1849016010127852, 0.18637360241335177, 0.2174973048360589, 0.18285261850622514, 0.1801830163818775, 0.17656672455580624, 0.19555568072396157, 0.1765866673481723, 0.18767721951861738, 0.17670769623495342, 0.18262221451405747, 0.1718780811670636, 0.18304433759112348, 0.18443547870836186, 0.15299058023327672, 0.545388511537802, 0.196175939516966, 0.4812387056284779, 0.474200677512175, 0.15893382970165892, 0.524724952301816, 0.5415112705443792, 0.15487214839383012, 0.15352814694042427, 0.39996650331061834, 0.3271058025213922, 0.4515637974331269, 0.1542355755103979, 0.15365474247514943, 0.2102238410025007, 0.18965383716290174, 0.18532820142855477, 0.17883269979144967, 0.1857283355864613, 0.18081595266007766, 0.17222019338697625, 0.18508756122978542, 0.19054579851431186, 0.18416923193061918, 0.06866348513491172, 0.07773124518746133, 0.0692917814228029, 0.09379234104775913, 0.0733292714844116, 0.09459222292523739, 0.08567692540789662, 0.08342092166743664, 0.0806743446364544]}, "mutation_prompt": null}
{"id": "6c8c8c1b-db11-4d93-b410-5ed022bd7436", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_CSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 50  # Increased particle count for diversity\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff = 1.7  # Adjusted for faster exploration\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Balanced scaling factor\n        self.CR = 0.85  # Adjusted crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update inertia weight dynamically\n            inertia_weight = ((self.budget - evals) / self.budget) * (self.inertia_weight_start - self.inertia_weight_end) + self.inertia_weight_end\n\n            # Update velocities and positions (Hybrid APSO with Chaotic Search)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.005 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_CSA", "description": "Enhanced Hybrid APSO with Chaotic Search and Adaptive Parameters for Improved Convergence", "configspace": "", "generation": 42, "fitness": 0.3039035563483402, "feedback": "The algorithm Enhanced_Hybrid_APSO_CSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.7304989046187201, 0.7268994609691704, 0.7691168121280647, 0.7359637334739051, 0.7374825973410079, 0.7590593228525465, 0.7508755409415646, 0.7270309434229403, 0.7485941478640749, 0.4940957373677777, 0.521241030261778, 0.5016615028199808, 0.4927004090928554, 0.5160608963131184, 0.4961959235446104, 0.4983085670690188, 0.4904571316825058, 0.5191619364981204, 0.14740142629216657, 0.12874426924506277, 0.1367569171877494, 0.1550720893292773, 0.13239028818021037, 0.15085418991691346, 0.12189196155418813, 0.12485474112060768, 0.14336344126885037, 0.09963817947680831, 0.15405113182781227, 0.10504015927066668, 0.10067642602199323, 0.11134049059880069, 0.09682248720713471, 0.1042857214145888, 0.09472105901793859, 0.11819498704906928, 0.9049239793034677, 0.8674592326885616, 0.9215731821787991, 0.8934783237148278, 0.8372754959820494, 0.9463709359728464, 0.8306910250254687, 0.8430921375776985, 0.8850276841342981, 0.41510221206851405, 0.4474309205498086, 0.4646678342448435, 0.42181029623292543, 0.3966553979385695, 0.444683560697799, 0.39459696934665234, 0.36893004744935665, 0.4093661973281292, 0.7143544638274251, 0.7577382714251154, 0.7322019816348977, 0.26409905400742173, 0.7290502365900307, 0.7884272417849916, 0.7199866937893713, 0.7321294332499688, 0.7189320474814243, 0.16039435527610224, 0.15742549655649796, 0.2654449988859736, 0.17697576671137571, 0.14734550348337938, 0.18289879374147244, 0.166052621708496, 0.2283081971126154, 0.17693165136043776, 0.17200270133957507, 0.12061424979794033, 0.1660552443869998, 0.1665195452275532, 0.1567046083200586, 0.17247667941674738, 0.22290826260620966, 0.17216360967266697, 0.19243779569298713, 0.020560231949384833, 0.07495940358583719, 9.999999999998899e-05, 0.043301276429738356, 0.09449513265274623, 0.0633254001602187, 0.030047279703410812, 0.019411275020904784, 0.013370622972252777, 0.18750246159294737, 0.11220077704757803, 0.14338541663026716, 0.11313459487406108, 0.06228512388486285, 0.07386016219463531, 0.14430545252518334, 0.12175577249664693, 0.11384149097000773, 0.11237723559273272, 0.06703715777861086, 0.05232267382526046, 0.13436811448266106, 0.08649257440157365, 0.08637022366099467, 0.07247571833760702, 0.08297120675127045, 0.09842323322318114, 0.1413995130365926, 0.17138415551363828, 0.10555237095487591, 0.14407344701848146, 0.15366735850566515, 0.20345552830078095, 0.11892933117410343, 0.13762072029340855, 0.1460616258712948, 0.5551960367907851, 0.5110185331293214, 0.5482026763354431, 0.5422508924487277, 0.5412887566176818, 0.564677315625301, 0.5633705936554931, 0.4932643544128126, 0.5940477178805921, 0.12887435672972603, 0.09547383191048375, 0.11033852232396058, 0.1154626268090202, 0.12192314505998314, 0.12845185200778264, 0.23926302324987891, 0.11027381503287648, 0.09617356909632613, 0.19992936190358557, 0.23073962667080639, 0.26469739117359137, 0.18314484887000515, 0.17438786805966733, 0.15588884468451236, 0.14065929926425846, 0.13935045985677008, 0.15205216935176158, 0.37895069171762874, 0.4230374109930304, 0.4345692325407041, 0.40058784666924685, 0.40561692857000275, 0.4483107423702425, 0.43594630022032765, 0.4263107070495422, 0.442753933761851, 0.3054504786618263, 0.3242121343355051, 0.2851947696665895, 0.27822442957140825, 0.3029318710015003, 0.3103910659061807, 0.34695312224676955, 0.30321571143453785, 0.32909391874691973, 0.2031632476913645, 0.220930199848, 0.21527373152555818, 0.20011440089099364, 0.19515854883637973, 0.21539160594368223, 0.18987194349580827, 0.23036854622294212, 0.2501146000282939, 0.2272306239467472, 0.1744044210351241, 0.18583256375139767, 0.19990424052800904, 0.19413080134477545, 0.19718927584938484, 0.20111024338746009, 0.18153264837602434, 0.20991239070606282, 0.763351917907463, 0.18254275020774435, 0.1498117812128683, 0.7117709296136054, 0.19422243993472021, 0.7945297682106216, 0.7612047959565978, 0.16745005871881347, 0.1448200875337612, 0.5989959695148808, 0.6965774134385101, 0.47215921098508995, 0.19844916611545538, 0.20126287767300632, 0.1650311561498662, 0.6590381239521609, 0.20856356355249084, 0.16075432076901686, 0.18089380536750754, 0.18598470090170616, 0.1767886391120541, 0.18557651581148948, 0.1737705066589057, 0.17684996996512914, 0.18160926332824134, 0.1776128549625422, 0.19422118441189973, 0.08135071858825504, 0.08069130347548947, 0.086861014799686, 0.08771495157884568, 0.08235617581314236, 0.08923466106187838, 0.08802644174079344, 0.08540793074418329, 0.08185081847272291]}, "mutation_prompt": null}
{"id": "cb6a8af8-a9cd-4bdb-aecc-1c314e6cb876", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "54f388a7-034c-4656-904c-4ce952d3f679", "solution": "import numpy as np\n\nclass Hybrid_CHDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Slightly lower to encourage exploitation\n        self.CR = 0.8  # Reduced for more adaptive exploration\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO with chaotic inertia)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_map(chaos_factor) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with adaptive crossover\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                adaptive_CR = self.CR * (1 - (evals / self.budget))  # Adaptive crossover\n                trial_vector = np.where(np.random.rand(self.dim) < adaptive_CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_CHDE", "description": "A hybrid algorithm combining chaotic maps for dynamic inertia adaptation and DE mutation strategy with adaptive crossover for improved convergence speed.", "configspace": "", "generation": 44, "fitness": 0.31693386562425385, "feedback": "The algorithm Hybrid_CHDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8454131962274953, 0.8428216492997407, 0.8595844178292525, 0.8359779562021248, 0.865531643711405, 0.8375740513581832, 0.8575307643635066, 0.8547716772921606, 0.8578732880215554, 0.5628694282247939, 0.7108470623089496, 0.6895008981486453, 0.6793814934827692, 0.7248787181773988, 0.7277693085171039, 0.6710805532004365, 0.6894090620952246, 0.6901913473737853, 0.1680832513954139, 0.11191626859924797, 0.1528946235579387, 0.15751041887330253, 0.15161883154994316, 0.15044903836670254, 0.16387609578444517, 0.13926130829848882, 0.17158985936087334, 0.09165399916835582, 0.0703580310591777, 0.11023423188867942, 0.10623982490544037, 0.10456872248390248, 0.10870968764238698, 0.14792816481558113, 0.1138551217995728, 0.09739049355331297, 0.9329396368568491, 0.9430129562511823, 0.9360383479101757, 0.9287421491613006, 0.9317589485894286, 0.9393975422702033, 0.9215443948512785, 0.927325736394056, 0.9442071150307886, 0.7137622078287716, 0.5058945490629496, 0.24826371960491045, 0.6605294753873215, 0.5193191731334367, 0.6756895265597467, 0.5505708540920264, 0.6096837322573794, 0.43094240290909636, 0.8797130656337826, 0.16595791583357478, 0.22457856567320467, 0.2748639528466541, 0.2751326055878568, 0.37364701496524844, 0.35104683915745816, 0.23649274114127716, 0.8555906405997615, 0.21770151876078736, 0.1293487583357823, 0.15199299056067173, 0.08387303643430333, 0.1669108578115458, 0.15487817742186338, 0.15925170013541956, 0.12687031658736636, 0.15750467282954883, 0.16007361074385718, 0.14473882198088817, 0.13799619302760202, 0.20988146390799733, 0.13854986331279873, 0.1783706233407707, 0.17968235511596198, 0.2189810153900551, 0.21858608274711466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010964684235239552, 0.008172228468058762, 0.02696918822101746, 0.037513410928374236, 9.999999999998899e-05, 0.11921482736510003, 0.09574670399944407, 0.08201540102060412, 0.08765500827075301, 0.08459666359376805, 0.028655183836628573, 0.027618117306382195, 0.15711861570954222, 0.0746829292152339, 0.06528195281014737, 0.21049139845197629, 0.19215222073537996, 0.28284016968034975, 0.0916082245939066, 0.07459056827536914, 0.06324670968594237, 0.1586480112803914, 0.17030094485316294, 0.10937847147028623, 0.2504763317379226, 0.025192982445498502, 0.154263995490328, 0.1881247507456596, 0.11731426359285291, 0.18815264915999186, 0.10529613254180825, 0.19999395891850447, 0.08184524788029335, 0.5946848220768013, 0.5035241571984126, 0.4952415147626025, 0.5871109940708459, 0.570674015199456, 0.493377912265054, 0.5575782939288569, 0.5417763185294326, 0.5270085223628074, 0.17278433430496776, 0.15094177808278986, 0.10386788057571172, 0.11522435713758006, 0.12947031505002038, 0.14645120533273182, 0.10487099467734429, 0.1287908325879713, 0.10633364028771486, 0.24412465522407778, 0.19363625730518597, 0.2026059081116055, 0.15294497605816249, 0.2238644915791429, 0.19854980997947758, 0.24445154030519456, 0.16356504760835233, 0.2638490826167291, 0.3731651740119065, 0.5294972342713355, 0.333586520007628, 0.4957564376469229, 0.32090566856024194, 0.32751296577453937, 0.39084217310426916, 0.5605665149942156, 0.47520040636789707, 0.21059079708533168, 0.22806618828144543, 0.38750195524343023, 0.3116666395900074, 0.3149043810962582, 0.37443919282365135, 0.2973414921970974, 0.32748634600286664, 0.30635658377925234, 0.20113933499320136, 0.23245609688929492, 0.17666882152367802, 0.204628115319069, 0.20174884476252042, 0.2005539422415885, 0.231179391895312, 0.2266715326573875, 0.2120743702971416, 0.20845946395851944, 0.21749562468741435, 0.18000586750739245, 0.20143321112644108, 0.2054563601708984, 0.1957689230840921, 0.21274724310617643, 0.20495971974736493, 0.19527657967134548, 0.1240797970932841, 0.8414088420185933, 0.15219432829841117, 0.8898792295220769, 0.1999350010209242, 0.87520455739268, 0.16147231791160976, 0.16780688880937122, 0.8774329744146505, 0.5973930825673432, 0.21004837265456888, 0.8010024418219023, 0.8170386142779997, 0.3733043906250355, 0.1662864054897304, 0.4292799746985736, 0.16563415127564274, 0.3023733076447255, 0.18139203990781394, 0.18813874052673596, 0.17885735350738885, 0.18630736384975544, 0.21297771771329488, 0.19142037314912796, 0.19587987644173688, 0.17650741868145214, 0.19744478560725898, 0.08632430577473094, 0.09504485038181609, 0.08904682178536183, 0.08337698361900858, 0.09740412341405369, 0.09433470883139561, 0.10832056157033254, 0.09439940632292021, 0.08371300684180172]}, "mutation_prompt": null}
{"id": "92c630d7-d489-496f-8e38-81e04dbde911", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "6676348b-8bdb-4de6-aab3-c4f578a3bae6", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "044495fe-eec1-447b-9614-9d56f6bfe9a9", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "4841d458-4af7-455f-88fc-f8cdf0b8dc5e", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "f32e4f75-a990-4691-b1b4-4d500bf768d4", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Particle Swarm Optimization parameters\n        self.num_particles = 50  # Increased particle count for diversity\n        self.inertia_weight = 0.9  # Higher inertia weight for global exploration\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6  # Slightly higher social impact for convergence\n\n        # Adaptive Differential Evolution parameters\n        self.base_F = 0.7  # Base scaling factor for adaptability\n        self.base_CR = 0.8  # Base crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.6, 0.6, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 3.9 * x * (1 - x)  # Adjusted chaotic map\n\n    def levy_flight(self, L):\n        beta = 1.7  # Adjusted beta for Lévy stability\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)  # Slightly broader range\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Adaptive Differential Evolution with Dynamic Lévy flights\n            for i in range(self.num_particles):\n                F = self.base_F + (0.2 * np.random.rand())  # Adaptive F\n                CR = self.base_CR + (0.1 * np.random.rand())  # Adaptive CR\n\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Dynamic Levy flights\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE", "description": "Enhanced Hybrid PSO with Adaptive Differential Evolution and Dynamic Lévy Flight for accelerated convergence.", "configspace": "", "generation": 49, "fitness": 0.3104793925437436, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8164674896424312, 0.8056266647282033, 0.8020546922517826, 0.8018946883450446, 0.8097722505589048, 0.8024748649345632, 0.810917639596038, 0.8171190715822966, 0.7922626342870862, 0.6115483761934564, 0.6077483662785601, 0.04290076739016824, 0.6032947353997944, 0.5848838710547535, 0.6135254557546783, 0.6427864204158833, 0.6219801810913719, 0.5450670359394706, 0.10652260657683887, 0.12401442822460362, 0.5566812144259733, 0.11824239824083893, 0.38099693310968985, 0.10595121557862497, 0.12857432627514032, 0.12109822024041039, 0.1099111330009257, 0.10359699741657913, 0.10391556750392028, 0.08825331479427856, 0.10723211747389672, 0.0942665350385139, 0.10586929560207425, 0.15029335566764712, 0.09020442589866362, 0.0991833019633439, 0.9309765956106285, 0.9133596486050246, 0.9495608516050881, 0.9372276149698908, 0.930102131196653, 0.9584834580575448, 0.9390987846209308, 0.9209963827742288, 0.9607841601860723, 0.6517390345784777, 0.5982462848055063, 0.5987527530952672, 0.6579761453577619, 0.5861445905132197, 0.5199986759142992, 0.617778537866702, 0.6076557353924024, 0.5094331282133718, 0.8753793824874014, 0.383531964262667, 0.8490041797589489, 0.27110658199091586, 0.2710233700562843, 0.2614060629018796, 0.7035464492983635, 0.37733957597698875, 0.1707038372697891, 0.22797535041822503, 0.12536034258168005, 0.12680313139654442, 0.12348624729650237, 0.17161324980049408, 0.12453304962527834, 0.23662686617124518, 0.15016248134461385, 0.17808564616451117, 0.18870111454383065, 0.19552837892004515, 0.21627301776799002, 0.30311606745052844, 0.15898073756459485, 0.1779675252525572, 0.19492546764807517, 0.17166350440577005, 0.1459573023659374, 0.00037259162810698854, 0.029060628908149866, 0.07217560695750924, 0.08649557048413259, 0.028293281145103766, 9.999999999998899e-05, 0.04638294285827482, 0.04338066338555835, 0.053126265536028616, 0.16086060885944842, 0.07974288152640152, 0.17279476713398345, 0.11250828224778398, 0.026663997196978872, 0.018828426420398836, 0.12386915673234566, 0.02282667970773178, 0.12826661586772137, 0.11044971354421318, 0.08744062389098328, 0.31701630966789274, 0.09718199554447238, 0.1583231982720541, 0.07230163339212481, 0.3481214732892284, 0.2741934499357763, 0.06533553414443305, 0.0773554558802938, 0.10072036544074014, 0.08364663307036502, 0.19638689768093387, 0.20059183088254617, 0.1192617438228919, 0.33159639139967256, 0.15410736139390324, 0.07913153348341462, 0.5487115818576309, 0.536845058919418, 0.5310934411322313, 0.5764228604705646, 0.5275118601083009, 0.5348903197576618, 0.5537390959057533, 0.5300461051804861, 0.5697106490684936, 0.11586317708860094, 0.13391356874049487, 0.36503086317878164, 0.13663814997078394, 0.13953209925360555, 0.09601890523281453, 0.11922400527872234, 0.11778787354784126, 0.09933354603471523, 0.22502390395138094, 0.2551006245258629, 0.17435086208004325, 0.30205229870050576, 0.16496120645659373, 0.16157560910142843, 0.2452091072443614, 0.16256975304430288, 0.5028533045730362, 0.2986843405759215, 0.24038489218525427, 0.417831439437202, 0.42522082472702805, 0.505628379545835, 0.33056468638802494, 0.5184983458504238, 0.547722243566918, 0.5696057632977386, 0.2494043715492994, 0.28393221195587404, 0.24913762076299373, 0.2985076225041192, 0.27841292506466897, 0.2940974439226335, 0.20478502866329695, 0.26230928753588745, 0.35240822151375406, 0.2508811254039285, 0.21119135759810137, 0.19732848731360764, 0.23422952867878744, 0.22183620354197153, 0.2181395576991152, 0.21518087501561045, 0.19302934979093211, 0.20807403301299188, 0.17891504902024458, 0.17655744000555296, 0.20891238280563262, 0.22225953426100564, 0.2162272089492543, 0.18121905341652167, 0.1869676333488589, 0.19638853693832614, 0.20340505487541927, 0.17879716063291584, 0.15935519687141386, 0.1694591548974098, 0.1931869203775729, 0.19794192987175407, 0.15621550092246106, 0.8500442304092248, 0.17059067453521093, 0.1753214749070281, 0.7255236090656092, 0.15505188443406148, 0.15042141238301265, 0.7149375758923435, 0.20673480656554055, 0.16724355969330318, 0.7729754386785226, 0.4071331963734529, 0.5468680018390921, 0.1762698228323365, 0.17431556281153193, 0.178953492863541, 0.17414548204127056, 0.17152405735642295, 0.17787290852020998, 0.19017554785025326, 0.17397854988975248, 0.19065101525454986, 0.09703206733227765, 0.08680475089409434, 0.08331005844770734, 0.08847239355227321, 0.08531961192193815, 0.10234567466562672, 0.1046212460817123, 0.07693099782470103, 0.08397682793856398]}, "mutation_prompt": null}
{"id": "d74da0eb-f13b-4e60-bf98-65944d2c3cb7", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "7c5f269d-b73d-4588-892c-d9844e2e3cb0", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted scaling factor\n        self.CR = 0.9  # Crossover probability remains high\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (evals / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform DE with mutation\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.005 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            chaos_factor = self.chaotic_map(chaos_factor)\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Dynamic Hybrid Particle Swarm with Adaptive Differential Evolution and Mutation Strategies for Accelerated Convergence.", "configspace": "", "generation": 51, "fitness": 0.2999897981210487, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8384995612939079, 0.8402211289742184, 0.7568306698471535, 0.8422856131297478, 0.840126766979683, 0.8057184279641865, 0.8188494436305966, 0.8411694883420626, 0.8166451819323347, 0.6931905373107115, 0.5055832583609443, 0.627635670914704, 0.6404797069572012, 0.44753162904486066, 0.6343312505136708, 0.6642629493061541, 0.671821577614732, 0.560111560018367, 0.10533005110365101, 0.11935130506201497, 0.20461436281091494, 0.10641373254391695, 0.10625200004516444, 0.12201163723993536, 0.104960023739751, 0.10770032114602235, 0.13184179488624836, 0.092773486740927, 0.10611242599944848, 0.10661949479208999, 0.17281341891706614, 0.12385115107538225, 0.1383011950556995, 0.10453507707022913, 0.11872224267699605, 0.10221330536936934, 0.9689472408191805, 0.9498607952424418, 0.9775498007135007, 0.9611513367036028, 0.9356564069862245, 0.9575944482888893, 0.930594492675182, 0.9677549423180125, 0.972212420692203, 0.5841305181507366, 0.6379847524448768, 0.3813620385626568, 0.6243374155568283, 0.5747786923302118, 0.5324415379316916, 0.12363336332967778, 0.3753393535489875, 0.28504940481418506, 0.4208301993169178, 0.22194377252747988, 0.309499966590295, 0.27575087769411766, 0.20667561826463465, 0.18972001219072576, 0.17591957682035497, 0.13718044775960514, 0.1728852084195538, 0.20338752656843817, 0.1676314176036583, 0.22947479950930982, 0.12734472019388143, 0.1539580563312658, 0.12243986717975475, 0.12314070945359945, 0.12453497276894099, 0.1412199998993119, 0.21167298575797955, 0.12845986562584533, 0.2140287957560537, 0.21142002533759008, 0.19204512895655934, 0.1976575829703383, 0.21565511627514444, 0.12511906740238898, 0.13388824271956112, 0.005022600487077589, 9.999999999998899e-05, 0.059227370150824354, 0.0003130434053900677, 0.03496929995443532, 0.028393842729680374, 0.011970018326751264, 0.022219974863253444, 9.999999999998899e-05, 0.07612773293855046, 0.09037631627057796, 0.07435914096619378, 0.11213765757936511, 0.0634397457615874, 0.10336431600046259, 0.12017285289650204, 0.0969916606746638, 0.08863716775877639, 0.05003232531064805, 0.15892092097134736, 0.04462846119673691, 0.17413402846702242, 0.18477167931902938, 0.06841283281380617, 0.12937596389224548, 0.29986151099285396, 0.13582668566907818, 0.2837829761814238, 0.2980880290716541, 0.10630402188112109, 0.1052120914398309, 0.2389889408611211, 0.12714691715625337, 0.10589408562368441, 0.16999597262895372, 0.07817811353074977, 0.5951948420610578, 0.5666466980135763, 0.5357075306453173, 0.5248819452566515, 0.603213450967991, 0.5944312404970704, 0.5771295359503266, 0.5717552464960192, 0.533188711649459, 0.07617553130448618, 0.0685672442058054, 0.11981681300933889, 0.10638754248158944, 0.1465992249489877, 0.12252674788328333, 0.15560417754170885, 0.1253427073189829, 0.10781473247982998, 0.17849223018196825, 0.14396380079748383, 0.32186712965663156, 0.25202707192321705, 0.2565396615253658, 0.1630418784443891, 0.310080039383799, 0.19445171286749063, 0.13168604571469478, 0.29073693604732953, 0.32011046329001225, 0.43248309464577983, 0.5374366955440213, 0.42816898061525943, 0.5308844061822993, 0.3044394982343054, 0.4220510421284801, 0.49665822117676317, 0.3715332944609321, 0.2479403735756337, 0.23102208387959489, 0.26115284281553, 0.23912883318401934, 0.29303018103622214, 0.328735741473797, 0.42146961341935407, 0.2792120614400868, 0.22527353599131872, 0.17995597001432084, 0.211839001276658, 0.19592953700365, 0.19520344534309908, 0.18526776252837418, 0.22616792851184087, 0.21558539478246563, 0.19330452259261266, 0.19116967706360366, 0.21587938989289013, 0.18286000770446853, 0.5254945678267591, 0.18904738866443516, 0.199583068483847, 0.2218085108330995, 0.22362425825394017, 0.21310697721679517, 0.8815973789861777, 0.126020914180766, 0.1521177411963638, 0.868143359674973, 0.20101336175813345, 0.19348370006064575, 0.14195397181872194, 0.16968002871925092, 0.8396370123074559, 0.8537050019936521, 0.21133538603863733, 0.7761799752121622, 0.20393682388032275, 0.46220958088691055, 0.1529210534080394, 0.20118952014562996, 0.21124044869491598, 0.5873499274926686, 0.1856850792631849, 0.17583952849516793, 0.18134456590123116, 0.20165562390278668, 0.18800282827324144, 0.18959455562375205, 0.18876864961865047, 0.18247340245341226, 0.18898987831193048, 0.08449882242364948, 0.08097680037264177, 0.07978230499814365, 0.08380435721713997, 0.07620605706560069, 0.08508260860142003, 0.07568657255316646, 0.078996945479619, 0.0852105596121131]}, "mutation_prompt": null}
{"id": "105037ff-31e0-4588-bd50-f9720a2e2983", "solution": "import numpy as np\n\nclass Fuzzy_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 50  # Increased for better diversity\n        self.inertia_weight = 0.5  # Variable inertia weight\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.8\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Modified scaling factor for balance\n        self.CR = 0.85  # Tweaked crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def fuzzy_inertia_weight(self, evals_ratio):\n        return 0.5 + 0.4 * np.tanh(10 * (evals_ratio - 0.5))\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        \n        while evals < self.budget:\n            evals_ratio = evals / self.budget\n            inertia_weight = self.fuzzy_inertia_weight(evals_ratio)\n            \n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * np.random.uniform(0.1, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n        return self.global_best_position, self.global_best_score", "name": "Fuzzy_Hybrid_APSO_DE", "description": "Fuzzy Logic Adaptive Hybrid Particle Swarm Optimization with Differential Evolution and Lévy Flights for accelerated convergence.", "configspace": "", "generation": 52, "fitness": 0.3159066194658782, "feedback": "The algorithm Fuzzy_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8563938360974103, 0.8637100524899977, 0.8600641303054157, 0.8394277759996432, 0.8625805346000046, 0.8816179193345499, 0.8676758248385438, 0.8717865235882012, 0.8604433154280152, 0.7118526977319476, 0.7238993442248138, 0.7462776101205065, 0.7340443844463163, 0.7243139731408268, 0.7202541594028338, 0.7410444326277907, 0.7397134523694833, 0.6236244425430062, 0.15288226651166348, 0.10400129106709133, 0.10396714583678679, 0.14440008394318082, 0.17011805151234516, 0.13871020438743165, 0.14085128423737403, 0.11684790530733158, 0.1372845088692577, 0.10487204227343594, 0.1094177666453452, 0.0946230166002644, 0.098946325711321, 0.13669988119423215, 0.09191174073114583, 0.10160466536133517, 0.10133403620350523, 0.08340618206847739, 0.8966160567419655, 0.9311212159179076, 0.9483213964624093, 0.821043401526683, 0.8892965882891066, 0.9338079167694566, 0.8656971990063647, 0.8344420516370799, 0.9094121117660658, 0.6031433241412401, 0.46031083774368, 0.5816664548350099, 0.66328791272134, 0.6200196820466766, 0.3938827981615014, 0.6063093677502831, 0.6050062157249734, 0.27209030949140556, 0.3537479318990724, 0.38088036740515885, 0.8342860731433253, 0.27791479250633655, 0.27330846264419073, 0.20981752903169504, 0.34861643908716944, 0.23123187225199404, 0.7838778931283021, 0.19660529303561514, 0.15292004286770267, 0.12149833376760366, 0.17845812029609553, 0.15325268209604037, 0.12390979798792523, 0.23974123756555843, 0.12999517058729904, 0.1729358608704561, 0.16400484157905737, 0.15338498228028186, 0.13255628365245453, 0.14852299693106819, 0.15979816724888152, 0.1802100122184047, 0.200909993174069, 0.12577431025867702, 0.13825287371895756, 9.999999999998899e-05, 0.05397773028303832, 9.999999999998899e-05, 0.0982205971075778, 0.0005163941681414208, 0.017861998359360753, 0.013445931045427462, 9.999999999998899e-05, 0.035889940378431184, 0.21511011496990218, 0.05477740789450869, 0.14201298642005622, 0.08210913275073561, 0.09794040800900472, 0.04595102212747426, 0.11185098335575316, 0.03241145650928523, 0.06674161938314682, 0.1668233768500197, 0.13609750164145207, 0.18420457281685765, 0.119560533543553, 0.1727012598499268, 0.08167074547766551, 0.14158825827869714, 0.3224804220590194, 0.07993241196442669, 0.13955778661427465, 0.14410014114398095, 0.2111332100645371, 0.20617160659588418, 0.24206269487477672, 0.168145142989506, 0.15969125979746568, 0.07048409662828559, 0.13024997638629754, 0.5827719704180111, 0.4829249574484573, 0.5391707595548059, 0.5457502246716972, 0.4723030778739028, 0.6360629204230328, 0.5877437443146651, 0.6062574220140122, 0.5381952750769117, 0.11650632153029561, 0.09941866213890116, 0.1320576750157657, 0.1507711742682617, 0.13974153577251014, 0.10956239658148847, 0.1527427851105515, 0.11497822347788611, 0.10319347089175879, 0.1919574029920874, 0.16009120909866614, 0.2633791714276882, 0.26671379892889235, 0.3540894049852241, 0.24753739641401995, 0.16045873748923112, 0.20589455427502734, 0.17110894401560495, 0.5800959138769566, 0.37408954753498924, 0.34655031460202734, 0.5457383626732658, 0.31201327656270406, 0.37629576715193147, 0.3422842585209789, 0.5115040478110877, 0.5974703546233713, 0.36018660617622944, 0.2937258403369797, 0.39957134940450023, 0.24639197057392426, 0.34827444548622255, 0.2491404097508858, 0.23981953314902038, 0.3249549742213479, 0.22506591925630381, 0.2001674113241083, 0.22365024161390157, 0.2002997025875377, 0.21625615016884236, 0.2227415334386108, 0.2206306007847918, 0.23221407843703112, 0.24224683446644157, 0.24417551426299322, 0.19631277674590242, 0.17696889688150308, 0.20668328898165, 0.21785855216400174, 0.22434045295031624, 0.19145725986076756, 0.20752655891963623, 0.20078432135484303, 0.24468291130123365, 0.8640311392111886, 0.1889499356816522, 0.14530946988284377, 0.8916418536471392, 0.1992530618160565, 0.14670535592923184, 0.1416062497508761, 0.8769067450654202, 0.8712531575026917, 0.46531075545725176, 0.21117757159422523, 0.7641964591812438, 0.20531100555226034, 0.1666170133886955, 0.16494844677624965, 0.2093942020138051, 0.26753449960114517, 0.6249506639977994, 0.18151452265439794, 0.184435865745186, 0.1746775529063067, 0.17182102812019406, 0.18402184983780268, 0.18688620185630278, 0.18921301850862882, 0.1804568567086846, 0.19292367531270826, 0.09165204208708733, 0.08885570694087475, 0.08629050924457626, 0.08759611474738938, 0.08859297223655305, 0.08616025953592377, 0.09422192147269248, 0.08444715298147365, 0.0951490434611183]}, "mutation_prompt": null}
{"id": "5939ec15-99c5-4a23-b4f7-5494a949b731", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "d9eaef43-c98a-47e7-ab8e-682454a94d6d", "solution": "import numpy as np\n\nclass Enhanced_Chaos_Swarm_Optimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 50  # Increased particles for better exploration\n        self.inertia_weight = 0.5  # Reduced inertia for faster convergence\n        self.cognitive_coeff = 1.8  # Adjusted cognitive component\n        self.social_coeff = 1.2  # Adjusted social component\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize particles, velocities, and learning rates\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.learning_rates = np.random.uniform(0.1, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        # Improved chaotic map for diversity\n        return np.sin(np.pi * x) * np.exp(-x)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Adaptive learning rate adjustment\n            for i in range(self.num_particles):\n                self.learning_rates[i] = np.clip(self.learning_rates[i] * (1 + 0.01*(self.personal_best_scores[i] - self.global_best_score)), 0.1, 0.5)\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n            self.positions += self.velocities * self.learning_rates\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Chaos_Swarm_Optimization", "description": "Enhanced Chaos-Guided Swarm Optimization with Adaptive Learning Rate for Improved Convergence.", "configspace": "", "generation": 54, "fitness": 0.31841426073976403, "feedback": "The algorithm Enhanced_Chaos_Swarm_Optimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8453128288143306, 0.8306550491394891, 0.8408799023167282, 0.830965369842656, 0.837795647281277, 0.8333150383494907, 0.8383825049262394, 0.8254199520325705, 0.8325467255320254, 0.6604928428713893, 0.5589586393656146, 0.5685747097788327, 0.683097890120075, 0.6988713878326256, 0.6511385846796168, 0.6990490638855995, 0.6448312624291972, 0.6564572614990287, 0.10664313630280997, 0.10143878771439863, 0.11572878466383096, 0.12280924725125775, 0.12174490718942055, 0.13441996072647944, 0.10800866540117127, 0.125324422786938, 0.14303376368585052, 0.09579624185946756, 0.10752499215156441, 0.09689112485354112, 0.12124391031821746, 0.13757491494590868, 0.12571977992213612, 0.1476536118058922, 0.10145897791939384, 0.1323987285338426, 0.9598660756741315, 0.9276160375389764, 0.9577582189854267, 0.9488213316714168, 0.9580548676164587, 0.9488537302704934, 0.95334614515955, 0.9594992069444649, 0.9618222330416635, 0.6741580194743045, 0.6804403777523704, 0.5809924020222235, 0.6645345940660614, 0.6168305935579401, 0.621300012768208, 0.6805395123933577, 0.08710498342543038, 0.6674462417535664, 0.8434116190468084, 0.37900075825587687, 0.22554543662334214, 0.2792934796391896, 0.2771350281129612, 0.21132336477174285, 0.22576124923772267, 0.8064846628703324, 0.8512497897576168, 0.3701245513594167, 0.2715779907588778, 0.17144415099635113, 0.15144081113042063, 0.18253846010794172, 0.12903839377031168, 0.19817229638373723, 0.23919373701377467, 0.17481760389557022, 0.21481203729256848, 0.1975592745165945, 0.09911557174921437, 0.13055234642002522, 0.1832960037090663, 0.17481964974266395, 0.23550059561420134, 0.1812319410167198, 0.1916969920333359, 0.018909961744446813, 0.018365058864612593, 0.029233211759860933, 0.041408093223097464, 0.1036019061060297, 0.010075861877750003, 0.021178897404920516, 0.001844542202386057, 0.14115044465773896, 0.14465917825718044, 0.08318528897358646, 0.10219524917854417, 0.09700420612040905, 0.08133866670861045, 0.034175419499151594, 0.06266738021588958, 0.09692475571123105, 0.07668358205332881, 0.057242267582919726, 0.05028224118919877, 0.21098970680197904, 0.11044258545054053, 0.07259337823507173, 0.2113669228669678, 0.09263369318870651, 0.20018906740777143, 0.22879167633787678, 0.14988734609714538, 0.225265261091935, 0.22796552059962616, 0.14263372175068156, 0.21099394903006985, 0.22987216561398538, 0.08166039040159834, 0.17440226108216517, 0.08155821960037557, 0.5886644303153723, 0.5254924685397556, 0.587632236529101, 0.5195566746204077, 0.6090799616477822, 0.5505663810861878, 0.578317397926904, 0.58907327069245, 0.5911850950712892, 0.09068416111429434, 0.1313893837213327, 0.10974676438999942, 0.11453857026758485, 0.15078468179661653, 0.11830271522747715, 0.11251043381611203, 0.09902486038350122, 0.11292985351619422, 0.18449228257521377, 0.3698910514261252, 0.17020775061132576, 0.15366812625961723, 0.14648427971869782, 0.1385415958705113, 0.30497488682643703, 0.2199442453756586, 0.15571400640744182, 0.30257862885802045, 0.40603260434809607, 0.3515390158570164, 0.4627365799562909, 0.4384774736716903, 0.3954204822908728, 0.5646272502648821, 0.4038471164793537, 0.5168795556743528, 0.2694074433135638, 0.3026975823889567, 0.3069583269096917, 0.3425876792455872, 0.36033034243838213, 0.32837063824425305, 0.25885742836887526, 0.3721514030619649, 0.3644579039700273, 0.2097121200270321, 0.2008639850899796, 0.21425533333015345, 0.18360253492608303, 0.23065594014613355, 0.19351611048354955, 0.20958940328535203, 0.2013986577327781, 0.21476644560354086, 0.21811075612274522, 0.1946976482688838, 0.2142121065935455, 0.23319869786093628, 0.5328990326070631, 0.24553236233566544, 0.23198075705226073, 0.24051239057611062, 0.20827584695216184, 0.2048182891673026, 0.16188129264325157, 0.16430251912489202, 0.1855097838468187, 0.7757499359864206, 0.878696200290189, 0.8176129188734973, 0.16925376169033768, 0.1468391237652038, 0.7935079479900786, 0.21127253147032576, 0.7625221515428213, 0.20717338816929787, 0.12725715014529038, 0.16598404815507817, 0.20954078723412395, 0.2099764389539246, 0.3462445728820055, 0.18489287630969253, 0.17913474041814714, 0.1872418567253542, 0.1709769381206686, 0.20497376723744232, 0.18236417215502942, 0.18946703920486896, 0.18181371301979776, 0.187282928198776, 0.07709804655922492, 0.09412010548226135, 0.0888738404419317, 0.0909417837578056, 0.07906348448260214, 0.08710783531039124, 0.07746418854865655, 0.09774140841471557, 0.07899052584283306]}, "mutation_prompt": null}
{"id": "9e83075d-b13b-4446-977d-2dcaadb63553", "solution": "import numpy as np\n\nclass Hybrid_SADE_CPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 40\n        self.w_min, self.w_max = 0.4, 0.9  # Dynamic inertia weight range\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Self-Adaptive Differential Evolution (SADE) parameters\n        self.F_base = 0.8\n        self.CR_base = 0.9\n\n        # Initialize\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        \n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 3.9 * x * (1 - x)  # Adjusted parameter for chaotic map\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (CPSO with SADE)\n            inertia_weight = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Self-Adaptive Differential Evolution (SADE)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                F = self.F_base + np.random.normal(0, 0.1)\n                CR = self.CR_base + np.random.normal(0, 0.1)\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            chaos_factor = self.chaotic_map(chaos_factor)\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_SADE_CPSO", "description": "Integrating Self-Adaptive Differential Evolution and Chaotic Sequences with Particle Swarm for enhanced convergence.", "configspace": "", "generation": 55, "fitness": 0.2938537689220061, "feedback": "The algorithm Hybrid_SADE_CPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.859125424472392, 0.8494961348147746, 0.8499158628029913, 0.8321506524578124, 0.8545552762900133, 0.8436400906482896, 0.8165726643973429, 0.8513961148780159, 0.7814752874178282, 0.30535843909179916, 0.6435840097724437, 0.03301131459293705, 0.6675168223650673, 0.6842795613434733, 0.7078706853412631, 0.5226236023684441, 0.6414837991888557, 0.05679705572646254, 0.12047712461779247, 0.1170729539214892, 0.0981441588113261, 0.10199754197238309, 0.12800186593770468, 0.10707471974466842, 0.14077557236962535, 0.1725500916532432, 0.1163503425923127, 0.10710313531832127, 0.12295500138003312, 0.1513310024614657, 0.10355271651128384, 0.11241117606650874, 0.10306104575880248, 0.11441060903563671, 0.11441557871379904, 0.07965619868931262, 0.9591569778917481, 0.9740350068019096, 0.9716076615979493, 0.9662533651443262, 0.9554457476904877, 0.9656235276633973, 0.9699789853394138, 0.9563935386314937, 0.9660425155772792, 0.5747252810752377, 0.6469104960183841, 0.059290210279633215, 0.5504397985221902, 0.6244627722899151, 0.5690479579415257, 0.57351929228196, 0.40139345890426115, 0.47420443771148624, 0.17148062987187784, 0.21940248851728306, 0.7789403170990337, 0.2722136632235639, 0.19014407727637261, 0.1908522387130902, 0.21356675159444216, 0.6508661315673463, 0.8014216025038614, 0.24804011963800043, 0.12476281856723015, 0.1005820054945028, 0.18898325397081905, 0.12829122202022059, 0.12776946484163143, 0.17011457204731983, 0.11554096235481481, 0.17869277769946235, 0.19787030668417516, 0.16422857980359584, 0.14759675529565952, 0.20748154121572748, 0.20424562193057805, 0.32398897944795957, 0.18297386850245523, 9.999999999998899e-05, 0.1085363009748922, 9.999999999998899e-05, 0.010901478060692193, 0.017347949664667794, 0.000363439840640023, 0.07020638745148533, 9.999999999998899e-05, 0.006128126510552612, 0.001015902299000837, 9.999999999998899e-05, 0.05612745519811979, 0.056725782279504866, 0.0454126626753808, 0.1059057944357582, 0.0374480641088456, 0.11544812968295859, 0.09448945696487554, 0.08161450789556601, 0.05881945494581142, 0.16304618549596195, 0.09757450585436123, 0.048255339156450305, 0.2571725837714516, 0.07605995503869034, 9.999999999998899e-05, 0.3491901039125819, 0.09363572117433827, 0.10005283791856512, 0.10539697603354614, 0.07252535778642522, 0.0706732445609195, 0.0062194890246013435, 0.09897784378681207, 0.09780837002688092, 0.10776761942217694, 0.05964095221862664, 0.23689483468118122, 0.5286552699701883, 0.5851071012233136, 0.5764659301070816, 0.5516901338701037, 0.6386528863922416, 0.5921309880248348, 0.5840638003254107, 0.5398115863860373, 0.5846930958478563, 0.08653729567290103, 0.08886597492897186, 0.10756269109715244, 0.10729527461327815, 0.11132583953330466, 0.09197129972695184, 0.10200752549519299, 0.11456805729547959, 0.10342027882361804, 0.1491521387561363, 0.20141629623392865, 0.20791111569426657, 0.1778350620820618, 0.2478027908245044, 0.3017541052301512, 0.16622398130913718, 0.166200961690664, 0.14685941649975298, 0.3480890058302555, 0.3508762254137552, 0.24052703496339212, 0.3703464944985516, 0.3293919386682378, 0.3748030969505529, 0.5199134172197666, 0.514530781859226, 0.41948776810869226, 0.27834428891868623, 0.3310574241785119, 0.2624217743355559, 0.29756159300296514, 0.2718782924787565, 0.29732073165388173, 0.3317093991106971, 0.2754625937719003, 0.33499468096846374, 0.20437980208890116, 0.18802520769924724, 0.19942949755688422, 0.2202007841549496, 0.2180570606092912, 0.19214748935046133, 0.206448782031589, 0.17835184276493188, 0.1919175790610902, 0.2216476589423947, 0.20591250102122083, 0.20223552635163855, 0.2088647023803788, 0.2215698573460806, 0.2193629446921036, 0.20033488357386797, 0.19562063574645683, 0.20400096882971497, 0.18690609564161154, 0.16804928526944662, 0.1525269960644624, 0.903665736427416, 0.2005325072387385, 0.8961321677177765, 0.14137101482116632, 0.16868414993753245, 0.21137566756176474, 0.3291784360340575, 0.2123201286970411, 0.627359908478401, 0.7130062377405604, 0.7434234216272347, 0.15953768144108615, 0.10417611716982866, 0.4021629741164373, 0.8287177167153158, 0.17320905125859132, 0.16915323873623567, 0.18377528625998119, 0.16907683210632019, 0.18508481913527008, 0.1767992631557176, 0.1786351650608462, 0.1834401682250757, 0.20599286944177353, 0.08220723081702686, 0.08641073136872546, 0.08407855740585968, 0.08537840985406386, 0.08133118021543362, 0.0731740446948399, 0.07678086580055166, 0.08678802518934647, 0.07610871431835609]}, "mutation_prompt": null}
{"id": "9c934bed-0b67-4b27-b4f6-0cdc72ce1af9", "solution": "import numpy as np\n\nclass Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid APSO parameters\n        self.num_particles = 40  # Adjusted particle count for balance\n        self.inertia_weight = 0.7  # Dynamic inertia weight for improved stability\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Differential Evolution parameters\n        self.F = 0.9  # Enhanced scaling factor for exploration\n        self.CR = 0.9  # Enhanced crossover probability\n\n        # Initialize particles and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        \n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Hybrid APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Perform Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n\n        return self.global_best_position, self.global_best_score", "name": "Hybrid_APSO_DE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Evolution and Lévy Flights for efficient global search.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8183385441116307, 0.7846233459550631, 0.8005221447097088, 0.8238274188929875, 0.7822924803158775, 0.7818314893914208, 0.8023347252977432, 0.7886320667322564, 0.7717866745644415, 0.6672209648981999, 0.629852626333074, 0.6003520547098133, 0.6439114743931387, 0.5581145435884551, 0.6071497148477449, 0.6470915977241846, 0.6167866148403651, 0.6061337429497171, 0.13193678527929897, 0.13848474192115423, 0.1450655927927642, 0.16325572240326236, 0.1286226080207441, 0.126533548770699, 0.40011440128984443, 0.12995317189487776, 0.1397820588992137, 0.11688389664148346, 0.11030790997879225, 0.10978842349057538, 0.10675291979403623, 0.0997693291912557, 0.10021301322060117, 0.10366254374757244, 0.08810457449096432, 0.11101140304418022, 0.9264458310547967, 0.8860587654822514, 0.9285621859565093, 0.9202109769096619, 0.9253691769554087, 0.9064879349795731, 0.9245269078980134, 0.8788986978833329, 0.9348932255434574, 0.5755037915869721, 0.538710074826478, 0.47761343368062215, 0.5793721243048204, 0.46926138735180434, 0.5458129334799531, 0.5460926664487125, 0.5348189432218637, 0.4312818521191183, 0.8274918919658388, 0.7623848193623552, 0.7529319078539067, 0.8308153553516573, 0.8145298925776395, 0.7109331655552054, 0.7936731018799714, 0.778197642857005, 0.8046663354556131, 0.3304577286622743, 0.1839042192841589, 0.19527474525141164, 0.24145271569034132, 0.2430132335031283, 0.12901545501383394, 0.17027150329140073, 0.20043357562795983, 0.1924205948425124, 0.1688226800277398, 0.20623225998623396, 0.17798673510150598, 0.2160910213533931, 0.20323196562531043, 0.17867428988790857, 0.24608236911940407, 0.21253427011443837, 0.23943960515646479, 0.06771165876819485, 0.10614640704643175, 0.030395814929258802, 0.015075914361637466, 0.052994451989199276, 0.024821900059547986, 0.05548980964663297, 0.08808684978829973, 0.10173499375496375, 0.18699804412496523, 0.11698424865686596, 0.1205604269592031, 0.10774768564347692, 0.1504120582329328, 0.10831129955291341, 0.16388918562877441, 0.17078741206875125, 0.13310001009511474, 0.11684510926752023, 0.06097887824880277, 0.08112356342051952, 0.15586020872480932, 0.0885960651904214, 0.165781787989431, 0.16345238984719235, 0.22390100816108438, 0.14273817895153096, 0.09468144588366156, 0.16701622777177616, 0.13906944123493525, 0.31297727434946665, 0.22809922523021842, 0.15244793178206184, 0.16862137199422322, 0.19910001935133081, 0.14546410766476658, 0.5823735817191478, 0.5533199591900311, 0.5967285871032315, 0.5705258237027383, 0.5568803054634552, 0.6011914559900284, 0.5450227786094047, 0.5868617095255961, 0.6097974769818071, 0.1516429154330644, 0.15545902040550685, 0.13210300808508235, 0.1573351769585437, 0.11209783654514616, 0.10853639136463666, 0.11935626925409726, 0.12699926901491032, 0.10927569191650288, 0.1858742934400177, 0.15089073570013423, 0.25922596608384096, 0.18915627639658017, 0.1531058462217345, 0.422662439672734, 0.14888464517582523, 0.1366568866259784, 0.18519161703533904, 0.5052458252264734, 0.423784252226481, 0.35549698906169924, 0.4576763965876445, 0.25693523550946973, 0.47560332622896473, 0.483992640688202, 0.48618065861214055, 0.4925253495104508, 0.44265904086608077, 0.29411977692639657, 0.23302967351349257, 0.26106217400623744, 0.21571270268851184, 0.31684810836025834, 0.22722331977705867, 0.23100728286767813, 0.39436032023642653, 0.20210709629364088, 0.1917261689023575, 0.19696016584740306, 0.2030690187033063, 0.19282335704439768, 0.20407543846783738, 0.22774467325725334, 0.21199049925434843, 0.2097497485252059, 0.19521323094656695, 0.19005851351794467, 0.22940669460882257, 0.20961117323286094, 0.20268704717840946, 0.20939153159449364, 0.20573387994024206, 0.20044745611774906, 0.1965996780573379, 0.7855091731114049, 0.1810135804673363, 0.1451899946254962, 0.8476437294833369, 0.19756273209090036, 0.19467385202362386, 0.1726818371570038, 0.7907666444549595, 0.1461229464021433, 0.8033135165576257, 0.20635604359345128, 0.2046723219158798, 0.20553756231574594, 0.20217794445517234, 0.20054143527475188, 0.2023666807699427, 0.7334014960227642, 0.2094607702604422, 0.18585109134240152, 0.17831559149639342, 0.17242417181424097, 0.18955641278067636, 0.18520118336097557, 0.18469037564660207, 0.18127462274079742, 0.18545345340963482, 0.1776899134874308, 0.08785724218226665, 0.09044401967368798, 0.08863457528060859, 0.08645281785654191, 0.08380203296834643, 0.08918194493862497, 0.09077003594402833, 0.09645380522467184, 0.07762426728025618]}, "mutation_prompt": null}
{"id": "f297485f-494e-44f5-8d09-a677c6d670e6", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 30  # Reduced particle count for exploration-exploitation balance\n        self.inertia_weight = 0.6  # Further dynamic inertia for convergence control\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.7\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Base scaling factor\n        self.CR_base = 0.8  # Base crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.5 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Hybrid Algorithm combining Adaptive Multi-Swarm PSO with Adaptive Mutation Strategy for improved convergence speed.", "configspace": "", "generation": 57, "fitness": 0.3297699803471785, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "179fad37-b069-4bff-a0e7-0028f6d223ea", "metadata": {"aucs": [0.8202509724435536, 0.8286463783964011, 0.8314438115579863, 0.8250378271088424, 0.8284319028717263, 0.8318715535174002, 0.8246274194080301, 0.8436564616873843, 0.8375884792382629, 0.7084942567382813, 0.7101005791290572, 0.689604250772142, 0.7139574965124752, 0.6353824256248041, 0.6901260396801652, 0.668650575272562, 0.7003175493614089, 0.6946506098583027, 0.1371191395234258, 0.10661224751510656, 0.1515470059099584, 0.13356074714392874, 0.14898650372279265, 0.14716153239853935, 0.113876798523188, 0.13241975766796732, 0.12384490038983165, 0.12014424789847578, 0.10965863486898053, 0.12837172884901593, 0.10418454487754336, 0.09791145400765144, 0.09470459370369466, 0.12132303567503677, 0.11641529790652816, 0.0935920813015586, 0.9149955697673609, 0.9264579295726042, 0.9524983373606788, 0.9378216224091614, 0.9379441027221203, 0.9285191415739553, 0.895437155353285, 0.8984103168525003, 0.9188067142212943, 0.5707713705468973, 0.560158513321797, 0.6117034943970523, 0.614587832835173, 0.6132406512891682, 0.5691290777023439, 0.6046799417207387, 0.5811263047360729, 0.5854254812503943, 0.7487040495967497, 0.7781222780576396, 0.3460380873919585, 0.3440668259841003, 0.8305571274484389, 0.19974339207470349, 0.8107766989274727, 0.3531968458940562, 0.795169524307018, 0.1889128188543716, 0.18987677645641465, 0.17121605124235628, 0.12311906190129795, 0.2240364788161875, 0.18882530369740458, 0.19413399414679355, 0.24407138888719293, 0.19767190581384553, 0.11309618780602848, 0.1658032549879188, 0.19801255036595689, 0.2366501941457695, 0.237753674793029, 0.1290008417761057, 0.22704725267057335, 0.1664293304580129, 0.20683477658120697, 0.008305714230815497, 0.013816548029104925, 0.009854723907953722, 0.04186673503025651, 0.0033040262889156846, 0.07809263689803192, 0.10128253505251827, 9.999999999998899e-05, 0.00044934464153978393, 0.1274430615651394, 0.12724526922687052, 0.12066888517517382, 0.13089564189917768, 0.06887984250129853, 0.11909846966810422, 0.14577866382405757, 0.1314974791622786, 0.11907206465142495, 0.16505653827868505, 0.06992739611589549, 0.2977822463922535, 0.1910332508039433, 0.249395995070416, 0.19253279699774783, 0.13769988830421864, 0.20543100666426217, 0.11184498562511613, 0.10333858981863031, 0.19253859432780118, 0.3256795693286898, 0.18631603311631195, 0.24878518842750386, 0.1495170558190162, 0.11155501055542905, 0.12733918903878205, 0.2496482539853253, 0.5996481143801348, 0.5694993506758397, 0.5236247953873849, 0.570767845032667, 0.5488336077811267, 0.5583400879787479, 0.5793276712773134, 0.5428493848385928, 0.579026655813415, 0.0981344195546251, 0.11756274444671311, 0.13673227680543898, 0.15669982550458228, 0.13321353635170197, 0.1142708143901433, 0.11065937020743899, 0.12254286094841649, 0.09379963712317219, 0.13405720977540603, 0.1482965050486329, 0.16224745856963507, 0.1583847071142922, 0.1465134511474342, 0.12449266761771183, 0.14189811262063157, 0.14876209706058086, 0.144274717653046, 0.3258963211887621, 0.4350820198577252, 0.48839068844877453, 0.5152051496501491, 0.24053131013387585, 0.47126728939941886, 0.5078994533878761, 0.5918247761074172, 0.4535347539422868, 0.43078880087298443, 0.24312665136670553, 0.29175385748985583, 0.19017827795354758, 0.2160815754524209, 0.26708906647274056, 0.2762269920538797, 0.2664321397741264, 0.20411980440719257, 0.18658353102867709, 0.21960115313335005, 0.20428862356033717, 0.20420088672588488, 0.21501033710724005, 0.22098274284716712, 0.19087112881690116, 0.18819029735712023, 0.2294656875563802, 0.21866033577757604, 0.22401249372671173, 0.21066482428694122, 0.18676043524312547, 0.2347481742310259, 0.2202910755497931, 0.6735039894158759, 0.2164679158257602, 0.19608924169831976, 0.1783758558901667, 0.18338617796609336, 0.8823557653471623, 0.13568096913185113, 0.1967670054259092, 0.8480636846098769, 0.7894332363565284, 0.7619560669009715, 0.642442967783377, 0.8533088711470951, 0.1540837434618093, 0.16335585615884152, 0.6221938252525968, 0.12626929635800876, 0.7911486615613991, 0.20707922080591157, 0.20992700040824552, 0.15359297405139483, 0.20129509693663072, 0.1833587204778906, 0.1815406541756226, 0.17840709128847998, 0.1906391815100762, 0.18209000438836387, 0.18523054672656292, 0.18297873220678407, 0.1789768482070998, 0.0912075031906967, 0.08879093193168541, 0.07753879960044852, 0.09112941602306801, 0.09153168056558281, 0.08349349165876518, 0.0823848938840932, 0.09093692203747938, 0.09115603241133063]}, "mutation_prompt": null}
{"id": "6683f34e-e0a7-4c71-99fe-a4248e920fa7", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 30  # Reduced particle count for exploration-exploitation balance\n        self.inertia_weight = 0.6  # Further dynamic inertia for convergence control\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.7\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Base scaling factor\n        self.CR_base = 0.8  # Base crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.5 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Hybrid Algorithm combining Adaptive Multi-Swarm PSO with Adaptive Mutation Strategy for improved convergence speed.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f297485f-494e-44f5-8d09-a677c6d670e6", "metadata": {"aucs": [0.8202509724435536, 0.8286463783964011, 0.8314438115579863, 0.8250378271088424, 0.8284319028717263, 0.8318715535174002, 0.8246274194080301, 0.8436564616873843, 0.8375884792382629, 0.7084942567382813, 0.7101005791290572, 0.689604250772142, 0.7139574965124752, 0.6353824256248041, 0.6901260396801652, 0.668650575272562, 0.7003175493614089, 0.6946506098583027, 0.1371191395234258, 0.10661224751510656, 0.1515470059099584, 0.13356074714392874, 0.14898650372279265, 0.14716153239853935, 0.113876798523188, 0.13241975766796732, 0.12384490038983165, 0.12014424789847578, 0.10965863486898053, 0.12837172884901593, 0.10418454487754336, 0.09791145400765144, 0.09470459370369466, 0.12132303567503677, 0.11641529790652816, 0.0935920813015586, 0.9149955697673609, 0.9264579295726042, 0.9524983373606788, 0.9378216224091614, 0.9379441027221203, 0.9285191415739553, 0.895437155353285, 0.8984103168525003, 0.9188067142212943, 0.5707713705468973, 0.560158513321797, 0.6117034943970523, 0.614587832835173, 0.6132406512891682, 0.5691290777023439, 0.6046799417207387, 0.5811263047360729, 0.5854254812503943, 0.7487040495967497, 0.7781222780576396, 0.3460380873919585, 0.3440668259841003, 0.8305571274484389, 0.19974339207470349, 0.8107766989274727, 0.3531968458940562, 0.795169524307018, 0.1889128188543716, 0.18987677645641465, 0.17121605124235628, 0.12311906190129795, 0.2240364788161875, 0.18882530369740458, 0.19413399414679355, 0.24407138888719293, 0.19767190581384553, 0.11309618780602848, 0.1658032549879188, 0.19801255036595689, 0.2366501941457695, 0.237753674793029, 0.1290008417761057, 0.22704725267057335, 0.1664293304580129, 0.20683477658120697, 0.008305714230815497, 0.013816548029104925, 0.009854723907953722, 0.04186673503025651, 0.0033040262889156846, 0.07809263689803192, 0.10128253505251827, 9.999999999998899e-05, 0.00044934464153978393, 0.1274430615651394, 0.12724526922687052, 0.12066888517517382, 0.13089564189917768, 0.06887984250129853, 0.11909846966810422, 0.14577866382405757, 0.1314974791622786, 0.11907206465142495, 0.16505653827868505, 0.06992739611589549, 0.2977822463922535, 0.1910332508039433, 0.249395995070416, 0.19253279699774783, 0.13769988830421864, 0.20543100666426217, 0.11184498562511613, 0.10333858981863031, 0.19253859432780118, 0.3256795693286898, 0.18631603311631195, 0.24878518842750386, 0.1495170558190162, 0.11155501055542905, 0.12733918903878205, 0.2496482539853253, 0.5996481143801348, 0.5694993506758397, 0.5236247953873849, 0.570767845032667, 0.5488336077811267, 0.5583400879787479, 0.5793276712773134, 0.5428493848385928, 0.579026655813415, 0.0981344195546251, 0.11756274444671311, 0.13673227680543898, 0.15669982550458228, 0.13321353635170197, 0.1142708143901433, 0.11065937020743899, 0.12254286094841649, 0.09379963712317219, 0.13405720977540603, 0.1482965050486329, 0.16224745856963507, 0.1583847071142922, 0.1465134511474342, 0.12449266761771183, 0.14189811262063157, 0.14876209706058086, 0.144274717653046, 0.3258963211887621, 0.4350820198577252, 0.48839068844877453, 0.5152051496501491, 0.24053131013387585, 0.47126728939941886, 0.5078994533878761, 0.5918247761074172, 0.4535347539422868, 0.43078880087298443, 0.24312665136670553, 0.29175385748985583, 0.19017827795354758, 0.2160815754524209, 0.26708906647274056, 0.2762269920538797, 0.2664321397741264, 0.20411980440719257, 0.18658353102867709, 0.21960115313335005, 0.20428862356033717, 0.20420088672588488, 0.21501033710724005, 0.22098274284716712, 0.19087112881690116, 0.18819029735712023, 0.2294656875563802, 0.21866033577757604, 0.22401249372671173, 0.21066482428694122, 0.18676043524312547, 0.2347481742310259, 0.2202910755497931, 0.6735039894158759, 0.2164679158257602, 0.19608924169831976, 0.1783758558901667, 0.18338617796609336, 0.8823557653471623, 0.13568096913185113, 0.1967670054259092, 0.8480636846098769, 0.7894332363565284, 0.7619560669009715, 0.642442967783377, 0.8533088711470951, 0.1540837434618093, 0.16335585615884152, 0.6221938252525968, 0.12626929635800876, 0.7911486615613991, 0.20707922080591157, 0.20992700040824552, 0.15359297405139483, 0.20129509693663072, 0.1833587204778906, 0.1815406541756226, 0.17840709128847998, 0.1906391815100762, 0.18209000438836387, 0.18523054672656292, 0.18297873220678407, 0.1789768482070998, 0.0912075031906967, 0.08879093193168541, 0.07753879960044852, 0.09112941602306801, 0.09153168056558281, 0.08349349165876518, 0.0823848938840932, 0.09093692203747938, 0.09115603241133063]}, "mutation_prompt": null}
{"id": "7fa6ee48-d412-432b-8f50-73312b4b8345", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 30  # Reduced particle count for exploration-exploitation balance\n        self.inertia_weight = 0.6  # Further dynamic inertia for convergence control\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.7\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Base scaling factor\n        self.CR_base = 0.8  # Base crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.5 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Hybrid Algorithm combining Adaptive Multi-Swarm PSO with Adaptive Mutation Strategy for improved convergence speed.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f297485f-494e-44f5-8d09-a677c6d670e6", "metadata": {"aucs": [0.8202509724435536, 0.8286463783964011, 0.8314438115579863, 0.8250378271088424, 0.8284319028717263, 0.8318715535174002, 0.8246274194080301, 0.8436564616873843, 0.8375884792382629, 0.7084942567382813, 0.7101005791290572, 0.689604250772142, 0.7139574965124752, 0.6353824256248041, 0.6901260396801652, 0.668650575272562, 0.7003175493614089, 0.6946506098583027, 0.1371191395234258, 0.10661224751510656, 0.1515470059099584, 0.13356074714392874, 0.14898650372279265, 0.14716153239853935, 0.113876798523188, 0.13241975766796732, 0.12384490038983165, 0.12014424789847578, 0.10965863486898053, 0.12837172884901593, 0.10418454487754336, 0.09791145400765144, 0.09470459370369466, 0.12132303567503677, 0.11641529790652816, 0.0935920813015586, 0.9149955697673609, 0.9264579295726042, 0.9524983373606788, 0.9378216224091614, 0.9379441027221203, 0.9285191415739553, 0.895437155353285, 0.8984103168525003, 0.9188067142212943, 0.5707713705468973, 0.560158513321797, 0.6117034943970523, 0.614587832835173, 0.6132406512891682, 0.5691290777023439, 0.6046799417207387, 0.5811263047360729, 0.5854254812503943, 0.7487040495967497, 0.7781222780576396, 0.3460380873919585, 0.3440668259841003, 0.8305571274484389, 0.19974339207470349, 0.8107766989274727, 0.3531968458940562, 0.795169524307018, 0.1889128188543716, 0.18987677645641465, 0.17121605124235628, 0.12311906190129795, 0.2240364788161875, 0.18882530369740458, 0.19413399414679355, 0.24407138888719293, 0.19767190581384553, 0.11309618780602848, 0.1658032549879188, 0.19801255036595689, 0.2366501941457695, 0.237753674793029, 0.1290008417761057, 0.22704725267057335, 0.1664293304580129, 0.20683477658120697, 0.008305714230815497, 0.013816548029104925, 0.009854723907953722, 0.04186673503025651, 0.0033040262889156846, 0.07809263689803192, 0.10128253505251827, 9.999999999998899e-05, 0.00044934464153978393, 0.1274430615651394, 0.12724526922687052, 0.12066888517517382, 0.13089564189917768, 0.06887984250129853, 0.11909846966810422, 0.14577866382405757, 0.1314974791622786, 0.11907206465142495, 0.16505653827868505, 0.06992739611589549, 0.2977822463922535, 0.1910332508039433, 0.249395995070416, 0.19253279699774783, 0.13769988830421864, 0.20543100666426217, 0.11184498562511613, 0.10333858981863031, 0.19253859432780118, 0.3256795693286898, 0.18631603311631195, 0.24878518842750386, 0.1495170558190162, 0.11155501055542905, 0.12733918903878205, 0.2496482539853253, 0.5996481143801348, 0.5694993506758397, 0.5236247953873849, 0.570767845032667, 0.5488336077811267, 0.5583400879787479, 0.5793276712773134, 0.5428493848385928, 0.579026655813415, 0.0981344195546251, 0.11756274444671311, 0.13673227680543898, 0.15669982550458228, 0.13321353635170197, 0.1142708143901433, 0.11065937020743899, 0.12254286094841649, 0.09379963712317219, 0.13405720977540603, 0.1482965050486329, 0.16224745856963507, 0.1583847071142922, 0.1465134511474342, 0.12449266761771183, 0.14189811262063157, 0.14876209706058086, 0.144274717653046, 0.3258963211887621, 0.4350820198577252, 0.48839068844877453, 0.5152051496501491, 0.24053131013387585, 0.47126728939941886, 0.5078994533878761, 0.5918247761074172, 0.4535347539422868, 0.43078880087298443, 0.24312665136670553, 0.29175385748985583, 0.19017827795354758, 0.2160815754524209, 0.26708906647274056, 0.2762269920538797, 0.2664321397741264, 0.20411980440719257, 0.18658353102867709, 0.21960115313335005, 0.20428862356033717, 0.20420088672588488, 0.21501033710724005, 0.22098274284716712, 0.19087112881690116, 0.18819029735712023, 0.2294656875563802, 0.21866033577757604, 0.22401249372671173, 0.21066482428694122, 0.18676043524312547, 0.2347481742310259, 0.2202910755497931, 0.6735039894158759, 0.2164679158257602, 0.19608924169831976, 0.1783758558901667, 0.18338617796609336, 0.8823557653471623, 0.13568096913185113, 0.1967670054259092, 0.8480636846098769, 0.7894332363565284, 0.7619560669009715, 0.642442967783377, 0.8533088711470951, 0.1540837434618093, 0.16335585615884152, 0.6221938252525968, 0.12626929635800876, 0.7911486615613991, 0.20707922080591157, 0.20992700040824552, 0.15359297405139483, 0.20129509693663072, 0.1833587204778906, 0.1815406541756226, 0.17840709128847998, 0.1906391815100762, 0.18209000438836387, 0.18523054672656292, 0.18297873220678407, 0.1789768482070998, 0.0912075031906967, 0.08879093193168541, 0.07753879960044852, 0.09112941602306801, 0.09153168056558281, 0.08349349165876518, 0.0823848938840932, 0.09093692203747938, 0.09115603241133063]}, "mutation_prompt": null}
{"id": "863aca56-b8ff-4296-bb26-727e0d9265e5", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 30  # Reduced particle count for exploration-exploitation balance\n        self.inertia_weight = 0.6  # Further dynamic inertia for convergence control\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.7\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Base scaling factor\n        self.CR_base = 0.8  # Base crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.5 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.1, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.chaotic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced Hybrid Algorithm combining Adaptive Multi-Swarm PSO with Adaptive Mutation Strategy for improved convergence speed.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f297485f-494e-44f5-8d09-a677c6d670e6", "metadata": {"aucs": [0.8202509724435536, 0.8286463783964011, 0.8314438115579863, 0.8250378271088424, 0.8284319028717263, 0.8318715535174002, 0.8246274194080301, 0.8436564616873843, 0.8375884792382629, 0.7084942567382813, 0.7101005791290572, 0.689604250772142, 0.7139574965124752, 0.6353824256248041, 0.6901260396801652, 0.668650575272562, 0.7003175493614089, 0.6946506098583027, 0.1371191395234258, 0.10661224751510656, 0.1515470059099584, 0.13356074714392874, 0.14898650372279265, 0.14716153239853935, 0.113876798523188, 0.13241975766796732, 0.12384490038983165, 0.12014424789847578, 0.10965863486898053, 0.12837172884901593, 0.10418454487754336, 0.09791145400765144, 0.09470459370369466, 0.12132303567503677, 0.11641529790652816, 0.0935920813015586, 0.9149955697673609, 0.9264579295726042, 0.9524983373606788, 0.9378216224091614, 0.9379441027221203, 0.9285191415739553, 0.895437155353285, 0.8984103168525003, 0.9188067142212943, 0.5707713705468973, 0.560158513321797, 0.6117034943970523, 0.614587832835173, 0.6132406512891682, 0.5691290777023439, 0.6046799417207387, 0.5811263047360729, 0.5854254812503943, 0.7487040495967497, 0.7781222780576396, 0.3460380873919585, 0.3440668259841003, 0.8305571274484389, 0.19974339207470349, 0.8107766989274727, 0.3531968458940562, 0.795169524307018, 0.1889128188543716, 0.18987677645641465, 0.17121605124235628, 0.12311906190129795, 0.2240364788161875, 0.18882530369740458, 0.19413399414679355, 0.24407138888719293, 0.19767190581384553, 0.11309618780602848, 0.1658032549879188, 0.19801255036595689, 0.2366501941457695, 0.237753674793029, 0.1290008417761057, 0.22704725267057335, 0.1664293304580129, 0.20683477658120697, 0.008305714230815497, 0.013816548029104925, 0.009854723907953722, 0.04186673503025651, 0.0033040262889156846, 0.07809263689803192, 0.10128253505251827, 9.999999999998899e-05, 0.00044934464153978393, 0.1274430615651394, 0.12724526922687052, 0.12066888517517382, 0.13089564189917768, 0.06887984250129853, 0.11909846966810422, 0.14577866382405757, 0.1314974791622786, 0.11907206465142495, 0.16505653827868505, 0.06992739611589549, 0.2977822463922535, 0.1910332508039433, 0.249395995070416, 0.19253279699774783, 0.13769988830421864, 0.20543100666426217, 0.11184498562511613, 0.10333858981863031, 0.19253859432780118, 0.3256795693286898, 0.18631603311631195, 0.24878518842750386, 0.1495170558190162, 0.11155501055542905, 0.12733918903878205, 0.2496482539853253, 0.5996481143801348, 0.5694993506758397, 0.5236247953873849, 0.570767845032667, 0.5488336077811267, 0.5583400879787479, 0.5793276712773134, 0.5428493848385928, 0.579026655813415, 0.0981344195546251, 0.11756274444671311, 0.13673227680543898, 0.15669982550458228, 0.13321353635170197, 0.1142708143901433, 0.11065937020743899, 0.12254286094841649, 0.09379963712317219, 0.13405720977540603, 0.1482965050486329, 0.16224745856963507, 0.1583847071142922, 0.1465134511474342, 0.12449266761771183, 0.14189811262063157, 0.14876209706058086, 0.144274717653046, 0.3258963211887621, 0.4350820198577252, 0.48839068844877453, 0.5152051496501491, 0.24053131013387585, 0.47126728939941886, 0.5078994533878761, 0.5918247761074172, 0.4535347539422868, 0.43078880087298443, 0.24312665136670553, 0.29175385748985583, 0.19017827795354758, 0.2160815754524209, 0.26708906647274056, 0.2762269920538797, 0.2664321397741264, 0.20411980440719257, 0.18658353102867709, 0.21960115313335005, 0.20428862356033717, 0.20420088672588488, 0.21501033710724005, 0.22098274284716712, 0.19087112881690116, 0.18819029735712023, 0.2294656875563802, 0.21866033577757604, 0.22401249372671173, 0.21066482428694122, 0.18676043524312547, 0.2347481742310259, 0.2202910755497931, 0.6735039894158759, 0.2164679158257602, 0.19608924169831976, 0.1783758558901667, 0.18338617796609336, 0.8823557653471623, 0.13568096913185113, 0.1967670054259092, 0.8480636846098769, 0.7894332363565284, 0.7619560669009715, 0.642442967783377, 0.8533088711470951, 0.1540837434618093, 0.16335585615884152, 0.6221938252525968, 0.12626929635800876, 0.7911486615613991, 0.20707922080591157, 0.20992700040824552, 0.15359297405139483, 0.20129509693663072, 0.1833587204778906, 0.1815406541756226, 0.17840709128847998, 0.1906391815100762, 0.18209000438836387, 0.18523054672656292, 0.18297873220678407, 0.1789768482070998, 0.0912075031906967, 0.08879093193168541, 0.07753879960044852, 0.09112941602306801, 0.09153168056558281, 0.08349349165876518, 0.0823848938840932, 0.09093692203747938, 0.09115603241133063]}, "mutation_prompt": null}
{"id": "b529ff21-2e4d-4546-bd13-7cf6bb5c79c1", "solution": "import numpy as np\n\nclass Enhanced_Multi_heuristic_Optimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Particle Swarm Optimization parameters\n        self.num_particles = 40  # Increased particle count for better exploration\n        self.inertia_weight = 0.7  # Dynamic inertia for balance\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n\n        # Adaptive Mutation Strategy parameters\n        self.F_base = 0.9  # Slightly higher base scaling factor\n        self.CR_base = 0.7  # Lower base crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        return 4.0 * x * (1 - x)  # Logistic map for chaotic sequence\n\n    def adaptive_mutation(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def quantum_perturbation(self, L):\n        return np.random.normal(0, 1, L)\n\n    def __call__(self, func):\n        evals = 0\n        chaos_factor = np.random.rand()\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Guided PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * chaos_factor\n            self.positions += self.velocities * np.random.uniform(0.2, 0.6, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Mutation with Quantum-inspired Dynamics\n            F = self.adaptive_mutation(iter_count, self.budget)\n            for i in range(self.num_particles):\n                indices = [idx for idx in range(self.num_particles) if idx != i]\n                x1, x2, x3 = self.positions[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Quantum perturbation for diverse exploration\n                quantum_steps = self.quantum_perturbation(self.dim)\n                trial_vector += 0.02 * quantum_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            chaos_factor = self.logistic_map(chaos_factor)  # Update chaos factor for next iteration\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Multi_heuristic_Optimization", "description": "Enhanced Multi-heuristic Optimization combines Guided Particle Swarm with Adaptive Mutation and Quantum-inspired Dynamics for improved search efficiency.", "configspace": "", "generation": 61, "fitness": 0.31556900683041783, "feedback": "The algorithm Enhanced_Multi_heuristic_Optimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "f297485f-494e-44f5-8d09-a677c6d670e6", "metadata": {"aucs": [0.8049819566704556, 0.8149444422448537, 0.8024690940756831, 0.8147891934504152, 0.8219674481067156, 0.8036752566865148, 0.7895926995058288, 0.8147019409110168, 0.7742784613334919, 0.6471691967443833, 0.6545116393670674, 0.5865993081092435, 0.6402819285636947, 0.516749167798451, 0.6319034123915792, 0.6509005903705408, 0.668708073858681, 0.6155781305392528, 0.11816195484649639, 0.1300937779289787, 0.12512017511391782, 0.162298093319743, 0.1435093905129814, 0.29651175410962594, 0.1259823483434469, 0.1228395970281102, 0.11450529026919976, 0.11181597911531937, 0.1286876470279602, 0.12570511810094465, 0.10111643009133409, 0.12243790146625355, 0.10567962725341273, 0.09348113926801271, 0.11516391047892616, 0.1263908296808448, 0.970961158070814, 0.9472586043577396, 0.917120140622752, 0.9242596967449289, 0.945166241841494, 0.9083646856319008, 0.9312894053289675, 0.9570661244430162, 0.9171277118818216, 0.5876295535319179, 0.5594497294963938, 0.5031796391976958, 0.5255180474794001, 0.45927730609764916, 0.5021589480770801, 0.5768761967894613, 0.539186761332102, 0.5433368231240507, 0.7657184028467852, 0.23586977394131126, 0.6973199575635056, 0.27104821432670156, 0.26752356668513166, 0.2017339401026298, 0.21925402398778182, 0.8337864695106466, 0.8072285147492649, 0.16297706153780633, 0.20704933813720694, 0.14554882291204307, 0.17232208420022876, 0.19599730087099565, 0.17556277372881957, 0.16050006222116409, 0.1530900231473732, 0.16155728720978446, 0.20054872225024512, 0.20302426273081642, 0.20910683843198374, 0.1491500570377351, 0.18980618815901806, 0.12458222962391396, 0.19401594143478595, 0.21258120926795054, 0.20238732085648048, 0.052491739976975094, 0.030963156638582734, 0.028808358384834865, 0.058925876082469575, 0.09458955255676793, 9.999999999998899e-05, 0.0069788982561985735, 9.999999999998899e-05, 0.009630251809423895, 0.14509407030644905, 0.029611287540463826, 0.11378731860969205, 0.14849790522758544, 0.04062139875551707, 0.07040309758839536, 0.1404706649699674, 0.09777186643750069, 0.10495711041419908, 0.15872374498062403, 0.08323364372892816, 0.048075313413115106, 0.20415500526214847, 0.2932576533309884, 0.1172705723667703, 0.14706227315894504, 0.11189340345770848, 0.127327539378164, 0.16118199555542578, 0.0764748555930238, 0.1810936374044726, 0.1500323338840459, 0.08715550240114645, 0.13876375834877475, 0.1521494256445478, 0.09791123054529127, 0.09136091190183637, 0.5360687436558204, 0.5283195290027499, 0.5252230552258739, 0.6009050620913425, 0.6398222368332634, 0.5046419297226943, 0.5354963297433482, 0.5660369844030553, 0.5624172164978247, 0.141344753798616, 0.12168725870327524, 0.12653487068259706, 0.1266689415051031, 0.12762536527381796, 0.15168903276466594, 0.14066817616694405, 0.12400788870605173, 0.10097861673195552, 0.19533073324431538, 0.41703774742681476, 0.1569595009938406, 0.1464673004792334, 0.27065705704239706, 0.12965504489966517, 0.25725640509056524, 0.20801429246810754, 0.13463076415516584, 0.37448624801192987, 0.32735815977646787, 0.32596638554420176, 0.2987972007351495, 0.45746844382997676, 0.3829058605416046, 0.38642190612573435, 0.47283862978675484, 0.45751719210738495, 0.24150609232755582, 0.35520253164992643, 0.20094609706679578, 0.26607562777182514, 0.2545519984809672, 0.21739189558222916, 0.2610741670372886, 0.3911469784793753, 0.2207910457162955, 0.20446559076777926, 0.1922184618900583, 0.21422083621727672, 0.1968722992392975, 0.20380277836118543, 0.20594323729851982, 0.19737365857577827, 0.22306227389660094, 0.2438485982399743, 0.22615624884386532, 0.20005243997855882, 0.18695257306665702, 0.19018824425050596, 0.1984042778500127, 0.5408953560777348, 0.21933943581766935, 0.21862066992505047, 0.20029990822272448, 0.7773248378596133, 0.1886148997677155, 0.15099930386078053, 0.8284136607877288, 0.19811102278973047, 0.17922782332374299, 0.7995733551902063, 0.7957836611090638, 0.752423738881603, 0.8672905034372516, 0.2082707011379311, 0.5190584902987018, 0.461933723932464, 0.12641452052198587, 0.20429985617323687, 0.47702260327072565, 0.2107649229425722, 0.37328976491776944, 0.18000080927877748, 0.2093626163075153, 0.1882817458135022, 0.1972653763195099, 0.16962433374628305, 0.17528626582359574, 0.18812534125277947, 0.19525937079383304, 0.19059791787112512, 0.07570123417777774, 0.09361245568088872, 0.0855905316434955, 0.07569907413373489, 0.08658678369021366, 0.08150355798796005, 0.08025661917217308, 0.0791722163653682, 0.10210822859341373]}, "mutation_prompt": null}
{"id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 62, "fitness": 0.37171158773994456, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "f297485f-494e-44f5-8d09-a677c6d670e6", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "d2e1dbe7-fdb1-44cd-9aa2-bff6bb47c865", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE_Modified:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Adjusted parameters for enhanced performance\n        self.num_particles = 50  # Increased particles for better diversity\n        self.inertia_weight = 0.8  # Modified inertia for improved exploration-exploitation balance\n        self.cognitive_coeff = 2.0  # Enhanced cognitive behavior\n        self.social_coeff = 1.3  # Reduced social influence for exploration\n\n        # Differential Evolution parameters\n        self.F_base = 0.8  # Fine-tuned scaling factor\n        self.CR_base = 0.85  # Adjusted crossover probability\n\n        # Initialization\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_inertia(self, iter_count):\n        return 0.9 - iter_count * (0.5 / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter):\n        return self.F_base + 0.4 * np.exp(-current_iter / self.budget)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.adaptive_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.05, 0.25, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = np.random.choice(range(self.num_particles), 3, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.005 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE_Modified", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution and Lévy Flights for enhanced convergence through diversified exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.19024354922708314, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE_Modified got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.4346168632217261, 0.40752751026567946, 0.4512056941374665, 0.3082705415830024, 0.45078102691170063, 0.42218041518810767, 0.41146846137698145, 0.4331682686585122, 0.4582814833741984, 0.0045501747500821255, 0.07445871066715404, 0.02320484880901663, 0.09058804632869921, 0.10136678393145993, 0.03535864217837903, 0.12643430038446024, 0.04356584459624013, 0.1391113834348212, 0.09855342208123752, 0.09617769660814868, 0.1043547356731438, 0.09075360927722709, 0.1090173519641281, 0.10359436566925018, 0.08337107237980657, 0.08847577807769991, 0.10067210952213845, 0.07701517070458708, 0.09840837696798677, 0.08639379131412661, 0.06299702111548522, 0.07523712594064913, 0.05375182434154213, 0.07271407890643677, 0.046871169847453875, 0.06930331985368188, 0.9621104598067677, 0.9539359556861422, 0.9747249963182925, 0.9446676864978466, 0.9437049847730241, 0.9549213484663379, 0.9480136230580278, 0.9497123202778014, 0.9631459186524057, 0.15209573682640876, 0.15787474804242485, 0.16629527989806703, 0.12803794972415505, 0.15128225470272572, 0.1823244346730185, 0.14654885346362734, 0.12923245024564334, 0.12342644382701162, 0.23013876813669787, 0.2848160244657536, 0.30230331306680136, 0.19087545797097694, 0.19364060068068178, 0.3166371409046249, 0.24855275791180764, 0.20858337605504862, 0.21126852887417014, 0.11503626033398429, 0.12850230301215237, 0.13049271544955243, 0.11011514044829729, 0.1308030135364524, 0.16179723255524792, 0.1413324289439355, 0.11961301316382811, 0.1223222291502809, 0.11237911979127091, 0.046495474554971716, 0.1449801299838397, 0.17638854676004667, 0.14386971473883114, 0.1480112243966445, 0.15229776782793525, 0.10002385577844797, 0.1578884312824541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020991944051549583, 0.09687622432607645, 0.0763036117740914, 0.06256543352432542, 0.08722789608473502, 0.04837760531450164, 0.06309938560145623, 0.07108239902316471, 0.055848200869143105, 0.10521733185005178, 9.999999999998899e-05, 0.029250209394264703, 0.002692556473309793, 0.024898028713929654, 0.012604348224296347, 0.028772546520376308, 0.011260855589583674, 0.0059262295200993576, 9.999999999998899e-05, 0.08371821158420267, 0.029036049775511885, 0.0695037533479963, 0.09640639749785274, 0.10205833677056375, 0.08219469370675525, 0.04138737536419956, 0.04050294858215653, 0.06366711176074058, 0.4064315812447239, 0.3753338678822239, 0.35706400665126925, 0.4077144945914297, 0.3181206829851587, 0.43501242750357305, 0.3902469005499851, 0.3974480635865456, 0.4077433287976815, 0.08694534082744998, 0.08518701287177788, 0.07374661429648599, 0.09003620526838019, 0.084834810568301, 0.1031316931425279, 0.0688645988151404, 0.08205389485858028, 0.08984727952957439, 0.20713087290323628, 0.17861363799125374, 0.13807328035540778, 0.16739259378725824, 0.15192861682502823, 0.138898361834778, 0.15021841640383649, 0.16045509796233182, 0.12999454096036256, 0.2736386215964949, 0.26344121542214183, 0.23376884101558293, 0.26893940319625786, 0.25774931235992127, 0.20166938150055158, 0.27556515991507036, 0.2630178857239307, 0.28385545917485266, 0.170500213889772, 0.21216186559433814, 0.20801424793671286, 0.19501036674966477, 0.1544107192015084, 0.21366206432221047, 0.18852991532207275, 0.1859774878300231, 0.1987861820278315, 0.19302960889758858, 0.16722866840508543, 0.21757526058209165, 0.18884229813801634, 0.16984170411182842, 0.18698431458378562, 0.19797426944070506, 0.17531390689680704, 0.21284680442470294, 0.1774445666700214, 0.18915333745172735, 0.1738462300348932, 0.18975275528008784, 0.17423011260023435, 0.16629259993243273, 0.1765262638648274, 0.1831454383994804, 0.16860881643097914, 0.24507866533467781, 0.15196788391855665, 0.14999087312675785, 0.22680731636624085, 0.19133344517246698, 0.18652545856813674, 0.41140778597399463, 0.15805067736238287, 0.4351327912620002, 0.19077045030412887, 0.16824211216771068, 0.19879324189709413, 0.1250399600433042, 0.18790381059993277, 0.14817673342068083, 0.19504115115058407, 0.17112855197206878, 0.315556642678841, 0.1869390100164382, 0.194170515182724, 0.19437128372668955, 0.19229566201786064, 0.17897460003490873, 0.1998442786949658, 0.179067559437041, 0.2041284377724112, 0.18717360506420078, 0.0879643422743226, 0.06684631657061513, 0.07918232814722648, 0.07579814957221676, 0.07417470666184223, 0.0657776693988108, 0.08154747068192214, 0.06818572978258142, 0.07192317477327292]}, "mutation_prompt": null}
{"id": "42f1b675-45fe-4aa2-bf53-ca7e7c28b7f7", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_Chaos_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm parameters\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.5  # Varying inertia for flexibility\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 1.0\n\n        # Differential Evolution parameters\n        self.F_base = 0.8  # Adjusted F for better adaptive exploration\n        self.CR_base = 0.85  # Balanced crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.9 * np.sin(np.pi * iter_count / self.budget)\n\n    def adaptive_mutation(self, current_iter):\n        return self.F_base + 0.4 * (1 - current_iter / self.budget)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.2, 0.4, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with Lévy flights\n            F = self.adaptive_mutation(iter_count)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n\n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_Chaos_DE", "description": "A hybrid swarm and evolutionary optimizer with chaotic exploration and differential evolution refinement for accelerated convergence.", "configspace": "", "generation": 64, "fitness": 0.3482857095921441, "feedback": "The algorithm Enhanced_Hybrid_Chaos_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.785351963943503, 0.7766838065446127, 0.7922531061272212, 0.7774362614565078, 0.7800641516390912, 0.7976377784504439, 0.8012836751362846, 0.7954212374909129, 0.794926158761716, 0.6278748869314511, 0.6220558277315053, 0.6212086396416795, 0.605141337347489, 0.6223022937846907, 0.618187829459306, 0.634503130839844, 0.6343024331817028, 0.6440224287917686, 0.14201110814565532, 0.1349655433865251, 0.16684813681074773, 0.1371002788321123, 0.14927218516454, 0.1638799810588345, 0.14479094623797062, 0.12525627427456942, 0.45709626942153525, 0.1318871663099095, 0.11693606331275097, 0.11731485384528406, 0.10118857596301478, 0.09883538584518536, 0.1229149274780924, 0.1057962400508422, 0.1469953330375161, 0.1135374400995377, 0.8882034638591226, 0.8939051179151623, 0.9114199412180289, 0.8454368911763279, 0.8723428844991037, 0.8757650191920693, 0.9217129339205278, 0.8826444885784105, 0.8786354657214175, 0.4414105576764491, 0.49145484353734226, 0.4590341762903022, 0.49890689578439396, 0.4795746321921137, 0.47016335508907536, 0.48802971289575603, 0.5044338933521567, 0.4462265954888086, 0.8119578175297957, 0.7966482551581733, 0.7902875256654087, 0.7771881394699887, 0.8229677133405631, 0.8199850922139797, 0.7901089689837604, 0.7841066230305889, 0.7870275447367537, 0.268166363026752, 0.2874811189947786, 0.34186579539981554, 0.28976447232488145, 0.33023953845939236, 0.304688345708098, 0.25949733310223666, 0.2578563942119594, 0.25931061316275117, 0.2351167565183908, 0.21541545384515914, 0.19816847905169477, 0.3805357099007193, 0.40315225274549105, 0.19220244657472407, 0.3188109546107044, 0.11794555254427419, 0.25822122429465666, 0.07755874711799937, 0.0884542147391505, 0.26999500345212546, 0.025973788845710777, 0.07487636140578857, 0.03389910475643898, 0.05681686573610256, 0.018070402571602973, 0.0755188761768153, 0.16740296641494534, 0.12210714231134312, 0.17610426958265268, 0.11988532358134418, 0.10357391239022729, 0.19058585931061678, 0.18143543977710863, 0.16385270589427492, 0.13647723900179465, 0.09534642484009548, 0.12119502606041987, 0.12304723023977182, 0.21428147047617263, 0.10622117267205633, 0.13026997312589395, 0.13160730303875812, 0.10795276743080062, 0.14677986284412714, 0.23092710072938638, 0.18854799311586545, 0.1743830148506137, 0.20045175256002035, 0.23912336963534486, 0.25494785154009647, 0.22345384921133082, 0.2408601247217862, 0.15438453711720246, 0.5688415119828005, 0.5534849998182446, 0.5926095741976765, 0.5822699862860178, 0.5797737175575993, 0.5703373699825922, 0.6161320100342476, 0.600901485584516, 0.6350247575426256, 0.12296344384333113, 0.16086312699794458, 0.13485185206457084, 0.5208128925489883, 0.13163800563983874, 0.12350766307477956, 0.12845184312577984, 0.1425927501364509, 0.1096920710817465, 0.17588022431051764, 0.5421007395254933, 0.4497465143221666, 0.4207375508299226, 0.2516480290217441, 0.1985144065826444, 0.2540566721998887, 0.16074786438357747, 0.18333353143860542, 0.44558219816598943, 0.45102724980963604, 0.5065699189119722, 0.4490891059853901, 0.47160103525943153, 0.4446759140854666, 0.5391923752032883, 0.49344745622809527, 0.4609055727313205, 0.31491812929970764, 0.3189690739370351, 0.4034664716890799, 0.39112563078855156, 0.3066804734930192, 0.33203893067638945, 0.44299972550887345, 0.3891949231256453, 0.41254035600080996, 0.20907697433639594, 0.21644140162078596, 0.20444326627712806, 0.199089146753203, 0.1831610741203572, 0.2209424842117872, 0.2028779896575651, 0.22461787689054336, 0.2170063070159255, 0.19499656234519347, 0.5442778969050852, 0.22251009059643756, 0.6181654804752876, 0.20818723130147476, 0.20960245718994097, 0.19831801275612915, 0.19974109745672775, 0.18843457836523714, 0.837679886142917, 0.18361801446727932, 0.15131244097112373, 0.8223095773063959, 0.19695403942642697, 0.19164009174505292, 0.17289347793151233, 0.17095734300963816, 0.15457854459988007, 0.7827663652532195, 0.8106179916859232, 0.7416780682927646, 0.20508422480834765, 0.1667275326742229, 0.12616437791728385, 0.20899005399338, 0.20980215161921845, 0.11077399413806688, 0.19999626386666713, 0.20054740924525516, 0.18561803475591687, 0.18887436483161213, 0.19817122927953656, 0.18197302393295556, 0.18307399757468035, 0.17467353479726133, 0.1826640105246503, 0.09111049856053233, 0.09677215484224544, 0.08896743138543517, 0.10130787755482729, 0.0906629293427701, 0.07835173242775617, 0.09966855022877119, 0.09479154422174707, 0.07884138845643829]}, "mutation_prompt": null}
{"id": "607ea3fe-ce21-4e66-9c7b-5614a9e52f9c", "solution": "import numpy as np\n\nclass Chaotic_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Hybrid PSO-DE parameters\n        self.num_particles = 50  # Increased particle count for better sampling\n        self.inertia_weight_decay = 0.99  # Introduced decay in inertia weight\n        self.inertia_weight = 0.9  # Starting value\n        self.cognitive_coeff = 2.0  # Adjusted coefficients for improved search\n        self.social_coeff = 1.3\n\n        # DE parameters\n        self.F_base = 0.8  # More aggressive scaling factor\n        self.CR_base = 0.85  # Balancing exploration and exploitation\n\n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_search(self, iter_count):\n        return 0.5 * (1 + np.sin(3 * np.pi * iter_count / self.budget))\n\n    def adaptive_mutation_factor(self, current_iter):\n        return self.F_base * np.exp(-5 * current_iter / self.budget)\n\n    def levy_flight(self, L, scale=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return scale * step\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            self.inertia_weight *= self.inertia_weight_decay\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_search(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            F = self.adaptive_mutation_factor(iter_count)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = np.random.choice(range(self.num_particles), 3, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                trial_vector += self.levy_flight(self.dim)\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Chaotic_Hybrid_PSO_DE", "description": "Enhanced hybrid particle swarm and differential evolution algorithm with chaotic search and dynamic learning for faster convergence.", "configspace": "", "generation": 65, "fitness": 0.23070669769302996, "feedback": "The algorithm Chaotic_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.590675501815029, 0.6530830469767321, 0.713009509481724, 0.7400110729686693, 0.5917899042654615, 0.6725791813410003, 0.65718450969397, 0.6764050186331342, 0.6655734051707234, 0.42106507046255426, 0.226722986387212, 0.4003396147395252, 0.32318520683397023, 0.49103529904567766, 0.2496984675031022, 0.26091325324320147, 0.2056785990266209, 0.4550809998289257, 0.08715208534461816, 0.11797241763625732, 0.10070364007083499, 0.136106265763271, 0.06641528322284462, 0.05845958155466746, 0.07996711836347181, 0.08407279445577442, 0.08397150589754276, 0.08611833551459513, 0.10167120554935483, 0.06506850406936626, 0.04554509430307041, 0.08816996389341236, 0.07226501263953711, 0.1007886773778004, 0.09820486366103165, 0.07693280448862572, 0.9640565612085414, 0.9595872578810811, 0.9640484858259668, 0.9584435348934108, 0.965926863708833, 0.9576055189444368, 0.9663957162392188, 0.9723804916811677, 0.9635052515450995, 0.21592352766085565, 0.18203048765653618, 0.2428651715982576, 0.31031979565494605, 0.14286217470089702, 0.13912872151111422, 0.35669245518677484, 0.12634120269423654, 0.20862132794010446, 0.20778665586541578, 0.27094563867487875, 0.2207029576386269, 0.18838225073967818, 0.1991768702227128, 0.2144232413826831, 0.1712341392980643, 0.17184743342028852, 0.2392618454633928, 0.22667024686498394, 0.13544749658125343, 0.17755224222523935, 0.16680681631208205, 0.17333477728716118, 0.10345850970453763, 0.16793118063589352, 0.16138886944748132, 0.12907574988367687, 0.18499151720845852, 0.12258118276361618, 0.2120349504179534, 0.12038083775665198, 0.14466967281357024, 0.20060880426784367, 0.17707848380587343, 0.18811652790984024, 0.17402201789147187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017670293863247255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06213096369411397, 0.06389688403519389, 0.03676182108349024, 0.05741896346852604, 0.07376184392706508, 0.04264637012075745, 0.02316753131209992, 0.06039471158804499, 0.03674941022455391, 0.08286871720522326, 0.02816788069525078, 0.05077789160272317, 0.03767772009630521, 0.056773788149304893, 0.06592220259728798, 0.10416006949260115, 0.03164647373752616, 0.04294761212832621, 0.030322179398284188, 0.07867713841644708, 0.08255790362996962, 0.10409304374671569, 0.09730311387565693, 0.13325856384857637, 0.06100730166467361, 0.0736485046315809, 0.053629149631338024, 0.07655131170684892, 0.47259189631204734, 0.4237785095733342, 0.46552879241806167, 0.4669928390620457, 0.4525937789599407, 0.46151182710034977, 0.4803607276043188, 0.5017443868521261, 0.4436919409803428, 0.08530606558774356, 0.07155627329457859, 0.06700789024654275, 0.10915488527153872, 0.07831360117668795, 0.10881162222522112, 0.09228559469796871, 0.06667585229565198, 0.09191391789429149, 0.15663618261764545, 0.16875843718615746, 0.15337928888442454, 0.13410801598099864, 0.14908871416880953, 0.12211876399674348, 0.21373936692196405, 0.13334319907483838, 0.211285343535082, 0.39851315963811895, 0.2524000488381746, 0.2769063820197716, 0.2892662542121057, 0.21403005667741615, 0.2472698889817182, 0.31853686310328455, 0.37186167318346197, 0.36815677704298855, 0.27364271957977915, 0.258926761366019, 0.2617850391773229, 0.2386811078879234, 0.16281102919410428, 0.19465744681468278, 0.22694987529708088, 0.17858250445077606, 0.2076443942918197, 0.21264313541664115, 0.18169120631953695, 0.1641690065960938, 0.19686501518210542, 0.18377663935416833, 0.1751012620072252, 0.17798800389141156, 0.19999742819303956, 0.18920366635994745, 0.20158032966588768, 0.18149409875825018, 0.18524756510973273, 0.17486441851629897, 0.174486835813769, 0.17764303274010473, 0.19850662757986104, 0.20216664158779585, 0.19143902458578976, 0.814325383172007, 0.1686687612356993, 0.15150299139826107, 0.787592664429092, 0.19727925967109528, 0.1977809959796265, 0.14065552669168224, 0.1971976833265161, 0.796630939717279, 0.4270931557582206, 0.20489315316139312, 0.07327878531566401, 0.19405442409958318, 0.304498730023804, 0.1443025745320865, 0.1042019828881452, 0.20514254188900727, 0.20534289259347283, 0.1954139393087242, 0.1765299105065764, 0.18791335873393322, 0.18382618274098983, 0.1980496104178583, 0.1680750300355619, 0.18535080962231065, 0.16852465620832047, 0.1770175518720023, 0.06552497823848735, 0.07415911669574726, 0.08055744153958821, 0.06985016137235778, 0.06309513092684915, 0.07236155344569506, 0.07446723982923864, 0.068779760774757, 0.059393566379319584]}, "mutation_prompt": null}
{"id": "1169876f-5882-43ac-be09-81471f5b190c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "26dd12fa-f657-441c-a695-e3b69eefe7f4", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "48eda45e-e827-46c3-8be1-7ffd38748693", "solution": "import numpy as np\n\nclass Enhanced_APSO_DE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia_weight = 0.6  # Adjusted weight for dynamic adaptation\n        self.cognitive_coeff = 1.7\n        self.social_coeff = 1.5\n\n        self.F_base = 0.8  # Higher scaling factor for exploration\n        self.CR_base = 0.85  # Adjusted crossover probability\n\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.3 * np.sin(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter):\n        return self.F_base + 0.5 * (1 - current_iter / self.budget)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.15, 0.25, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            F = self.adaptive_mutation_strategy(iter_count)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_APSO_DE_LS", "description": "Enhanced PSO-DE with adaptive exploration using Lévy flights and fitness-based local search for improved convergence.", "configspace": "", "generation": 68, "fitness": 0.3549464596001291, "feedback": "The algorithm Enhanced_APSO_DE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8253031758434416, 0.806004798321097, 0.834585956664814, 0.8101715302044488, 0.8105320993784324, 0.8177230716612659, 0.8322799621566223, 0.8010818395816592, 0.8000693231650889, 0.6600456189770296, 0.6689038368938269, 0.6671164683198834, 0.6343238595463017, 0.6749210781407232, 0.6594765898246419, 0.6417644996244828, 0.6572280838166181, 0.6723781555547281, 0.15172865071682573, 0.1688745183441942, 0.12336088537127998, 0.16064787399400537, 0.4986562220030941, 0.11525106028652576, 0.1502861133636848, 0.1279361823370775, 0.11352223796967087, 0.08980836410689941, 0.10949933111375854, 0.10296103439156035, 0.13608002568862831, 0.10517764662125051, 0.09004214138778643, 0.11802274741805718, 0.13273913537743376, 0.12286630074567406, 0.944146687957181, 0.9454025483977523, 0.9438580737598884, 0.9598614610407351, 0.9186152357636375, 0.9367599617243243, 0.9577485883957352, 0.9494031438394458, 0.9571346481994312, 0.5903796891447958, 0.6028111088099655, 0.5128100038034831, 0.5372638260031597, 0.5834541878724888, 0.6205371534925672, 0.4708688697552966, 0.5053268605021415, 0.5508688424072159, 0.8227178512383685, 0.7989760879446822, 0.7775274294218404, 0.8157825637052509, 0.8403699873719537, 0.7966231715945269, 0.2294166172269847, 0.7830032670972404, 0.827303526155224, 0.21885306820268957, 0.18483604614792248, 0.4128997188552699, 0.12118453168992949, 0.1890651707277209, 0.361759161578904, 0.276476094902842, 0.27254623876969986, 0.1965961101260335, 0.25920995165984306, 0.22731770046203514, 0.12526389530081306, 0.25103897954719034, 0.21581614242020508, 0.23379634252944292, 0.26583119984459314, 0.210099787923272, 0.12841311980170178, 0.09648681195484421, 0.04744609015446055, 0.20677108238980213, 0.037066271826496466, 0.05339366649463895, 0.13928467496959673, 0.057349893458254475, 0.09575915003284552, 0.08886459790814005, 0.221062977601584, 0.1105022013201773, 0.13671238109803674, 0.12575164717687837, 0.06659399246816555, 0.12151669694910738, 0.11788102429853842, 0.11560845142902276, 0.0856645237706729, 0.26640515446203905, 0.08368932702687304, 0.10875879142777245, 0.0877407958774602, 0.10048743819192896, 0.13089820726055168, 0.18287480598573447, 0.23355927453457126, 0.14658321762056437, 0.2653769966407543, 0.12469927749524068, 0.1810563505034204, 0.14831741458914294, 0.15968248984518885, 0.16584032279561944, 0.15146957214872891, 0.16982531233326958, 0.10666045367860988, 0.5806437865992353, 0.5618070341595334, 0.5493347275963364, 0.6109343806027976, 0.5891479077230226, 0.5475402150876257, 0.5885785513616176, 0.5920407333894963, 0.5858924771221867, 0.14105969430811005, 0.10797947087091309, 0.14777018558808197, 0.12279911696466095, 0.14551233892543747, 0.13988203520933817, 0.14798497078465755, 0.10918746371746924, 0.1139876196134133, 0.1474436539465751, 0.14731894958479752, 0.13190405134266658, 0.13375915703122954, 0.19550928042719584, 0.2741258220096433, 0.1667458007024295, 0.5122760162658452, 0.1750788634292263, 0.4553835299337847, 0.395369274246016, 0.35235224108053764, 0.44974243714757034, 0.5350661615329904, 0.40696377894781777, 0.5611747863207519, 0.5006997854464165, 0.48507484665980316, 0.2598214731555426, 0.27570876544481626, 0.2783392205414148, 0.26943388095790666, 0.19829071181474545, 0.3299703822823493, 0.295142828518522, 0.2882980561922286, 0.35560797650316023, 0.23564103190105856, 0.19271254643388047, 0.21286128661717463, 0.20522680890079115, 0.20479652528677728, 0.1918905353054402, 0.20252966394562055, 0.229386749843142, 0.19414280570002207, 0.594959419608706, 0.6717538663304334, 0.2188133935400719, 0.20342184412292497, 0.20241142511303567, 0.19358592445117306, 0.19407287117067895, 0.20541243849197366, 0.17410010444661916, 0.8469721749000131, 0.18543198192088983, 0.14578576894203266, 0.8305050334552233, 0.8518821286070434, 0.8658464768005361, 0.7746079709927114, 0.7741535817773615, 0.8411902052738319, 0.8062332785401187, 0.20877972843547343, 0.11203083266899161, 0.619062715432231, 0.20519538499539636, 0.6653291214034006, 0.1261045787172852, 0.7922241920270798, 0.15202230932446914, 0.176802137780532, 0.1863071570893925, 0.17982227844878795, 0.1894243094453968, 0.1975981994522511, 0.18662955009222537, 0.17669761686433105, 0.17769204984639997, 0.19004921032199518, 0.08499031713350469, 0.09256720054968515, 0.0811729710718222, 0.08040518965187526, 0.08564546943861329, 0.0795802897562935, 0.08077236856597925, 0.08788480032571278, 0.0856466015328935]}, "mutation_prompt": null}
{"id": "fd75acbd-796b-4e6c-a243-8661ed143a68", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "22b5175f-3274-458a-a983-78c7ff371a9e", "solution": "import numpy as np\n\nclass Synergistic_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Adjusted parameters for enhanced synergy\n        self.num_particles = 50  # Increased population for better exploration\n        self.inertia_weight = 0.6  # Adaptive inertia weight based on budget usage\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # DE parameters modified for synergy\n        self.F_base = 0.8\n        self.CR_base = 0.85\n\n        # Initializing positions and velocities\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_inertia_weight(self, iter_count):\n        return 0.4 + 0.3 * (1 - iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter):\n        return self.F_base * (1 + 0.2 * np.sin(2 * np.pi * current_iter / self.budget))\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            inertia_weight = self.adaptive_inertia_weight(iter_count)\n            self.velocities = (inertia_weight * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.2, 0.5, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive DE with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Synergistic_PSO_DE", "description": "A synergy of PSO and DE, enhanced with adaptive parameters and Lévy flights, tailored for rapid convergence.", "configspace": "", "generation": 70, "fitness": 0.27083716829394333, "feedback": "The algorithm Synergistic_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.7750299912904812, 0.7755750936821507, 0.7611207947746605, 0.7345067023702826, 0.7355184147725689, 0.1896571704887816, 0.5019726518482751, 0.7430155322956645, 0.7621922093914045, 0.5066296191291519, 0.4616648463527756, 0.07088121683652826, 0.450041702932372, 0.5269556185270344, 0.49196985805457283, 0.04071569646955708, 0.0513528254615212, 0.04810042430412709, 0.08780726595145438, 0.11587755266609745, 0.12621523468952112, 0.10226269475855809, 0.10603948833020116, 0.09361377749308175, 0.10943696116918822, 0.16810364642680853, 0.11875091964903262, 0.08281061559572722, 0.094446754114629, 0.12638668641891548, 0.10126694196849817, 0.10814071162288252, 0.040666782685492064, 0.06365614391573016, 0.1251949139615146, 0.09074573958022647, 0.9641401523737011, 0.9617868404297165, 0.9611417166171514, 0.9608330117476174, 0.9603949358591592, 0.9697723468874009, 0.9660729345477747, 0.9673149591293926, 0.9670874366821277, 0.47608713143369863, 0.4248343184107978, 0.33319313035070364, 0.3225900696128161, 0.3886995842670039, 0.1452904724730013, 0.3985793522636264, 0.4026451255601914, 0.05096016994649577, 0.7794651435333315, 0.13638959497437486, 0.4307478513252022, 0.20996768738491223, 0.19785601062514435, 0.7964921116494825, 0.7730475531516491, 0.12425735845401997, 0.716297854086547, 0.25777795836446005, 0.2510782427853765, 0.23120287434044073, 0.11953863414075727, 0.21884364554487856, 0.17195450806023105, 0.30739484012750784, 0.11864742288919783, 0.1278975040797975, 0.2633453069950368, 0.23306353169538874, 0.24706612993742494, 0.12665616178831018, 0.25451100557495443, 0.2711958763697181, 0.2549958018995264, 0.23338514030977642, 0.21481348961254343, 9.999999999998899e-05, 0.022561213089205, 0.009236731994239245, 0.04386522071402865, 9.999999999998899e-05, 9.999999999998899e-05, 0.07103037748834395, 9.999999999998899e-05, 0.04404009483142313, 0.046286809038584065, 0.049488463461047516, 0.12458628534255256, 0.0930733311001406, 0.09728484707070073, 0.001986895438325864, 0.0937283611191122, 0.10988273743642496, 0.07775416664861912, 0.09289299056044475, 0.030891191761298953, 0.04092461299673522, 0.09193459178653007, 0.013464339340357623, 0.06729905683937853, 0.12457573731816296, 0.07827893246649187, 0.12523037395657755, 0.20336501738295976, 0.07989819051715186, 0.18605000655581128, 0.15214519840723695, 0.14909459989972673, 0.12050079223049448, 0.15051435887221432, 0.04664366945090492, 0.07657790766979355, 0.5223444367034997, 0.50290472646222, 0.5597246469849471, 0.5093502000296906, 0.5396570667219565, 0.5138432473270725, 0.5349601977456819, 0.5195672945341243, 0.513214487438951, 0.09120319968025492, 0.07722538403032575, 0.07105202320391324, 0.08430184477177793, 0.08243484524954803, 0.11724872059905433, 0.09237360764293867, 0.08440364114694299, 0.08650563420212076, 0.2169926722802089, 0.16014647109840918, 0.13202359719811718, 0.2351838896509344, 0.17733234877689596, 0.15871756871618925, 0.1976319116883123, 0.12910731421730437, 0.13948103641624743, 0.3861888057258426, 0.2251403860663721, 0.4206520789804582, 0.34868572517306806, 0.4194834330092996, 0.44849632705648, 0.42403743914358416, 0.4242273268158474, 0.4376602161982507, 0.16834776227687764, 0.21162301603864897, 0.27448305134016004, 0.33101524730645737, 0.2981487934817614, 0.1744472216258367, 0.19805634933527816, 0.2184104433000733, 0.27701170981052703, 0.20260539986079096, 0.21349807868326698, 0.18177521929823337, 0.18808046660054456, 0.2039005108061388, 0.19594846694125367, 0.21070454310942366, 0.1891273090396186, 0.2041619293158745, 0.1786856563071949, 0.18225785326885302, 0.18886964793601668, 0.20272044569434466, 0.19028519351244244, 0.18887662273690153, 0.4815493034534627, 0.19161430253935785, 0.24022033169923462, 0.8450127729834243, 0.16727203614087016, 0.15182357479701603, 0.8325063561439712, 0.1930654791971197, 0.19889607531207787, 0.12446864274742442, 0.15925946115314416, 0.83565434725795, 0.7212543677848173, 0.1989152554746082, 0.072114332547493, 0.7440652613853789, 0.16792211095586385, 0.16252709517993158, 0.10351613846932428, 0.20203741724160595, 0.7777592226628607, 0.19134790486883335, 0.18714358924504126, 0.17518373940742238, 0.17560077656659323, 0.1853833877008425, 0.1737002832432365, 0.1813585994994612, 0.18610544208497437, 0.17780868043317732, 0.07982070088911586, 0.08063683180252079, 0.09114324531326079, 0.0795565653873398, 0.09383182557050118, 0.07759780780434611, 0.08335206517079008, 0.08368103687341188, 0.07645406313374403]}, "mutation_prompt": null}
{"id": "61777db4-3980-4b1e-afdc-809519fa6ade", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "4c1c41fc-3f16-4b64-9000-d9ec660118ea", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "33431fcb-882f-4ff8-96a0-36343efceb49", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE_ST:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 50  # Slightly larger particle count for exploration\n        self.inertia_weight = 0.6  # Further tuned inertia weight\n        self.cognitive_coeff = 2.0  # Adjusted cognitive coefficient\n        self.social_coeff = 1.4  # Adjusted social coefficient\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Slightly higher scaling factor\n        self.CR_base = 0.85  # Slightly reduced crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def stochastic_tunneling(self, score, min_score):\n        return np.exp(-0.1 * (score - min_score))\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights and Stochastic Tunneling\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n                tunneling_prob = self.stochastic_tunneling(trial_score, self.global_best_score)\n\n                # DE acceptance criterion with stochastic tunneling\n                if trial_score < scores[i] or np.random.rand() < tunneling_prob:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE_ST", "description": "Hybrid algorithm combining enhanced PSO with adaptive DE and stochastic tunneling for improved exploration and convergence.", "configspace": "", "generation": 73, "fitness": 0.25058152390690025, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE_ST got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.35772792246802787, 0.3587137629919034, 0.36797637931656924, 0.3562137869501961, 0.3660256130073982, 0.4016016436820533, 0.3706822781213416, 0.3655587890409461, 0.37765158803106114, 0.2918127341937111, 0.2938449407395456, 0.32238717314803267, 0.3321027957076492, 0.30124486737428413, 0.2983095355619506, 0.31494572918041364, 0.2909221109735982, 0.3105061614430905, 0.12706160352899298, 0.14109987465593654, 0.16214006677083304, 0.12863658749051865, 0.1129386655652217, 0.2419235849942145, 0.13596199456210345, 0.140130850849701, 0.1619727881035815, 0.13897916246285935, 0.10666136520637426, 0.15132058018182526, 0.12479015655832515, 0.15595175898995817, 0.12407384821339851, 0.13478213243416226, 0.11026114182161895, 0.12411856229723794, 0.945894902803886, 0.9448591723643859, 0.9543009311305997, 0.946869588614433, 0.9476181367092424, 0.9495462421940678, 0.9555477183244894, 0.9454909446112163, 0.9495433726130807, 0.4034159802128706, 0.39970602621580764, 0.38499897134058225, 0.4184898439669531, 0.3979565843663456, 0.3244110230593782, 0.4123999158765298, 0.41077180982489325, 0.08816602162991782, 0.33446271324986965, 0.23912249377205175, 0.3309034171973898, 0.3400641473322017, 0.3169528191792622, 0.3313429802043063, 0.3286778253149799, 0.3582391288512289, 0.31278024324531584, 0.21048153734602348, 0.19015910489005805, 0.2325648075559198, 0.20582600428018727, 0.20837858280847288, 0.195215591469046, 0.23750478860382784, 0.2364062238332253, 0.18866268395884112, 0.20086713059404748, 0.026955068104146496, 0.21619333019426445, 0.2165985893662481, 0.29153015077778177, 0.19587140475972908, 0.22806196436429693, 0.2104049978980601, 0.12902068485513696, 0.17317931838175005, 0.08550365014405947, 0.016906263444895875, 0.08245978134748133, 0.05092780575593292, 0.024631910030560533, 0.09010620574190253, 0.02003809399794554, 0.05896351563088176, 0.13525095610702598, 0.11917200573373554, 0.15957156635691916, 0.07662243960741422, 0.1297183263091316, 0.04083875376280799, 0.12400171188705722, 0.1337155647407965, 0.1304319324069847, 0.04209344207714205, 0.043843176184818033, 0.10587290237668545, 0.0776212064573869, 0.13191832810088566, 0.12531473478622068, 0.22154054855965988, 0.12041786180295022, 0.22097965038214984, 0.1791143833420572, 0.17024667417587258, 0.18106921678558385, 0.1903096978178942, 0.1594041062233975, 0.15290610592065856, 0.14848982721292958, 0.1856591473209518, 0.18055985552716902, 0.3333263317362455, 0.337761226802772, 0.3154267580952451, 0.34701904927617766, 0.3491792347699857, 0.3400066150360642, 0.32216977262723545, 0.30616249209678603, 0.3439132630685756, 0.13715296699228108, 0.12714126372224965, 0.11871721971076243, 0.13363178760417704, 0.1366656912821449, 0.12194410031310376, 0.10998139356804826, 0.1273795618231528, 0.0919541378647657, 0.24200195828822102, 0.13608311329917744, 0.14523952330418066, 0.24928370273403244, 0.13996121101394743, 0.23694053263965376, 0.16959707699177184, 0.14797304002296296, 0.1725580453284019, 0.25562283503784533, 0.26166801152655794, 0.2530886315948594, 0.24136972414606217, 0.2519357405696818, 0.24282654447762075, 0.25135411014202413, 0.24636446370275977, 0.26196087122629386, 0.22688188490870453, 0.24241508546442214, 0.2277972971920359, 0.22262463947049005, 0.21116884517448975, 0.2279926820185837, 0.23209276359214093, 0.2251244199439334, 0.22531650800835, 0.22658517368657083, 0.1874854940990871, 0.20931112480015213, 0.1873578301705291, 0.20968629172380804, 0.21916683594644493, 0.20091527861562808, 0.21057729429105032, 0.18488547370910968, 0.2657729746964087, 0.1897398093964915, 0.25550277526962994, 0.2127940607632559, 0.30439167538014866, 0.2015252184657328, 0.21495893042799785, 0.17962837266776555, 0.19059902661114014, 0.5449527231826488, 0.528431201840587, 0.19111078156620864, 0.5295361326295016, 0.46455934436620905, 0.5554944802871431, 0.1886002426421307, 0.503051221741942, 0.5227069975842673, 0.5249563720378021, 0.16792080569074408, 0.20185439340607736, 0.5385303182231668, 0.16479171889909483, 0.1629267204901924, 0.12434860062215702, 0.20859360225401802, 0.5051026378998476, 0.19445349679781043, 0.18905916099101927, 0.17443522473386852, 0.19032936891914198, 0.1734413244333286, 0.1814091376348933, 0.18025389110577839, 0.17223557608061424, 0.17872161863787728, 0.08743810470046609, 0.08320599224703507, 0.08361279860299908, 0.07945812130674146, 0.0848363735234483, 0.09575051211880892, 0.08972388190747427, 0.09285815198720115, 0.0855895609433519]}, "mutation_prompt": null}
{"id": "89d421b3-241a-4329-959a-a4714e1bbf5d", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 50  # Adjusted for better diversity\n        self.elite_archive_size = 5\n        self.inertia_weight = 0.6  # Dynamic inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # DE parameters\n        self.F_base = 0.8  # Enhanced exploration-exploitation balance\n        self.CR_base = 0.85\n\n        # Initialization\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best and elite archive\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.elite_archive = []\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.5 * np.sin(4 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * (current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def update_elite_archive(self, scores):\n        sorted_indices = np.argsort(scores)\n        for idx in sorted_indices[:self.elite_archive_size]:\n            if len(self.elite_archive) < self.elite_archive_size:\n                self.elite_archive.append(self.positions[idx])\n            else:\n                if scores[idx] < func(self.elite_archive[-1]):\n                    self.elite_archive[-1] = self.positions[idx]\n            self.elite_archive.sort(key=func)\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions with elite influence\n            self.update_elite_archive(scores)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            elite_influence = np.mean(self.elite_archive, axis=0) if self.elite_archive else self.global_best_position\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (elite_influence - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2 = np.random.choice(range(self.num_particles), 2, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.global_best_position\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE_v2", "description": "Improved PSO-DE hybrid using elite archiving and dynamic adaptation of evolution strategies for faster convergence.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {}, "mutation_prompt": null}
{"id": "712b5b9c-d626-492e-85dd-298de5159539", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "76994b82-1050-427d-b8b7-3a7d0f3a1f0b", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "1be074d8-cdeb-4285-8ab1-3d5afbef9a23", "solution": "import numpy as np\n\nclass Cooperative_Bat_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Bat Algorithm Parameters\n        self.num_bats = 40  # Number of bats (equivalent to particles)\n        self.loudness = 0.5  # Loudness parameter\n        self.pulse_rate = 0.5  # Pulse emission rate\n        self.frequency_min = 0.0\n        self.frequency_max = 1.0\n\n        # Adaptive Differential Evolution Parameters\n        self.F = 0.7  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n\n        # Initialize positions, velocities, and best solutions\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_bats, self.dim))\n        self.velocities = np.zeros((self.num_bats, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_bats, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n\n        while evals < self.budget:\n            # Evaluate each bat\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_bats\n\n            # Update personal and global bests\n            for i in range(self.num_bats):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Bat Algorithm)\n            for i in range(self.num_bats):\n                freq = self.frequency_min + (self.frequency_max - self.frequency_min) * np.random.rand()\n                self.velocities[i] += (self.positions[i] - self.global_best_position) * freq\n                new_position = self.positions[i] + self.velocities[i]\n\n                if np.random.rand() > self.pulse_rate:\n                    new_position = self.global_best_position + self.loudness * np.random.randn(self.dim)\n\n                new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n\n                new_score = func(new_position)\n                evals += 1\n\n                # Accept the new solutions based on the loudness and update\n                if new_score < scores[i] and np.random.rand() < self.loudness:\n                    self.positions[i] = new_position\n                    scores[i] = new_score\n\n            # Adaptive Differential Evolution\n            for i in range(self.num_bats):\n                idx1, idx2, idx3 = np.random.choice(range(self.num_bats), 3, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n        return self.global_best_position, self.global_best_score", "name": "Cooperative_Bat_DE", "description": "Novel Cooperative Hybrid of Bat Algorithm and DE with adaptive parameters for enhanced convergence and exploration.", "configspace": "", "generation": 77, "fitness": 0.2345909240983185, "feedback": "The algorithm Cooperative_Bat_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.5178353831717148, 0.5085807272032608, 0.48147336617309044, 0.531280462333713, 0.4815114995449715, 0.5083126536458824, 0.527047157213729, 0.46593360370420356, 0.4720457715970874, 0.1473909367421089, 0.16592218791654556, 0.16061584888600977, 0.14356048583210035, 0.13883616923702025, 0.16617606838648658, 0.23026312660159587, 0.1677575034507336, 0.14945452194589892, 0.11647144201241022, 0.10149650180102454, 0.09907010812138961, 0.08451939777530282, 0.08625092337580864, 0.08578460531424881, 0.08734318012937381, 0.11019028094616301, 0.09407240054084665, 0.08490861273375028, 0.09258585388756546, 0.08890289980181898, 0.0932052809995273, 0.08328451026716188, 0.06898377346324946, 0.09670854126285233, 0.0808752965616033, 0.10160250773756851, 0.9592092227461141, 0.9705965633241183, 0.9270712390061193, 0.9462771633694657, 0.9630893744520423, 0.8809219506581871, 0.9818154625348658, 0.955308161124599, 0.8977210473852192, 0.2856368527190042, 0.21812498062556795, 0.21561238100308722, 0.23171752922637323, 0.24631303384182646, 0.2384712222403066, 0.23481341267593792, 0.24223594636694412, 0.24165121072555784, 0.3149765977266967, 0.3268691231294547, 0.29146954205640396, 0.5339029799085646, 0.5144418231471652, 0.3915961749813015, 0.39995117086625775, 0.43747131741753775, 0.3491796803298969, 0.17712709618158917, 0.12066242928998727, 0.16511443153167382, 0.1493226171966089, 0.1643767111039659, 0.15691906799726008, 0.1492047660466913, 0.19541499543941165, 0.13351998019361577, 0.186798343522246, 0.1277936788515308, 0.15426043746428764, 0.14121446753664058, 0.15158487093010442, 0.1648248907956955, 0.16013871990715633, 0.12724295078157644, 0.1257805235255488, 0.06314679389954303, 0.06317479667477088, 0.06526572285267518, 0.07784949421407183, 0.06594745744498376, 0.04974055113920617, 0.07324875810234766, 0.04684913443329353, 0.04171421694543642, 0.1812793459209464, 0.18647580804494324, 0.19711953370491175, 0.15928749349992244, 0.1483594161836279, 0.1570080118973759, 0.2053347931307994, 0.18897368161463202, 0.18039326110993337, 0.0096354295494957, 0.003178802067214881, 0.017342579234885136, 0.032340652113766244, 0.0012317941383367392, 0.02511987526001791, 0.010394954119430255, 0.005999468304937139, 0.0052958832262353095, 0.12222563402397923, 0.12465932342873598, 0.12478531928270409, 0.1034917141411048, 0.12195358793249267, 0.12089485036595382, 0.10892143344369776, 0.1176374447314884, 0.10076049853827462, 0.40193539144505197, 0.4200775848315168, 0.43402927418496595, 0.4271422128222331, 0.39765620694932546, 0.4415273347976155, 0.45877447642672897, 0.4277315099352017, 0.4342983223404432, 0.09368604573024908, 0.0903260600040574, 0.08332103716730765, 0.09329902785874788, 0.09859281587296209, 0.0869308361881076, 0.08442835890141565, 0.09694640943758603, 0.09461491953164602, 0.16578778605264566, 0.22461643319345492, 0.15697524844158028, 0.2110177137029382, 0.35594629600526073, 0.15305456387094252, 0.18932557642736836, 0.1769436890025745, 0.17434002376917412, 0.2576190267515238, 0.28851327307266705, 0.2639132430666077, 0.26480337876397775, 0.2646974978999861, 0.28637303403625036, 0.25166762873785775, 0.2699038224683634, 0.26907589245596497, 0.24141821702902555, 0.20650028349304972, 0.1956477158370472, 0.1950898611668067, 0.21403991047307747, 0.22707711811200892, 0.21734367959300427, 0.21353221008533252, 0.22281984410168343, 0.19379539266448687, 0.1834672967390627, 0.177244327176023, 0.18003322766519847, 0.19642902626850955, 0.18262814516112713, 0.20902786749655733, 0.2067954739532022, 0.19351431149596376, 0.17161883232015496, 0.17748601396179653, 0.1920292878958204, 0.19818642012318344, 0.17687974724533506, 0.1759613175140834, 0.22176863806710567, 0.19392220704720553, 0.18194846797294328, 0.18392025202050954, 0.18505326122287746, 0.17515168696672667, 0.6993447513655964, 0.6719080305843794, 0.20714059594452938, 0.14229336459132724, 0.14768190238934253, 0.6878571996405367, 0.6507914512768015, 0.2080390747653762, 0.6057950901648024, 0.20426734511975342, 0.2037494179172361, 0.19814172416639908, 0.6013980416407332, 0.2106782094660593, 0.20435360074109066, 0.18125218969731127, 0.17767701215765552, 0.18352792506689597, 0.20141396105112186, 0.17811933332158458, 0.17056724626260167, 0.18031318025248655, 0.17694130231636407, 0.18633247966482835, 0.07875676611952132, 0.0755201618953959, 0.0831890648842798, 0.10095086323250002, 0.08187621109205756, 0.07926273053798327, 0.07785224693390791, 0.08618208473019673, 0.07320580631474038]}, "mutation_prompt": null}
{"id": "fac42c2a-19d7-426b-a96d-e50be59dfaad", "solution": "import numpy as np\n\nclass AQPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Adaptive Quantum Particle Swarm Optimization parameters\n        self.num_particles = 50  # Increased particle count for more diversity\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.quantum_delta = 0.005  # Quantum step size for exploration\n\n        # Differential Evolution parameters\n        self.F_base = 0.6  # Scaling factor for DE mutation\n        self.CR_base = 0.8  # Crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def quantum_inspired_motion(self, position, best_position):\n        return position + self.quantum_delta * np.sign(np.random.rand(self.dim) - 0.5) * (best_position - position)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * np.sin(2 * np.pi * current_iter / total_iters)\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (AQPSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.inertia_weight * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Apply quantum-inspired motion for enhanced exploration\n            if iter_count % 10 == 0:  # Apply periodically to prevent premature convergence\n                for i in range(self.num_particles):\n                    self.positions[i] = self.quantum_inspired_motion(self.positions[i], self.global_best_position)\n\n            # Differential Evolution\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = np.random.choice(range(self.num_particles), 3, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AQPSO_DE", "description": "Adaptive Quantum Particle Swarm Optimization with Differential Evolution for enhanced exploration and faster convergence.", "configspace": "", "generation": 78, "fitness": 0.15813769144916653, "feedback": "The algorithm AQPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.40313614864454417, 0.3810703014670539, 0.494642494600409, 0.4834310051248747, 0.3543110102479906, 0.18613080252505265, 0.4621746827785662, 0.1795528288251249, 0.19007190484250813, 0.028130712316497775, 9.999999999998899e-05, 0.053098900273493954, 9.999999999998899e-05, 0.18405779837428637, 0.04378174710773053, 0.039774093384382425, 9.999999999998899e-05, 0.032989914622738814, 0.05220395833005642, 0.07399919818321199, 0.0472704643659656, 0.0561496491593767, 0.06261667072674171, 0.05473892541998959, 0.06288215805930886, 0.08631403306776841, 0.06625694532070414, 0.0675659531889391, 0.04989659975075633, 0.05227186337717471, 0.06391589564850497, 0.056170146222998096, 0.04988668277016317, 0.11577667010688275, 0.04700408832670777, 0.04867902414391723, 0.9692046951636192, 0.9596704365502117, 0.9796727148331223, 0.958316824630238, 0.9683061648228601, 0.9688147164452473, 0.977782715703123, 0.9769583314095311, 0.9762398443080795, 0.08310539007618756, 0.1561424827616571, 0.14884427365414998, 0.13691366477228717, 0.1671474587899625, 0.11613059112815605, 0.10593523133198923, 0.05890643470653234, 0.19254770326247816, 0.20014723737347495, 0.16485205941953351, 0.22092288702821195, 0.19941241398890408, 0.2153055020925132, 0.18445937049473093, 0.15847041975630094, 0.12041594282074497, 0.12585277428560215, 0.07916083671791252, 0.07595862492578431, 0.10960347822905481, 0.007910777953953452, 0.097959860116685, 0.13346697891256065, 0.12292283381118341, 0.11134816250736057, 0.09484687986370732, 0.07163533919317544, 0.085418164100865, 0.016622183036996807, 0.11525572758975666, 0.06527299988714352, 0.13366264534789074, 0.03755473768635742, 9.999999999998899e-05, 0.10521674960786609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07087211596309118, 0.05547591721181888, 0.03982339297034709, 0.0824864507187838, 0.016182845331162543, 0.019464035637469124, 0.06055474953947959, 0.018915248600256618, 0.041199770850354644, 0.009341803300791818, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019182362751829718, 0.02124463684818334, 0.0030518052301035103, 9.999999999998899e-05, 9.999999999998899e-05, 0.027506561872776003, 9.999999999998899e-05, 9.999999999998899e-05, 0.004917246371652806, 0.03345429762758889, 9.999999999998899e-05, 0.03460509821019275, 0.05301154487334059, 0.023866600894538403, 0.2096664987775283, 0.3423887715238624, 0.393707785460902, 0.34417661488143125, 0.3243560558994102, 0.29869768199677516, 0.3537370758248608, 0.3727299561586259, 0.23573011937963306, 0.06457457247722653, 0.05767815868372417, 0.05638673938222183, 0.056261483402889834, 0.07218115258994562, 0.07828599314743734, 0.05110472614349015, 0.04976293162316492, 0.06750481837910938, 0.1215765425119647, 0.14426451716354516, 0.12984584694901058, 0.13393265290186407, 0.14420067406265658, 0.1257707242333339, 0.130249124285035, 0.10987624895308634, 0.17411150668222763, 0.20840785542189455, 0.17829438895002547, 0.20189348985195177, 0.16866824372964673, 0.17282689180020971, 0.18757856520344673, 0.21373266474648622, 0.2198142045047875, 0.19262243139953283, 0.1310677146247281, 0.15081035489852834, 0.14275954266509727, 0.11796072037572869, 0.15756473493204337, 0.1809995629296154, 0.17890703582148304, 0.19672933682341032, 0.16597527734414452, 0.1623273788908316, 0.16167917525083197, 0.1837402045159231, 0.15534460886957258, 0.16149278060167294, 0.13653688616180537, 0.17675540627562225, 0.19201987870586945, 0.1638981205759592, 0.16853229210021747, 0.18216599217666785, 0.15795705498957546, 0.1710777420307733, 0.16173379042931246, 0.15527292232711354, 0.16175149069697892, 0.16719553888147587, 9.999999999998899e-05, 0.14736524132573847, 0.15945013836303423, 0.1232865187894413, 0.30389733048202305, 0.1617939888748604, 0.1935595887466759, 0.13310402788592313, 0.14752548909592111, 0.16809318286728103, 0.20996179685595484, 0.16841455841440633, 0.07321200558832874, 0.2900857902906727, 0.164648842643914, 0.1062134473682127, 0.20296763839786658, 0.1512247166595091, 0.1945033610426451, 0.18468825418937462, 0.17757061106271554, 0.17020670706028707, 0.167426066113333, 0.2038550219540155, 0.20244901821972583, 0.17024011183806087, 0.18177741240829703, 0.18719254768018256, 0.06048328142671633, 0.054178377513013354, 0.06436161617590153, 0.07937049877714797, 0.05886467179107313, 0.06289536330937806, 0.06842725381130299, 0.05855741406393222, 0.055431191749285236]}, "mutation_prompt": null}
{"id": "fab1adc1-bff1-478d-9e5c-2837ff792448", "solution": "import numpy as np\n\nclass Adaptive_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 50  # Increased particle count for diversity\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 1.3\n\n        # Differential Evolution parameters\n        self.F_base = 0.6\n        self.CR_base = 0.8\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.3 * np.cos(5 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def dynamic_subpopulations(self, iter_count):\n        return max(1, self.num_particles // (1 + iter_count // (self.budget // 10)))\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.2, 0.4, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            subpop_size = self.dynamic_subpopulations(iter_count)\n            for i in range(self.num_particles):\n                idx_selection = np.random.choice(range(self.num_particles), subpop_size, replace=False)\n                idx1, idx2, idx3 = np.random.choice(idx_selection, 3, replace=False)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Hybrid_APSO_DE", "description": "Adaptive Hybrid APSO-DE algorithm with chaotic inertia and dynamic subpopulation strategy for enhanced convergence and diversity.", "configspace": "", "generation": 79, "fitness": 0.29778470413729335, "feedback": "The algorithm Adaptive_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.770735976047674, 0.7211898538124776, 0.7626753566114004, 0.7483255861306062, 0.7796685550483242, 0.7541915839551356, 0.7182544955328385, 0.7437398182882192, 0.7006054648114302, 0.4853371701171566, 0.4163457437147863, 0.5113115633782899, 0.49394094543493294, 0.46218489800185714, 0.4367775027155595, 0.48027065710292605, 0.5037528129786182, 0.4107771449348172, 0.09523996538579427, 0.12301696160067421, 0.1177974167251501, 0.1343276308001814, 0.10018684829274171, 0.09841338374824282, 0.11569130129296956, 0.11326813165861238, 0.11709038843754549, 0.08930118606804138, 0.13586287731053415, 0.1113504897656743, 0.12334272954587289, 0.09303451582939071, 0.10119953973407791, 0.12743798700109032, 0.09581434411489176, 0.09303141112121649, 0.9614501779448, 0.9535463610015732, 0.9468319600306834, 0.9477034293048022, 0.9437364558894373, 0.9479338820871404, 0.9466774808653565, 0.9530131316878825, 0.9407067010772995, 0.4674280973115895, 0.38157480385745735, 0.4107581253474404, 0.3187645020286973, 0.38001567848455353, 0.3833266120517306, 0.4649331111024356, 0.08686319214380966, 0.17481640956037003, 0.7786696299642522, 0.8040967108478659, 0.716337872977172, 0.688595873319092, 0.18902761446446747, 0.18961670722952617, 0.16906052567936858, 0.7306398559404323, 0.22359175511516638, 0.2366166989411549, 0.2005391633179867, 0.20311750356187097, 0.1627311460219496, 0.12648632320805786, 0.16092285795023142, 0.23291690758457895, 0.21077754334906063, 0.2154944442079605, 0.171354685987942, 0.19821258367215588, 0.15809573907916352, 0.2576584931023046, 0.20829076782325429, 0.1939296766489711, 0.2506050946610747, 0.22834191459119557, 0.21099831509356504, 9.999999999998899e-05, 0.031487136247093095, 9.999999999998899e-05, 0.04054709368758813, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016839642761686813, 0.001036395191341244, 0.11377877187416907, 0.10560177792349601, 0.0687838552466219, 0.08858239648337307, 0.08210289781132318, 0.06016203997674674, 0.04514345969889422, 0.10926851518544067, 0.12974445153227276, 0.14078742075595652, 0.060643961815250225, 0.03784280908487181, 0.08662674149084415, 0.06196124687274529, 0.06392925963701013, 0.11881178103755596, 0.05683656485958999, 0.08817868218856617, 0.11133998252102761, 0.22076987311592433, 0.12437713002387407, 0.15955744785512127, 0.20919823116657432, 0.14874152080379333, 0.24549002185792212, 0.08304977072069397, 0.1794796850633078, 0.09525682502750554, 0.5174746327788345, 0.5254539321747549, 0.512112778951444, 0.5286683079038974, 0.5320819793830777, 0.5094858699319644, 0.4340210674888013, 0.5549326783166632, 0.5593345787044679, 0.10165725881640597, 0.08364319468454973, 0.08762530801903812, 0.097061065623952, 0.09921721831828056, 0.10055195720670129, 0.10563761050027409, 0.10416215929402128, 0.12370623263444036, 0.1465517097112724, 0.1330664381259592, 0.13653239913440263, 0.18281914399651655, 0.24493227932395434, 0.1292266211723605, 0.14138005236436946, 0.13029900632240332, 0.13627544642400957, 0.416567343457799, 0.39824921773456545, 0.26309242506689134, 0.37818814345166885, 0.423325498769177, 0.4410314097559359, 0.374462251567246, 0.41476387442934093, 0.46735989794194455, 0.21796302937056322, 0.22813537526797412, 0.33815937495934945, 0.2653679270212036, 0.24925579468591197, 0.3006683142383576, 0.3243209122201738, 0.32382883537277407, 0.32725525414824286, 0.18968333974874263, 0.19338944630898136, 0.19815824411446448, 0.2007259513154992, 0.20478141767329094, 0.2190220137330534, 0.19495074473655427, 0.19975020158166856, 0.19910024414423, 0.19929053662291896, 0.18046240260696778, 0.18389582208059518, 0.21392522981638384, 0.20681783716293634, 0.20227924708417244, 0.18019290280292477, 0.23906309631346023, 0.20330204449169165, 0.18048752589159145, 0.4962673370941245, 0.18243224133426028, 0.8153888306425386, 0.6427921950729135, 0.8228398097564857, 0.6429998653316451, 0.1605034273056425, 0.8353405341676281, 0.7131296142273922, 0.20915281766080274, 0.6929958761608322, 0.8114581706116244, 0.16558674388823746, 0.39172140667493116, 0.2024972528381359, 0.7121571819818372, 0.7531852751054373, 0.18052605539419708, 0.17472982294818062, 0.19210336620741564, 0.1818633853059377, 0.1785938965073034, 0.18014732072862627, 0.17892324530288528, 0.1786446920385102, 0.18719676578624378, 0.08047672173795195, 0.0810096749996122, 0.09145821163372381, 0.0810910284706613, 0.08329236308165655, 0.08620965217234533, 0.07650486081752039, 0.07622003974973357, 0.09937189172304117]}, "mutation_prompt": null}
{"id": "e2a9e01c-4d7e-4dd6-ac4c-7c9a9fa323ce", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "507e8603-29a5-4539-9d14-127b33cbaab7", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "4d3f6d1e-0183-4b67-9e77-5b12fc5e83e2", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "b2687c3c-7ff0-4825-af50-fcdb42046d99", "solution": "import numpy as np\n\nclass Quantum_Enhanced_Hybrid_PSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Quantum-inspired PSO parameters\n        self.num_particles = 50  # Increased particle count for enhanced exploration\n        self.inertia_weight = 0.6  # Dynamically adjusting inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.8\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Altered scaling factor for exploration/exploitation balance\n        self.CR_base = 0.85  # Variation in crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.5 * np.sin(2 * np.pi * iter_count / self.budget)  # Leveraging chaos theory\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * (1 - current_iter / total_iters)\n\n    def quantum_levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Quantum-inspired PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.15, 0.35, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Quantum Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Quantum Levy flights for better exploration\n                quantum_steps = self.quantum_levy_flight(self.dim)\n                trial_vector += 0.02 * quantum_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Enhanced_Hybrid_PSODE", "description": "A novel hybrid algorithm combining adaptive PSO with DE leveraging chaos theory and quantum-inspired updates for enhanced exploration and convergence.", "configspace": "", "generation": 83, "fitness": 0.3457860675686199, "feedback": "The algorithm Quantum_Enhanced_Hybrid_PSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8661415625212585, 0.8654891982701606, 0.8681860530762724, 0.8730795810787884, 0.8592741220095534, 0.868147290335054, 0.8703326926863948, 0.8591159428862245, 0.8541827077189661, 0.7287291201791944, 0.7517795705067696, 0.7297744225102324, 0.7368331919471699, 0.7471493268197352, 0.7305337060249665, 0.7397722967917026, 0.7342381760240984, 0.7376959628749736, 0.1426274761252897, 0.1405802039455788, 0.1276532474064508, 0.1403737626081646, 0.17939825358079975, 0.1370506033947989, 0.11000196672298623, 0.1174021415669515, 0.12894260223801757, 0.10424576790940732, 0.11309425108788018, 0.09835516760663032, 0.10824156047588018, 0.11187219323387687, 0.1470736417917935, 0.1283419379876266, 0.12741781855150347, 0.12632298330396985, 0.9577021206308242, 0.949393517826535, 0.9580001653917489, 0.9541344116418516, 0.9369833034994844, 0.936029934491811, 0.9708755988191285, 0.9504261973399706, 0.9430327235417485, 0.7173448716221975, 0.7153146471976487, 0.6839342433681579, 0.7220378031764034, 0.7218299499091078, 0.7364354577245646, 0.6588566686847845, 0.6656313975214547, 0.6745079594816508, 0.22630861927008672, 0.22656453909806895, 0.7923006769142356, 0.8548955145711256, 0.20926745913425426, 0.2104390066562395, 0.22908985490324618, 0.14993762235002195, 0.8676486783744869, 0.19798546044965193, 0.1205523305701125, 0.12966377739556245, 0.22543575255275972, 0.2603259006877161, 0.22710923474490208, 0.2288656463453509, 0.21916136245804696, 0.23849376119731802, 0.2239147039848126, 0.23025473897645488, 0.24152048615232447, 0.18590329087701185, 0.22902684430744236, 0.20123778383421875, 0.26288243924586663, 0.20997973613704501, 0.1297384892262451, 0.015182928652537342, 0.08811584133935735, 0.01452639383431742, 0.00468228137517579, 9.999999999998899e-05, 0.02606620775836177, 0.0695204888347738, 0.0345684998626683, 0.004252882213873099, 0.1595563746054962, 0.08968615832908311, 0.17552643593645967, 0.05208259460146236, 0.16464673975859367, 0.022198357099644683, 0.11503351918643734, 0.07162288740443856, 0.07789204963302143, 0.22487694645350575, 0.06590217697725054, 0.12301313123883917, 0.07455410080968927, 0.12868219968699524, 0.2141273560808309, 0.16161053568306838, 0.1851538500093649, 0.09681291464339137, 0.1403641842597746, 0.18867244185453502, 0.3216066390723614, 0.19542858765263438, 0.1679602375304936, 0.13327978389777495, 0.15117827400319306, 0.11680468449312698, 0.12468099968667723, 0.5791272334467926, 0.5505256570495911, 0.6041090901166286, 0.6094966965382944, 0.6428428463030326, 0.627945079955561, 0.6508725597315992, 0.5483852059444012, 0.6039943096615588, 0.16274970256114107, 0.13792240379279397, 0.14012705534796077, 0.15631894406927382, 0.13879909456004202, 0.15099197926470276, 0.12791591181315032, 0.15208341644250345, 0.14064310939761693, 0.2636254152893974, 0.1701676578161887, 0.17815665572436734, 0.5022480215942551, 0.13332021456097465, 0.2526309654919513, 0.15466618091192486, 0.4771012050730221, 0.21555879983426662, 0.5662939767284692, 0.3454571274084526, 0.3238013968865643, 0.5260531106981017, 0.406530568648115, 0.6788679654347664, 0.6617163096521261, 0.5643078126966623, 0.6940186465162539, 0.3503575267591754, 0.33267330679543006, 0.3352254682830046, 0.4748002785662174, 0.23303447242283015, 0.39727655832905695, 0.2490254379332858, 0.32030558449049473, 0.154427192420039, 0.2375175250963888, 0.2219613215155033, 0.19858718396239705, 0.24322290108812772, 0.1858804041855121, 0.21191923846335714, 0.20466092432119654, 0.21239475345372494, 0.20960690242394175, 0.19673720544644324, 0.17272020455560777, 0.19459674571505947, 0.1804669182191505, 0.6208885063664458, 0.18654725522762505, 0.20557083275266708, 0.18717520969016854, 0.20634326223219568, 0.1639388614100733, 0.12621224457169333, 0.14623026741103184, 0.8979333706951643, 0.20009076286772864, 0.8865736963210814, 0.14202226264357964, 0.16168060999003664, 0.8786987438767894, 0.9091403833637139, 0.21104290498085987, 0.782133889460543, 0.8523862724079816, 0.1671791784513803, 0.15317753849997207, 0.8075366544214403, 0.6800571320438273, 0.21035831732010124, 0.18192011440327438, 0.18945505060327295, 0.1740259542691518, 0.174336718873772, 0.1791883939346568, 0.18106970849493642, 0.17564065784982763, 0.17281604179386068, 0.18349542165943755, 0.085815440266099, 0.08780042963242374, 0.08746312784825894, 0.09047008259614286, 0.10731340564332625, 0.10735339320385862, 0.10832784812154839, 0.0863406821305589, 0.08687471454093598]}, "mutation_prompt": null}
{"id": "e4490375-2fc3-404a-80db-d30a2c3e621e", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "1577be99-efc9-4481-afc1-c0f9c6765172", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "c716b66e-726a-47c2-958e-af3d45ccb9a1", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "217fdef9-60f5-4e01-b7f5-815387d2bb30", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "61a188d5-fece-454e-bcba-2ca9567fe363", "solution": "import numpy as np\n\nclass Enhanced_Dynamic_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        # Parameters\n        self.num_particles = 50  # Increase particle count for better space coverage\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 2.0  # Use dynamic learning coefficients\n        self.social_coeff = 1.5\n        \n        # DE parameters\n        self.F_base = 0.8  # Increased base scaling factor\n        self.CR_base = 0.95  # Increased crossover probability\n        \n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n        \n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.3 * np.cos(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * np.sin(np.pi * current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Dynamic learning coefficients for better adaptability\n            self.cognitive_coeff = 1.5 + 0.5 * np.cos(2 * np.pi * iter_count / self.budget)\n            self.social_coeff = 1.3 + 0.7 * np.sin(2 * np.pi * iter_count / self.budget)\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            \n            # Adaptive DE with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Dynamic_PSO_DE", "description": "An enhanced hybrid PSO-DE with dynamic learning coefficients, guided mutation strategy, and adaptive exploration for faster convergence.", "configspace": "", "generation": 88, "fitness": 0.156389070571468, "feedback": "The algorithm Enhanced_Dynamic_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.3632494356667565, 0.3064845421784754, 0.35937900380650833, 0.18038328177639473, 0.32286968714575026, 0.43324940532908485, 0.4356296106996568, 0.285589275910644, 0.2061616024305365, 0.18271330584621348, 0.018935189116131013, 9.999999999998899e-05, 0.040556748055922576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12630928144481568, 0.03582634136658558, 0.08400313995104935, 0.06903286795480257, 0.06244660010317782, 0.05814324593861597, 0.05306990632904307, 0.06479581583190064, 0.10092002000724265, 0.06340330493622837, 0.06497897172050271, 0.03716424279339903, 0.03529148747295208, 0.07356779898533117, 0.07919174180874111, 0.08067778516919566, 0.05240869289135153, 0.06117120088443884, 0.034391260349079356, 0.05895302857650786, 0.9751104716839117, 0.9726790773276153, 0.9777098320014102, 0.9772452493361974, 0.9659989850467791, 0.9592115131782514, 0.9685595796407216, 0.9672435149283464, 0.9772058537213986, 0.11439126263084054, 0.061334452014388585, 0.053076423603550804, 0.13253739322323577, 0.12236388963766454, 0.13682271643755428, 0.08166525155595716, 0.08486198386853738, 0.14466797712642943, 0.22186294768860515, 0.19236076133864277, 0.15868175206383128, 0.17942691839730363, 0.20449459032964756, 0.1860229623593811, 0.16071090767948448, 0.12489661242596428, 0.20258181413346976, 0.12098095302879641, 0.04708385791531111, 0.09315223503167469, 0.010138831246753632, 0.09445251216097184, 0.12211672120444106, 0.11462323588861112, 0.05963780810394148, 0.038712845810922825, 0.10570753346715189, 0.03694181238274685, 0.11817037397618546, 0.09902510471469739, 0.03851216277062264, 0.14022661625480703, 0.12165929920668406, 0.06466529303154256, 0.04713347762341491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05015627112682364, 0.0322561975616823, 0.05129334711572897, 0.058609605176401014, 9.999999999998899e-05, 9.999999999998899e-05, 0.062150161020543604, 0.06447322659491561, 0.019050555068818364, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0678766733864522, 9.999999999998899e-05, 0.02472021096170607, 0.022912826552096366, 0.03828660521470151, 0.01882143806617298, 0.03401294438649294, 0.021691725634131798, 0.03881348935404061, 0.22548349247994548, 0.30498102542387606, 0.24976109527816248, 0.28219268197963476, 0.2066223252584095, 0.2066877984253439, 0.25230322074313716, 0.30776204285753506, 0.3493235663256, 0.06887765716565153, 0.07062025747439515, 0.08029953213462415, 0.062190696027692116, 0.0807402979090881, 0.0636095380628221, 0.05719946947370391, 0.060905921290191456, 0.06314302402633987, 0.1235945960451672, 0.14486844483738515, 0.12936740007867886, 0.11265441398327858, 0.16353789672208674, 0.1302808781502206, 0.1941089382646085, 0.14273342814813605, 0.13820374186365425, 0.23129188886012086, 0.1923694917466835, 0.23052375767566258, 0.16818417656633788, 0.19246839409973737, 0.1578860695700458, 0.2545807805817114, 0.20900991450384743, 0.21689307820314885, 0.1168613226147569, 0.11171349071206405, 0.14872451795009278, 0.11063012957320428, 0.1684219776113679, 0.16609527400941315, 0.1269398424429481, 0.2042969117630844, 0.12455236536785907, 0.18364478234204407, 0.14368477975686944, 0.17443336966949463, 0.1757261893233958, 0.1639492996645251, 0.1401333639573863, 0.19139035010607708, 0.14539583433398295, 0.1736428146488339, 0.17569602934193063, 0.16049614741486495, 0.17446047685604937, 0.17341679117300957, 0.178150235437461, 0.16084817080572744, 0.17508429595627584, 0.16597090975164264, 0.1959442507706114, 0.2094411576717804, 0.1404983373210973, 0.15170013344461986, 0.1528159940454923, 0.18516735088515957, 0.183053910285205, 0.14455241364710636, 0.1642078755882982, 0.18094920539145254, 0.3722564207957001, 0.20494484767863164, 0.09996459944181824, 0.19850299785379122, 0.19690564136620348, 0.1994580600521817, 0.18739409066346902, 0.16244719725478662, 0.1908834697742725, 0.17714727553760945, 0.20290669143108475, 0.17917404896267397, 0.18765342411042307, 0.17575696546167796, 0.1945091840854838, 0.1875399913320912, 0.1801500331627327, 0.18766134706163295, 0.04812135954059271, 0.058008825061662495, 0.060931252610391895, 0.05188806795396472, 0.06143020504008234, 0.04708645100233244, 0.06583181034617902, 0.06192684122848713, 0.05636844385914597]}, "mutation_prompt": null}
{"id": "787fa6ff-1dfc-4f80-b084-573b0136121e", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "41e4b514-a467-4a20-a09b-2c2c3e855464", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "7299af20-eca0-45a3-a70b-bad07cfe5b25", "solution": "import numpy as np\n\nclass Enhanced_Adaptive_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 30  # Reduced particle count to focus on quality\n        self.inertia_weight = 0.9  # Adaptive inertia weight for dynamic control\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n\n        # DE parameters\n        self.F_base = 0.8  # Enhanced scaling factor for better adaptation\n        self.CR_base = 0.8  # Balanced crossover probability for stability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_inertia(self, iter_count):\n        return 0.4 + 0.5 * (1 - iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.4 * (current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # PSO velocity and position update\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.adaptive_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.2, 0.4, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive DE with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Adaptive_PSO_DE", "description": "A robust self-adaptive PSO-DE hybrid with a novel adaptive learning factor and dynamic population management for improved convergence and efficiency.", "configspace": "", "generation": 91, "fitness": 0.1772214386608313, "feedback": "The algorithm Enhanced_Adaptive_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.36135941000720506, 0.43296094757801606, 0.5548417994230901, 0.23214696204910246, 0.21107018883079542, 0.15737140314797926, 0.5011793286179345, 0.1819146015560169, 0.42934694238860394, 0.2067845323091, 9.999999999998899e-05, 0.06341051466290104, 9.999999999998899e-05, 9.999999999998899e-05, 0.03985976437560479, 0.043421347135871424, 0.0031223266069939637, 9.999999999998899e-05, 0.08412385211105611, 0.03864354213323751, 0.055563794604795436, 0.065228001892083, 0.060183983268035424, 0.0586984506333742, 0.1013710235417915, 0.07306857901100461, 0.04166477263499491, 0.07597850581289167, 0.05926022425133837, 0.039364967949795604, 0.07474048474056671, 0.03370613715708792, 0.05757756267671521, 0.05557009812860447, 0.07340363818202078, 0.06019446365695169, 0.980015980696927, 0.9772187211761022, 0.9757010422519734, 0.970847289674141, 0.9724188694261545, 0.9749076276903581, 0.9767838063382311, 0.9754714587318652, 0.9689936459835703, 0.16718200346697687, 0.12674377070555454, 0.05653558462103525, 0.19434529572412285, 0.12703402646767248, 0.13853874578213798, 0.16384516242647262, 0.07415318328375375, 0.18959688433630895, 0.347396933453219, 0.21284068455582716, 0.16547094698387033, 0.19626842712560655, 0.19232383756368432, 0.1871986541268008, 0.19705803666249944, 0.23435043774380437, 0.18975153777261844, 0.12854455965390787, 0.0179126379182033, 0.14671655204494471, 0.07150885577147859, 0.16516803545760428, 0.20203408224742658, 9.999999999998899e-05, 0.11375092955109956, 0.13274125134491677, 0.15024348655501707, 0.0461574869571012, 0.1502812249504596, 0.13531414651647555, 0.13218902050650283, 0.13651351056002003, 0.12224675776847782, 0.029994833467809623, 0.10962181403997295, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051853057202019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028246651455819616, 0.026233656609344735, 0.06241457864739752, 0.07408382416734893, 0.061777631456251925, 0.012738334640307603, 0.08600624562494286, 0.037773090235263096, 0.044443036716605766, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007907937729345615, 0.03691554111750006, 0.017409102298949763, 0.07445960778692118, 9.999999999998899e-05, 0.015052806634264893, 9.999999999998899e-05, 0.04896972223007667, 0.05791961824890823, 0.00375549334637304, 0.002906250408581612, 0.13191277751593877, 0.04603394106364034, 0.07996525780205233, 0.06979067328556343, 0.40207782587508367, 0.3725572676580361, 0.42987165965897234, 0.3148361635027115, 0.21338116016544895, 0.20612462539913345, 0.3954640612663878, 0.3131368172478296, 0.3765307684533252, 0.06046135749543502, 0.05740735683311726, 0.06221963252988083, 0.10178658751873226, 0.09925090742759402, 0.10459853714507894, 0.05474538540720553, 0.09523867200162583, 0.06541167321011943, 0.22761398108836606, 0.12602636405577927, 0.1607065287615136, 0.15554011090310815, 0.14425982837876294, 0.14478880141446793, 0.16581061582257062, 0.14346585735301454, 0.1486227285596704, 0.23953373810814027, 0.1732594977383609, 0.2806632202005569, 0.206131255411664, 0.1828586687761441, 0.18026601587164237, 0.1885451001456887, 0.2807437944842325, 0.17004361421326541, 0.19670531300781935, 0.15359737872984314, 0.15467707352368676, 0.1928110255402189, 0.16414904396775254, 0.19895226252433484, 0.1676032074429753, 0.1873622817242233, 0.13813305154832356, 0.17324951078050743, 0.189655533229109, 0.1778500906072491, 0.18260960696087225, 0.18593028302995485, 0.17948788531927784, 0.1908280413686586, 0.17278647236274935, 0.19273596351793854, 0.17155005263491307, 0.1715000447613675, 0.18358430327744313, 0.17231069516749742, 0.17238073694409117, 0.16720389005467862, 0.1702136023876466, 0.18381501788933385, 0.1876387872592049, 0.6721179028411729, 0.6547976786266295, 0.22898025761531426, 0.332973384234721, 0.18547810758601024, 0.16122838263202832, 0.09962293501278396, 0.16973018053044908, 0.18139951678075417, 0.44426878640043865, 0.299819686448455, 0.15202576915964583, 0.17094965984939048, 0.22210823771160404, 0.20647606995849888, 0.1640926813750686, 0.18512059614602527, 0.20539631984987528, 0.1806346121857768, 0.18269963936295874, 0.18037560239870165, 0.182740416901909, 0.18719221781610595, 0.17927486718874186, 0.17737495243381252, 0.17753972919895145, 0.1727352952711806, 0.08286816641773531, 0.07495606509040775, 0.06603054365899519, 0.07425804814884562, 0.057689694200589114, 0.07602833228618111, 0.0590083728420252, 0.07116260646231132, 0.05685968119066842]}, "mutation_prompt": null}
{"id": "d9391d42-505f-4c5e-8032-28d4083cda05", "solution": "import numpy as np\n\nclass Improved_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 50  # Adjusted particle count for balance\n        self.inertia_weight = 0.6  # Adjusted inertia weight for faster convergence\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Adjusted scaling factor for better exploration\n        self.CR_base = 0.85  # Adjusted crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def dynamic_inertia(self, iter_count):\n        return 0.4 + 0.5 * np.sin(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.4 * np.cos(np.pi * current_iter / total_iters)\n\n    def spiral_search(self, L):\n        alpha = 1.1\n        theta = np.random.uniform(0, 2 * np.pi, L)\n        return alpha * np.cos(theta), alpha * np.sin(theta)\n\n    def rank_based_selection(self, scores):\n        ranks = np.argsort(np.argsort(scores))\n        probabilities = (len(scores) - ranks) / sum(len(scores) - ranks)\n        return np.random.choice(range(len(scores)), p=probabilities)\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.dynamic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Spiral-guided search\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.rank_based_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Spiral-guided search for better exploration\n                spiral_x, spiral_y = self.spiral_search(self.dim)\n                trial_vector += 0.01 * np.array([spiral_x, spiral_y]).T * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Improved_Hybrid_APSO_DE", "description": "An improved PSO-DE hybrid with stochastic rank-based selection and spiral-guided search for enhanced exploration and convergence.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,2) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,2) (5,) ')", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {}, "mutation_prompt": null}
{"id": "b73e3568-414b-46d4-8d9c-0f82d3e13af7", "solution": "import numpy as np\n\nclass Adaptive_Grouped_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Parameters\n        self.num_particles = 50  # Increased particle count\n        self.inertia_weight = 0.6  # Adaptive inertia weight\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 1.3\n\n        # Differential Evolution parameters\n        self.F_base = 0.8  # Enhanced scaling factor\n        self.CR_base = 0.85  # Balanced crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def adaptive_inertia(self, iter_count):\n        return 0.6 + 0.4 * np.cos(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_factor(self, current_iter, total_iters):\n        return self.F_base + 0.2 * (current_iter / total_iters)\n\n    def gaussian_mutation(self, L):\n        return np.random.normal(0, 0.1, L)\n\n    def dynamic_grouping(self, scores):\n        return np.argpartition(scores, 3)[:3]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.adaptive_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.2, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with Gaussian mutation\n            F = self.adaptive_mutation_factor(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = self.dynamic_grouping(scores)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Gaussian mutation for exploration\n                gauss_steps = self.gaussian_mutation(self.dim)\n                trial_vector += 0.05 * gauss_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Adaptive_Grouped_PSO_DE", "description": "A hybrid of adaptive particle swarm optimization and differential evolution with dynamic grouping and enhanced mutation for improved convergence.", "configspace": "", "generation": 93, "fitness": 0.18633791105531974, "feedback": "The algorithm Adaptive_Grouped_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.3800105520224435, 0.4472081576886916, 0.4151541564919097, 0.18950568207469543, 0.49050296544212846, 0.44302663552701227, 0.538542990861418, 0.4436960431758865, 0.4199740878746294, 0.03030619525839262, 0.05078256260130187, 9.999999999998899e-05, 0.15915340006969347, 0.06709472071609923, 0.03331252663161266, 0.04338170510160855, 0.04408886962257674, 9.999999999998899e-05, 0.06761677033435376, 0.06782429475389329, 0.09265215803874471, 0.09107907494487222, 0.05625721302292097, 0.06969260114167342, 0.09569369302049946, 0.07142455695064631, 0.04366861489031504, 0.05069650788888158, 0.07746558117218705, 0.06846639411258171, 0.06753887505279033, 0.06887846349530535, 0.06006107152184126, 0.06285154878782273, 0.09162385669291051, 0.07128770610392221, 0.9785455656715097, 0.9767090842568459, 0.9683348849855067, 0.9779203389095015, 0.9330900541613381, 0.9551727258456941, 0.9740590230110993, 0.9783873429549358, 0.9609264837575484, 0.1828962980991813, 0.109598126604744, 0.20737338291357899, 0.22559313315792773, 0.1459177103148821, 0.2161968850538657, 0.11986784670771922, 0.1844266462491193, 0.24639441672277562, 0.16922671675233392, 0.25643169306196467, 0.26588797328654246, 0.19505714831250232, 0.18738791386584353, 0.18250025834151262, 0.123222060988183, 0.1280390112361649, 0.13052693394904324, 0.08267736018811389, 0.04527637226987313, 0.13560474719706195, 0.08479359868960912, 0.15975886619712076, 0.06137765048475263, 0.1652715915279932, 0.158853922117434, 0.1639943958413862, 0.12588883941029272, 0.15402003911623974, 0.12298819548474094, 0.18361767020500996, 0.12707241745281517, 0.11071871742049733, 0.07243422783857878, 0.12063970356961451, 0.029357947172058863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006037605384287992, 9.999999999998899e-05, 9.999999999998899e-05, 0.10496634679190542, 0.0319255323136034, 0.051230575808562606, 0.04697907901071796, 0.004319722948891602, 9.999999999998899e-05, 0.05836487351922082, 0.03784344238711068, 0.028435207165644405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00754258180297962, 9.999999999998899e-05, 0.021698100133430542, 9.999999999998899e-05, 0.005990677157927671, 9.999999999998899e-05, 0.08076253803090638, 0.04907912044392704, 0.06077237160954341, 0.08208058161866005, 0.09794608678009864, 0.07317104031190935, 0.06204379540727789, 0.07112720257895999, 0.06787990539831257, 0.39293125087478864, 0.4127962691595748, 0.43639665058578947, 0.41898827181230647, 0.37840070803046355, 0.35353517768343057, 0.38791003798044466, 0.33529209948988914, 0.4097835295754826, 0.09291673177780979, 0.07438745957227566, 0.05476126788087199, 0.07046631969616524, 0.08723273349894356, 0.08097028526353, 0.0824137705538236, 0.07382733580726675, 0.07756497442346622, 0.161330106798367, 0.1333567140049372, 0.13178168169041948, 0.18971408156003833, 0.1543107942078723, 0.12394278214386889, 0.1269334692726588, 0.14364248065684115, 0.15730091556035353, 0.2569556905446002, 0.22598672124836117, 0.24422200777984082, 0.25035625945876705, 0.18601862963035365, 0.25326093913227343, 0.26500800014719095, 0.22043717109456518, 0.2615040739611689, 0.15976652878527475, 0.1507869982390333, 0.17644645544274795, 0.19677397390668527, 0.16394055650910355, 0.16478962189696633, 0.1956006734748712, 0.18830135059214725, 0.21928075801155833, 0.169046041616004, 0.18314443153474136, 0.18056635316739467, 0.20656009376510387, 0.17447581941066892, 0.18143973326403284, 0.18757439665123632, 0.19992473081931772, 0.20970235884539412, 0.17205817197857598, 0.17680500985465164, 0.18154069464540512, 0.17091402072018103, 0.17064730095216196, 0.16453606351038053, 0.17622544849845145, 0.1691739059311158, 0.16539341095857707, 0.22927652792316866, 0.18104141254688821, 0.12383955424131943, 0.38214698016299553, 0.19392970882759542, 0.44071841758999997, 0.13558921825849846, 0.16244223401312263, 0.6047769716038125, 0.27958458647363693, 0.20353399996743626, 0.16362992473661486, 0.27397867059832537, 0.2112807163993381, 0.11533783467915637, 0.40227404398281585, 0.31828460455865903, 0.44835268515575966, 0.17410722633839026, 0.17789994337660586, 0.18305959734637067, 0.193099440195716, 0.17828444738401672, 0.18949544680660202, 0.1710861086487332, 0.17516382052455115, 0.17037616872407957, 0.06410029607443779, 0.08930163049929674, 0.07721509955493888, 0.0595606839808559, 0.06152967265482456, 0.07414400876193816, 0.05871190925765846, 0.05455792873933696, 0.058772430775796414]}, "mutation_prompt": null}
{"id": "e71baf10-b13f-4263-b48d-8d89c4ff205c", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm PSO parameters\n        self.num_particles = 50  # Slightly increased for more exploration\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5  # Adjusted for balanced exploration-exploitation\n        self.social_coeff = 1.7\n\n        # Differential Evolution parameters\n        self.F = 0.8  # Adjusted scaling factor\n        self.CR = 0.8  # Adjusted crossover rate\n\n        # Particle initialization\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim)) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.cos(3 * np.pi * iter_count / self.budget)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def select_parents(self, scores):\n        idxs = np.random.choice(range(len(scores)), 3, replace=False)\n        return idxs\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with Lévy flights\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = self.select_parents(scores)\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[i])\n                \n                # Incorporate Lévy flights for exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_PSO_DE_LF", "description": "A hybrid PSO-DE with chaotic inertia and adaptive levy flights, leveraging multi-strategy exploration and exploitation for faster convergence.", "configspace": "", "generation": 94, "fitness": 0.11875979325857837, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE_LF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.12797246737100754, 0.14696801977162666, 0.1789037159364243, 0.16619613734813243, 0.1587405180368896, 0.18003130097150366, 0.21489357069517734, 0.14766543394398035, 0.1577805137069911, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045353412212474575, 0.03367793380913531, 0.04725966455210362, 0.024422138350786216, 0.03367071116848763, 0.0347635648728829, 0.05100604369319195, 0.04424394573965218, 0.029460793129032936, 0.04082071012731814, 0.02842823666058325, 0.03203000824465452, 0.03763552752248811, 0.016075886000827322, 0.02303350834166462, 0.021774933226761273, 0.015217311355181118, 0.016779245546186927, 0.9764719054507851, 0.9688311487986624, 0.9750628017357132, 0.9593575773831148, 0.9699567704008887, 0.9764070181617669, 0.9784348321977492, 0.9761199763196257, 0.973819208141508, 0.08203480008131359, 0.04185302086510634, 9.999999999998899e-05, 0.1134024140331219, 0.08052859635850929, 0.09432686460294704, 0.09447703457413259, 0.05989790866127298, 0.09287097044229176, 0.11421003297032617, 0.15055963658909854, 0.13575751999912222, 0.2135040189365599, 0.09312806275727803, 0.14093534610682235, 0.06574451639095458, 0.10618088272509507, 0.08949534897322087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006432896006145938, 0.007882001530965188, 9.999999999998899e-05, 9.999999999998899e-05, 0.010819093480251452, 0.006150579297104608, 0.009744886145588882, 0.0359387293460921, 9.999999999998899e-05, 0.08658769553747148, 9.999999999998899e-05, 0.014336659985806355, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024141131475086675, 0.024251480295456318, 0.003978121548841584, 0.10166202610291097, 0.0010381872123805813, 0.00043316799167147924, 0.002509834233538677, 0.009083022238674632, 0.10168225184309498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034638709521416233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17773921160232253, 0.22592328590287591, 0.21611223171065364, 0.17253162571577596, 0.18697794165720083, 0.1722727138568787, 0.224954254148092, 0.1568775927866174, 0.1924636718448961, 0.04570587014387151, 0.05155966348499674, 0.05793396824481556, 0.054133202284455395, 0.02839418009946626, 0.04700323841321785, 0.026819847026300914, 0.05038239109793363, 0.05538983901579919, 0.1088596409360969, 0.1348446789207708, 0.15371264404805174, 0.12365813569444473, 0.1437711854852909, 0.1443273201798807, 0.15073235444548538, 0.128319754449143, 0.10975242292184662, 0.1361939413455897, 0.1234638205021441, 0.1620397822052564, 0.15765247791689996, 0.12738076421794464, 0.13087588753164714, 0.16838326266792192, 0.23152586920377694, 0.17023577152890468, 0.08046893087618323, 0.06958520272456703, 0.1330249847012216, 0.08302813573190237, 0.09883817743931089, 0.10967740928973346, 0.1074081602185406, 0.10848905516256235, 0.1087763160902625, 0.14869426747719994, 0.16711403502250144, 0.1628933822203832, 0.1520776379055243, 0.1528603612590128, 0.14216557710165612, 0.13691070034607655, 0.13046270446922514, 0.19819379071956122, 0.1705612817599782, 0.18066451330907052, 0.15682561241919935, 0.13351136654142104, 9.999999999998899e-05, 0.15184676303939326, 0.1592951691199339, 0.020107909823525172, 0.13503838610423624, 0.13454085518339398, 0.15431175247213091, 0.1369484416951955, 0.1098056696647749, 0.1676390938775557, 0.1084312399668319, 0.14933924391958242, 0.16383135179316177, 0.15064770126076343, 0.128954984171336, 0.1083808220393927, 0.09179686294947276, 0.16776262912973694, 0.10737785621606, 0.08491307545717175, 0.171848737692187, 0.16503709682202095, 0.1755301723660586, 0.186125364691606, 0.17598104367135636, 0.19121793049245717, 0.1690317309215461, 0.18600429150967368, 0.179961529294822, 0.16894527666162795, 0.16895755521074496, 0.19078119397178617, 0.04543461353003164, 0.037965857150481286, 0.03676392496673453, 0.04139316217146061, 0.04493826293632863, 0.04434939239230329, 0.03449711245133691, 0.048920469077107565, 0.04331567074988929]}, "mutation_prompt": null}
{"id": "0bbaeb3c-08bb-40db-a3b3-74245fd008dd", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "6fc9107a-6a19-4f51-b9d6-3e73c5909545", "solution": "import numpy as np\n\nclass Quantum_Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Quantum-inspired parameters\n        self.num_particles = 40\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n        self.quantum_coeff = 0.1  # New quantum potential factor\n\n        # DE parameters\n        self.F_base = 0.8  # Slightly increased scaling factor for exploration\n        self.CR_base = 0.85\n\n        # Initialization\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.9 - iter_count * (0.6 / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.2 * np.sin(np.pi * current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def quantum_operator(self, position):\n        return self.quantum_coeff * np.random.randn(self.dim) * (self.global_best_position - position)\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            quantum_component = np.array([self.quantum_operator(pos) for pos in self.positions])\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component + quantum_component)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [np.random.randint(0, self.num_particles) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Quantum_Enhanced_Hybrid_APSO_DE", "description": "Quantum-inspired PSO-DE hybrid algorithm with adaptive quantum potential for enhanced convergence and exploration.", "configspace": "", "generation": 96, "fitness": 0.12396063532955279, "feedback": "The algorithm Quantum_Enhanced_Hybrid_APSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.2120612619015897, 0.2077991920668597, 0.1489855011556681, 0.22531705150135495, 0.19829942967225056, 0.19585136289524896, 0.16488750209176284, 0.17209539315427513, 0.20992865692945073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0371915792715104, 0.0312114268574456, 0.037730633185906526, 0.05016464360749284, 0.02823748446631158, 0.048162734880284774, 0.04400129851453294, 0.032459721553398824, 0.04351448554059245, 0.026293955724143392, 0.0606369353902948, 0.018928011643362663, 0.025185861683670874, 0.06318052892989123, 0.014464157726544191, 0.03817071555417806, 0.06178887091587715, 0.02445494666080883, 0.9798235535481942, 0.9804061360721735, 0.9756744880098644, 0.976050687620039, 0.9746507723437794, 0.976860036593756, 0.9819229555093136, 0.979900665309697, 0.9751651573655176, 0.09675267464486481, 0.08106683842582008, 0.05347286776989191, 0.08851929244632761, 0.09312111475582752, 0.05175469813861877, 0.07314544143968682, 0.06342839296085512, 0.08152260340250883, 0.13610399655406635, 0.10276621966504462, 0.11296696067931467, 0.1425899269664096, 0.14204806827411065, 0.1264927674589308, 0.13567903099747658, 0.14683232115948264, 0.12237800703017188, 0.0028763096538015898, 0.0037387085319531277, 0.009471058598934046, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012200902877915754, 0.042702639182159, 9.999999999998899e-05, 0.021771568250107287, 0.04004130291483621, 0.008143593867479648, 0.02477695047842421, 0.023360099378904264, 9.999999999998899e-05, 0.013701414742411933, 0.004440556985574218, 9.999999999998899e-05, 0.010071603081991287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022165400016465497, 0.004037880382880887, 0.029966951126410457, 0.005106648649605083, 9.999999999998899e-05, 0.030479521297368195, 0.0710903004012533, 0.012042195716361115, 0.0022225321302407064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005051450758880138, 0.022564675083410424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037440669587984754, 9.999999999998899e-05, 0.020959165192676155, 0.20068087119812394, 0.17722900595464308, 0.2481998503052547, 0.21089565688549317, 0.16470928739730684, 0.18442232900221744, 0.3451715318433328, 0.15693071768328992, 0.1818230440034284, 0.051648329884674604, 0.07481158742329008, 0.05338150486362414, 0.051955075993833866, 0.02600813594253648, 0.043013563797861365, 0.05392410303466966, 0.03468026388929668, 0.06571210673658856, 0.13496612659829066, 0.11441921468128424, 0.1346925466850738, 0.12464512214669976, 0.13017905339094327, 0.11803746492498157, 0.14279413187311163, 0.11030002602544098, 0.17257881135553654, 0.13015512305606758, 0.16988659959262664, 0.16516511603599449, 0.14850841153975758, 0.15982136247905598, 0.14500904757507704, 0.15429132681433255, 0.19217140896123996, 0.14748862762772497, 0.07670791189862869, 0.1346387392359022, 0.09848931259931015, 0.09330297150887745, 0.12049379174122365, 0.11613124486411142, 0.12204890977432259, 0.12589588790377415, 0.11356037933858532, 0.17731142232914754, 0.12448774038665711, 0.17556750916149977, 0.1484184981921367, 0.14507862302523755, 0.17312432857883175, 0.17605722591666706, 0.15008626206725317, 0.15605777427226952, 0.15146299009863595, 0.1513916073715209, 0.1548612521519137, 0.14999963356203716, 0.1437292603985314, 0.15761264630236305, 0.04288647082936481, 0.13564414694367022, 0.11694462559034513, 0.15175214245784918, 0.15355907351202824, 0.1127848476193467, 0.12604876437727397, 0.14019816231907223, 0.140766563233642, 0.11545994444104923, 0.12677668338765202, 0.16932580198520442, 0.18542333558020052, 0.13850760200748446, 0.16092279285869826, 0.08832536753930598, 0.1655598550113102, 0.09775502537905101, 0.18108431839342942, 0.18294611376648173, 0.1836100865639081, 0.17202242859984707, 0.19504689947295506, 0.19092347525236109, 0.17371595328874612, 0.20049839815450832, 0.18201696269979262, 0.19331190398193387, 0.1581627978011375, 0.19058271634347168, 0.03661993450203427, 0.04508768727398582, 0.055154652206490185, 0.044308226401909234, 0.05749951315721069, 0.043856117112390014, 0.03013651263262418, 0.07174740287756798, 0.05005581346075472]}, "mutation_prompt": null}
{"id": "f9fbd394-129f-4c80-aa62-6b517d43393e", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Enhanced Multi-Swarm APSO parameters\n        self.num_particles = 40  # Increased particle count for diversity\n        self.inertia_weight = 0.7  # Chaotic inertia weight for dynamic adaptation\n        self.cognitive_coeff = 1.8\n        self.social_coeff = 1.5\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.7  # Modified scaling factor for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.5 + 0.5 * np.sin(3 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.3 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=2):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Enhanced Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.1, 0.3, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.01 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE", "description": "Enhanced PSO-DE hybrid algorithm with chaotic inertia and tournament selection for improved convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.8655410462939149, 0.8495439593558645, 0.8534682204864038, 0.8572874665778392, 0.8476407652333766, 0.8560242345046902, 0.8651754664916018, 0.8453780485686692, 0.8551664775834444, 0.7246611710612484, 0.7294297225284276, 0.7420142217071153, 0.7077463500487737, 0.7169058480983668, 0.7309158923102463, 0.7394937190051611, 0.7277026453480056, 0.7284061935335282, 0.16070992445392351, 0.6644215772895308, 0.12227770635297452, 0.16790800187811494, 0.14543190553851415, 0.13532691001698605, 0.14664264802857252, 0.10721941315466577, 0.1528315786927218, 0.12691990458192448, 0.1352929720158449, 0.1488814708609214, 0.10300584037927019, 0.1359195512036142, 0.10687975699627295, 0.12724245436406634, 0.10665316395898006, 0.09165303827474658, 0.9449788400581347, 0.9733416014496618, 0.9627326688753509, 0.9489360554389558, 0.9437493238800403, 0.9411298917067877, 0.9664861781216879, 0.958430176127441, 0.9554096395073997, 0.724752193270117, 0.6856322935477518, 0.6653952447696171, 0.7190404529835293, 0.6751081683920562, 0.6832930362316351, 0.7177867261322481, 0.6627453512118356, 0.6918437705625304, 0.8976381461192553, 0.8436447487828885, 0.8691357800568941, 0.20667076076677593, 0.8747825706532153, 0.8737393161255009, 0.7703922728820602, 0.23488886093074102, 0.2442552825611679, 0.32068770487639897, 0.12454142519961497, 0.29137270531767046, 0.32217075074462165, 0.2556253856492121, 0.13004973469731118, 0.3125838242093587, 0.33414366124956774, 0.30707358666560736, 0.232216811064218, 0.23542860997662185, 0.2183954343766945, 0.3041643947537854, 0.2644180272575454, 0.2977417877435088, 0.3263664081675379, 0.23183651135118688, 0.27410965825983635, 0.10792624007992269, 0.06876254840411478, 0.18919702084011913, 0.0001020497931824016, 9.999999999998899e-05, 0.0568056929212305, 0.020281753843331307, 9.999999999998899e-05, 0.09630259456700896, 0.14116243715383991, 0.13603849781531174, 0.10827772692255933, 0.03897367798357754, 0.08934816877049667, 0.11401933112876361, 0.1365868205380646, 0.11705296439547852, 0.14433431329022695, 0.04867235830004191, 0.08182350812747685, 0.04359211062469914, 0.16657831611100082, 0.26351847627530667, 0.11241704506576167, 0.1593171140712364, 0.29052184971458084, 0.09835508530874126, 0.2687953280598857, 0.12505909840171026, 0.17581505527465868, 0.18785290511373343, 0.172062197108365, 0.24494353153807358, 0.08546222589147578, 0.1756697005507003, 0.0810045375508478, 0.6049610170690058, 0.5716288872764248, 0.6873721658354233, 0.5535153588704163, 0.5796069228978102, 0.6002599605032178, 0.6162324454170304, 0.6048761917021851, 0.6063897604192914, 0.11819328409982532, 0.12327223226432993, 0.16922163141162838, 0.1617645861253948, 0.11315140039404381, 0.14298050604997825, 0.15136664308056935, 0.15137784181895964, 0.11794443502471474, 0.4443906219473607, 0.21111684078859094, 0.1706029610899179, 0.32032357430973823, 0.6280826061178435, 0.13416597572557898, 0.18008651534031395, 0.1585869872429525, 0.28692645472008405, 0.520121453890801, 0.5839488866417564, 0.389772029337459, 0.6516671577588511, 0.4953340488071529, 0.5258061810031774, 0.628133666341505, 0.5006138716454844, 0.5654841358582487, 0.21315787501253614, 0.25451662505180683, 0.2873796419857665, 0.2860044372460998, 0.20534077906734116, 0.21058769630858354, 0.5204871858390796, 0.3431513562772276, 0.31285790605417674, 0.2242648703346185, 0.20763769362761264, 0.22968640844559118, 0.24222273151991647, 0.21398970969521436, 0.26069831590247505, 0.21166705328020075, 0.18129302717974283, 0.20373247098577763, 0.21575074744771483, 0.18742593924191064, 0.6825538552144692, 0.20597289908626704, 0.21533476742395674, 0.24036003001917394, 0.19396452558781951, 0.21867380599408626, 0.20269712099710246, 0.8747388553038173, 0.1853554187986659, 0.18402490789925663, 0.8696628274104363, 0.19831430039090914, 0.15992001481998563, 0.8657907760914608, 0.16444877072346098, 0.8908890821549129, 0.8368177158717377, 0.1678988166003792, 0.8860165001304415, 0.8070103653357568, 0.8068839852239509, 0.8289752718041763, 0.8725358714627892, 0.12637711542316088, 0.20774831725892207, 0.18050618659183715, 0.18201577226368848, 0.1874822217103489, 0.18538495794788845, 0.18065546251409326, 0.1834492171971176, 0.1812113232590824, 0.19726388446874443, 0.17259677544663954, 0.08658589220555313, 0.09107561291135313, 0.08084098335696399, 0.08977272077104803, 0.08102860884811014, 0.0819797354209455, 0.09853154774230988, 0.07533379403913898, 0.08647330775617701]}, "mutation_prompt": null}
{"id": "d91da4ea-93c3-49a1-be14-d44c269ce6e3", "solution": "import numpy as np\n\nclass Dynamic_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Dynamic Multi-Swarm PSO parameters\n        self.num_particles = 30  # Adjusted particle count for performance\n        self.inertia_weight = 0.6  # Sinusoidal inertia weight for adaptability\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 1.2\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Enhanced scaling factor for exploration\n        self.CR_base = 0.85  # Tuned crossover probability for convergence\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def sinusoidal_inertia(self, iter_count):\n        return 0.4 + 0.3 * np.sin(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_factor(self, current_iter, total_iters):\n        return self.F_base + 0.4 * np.cos(np.pi * current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Dynamic Multi-Swarm PSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.sinusoidal_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.2, 0.4, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_factor(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n\n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Dynamic_Hybrid_PSO_DE", "description": "Dynamic PSO-DE hybrid with adaptive parameters and sinusoidal chaos for accelerated convergence.", "configspace": "", "generation": 98, "fitness": 0.3484279969133656, "feedback": "The algorithm Dynamic_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.912425940302622, 0.9053060044912511, 0.9045982005459592, 0.8886215739460375, 0.8800526042662806, 0.8753299707110864, 0.8970321823972848, 0.9011273184255243, 0.8918337124204558, 0.8237743403712992, 0.8316495775947622, 0.8055017227925397, 0.8075346863596206, 0.8026407763201914, 0.8161793338323011, 0.7718877957847132, 0.8071886576172496, 0.8036730068926202, 0.1518196158495856, 0.12382407704265352, 0.18491627510114117, 0.13399544648305806, 0.189048543192734, 0.15372166032034862, 0.14358441786226706, 0.13740891400607047, 0.149651488561224, 0.17591992687665736, 0.07603946298775954, 0.1340286888360257, 0.13238874419647184, 0.10793684771950451, 0.17404806692886743, 0.10932153770901509, 0.13501811428632482, 0.10767322052147033, 0.9614946715488986, 0.9415110831537069, 0.9600879454563895, 0.9738449924126256, 0.9865459628527864, 0.9529239893190398, 0.9764334199978795, 0.9719642977472992, 0.9507021244750979, 0.7363152809045848, 0.7525691898071412, 0.6887304247990405, 0.738035249183441, 0.7273112163997821, 0.18730925064639692, 0.7527627179866225, 0.7412277743228155, 0.0886906545127425, 0.22725789557602338, 0.22717228123183264, 0.22501809713197662, 0.2790404956070094, 0.2784926295547361, 0.9109134017347436, 0.907242206349816, 0.22287817573794655, 0.8731217110382111, 0.13307805476590662, 0.5743257676422505, 0.1324048965520096, 0.22842074920505628, 0.22696955288186438, 0.22440764217452958, 0.132991490767423, 0.13254561614589455, 0.2171550952547383, 0.1250451868206539, 0.23598897646561978, 0.13405351872673077, 0.18928194240147578, 0.32627814775103947, 0.3541138735997055, 0.29789265448212954, 0.13112455839338222, 0.18699066621918103, 0.004310101647653886, 9.999999999998899e-05, 0.06534321069258842, 0.07292590522676035, 0.010177857913142185, 0.06460544066425522, 0.037655897897515334, 0.001160434199340532, 0.17728445518110436, 0.09712405893278941, 0.08252611058467807, 0.12274135163994582, 0.015552066510851392, 0.05913589394747576, 0.0301301116995335, 0.09586517766429825, 0.07286086663817948, 0.13843770597514105, 0.23618466538148908, 0.10015660467927534, 0.0518385206676949, 0.1846031192285591, 0.1083582554157978, 0.11658599929784741, 0.1023695891722266, 0.16969730212052014, 0.09624559251591747, 0.15954682120707397, 0.16348863672009173, 0.22173699384006496, 0.09987999068140163, 0.2768709152542018, 0.16878966787242222, 0.19897202545888149, 0.1251855761525037, 0.08197830945438322, 0.7312617299871823, 0.5490510004991707, 0.5792316049320957, 0.680350153345639, 0.5602063506477019, 0.5744573667692048, 0.6515440357042648, 0.6448650718731488, 0.5796219725600019, 0.1463459493606888, 0.11750595192384405, 0.1570649932937216, 0.15640424086748006, 0.09096372940385422, 0.08936158986698028, 0.15816222038100425, 0.14055173631280737, 0.14613873231739394, 0.13694825033332514, 0.27932685642363964, 0.17435853336074214, 0.20253205089326054, 0.14795013549889902, 0.26026061801180034, 0.15695181185149198, 0.18460466720589297, 0.24908881528430993, 0.2560985404947448, 0.3579941737841593, 0.423513488717594, 0.6122144198629111, 0.3698790281381221, 0.36143336277521365, 0.44106299508042024, 0.25317094003075, 0.40573976793067923, 0.426041338010275, 0.2928871070663853, 0.2569867023412554, 0.29946059244777334, 0.2281431956295673, 0.29962989674866514, 0.41313222490241475, 0.3298249818004567, 0.3528640152802488, 0.23864592557003494, 0.19651240317191654, 0.196525028056883, 0.21285694783522113, 0.19543676048855174, 0.21233842523120294, 0.23658969237194927, 0.19694999930052481, 0.2480580958398092, 0.18507049406952047, 0.18156341423710232, 0.22096127402496357, 0.2515629377212083, 0.2239530595821796, 0.25049781235513136, 0.22364465823612267, 0.2237450341917736, 0.1968296711189732, 0.9352888808132132, 0.1844594072571405, 0.9143354000944588, 0.9406029255501647, 0.19952123794144982, 0.19911952950645584, 0.13551559434328286, 0.16920416232982594, 0.9162077237803813, 0.8863838311025469, 0.7186533449915629, 0.8884184505050313, 0.5842037169086466, 0.9135222066220261, 0.869143317335429, 0.210239605475823, 0.21227471447607704, 0.20982765095816058, 0.18325186524496107, 0.1951048799620515, 0.18028219330802897, 0.18827548154442098, 0.18971875254808113, 0.18236111146091116, 0.17450223355063355, 0.18560118327272146, 0.17912891093642958, 0.08699389628579612, 0.08718651298475999, 0.08798671186426732, 0.0833358454678852, 0.08842966120503648, 0.0899129899015314, 0.1068246462304665, 0.08466741142739431, 0.10323955731890455]}, "mutation_prompt": null}
{"id": "c850ff81-266f-4af0-8a92-6d6b2dc9fd39", "solution": "import numpy as np\n\nclass Enhanced_Hybrid_APSO_DE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        # Multi-Swarm APSO parameters\n        self.num_particles = 50  # Increased particle count for enhanced exploration\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 1.3\n\n        # Adaptive Differential Evolution parameters\n        self.F_base = 0.8  # Adjusted scaling for efficient exploration\n        self.CR_base = 0.85  # Slightly reduced crossover probability\n\n        # Particle initializations\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, np.inf)\n\n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_inertia(self, iter_count):\n        return 0.4 + 0.4 * np.sin(2 * np.pi * iter_count / self.budget)\n\n    def adaptive_mutation_strategy(self, current_iter, total_iters):\n        return self.F_base + 0.4 * (1 - current_iter / total_iters)\n\n    def levy_flight(self, L):\n        beta = 1.3\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, L)\n        v = np.random.normal(0, 1, L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def tournament_selection(self, scores, size=3):\n        indices = np.random.choice(range(len(scores)), size, replace=False)\n        return indices[np.argmin(scores[indices])]\n\n    def __call__(self, func):\n        evals = 0\n        iter_count = 0\n\n        while evals < self.budget:\n            # Evaluate each particle\n            scores = np.apply_along_axis(func, 1, self.positions)\n            evals += self.num_particles\n\n            # Update personal and global bests\n            for i in range(self.num_particles):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions (Multi-Swarm APSO)\n            r1, r2 = np.random.rand(self.num_particles, self.dim), np.random.rand(self.num_particles, self.dim)\n            cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions - self.positions)\n            social_component = self.social_coeff * r2 * (self.global_best_position - self.positions)\n            self.velocities = (self.chaotic_inertia(iter_count) * self.velocities +\n                               cognitive_component + social_component)\n            self.positions += self.velocities * np.random.uniform(0.05, 0.25, self.positions.shape)\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Evolution with Lévy flights\n            F = self.adaptive_mutation_strategy(iter_count, self.budget)\n            for i in range(self.num_particles):\n                idx1, idx2, idx3 = [self.tournament_selection(scores) for _ in range(3)]\n                x1, x2, x3 = self.positions[idx1], self.positions[idx2], self.positions[idx3]\n                mutant_vector = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                trial_vector = np.where(np.random.rand(self.dim) < self.CR_base, mutant_vector, self.positions[i])\n                \n                # Incorporate Levy flights for better exploration\n                levy_steps = self.levy_flight(self.dim)\n                trial_vector += 0.02 * levy_steps * (trial_vector - self.positions[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_score = func(trial_vector)\n\n                # DE acceptance criterion\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n            \n            evals += self.num_particles\n            iter_count += 1\n\n        return self.global_best_position, self.global_best_score", "name": "Enhanced_Hybrid_APSO_DE_V2", "description": "A hybrid particle swarm and adaptive differential evolution algorithm with enhanced adaptive parameters and multi-swarm strategy for improved convergence and exploration.", "configspace": "", "generation": 99, "fitness": 0.3427337864758735, "feedback": "The algorithm Enhanced_Hybrid_APSO_DE_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "456cdd13-157c-404a-8ed1-5bc63b4ef9de", "metadata": {"aucs": [0.7898972066817941, 0.7669529350202055, 0.7794390305167164, 0.7829599400181794, 0.7753868456953915, 0.8015748536216691, 0.7974806043892302, 0.7868185240668216, 0.7725257409354908, 0.6338898604820884, 0.6181195404151794, 0.5918408211109643, 0.6115630051620036, 0.6158943139627687, 0.629793378572689, 0.6105806396127309, 0.6316465209754653, 0.6171596869384339, 0.14082683277955166, 0.14784298759156933, 0.35229726205985235, 0.14883933512251601, 0.16973306101524654, 0.1298672187232176, 0.14876852315612454, 0.1528327490383612, 0.12349985326642332, 0.09876619413896637, 0.11949890838597133, 0.09349367261415209, 0.142023549958315, 0.11498294252707308, 0.1085265253598875, 0.10649555775220265, 0.10935241668614548, 0.11570285234014699, 0.9277865483558112, 0.9416467540453411, 0.9229751731425566, 0.9467655580373253, 0.9523503460211825, 0.9491229248864744, 0.9325921873927434, 0.9282531759085791, 0.9479124910810045, 0.4806911209101715, 0.47037312256433794, 0.4966371532123134, 0.546137801939955, 0.5788121498289011, 0.4793859217614522, 0.4923328194978338, 0.5287785298089687, 0.543615941354459, 0.7909748802156491, 0.22292502495004118, 0.3569584526426346, 0.7944314883547471, 0.8028553361851705, 0.7826831983226568, 0.7783469612839661, 0.7577408913311858, 0.8142914957117016, 0.38718711741137724, 0.24933765860891066, 0.2359665628226767, 0.12256375130308839, 0.12168781161398934, 0.3640754507543912, 0.30986148192046026, 0.2379726236644134, 0.2621243638626626, 0.14026665361509627, 0.2562579878429796, 0.23908731883962342, 0.23193187854177422, 0.26378610134783864, 0.29104375094311885, 0.3687596098635104, 0.25896867375489097, 0.2557801946654704, 0.04845217585588801, 0.06049580207835714, 0.038884778825274635, 0.02745712391729882, 0.0655391609627608, 0.048075987297735434, 0.06003774857650823, 0.03473819371527587, 0.11281393948629215, 0.2049272012733192, 0.10418801765189167, 0.11159422994823232, 0.08985852319474885, 0.11153581404706547, 0.1412357807081196, 0.11231919186827255, 0.13331043085181649, 0.14173457817660495, 0.042397924018744204, 0.05639432819463486, 0.04091760924983501, 0.18641271376742297, 0.1718391604716869, 0.18944997465856872, 0.1878408485743276, 0.11039698926235231, 0.3854418713376251, 0.19921973534818438, 0.14247784037785582, 0.18068303016780685, 0.23936446633145592, 0.2776393854200222, 0.1796607498741738, 0.2503156582308125, 0.31251770185643624, 0.1629335937389682, 0.5498182541809205, 0.5807395503289918, 0.5824998049588377, 0.5624943727467213, 0.5020941556928794, 0.5570200777508256, 0.6127481991691806, 0.5906692680319254, 0.567156789682402, 0.13144025271571935, 0.13707271794983622, 0.12656785592359376, 0.14238138790185895, 0.13918533707680436, 0.15157753745457125, 0.10766884538922894, 0.13783451120604118, 0.10149226768827979, 0.15448285270919515, 0.15696083643474323, 0.19079383890518842, 0.25337937988170023, 0.18230120655421778, 0.13876953818839755, 0.5202228808498849, 0.26785730277173214, 0.141539526982419, 0.45655209608181824, 0.4237305589723823, 0.4839574288081885, 0.4335743558578241, 0.45310815803527493, 0.46462323410638295, 0.44619052296702777, 0.47345533040063215, 0.4776131974662965, 0.31003687220253306, 0.27976214892861384, 0.34723850981292126, 0.3293871091341234, 0.20576894381603716, 0.2511118623266494, 0.4030733662728456, 0.3603931785353449, 0.3990701161104503, 0.24093800222936346, 0.21922055612578417, 0.21781914107128575, 0.21390372787972545, 0.2123606889901467, 0.2195012852798267, 0.1896223824647384, 0.18108485379038652, 0.20148753506456607, 0.5261720853693881, 0.19846326872337738, 0.2323738859122333, 0.5544118032414513, 0.4544637692761093, 0.20307878657376954, 0.18918541981495796, 0.48997053808195534, 0.46288185728387365, 0.18460493922023946, 0.18306064190717197, 0.15251473990019115, 0.8239497786340116, 0.1871377643142218, 0.15889940302671435, 0.16985425241294072, 0.7752541689897083, 0.8233663918148456, 0.6896612265348788, 0.1669901862455596, 0.8205857681237939, 0.7045317060717131, 0.6969452903627025, 0.16207554888904174, 0.15175203524287406, 0.2060857713833708, 0.20345696067920782, 0.19093467119380514, 0.16992705183817614, 0.19049288071064896, 0.18347538140721853, 0.1782673618075441, 0.20003023059604363, 0.18299800813291278, 0.1714203742345939, 0.17372634372151208, 0.07951169083233067, 0.08723616771317133, 0.08063436329327234, 0.08113692945350393, 0.087735047626891, 0.08785635718982321, 0.08158951506889756, 0.08868954287623187, 0.09774167107117282]}, "mutation_prompt": null}
